diff --git a/Makefile.def b/Makefile.def
index 90d9653..754f8a5 100644
--- a/Makefile.def
+++ b/Makefile.def
@@ -113,6 +113,8 @@ host_modules= { module= utils; no_check=true; };
 host_modules= { module= gnattools; };
 host_modules= { module= lto-plugin; bootstrap=true;
 		extra_configure_flags=--enable-shared; };
+host_modules= { module= function_reordering_plugin; bootstrap=true;
+		extra_configure_flags=--enable-shared; };
 
 target_modules = { module= libstdc++-v3;
 		   bootstrap=true;
@@ -293,6 +295,7 @@ dependencies = { module=all-build-fixincludes; on=all-build-libiberty; };
 dependencies = { module=configure-gcc; on=configure-intl; };
 dependencies = { module=configure-gcc; on=all-gmp; };
 dependencies = { module=configure-gcc; on=all-lto-plugin; };
+dependencies = { module=configure-gcc; on=all-function_reordering_plugin; };
 dependencies = { module=configure-gcc; on=all-binutils; };
 dependencies = { module=configure-gcc; on=all-gas; };
 dependencies = { module=configure-gcc; on=all-ld; };
@@ -315,14 +318,17 @@ dependencies = { module=all-gcc; on=all-libdecnumber; hard=true; };
 dependencies = { module=all-gcc; on=all-libiberty; };
 dependencies = { module=all-gcc; on=all-fixincludes; };
 dependencies = { module=all-gcc; on=all-lto-plugin; };
+dependencies = { module=all-gcc; on=all-function_reordering_plugin; };
 dependencies = { module=info-gcc; on=all-build-libiberty; };
 dependencies = { module=dvi-gcc; on=all-build-libiberty; };
 dependencies = { module=pdf-gcc; on=all-build-libiberty; };
 dependencies = { module=html-gcc; on=all-build-libiberty; };
 dependencies = { module=install-gcc ; on=install-fixincludes; };
 dependencies = { module=install-gcc ; on=install-lto-plugin; };
+dependencies = { module=install-gcc ; on=install-function_reordering_plugin; };
 dependencies = { module=install-strip-gcc ; on=install-strip-fixincludes; };
 dependencies = { module=install-strip-gcc ; on=install-strip-lto-plugin; };
+dependencies = { module=install-strip-gcc ; on=install-strip-function_reordering_plugin; };
 
 dependencies = { module=configure-libcpp; on=configure-libiberty; hard=true; };
 dependencies = { module=configure-libcpp; on=configure-intl; };
@@ -334,6 +340,7 @@ dependencies = { module=all-fixincludes; on=all-libiberty; };
 dependencies = { module=all-gnattools; on=all-target-libada; };
 
 dependencies = { module=all-lto-plugin; on=all-libiberty; };
+dependencies = { module=all-function_reordering_plugin; on=all-libiberty; };
 
 dependencies = { module=all-utils; on=all-libiberty; };
 
@@ -514,6 +521,7 @@ dependencies = { module=all-target-libjava; on=all-target-boehm-gc; };
 dependencies = { module=all-target-libjava; on=all-target-libffi; };
 dependencies = { module=configure-target-libobjc; on=configure-target-boehm-gc; };
 dependencies = { module=all-target-libobjc; on=all-target-boehm-gc; };
+dependencies = { module=configure-target-libmudflap; on=configure-target-libstdc++-v3; };
 dependencies = { module=configure-target-libstdc++-v3; on=configure-target-libgomp; };
 dependencies = { module=configure-target-libsanitizer; on=all-target-libstdc++-v3; };
 // parallel_list.o and parallel_settings.o depend on omp.h, which is
diff --git a/Makefile.in b/Makefile.in
index bfbaf03..0eaeabd 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -224,9 +224,6 @@ HOST_EXPORTS = \
 	CLOOGINC="$(HOST_CLOOGINC)"; export CLOOGINC; \
 	LIBELFLIBS="$(HOST_LIBELFLIBS)" ; export LIBELFLIBS; \
 	LIBELFINC="$(HOST_LIBELFINC)" ; export LIBELFINC; \
-@if gcc-bootstrap
-	$(RPATH_ENVVAR)=`echo "$(TARGET_LIB_PATH)$$$(RPATH_ENVVAR)" | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; export $(RPATH_ENVVAR); \
-@endif gcc-bootstrap
 	$(RPATH_ENVVAR)=`echo "$(HOST_LIB_PATH)$$$(RPATH_ENVVAR)" | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; export $(RPATH_ENVVAR);
 
 POSTSTAGE1_CXX_EXPORT = \
@@ -290,9 +287,6 @@ BASE_TARGET_EXPORTS = \
 	STRIP="$(STRIP_FOR_TARGET)"; export STRIP; \
 	WINDRES="$(WINDRES_FOR_TARGET)"; export WINDRES; \
 	WINDMC="$(WINDMC_FOR_TARGET)"; export WINDMC; \
-@if gcc-bootstrap
-	$(RPATH_ENVVAR)=`echo "$(TARGET_LIB_PATH)$$$(RPATH_ENVVAR)" | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; export $(RPATH_ENVVAR); \
-@endif gcc-bootstrap
 	$(RPATH_ENVVAR)=`echo "$(HOST_LIB_PATH)$$$(RPATH_ENVVAR)" | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; export $(RPATH_ENVVAR); \
 	TARGET_CONFIGDIRS="$(TARGET_CONFIGDIRS)"; export TARGET_CONFIGDIRS;
 
@@ -919,7 +913,8 @@ configure-host:  \
     maybe-configure-libtermcap \
     maybe-configure-utils \
     maybe-configure-gnattools \
-    maybe-configure-lto-plugin
+    maybe-configure-lto-plugin \
+    maybe-configure-function_reordering_plugin
 .PHONY: configure-target
 configure-target:  \
     maybe-configure-target-libstdc++-v3 \
@@ -1066,6 +1061,9 @@ all-host: maybe-all-gnattools
 @if lto-plugin-no-bootstrap
 all-host: maybe-all-lto-plugin
 @endif lto-plugin-no-bootstrap
+@if function_reordering_plugin-no-bootstrap
+all-host: maybe-all-function_reordering_plugin
+@endif function_reordering_plugin-no-bootstrap
 
 .PHONY: all-target
 
@@ -1161,6 +1159,7 @@ info-host: maybe-info-libtermcap
 info-host: maybe-info-utils
 info-host: maybe-info-gnattools
 info-host: maybe-info-lto-plugin
+info-host: maybe-info-function_reordering_plugin
 
 .PHONY: info-target
 
@@ -1243,6 +1242,7 @@ dvi-host: maybe-dvi-libtermcap
 dvi-host: maybe-dvi-utils
 dvi-host: maybe-dvi-gnattools
 dvi-host: maybe-dvi-lto-plugin
+dvi-host: maybe-dvi-function_reordering_plugin
 
 .PHONY: dvi-target
 
@@ -1325,6 +1325,7 @@ pdf-host: maybe-pdf-libtermcap
 pdf-host: maybe-pdf-utils
 pdf-host: maybe-pdf-gnattools
 pdf-host: maybe-pdf-lto-plugin
+pdf-host: maybe-pdf-function_reordering_plugin
 
 .PHONY: pdf-target
 
@@ -1407,6 +1408,7 @@ html-host: maybe-html-libtermcap
 html-host: maybe-html-utils
 html-host: maybe-html-gnattools
 html-host: maybe-html-lto-plugin
+html-host: maybe-html-function_reordering_plugin
 
 .PHONY: html-target
 
@@ -1489,6 +1491,7 @@ TAGS-host: maybe-TAGS-libtermcap
 TAGS-host: maybe-TAGS-utils
 TAGS-host: maybe-TAGS-gnattools
 TAGS-host: maybe-TAGS-lto-plugin
+TAGS-host: maybe-TAGS-function_reordering_plugin
 
 .PHONY: TAGS-target
 
@@ -1571,6 +1574,7 @@ install-info-host: maybe-install-info-libtermcap
 install-info-host: maybe-install-info-utils
 install-info-host: maybe-install-info-gnattools
 install-info-host: maybe-install-info-lto-plugin
+install-info-host: maybe-install-info-function_reordering_plugin
 
 .PHONY: install-info-target
 
@@ -1653,6 +1657,7 @@ install-pdf-host: maybe-install-pdf-libtermcap
 install-pdf-host: maybe-install-pdf-utils
 install-pdf-host: maybe-install-pdf-gnattools
 install-pdf-host: maybe-install-pdf-lto-plugin
+install-pdf-host: maybe-install-pdf-function_reordering_plugin
 
 .PHONY: install-pdf-target
 
@@ -1735,6 +1740,7 @@ install-html-host: maybe-install-html-libtermcap
 install-html-host: maybe-install-html-utils
 install-html-host: maybe-install-html-gnattools
 install-html-host: maybe-install-html-lto-plugin
+install-html-host: maybe-install-html-function_reordering_plugin
 
 .PHONY: install-html-target
 
@@ -1817,6 +1823,7 @@ installcheck-host: maybe-installcheck-libtermcap
 installcheck-host: maybe-installcheck-utils
 installcheck-host: maybe-installcheck-gnattools
 installcheck-host: maybe-installcheck-lto-plugin
+installcheck-host: maybe-installcheck-function_reordering_plugin
 
 .PHONY: installcheck-target
 
@@ -1899,6 +1906,7 @@ mostlyclean-host: maybe-mostlyclean-libtermcap
 mostlyclean-host: maybe-mostlyclean-utils
 mostlyclean-host: maybe-mostlyclean-gnattools
 mostlyclean-host: maybe-mostlyclean-lto-plugin
+mostlyclean-host: maybe-mostlyclean-function_reordering_plugin
 
 .PHONY: mostlyclean-target
 
@@ -1981,6 +1989,7 @@ clean-host: maybe-clean-libtermcap
 clean-host: maybe-clean-utils
 clean-host: maybe-clean-gnattools
 clean-host: maybe-clean-lto-plugin
+clean-host: maybe-clean-function_reordering_plugin
 
 .PHONY: clean-target
 
@@ -2063,6 +2072,7 @@ distclean-host: maybe-distclean-libtermcap
 distclean-host: maybe-distclean-utils
 distclean-host: maybe-distclean-gnattools
 distclean-host: maybe-distclean-lto-plugin
+distclean-host: maybe-distclean-function_reordering_plugin
 
 .PHONY: distclean-target
 
@@ -2145,6 +2155,7 @@ maintainer-clean-host: maybe-maintainer-clean-libtermcap
 maintainer-clean-host: maybe-maintainer-clean-utils
 maintainer-clean-host: maybe-maintainer-clean-gnattools
 maintainer-clean-host: maybe-maintainer-clean-lto-plugin
+maintainer-clean-host: maybe-maintainer-clean-function_reordering_plugin
 
 .PHONY: maintainer-clean-target
 
@@ -2281,7 +2292,8 @@ check-host:  \
     maybe-check-libtermcap \
     maybe-check-utils \
     maybe-check-gnattools \
-    maybe-check-lto-plugin
+    maybe-check-lto-plugin \
+    maybe-check-function_reordering_plugin
 
 .PHONY: check-target
 check-target:  \
@@ -2389,7 +2401,8 @@ install-host-nogcc:  \
     maybe-install-libtermcap \
     maybe-install-utils \
     maybe-install-gnattools \
-    maybe-install-lto-plugin
+    maybe-install-lto-plugin \
+    maybe-install-function_reordering_plugin
 
 .PHONY: install-host
 install-host:  \
@@ -2436,7 +2449,8 @@ install-host:  \
     maybe-install-libtermcap \
     maybe-install-utils \
     maybe-install-gnattools \
-    maybe-install-lto-plugin
+    maybe-install-lto-plugin \
+    maybe-install-function_reordering_plugin
 
 .PHONY: install-target
 install-target:  \
@@ -2538,7 +2552,8 @@ install-strip-host:  \
     maybe-install-strip-libtermcap \
     maybe-install-strip-utils \
     maybe-install-strip-gnattools \
-    maybe-install-strip-lto-plugin
+    maybe-install-strip-lto-plugin \
+    maybe-install-strip-function_reordering_plugin
 
 .PHONY: install-strip-target
 install-strip-target:  \
@@ -30740,6 +30755,884 @@ maintainer-clean-lto-plugin:
 
 
 
+.PHONY: configure-function_reordering_plugin maybe-configure-function_reordering_plugin
+maybe-configure-function_reordering_plugin:
+@if gcc-bootstrap
+configure-function_reordering_plugin: stage_current
+@endif gcc-bootstrap
+@if function_reordering_plugin
+maybe-configure-function_reordering_plugin: configure-function_reordering_plugin
+configure-function_reordering_plugin: 
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	test ! -f $(HOST_SUBDIR)/function_reordering_plugin/Makefile || exit 0; \
+	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/function_reordering_plugin ; \
+	$(HOST_EXPORTS)  \
+	echo Configuring in $(HOST_SUBDIR)/function_reordering_plugin; \
+	cd "$(HOST_SUBDIR)/function_reordering_plugin" || exit 1; \
+	case $(srcdir) in \
+	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  *) topdir=`echo $(HOST_SUBDIR)/function_reordering_plugin/ | \
+		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
+	esac; \
+	srcdiroption="--srcdir=$${topdir}/function_reordering_plugin"; \
+	libsrcdir="$$s/function_reordering_plugin"; \
+	$(SHELL) $${libsrcdir}/configure \
+	  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \
+	  --target=${target_alias} $${srcdiroption} --enable-shared \
+	  || exit 1
+@endif function_reordering_plugin
+
+
+
+.PHONY: configure-stage1-function_reordering_plugin maybe-configure-stage1-function_reordering_plugin
+maybe-configure-stage1-function_reordering_plugin:
+@if function_reordering_plugin-bootstrap
+maybe-configure-stage1-function_reordering_plugin: configure-stage1-function_reordering_plugin
+configure-stage1-function_reordering_plugin:
+	@[ $(current_stage) = stage1 ] || $(MAKE) stage1-start
+	@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/function_reordering_plugin
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	TFLAGS="$(STAGE1_TFLAGS)"; \
+	test ! -f $(HOST_SUBDIR)/function_reordering_plugin/Makefile || exit 0; \
+	$(HOST_EXPORTS) \
+	CFLAGS="$(STAGE1_CFLAGS)"; export CFLAGS; \
+	CXXFLAGS="$(STAGE1_CXXFLAGS)"; export CXXFLAGS; \
+	LIBCFLAGS="$(LIBCFLAGS)"; export LIBCFLAGS;  \
+	echo Configuring stage 1 in $(HOST_SUBDIR)/function_reordering_plugin ; \
+	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/function_reordering_plugin ; \
+	cd $(HOST_SUBDIR)/function_reordering_plugin || exit 1; \
+	case $(srcdir) in \
+	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  *) topdir=`echo $(HOST_SUBDIR)/function_reordering_plugin/ | \
+		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
+	esac; \
+	srcdiroption="--srcdir=$${topdir}/function_reordering_plugin"; \
+	libsrcdir="$$s/function_reordering_plugin"; \
+	$(SHELL) $${libsrcdir}/configure \
+	  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \
+	  --target=${target_alias} $${srcdiroption} \
+	  $(STAGE1_CONFIGURE_FLAGS) \
+	  --enable-shared
+@endif function_reordering_plugin-bootstrap
+
+.PHONY: configure-stage2-function_reordering_plugin maybe-configure-stage2-function_reordering_plugin
+maybe-configure-stage2-function_reordering_plugin:
+@if function_reordering_plugin-bootstrap
+maybe-configure-stage2-function_reordering_plugin: configure-stage2-function_reordering_plugin
+configure-stage2-function_reordering_plugin:
+	@[ $(current_stage) = stage2 ] || $(MAKE) stage2-start
+	@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/function_reordering_plugin
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	TFLAGS="$(STAGE2_TFLAGS)"; \
+	test ! -f $(HOST_SUBDIR)/function_reordering_plugin/Makefile || exit 0; \
+	$(HOST_EXPORTS) \
+	$(POSTSTAGE1_HOST_EXPORTS) \
+	CFLAGS="$(STAGE2_CFLAGS)"; export CFLAGS; \
+	CXXFLAGS="$(STAGE2_CXXFLAGS)"; export CXXFLAGS; \
+	LIBCFLAGS="$(STAGE2_CFLAGS)"; export LIBCFLAGS;  \
+	echo Configuring stage 2 in $(HOST_SUBDIR)/function_reordering_plugin ; \
+	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/function_reordering_plugin ; \
+	cd $(HOST_SUBDIR)/function_reordering_plugin || exit 1; \
+	case $(srcdir) in \
+	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  *) topdir=`echo $(HOST_SUBDIR)/function_reordering_plugin/ | \
+		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
+	esac; \
+	srcdiroption="--srcdir=$${topdir}/function_reordering_plugin"; \
+	libsrcdir="$$s/function_reordering_plugin"; \
+	$(SHELL) $${libsrcdir}/configure \
+	  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \
+	  --target=${target_alias} $${srcdiroption} \
+	  --with-build-libsubdir=$(HOST_SUBDIR) \
+	  $(STAGE2_CONFIGURE_FLAGS) \
+	  --enable-shared
+@endif function_reordering_plugin-bootstrap
+
+.PHONY: configure-stage3-function_reordering_plugin maybe-configure-stage3-function_reordering_plugin
+maybe-configure-stage3-function_reordering_plugin:
+@if function_reordering_plugin-bootstrap
+maybe-configure-stage3-function_reordering_plugin: configure-stage3-function_reordering_plugin
+configure-stage3-function_reordering_plugin:
+	@[ $(current_stage) = stage3 ] || $(MAKE) stage3-start
+	@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/function_reordering_plugin
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	TFLAGS="$(STAGE3_TFLAGS)"; \
+	test ! -f $(HOST_SUBDIR)/function_reordering_plugin/Makefile || exit 0; \
+	$(HOST_EXPORTS) \
+	$(POSTSTAGE1_HOST_EXPORTS) \
+	CFLAGS="$(STAGE3_CFLAGS)"; export CFLAGS; \
+	CXXFLAGS="$(STAGE3_CXXFLAGS)"; export CXXFLAGS; \
+	LIBCFLAGS="$(STAGE3_CFLAGS)"; export LIBCFLAGS;  \
+	echo Configuring stage 3 in $(HOST_SUBDIR)/function_reordering_plugin ; \
+	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/function_reordering_plugin ; \
+	cd $(HOST_SUBDIR)/function_reordering_plugin || exit 1; \
+	case $(srcdir) in \
+	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  *) topdir=`echo $(HOST_SUBDIR)/function_reordering_plugin/ | \
+		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
+	esac; \
+	srcdiroption="--srcdir=$${topdir}/function_reordering_plugin"; \
+	libsrcdir="$$s/function_reordering_plugin"; \
+	$(SHELL) $${libsrcdir}/configure \
+	  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \
+	  --target=${target_alias} $${srcdiroption} \
+	  --with-build-libsubdir=$(HOST_SUBDIR) \
+	  $(STAGE3_CONFIGURE_FLAGS) \
+	  --enable-shared
+@endif function_reordering_plugin-bootstrap
+
+.PHONY: configure-stage4-function_reordering_plugin maybe-configure-stage4-function_reordering_plugin
+maybe-configure-stage4-function_reordering_plugin:
+@if function_reordering_plugin-bootstrap
+maybe-configure-stage4-function_reordering_plugin: configure-stage4-function_reordering_plugin
+configure-stage4-function_reordering_plugin:
+	@[ $(current_stage) = stage4 ] || $(MAKE) stage4-start
+	@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/function_reordering_plugin
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	TFLAGS="$(STAGE4_TFLAGS)"; \
+	test ! -f $(HOST_SUBDIR)/function_reordering_plugin/Makefile || exit 0; \
+	$(HOST_EXPORTS) \
+	$(POSTSTAGE1_HOST_EXPORTS) \
+	CFLAGS="$(STAGE4_CFLAGS)"; export CFLAGS; \
+	CXXFLAGS="$(STAGE4_CXXFLAGS)"; export CXXFLAGS; \
+	LIBCFLAGS="$(STAGE4_CFLAGS)"; export LIBCFLAGS;  \
+	echo Configuring stage 4 in $(HOST_SUBDIR)/function_reordering_plugin ; \
+	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/function_reordering_plugin ; \
+	cd $(HOST_SUBDIR)/function_reordering_plugin || exit 1; \
+	case $(srcdir) in \
+	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  *) topdir=`echo $(HOST_SUBDIR)/function_reordering_plugin/ | \
+		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
+	esac; \
+	srcdiroption="--srcdir=$${topdir}/function_reordering_plugin"; \
+	libsrcdir="$$s/function_reordering_plugin"; \
+	$(SHELL) $${libsrcdir}/configure \
+	  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \
+	  --target=${target_alias} $${srcdiroption} \
+	  --with-build-libsubdir=$(HOST_SUBDIR) \
+	  $(STAGE4_CONFIGURE_FLAGS) \
+	  --enable-shared
+@endif function_reordering_plugin-bootstrap
+
+.PHONY: configure-stageprofile-function_reordering_plugin maybe-configure-stageprofile-function_reordering_plugin
+maybe-configure-stageprofile-function_reordering_plugin:
+@if function_reordering_plugin-bootstrap
+maybe-configure-stageprofile-function_reordering_plugin: configure-stageprofile-function_reordering_plugin
+configure-stageprofile-function_reordering_plugin:
+	@[ $(current_stage) = stageprofile ] || $(MAKE) stageprofile-start
+	@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/function_reordering_plugin
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	TFLAGS="$(STAGEprofile_TFLAGS)"; \
+	test ! -f $(HOST_SUBDIR)/function_reordering_plugin/Makefile || exit 0; \
+	$(HOST_EXPORTS) \
+	$(POSTSTAGE1_HOST_EXPORTS) \
+	CFLAGS="$(STAGEprofile_CFLAGS)"; export CFLAGS; \
+	CXXFLAGS="$(STAGEprofile_CXXFLAGS)"; export CXXFLAGS; \
+	LIBCFLAGS="$(STAGEprofile_CFLAGS)"; export LIBCFLAGS;  \
+	echo Configuring stage profile in $(HOST_SUBDIR)/function_reordering_plugin ; \
+	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/function_reordering_plugin ; \
+	cd $(HOST_SUBDIR)/function_reordering_plugin || exit 1; \
+	case $(srcdir) in \
+	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  *) topdir=`echo $(HOST_SUBDIR)/function_reordering_plugin/ | \
+		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
+	esac; \
+	srcdiroption="--srcdir=$${topdir}/function_reordering_plugin"; \
+	libsrcdir="$$s/function_reordering_plugin"; \
+	$(SHELL) $${libsrcdir}/configure \
+	  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \
+	  --target=${target_alias} $${srcdiroption} \
+	  --with-build-libsubdir=$(HOST_SUBDIR) \
+	  $(STAGEprofile_CONFIGURE_FLAGS) \
+	  --enable-shared
+@endif function_reordering_plugin-bootstrap
+
+.PHONY: configure-stagefeedback-function_reordering_plugin maybe-configure-stagefeedback-function_reordering_plugin
+maybe-configure-stagefeedback-function_reordering_plugin:
+@if function_reordering_plugin-bootstrap
+maybe-configure-stagefeedback-function_reordering_plugin: configure-stagefeedback-function_reordering_plugin
+configure-stagefeedback-function_reordering_plugin:
+	@[ $(current_stage) = stagefeedback ] || $(MAKE) stagefeedback-start
+	@$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/function_reordering_plugin
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	TFLAGS="$(STAGEfeedback_TFLAGS)"; \
+	test ! -f $(HOST_SUBDIR)/function_reordering_plugin/Makefile || exit 0; \
+	$(HOST_EXPORTS) \
+	$(POSTSTAGE1_HOST_EXPORTS) \
+	CFLAGS="$(STAGEfeedback_CFLAGS)"; export CFLAGS; \
+	CXXFLAGS="$(STAGEfeedback_CXXFLAGS)"; export CXXFLAGS; \
+	LIBCFLAGS="$(STAGEfeedback_CFLAGS)"; export LIBCFLAGS;  \
+	echo Configuring stage feedback in $(HOST_SUBDIR)/function_reordering_plugin ; \
+	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/function_reordering_plugin ; \
+	cd $(HOST_SUBDIR)/function_reordering_plugin || exit 1; \
+	case $(srcdir) in \
+	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  *) topdir=`echo $(HOST_SUBDIR)/function_reordering_plugin/ | \
+		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
+	esac; \
+	srcdiroption="--srcdir=$${topdir}/function_reordering_plugin"; \
+	libsrcdir="$$s/function_reordering_plugin"; \
+	$(SHELL) $${libsrcdir}/configure \
+	  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \
+	  --target=${target_alias} $${srcdiroption} \
+	  --with-build-libsubdir=$(HOST_SUBDIR) \
+	  $(STAGEfeedback_CONFIGURE_FLAGS) \
+	  --enable-shared
+@endif function_reordering_plugin-bootstrap
+
+
+
+
+
+.PHONY: all-function_reordering_plugin maybe-all-function_reordering_plugin
+maybe-all-function_reordering_plugin:
+@if gcc-bootstrap
+all-function_reordering_plugin: stage_current
+@endif gcc-bootstrap
+@if function_reordering_plugin
+TARGET-function_reordering_plugin=all
+maybe-all-function_reordering_plugin: all-function_reordering_plugin
+all-function_reordering_plugin: configure-function_reordering_plugin
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS)  \
+	(cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) $(EXTRA_HOST_FLAGS) $(STAGE1_FLAGS_TO_PASS)  \
+		$(TARGET-function_reordering_plugin))
+@endif function_reordering_plugin
+
+
+
+.PHONY: all-stage1-function_reordering_plugin maybe-all-stage1-function_reordering_plugin
+.PHONY: clean-stage1-function_reordering_plugin maybe-clean-stage1-function_reordering_plugin
+maybe-all-stage1-function_reordering_plugin:
+maybe-clean-stage1-function_reordering_plugin:
+@if function_reordering_plugin-bootstrap
+maybe-all-stage1-function_reordering_plugin: all-stage1-function_reordering_plugin
+all-stage1: all-stage1-function_reordering_plugin
+TARGET-stage1-function_reordering_plugin = $(TARGET-function_reordering_plugin)
+all-stage1-function_reordering_plugin: configure-stage1-function_reordering_plugin
+	@[ $(current_stage) = stage1 ] || $(MAKE) stage1-start
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	TFLAGS="$(STAGE1_TFLAGS)"; \
+	$(HOST_EXPORTS)  \
+	cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	$(MAKE) $(BASE_FLAGS_TO_PASS) \
+		CFLAGS="$(STAGE1_CFLAGS)" \
+		CXXFLAGS="$(STAGE1_CXXFLAGS)" \
+		LIBCFLAGS="$(LIBCFLAGS)" \
+		CFLAGS_FOR_TARGET="$(CFLAGS_FOR_TARGET)" \
+		CXXFLAGS_FOR_TARGET="$(CXXFLAGS_FOR_TARGET)" \
+		LIBCFLAGS_FOR_TARGET="$(LIBCFLAGS_FOR_TARGET)" \
+		$(EXTRA_HOST_FLAGS)  \
+		$(STAGE1_FLAGS_TO_PASS)  \
+		TFLAGS="$(STAGE1_TFLAGS)" \
+		$(TARGET-stage1-function_reordering_plugin)
+
+maybe-clean-stage1-function_reordering_plugin: clean-stage1-function_reordering_plugin
+clean-stage1: clean-stage1-function_reordering_plugin
+clean-stage1-function_reordering_plugin:
+	@if [ $(current_stage) = stage1 ]; then \
+	  [ -f $(HOST_SUBDIR)/function_reordering_plugin/Makefile ] || exit 0; \
+	else \
+	  [ -f $(HOST_SUBDIR)/stage1-function_reordering_plugin/Makefile ] || exit 0; \
+	  $(MAKE) stage1-start; \
+	fi; \
+	cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	$(MAKE) $(EXTRA_HOST_FLAGS)  \
+	$(STAGE1_FLAGS_TO_PASS)  clean
+@endif function_reordering_plugin-bootstrap
+
+
+.PHONY: all-stage2-function_reordering_plugin maybe-all-stage2-function_reordering_plugin
+.PHONY: clean-stage2-function_reordering_plugin maybe-clean-stage2-function_reordering_plugin
+maybe-all-stage2-function_reordering_plugin:
+maybe-clean-stage2-function_reordering_plugin:
+@if function_reordering_plugin-bootstrap
+maybe-all-stage2-function_reordering_plugin: all-stage2-function_reordering_plugin
+all-stage2: all-stage2-function_reordering_plugin
+TARGET-stage2-function_reordering_plugin = $(TARGET-function_reordering_plugin)
+all-stage2-function_reordering_plugin: configure-stage2-function_reordering_plugin
+	@[ $(current_stage) = stage2 ] || $(MAKE) stage2-start
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	TFLAGS="$(STAGE2_TFLAGS)"; \
+	$(HOST_EXPORTS) \
+	$(POSTSTAGE1_HOST_EXPORTS)  \
+	cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	$(MAKE) $(BASE_FLAGS_TO_PASS) \
+		CFLAGS="$(STAGE2_CFLAGS)" \
+		CXXFLAGS="$(STAGE2_CXXFLAGS)" \
+		LIBCFLAGS="$(STAGE2_CFLAGS)" \
+		CFLAGS_FOR_TARGET="$(CFLAGS_FOR_TARGET)" \
+		CXXFLAGS_FOR_TARGET="$(CXXFLAGS_FOR_TARGET)" \
+		LIBCFLAGS_FOR_TARGET="$(LIBCFLAGS_FOR_TARGET)" \
+		$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  \
+		TFLAGS="$(STAGE2_TFLAGS)" \
+		$(TARGET-stage2-function_reordering_plugin)
+
+maybe-clean-stage2-function_reordering_plugin: clean-stage2-function_reordering_plugin
+clean-stage2: clean-stage2-function_reordering_plugin
+clean-stage2-function_reordering_plugin:
+	@if [ $(current_stage) = stage2 ]; then \
+	  [ -f $(HOST_SUBDIR)/function_reordering_plugin/Makefile ] || exit 0; \
+	else \
+	  [ -f $(HOST_SUBDIR)/stage2-function_reordering_plugin/Makefile ] || exit 0; \
+	  $(MAKE) stage2-start; \
+	fi; \
+	cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	$(MAKE) $(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  clean
+@endif function_reordering_plugin-bootstrap
+
+
+.PHONY: all-stage3-function_reordering_plugin maybe-all-stage3-function_reordering_plugin
+.PHONY: clean-stage3-function_reordering_plugin maybe-clean-stage3-function_reordering_plugin
+maybe-all-stage3-function_reordering_plugin:
+maybe-clean-stage3-function_reordering_plugin:
+@if function_reordering_plugin-bootstrap
+maybe-all-stage3-function_reordering_plugin: all-stage3-function_reordering_plugin
+all-stage3: all-stage3-function_reordering_plugin
+TARGET-stage3-function_reordering_plugin = $(TARGET-function_reordering_plugin)
+all-stage3-function_reordering_plugin: configure-stage3-function_reordering_plugin
+	@[ $(current_stage) = stage3 ] || $(MAKE) stage3-start
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	TFLAGS="$(STAGE3_TFLAGS)"; \
+	$(HOST_EXPORTS) \
+	$(POSTSTAGE1_HOST_EXPORTS)  \
+	cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	$(MAKE) $(BASE_FLAGS_TO_PASS) \
+		CFLAGS="$(STAGE3_CFLAGS)" \
+		CXXFLAGS="$(STAGE3_CXXFLAGS)" \
+		LIBCFLAGS="$(STAGE3_CFLAGS)" \
+		CFLAGS_FOR_TARGET="$(CFLAGS_FOR_TARGET)" \
+		CXXFLAGS_FOR_TARGET="$(CXXFLAGS_FOR_TARGET)" \
+		LIBCFLAGS_FOR_TARGET="$(LIBCFLAGS_FOR_TARGET)" \
+		$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  \
+		TFLAGS="$(STAGE3_TFLAGS)" \
+		$(TARGET-stage3-function_reordering_plugin)
+
+maybe-clean-stage3-function_reordering_plugin: clean-stage3-function_reordering_plugin
+clean-stage3: clean-stage3-function_reordering_plugin
+clean-stage3-function_reordering_plugin:
+	@if [ $(current_stage) = stage3 ]; then \
+	  [ -f $(HOST_SUBDIR)/function_reordering_plugin/Makefile ] || exit 0; \
+	else \
+	  [ -f $(HOST_SUBDIR)/stage3-function_reordering_plugin/Makefile ] || exit 0; \
+	  $(MAKE) stage3-start; \
+	fi; \
+	cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	$(MAKE) $(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  clean
+@endif function_reordering_plugin-bootstrap
+
+
+.PHONY: all-stage4-function_reordering_plugin maybe-all-stage4-function_reordering_plugin
+.PHONY: clean-stage4-function_reordering_plugin maybe-clean-stage4-function_reordering_plugin
+maybe-all-stage4-function_reordering_plugin:
+maybe-clean-stage4-function_reordering_plugin:
+@if function_reordering_plugin-bootstrap
+maybe-all-stage4-function_reordering_plugin: all-stage4-function_reordering_plugin
+all-stage4: all-stage4-function_reordering_plugin
+TARGET-stage4-function_reordering_plugin = $(TARGET-function_reordering_plugin)
+all-stage4-function_reordering_plugin: configure-stage4-function_reordering_plugin
+	@[ $(current_stage) = stage4 ] || $(MAKE) stage4-start
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	TFLAGS="$(STAGE4_TFLAGS)"; \
+	$(HOST_EXPORTS) \
+	$(POSTSTAGE1_HOST_EXPORTS)  \
+	cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	$(MAKE) $(BASE_FLAGS_TO_PASS) \
+		CFLAGS="$(STAGE4_CFLAGS)" \
+		CXXFLAGS="$(STAGE4_CXXFLAGS)" \
+		LIBCFLAGS="$(STAGE4_CFLAGS)" \
+		CFLAGS_FOR_TARGET="$(CFLAGS_FOR_TARGET)" \
+		CXXFLAGS_FOR_TARGET="$(CXXFLAGS_FOR_TARGET)" \
+		LIBCFLAGS_FOR_TARGET="$(LIBCFLAGS_FOR_TARGET)" \
+		$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  \
+		TFLAGS="$(STAGE4_TFLAGS)" \
+		$(TARGET-stage4-function_reordering_plugin)
+
+maybe-clean-stage4-function_reordering_plugin: clean-stage4-function_reordering_plugin
+clean-stage4: clean-stage4-function_reordering_plugin
+clean-stage4-function_reordering_plugin:
+	@if [ $(current_stage) = stage4 ]; then \
+	  [ -f $(HOST_SUBDIR)/function_reordering_plugin/Makefile ] || exit 0; \
+	else \
+	  [ -f $(HOST_SUBDIR)/stage4-function_reordering_plugin/Makefile ] || exit 0; \
+	  $(MAKE) stage4-start; \
+	fi; \
+	cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	$(MAKE) $(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  clean
+@endif function_reordering_plugin-bootstrap
+
+
+.PHONY: all-stageprofile-function_reordering_plugin maybe-all-stageprofile-function_reordering_plugin
+.PHONY: clean-stageprofile-function_reordering_plugin maybe-clean-stageprofile-function_reordering_plugin
+maybe-all-stageprofile-function_reordering_plugin:
+maybe-clean-stageprofile-function_reordering_plugin:
+@if function_reordering_plugin-bootstrap
+maybe-all-stageprofile-function_reordering_plugin: all-stageprofile-function_reordering_plugin
+all-stageprofile: all-stageprofile-function_reordering_plugin
+TARGET-stageprofile-function_reordering_plugin = $(TARGET-function_reordering_plugin)
+all-stageprofile-function_reordering_plugin: configure-stageprofile-function_reordering_plugin
+	@[ $(current_stage) = stageprofile ] || $(MAKE) stageprofile-start
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	TFLAGS="$(STAGEprofile_TFLAGS)"; \
+	$(HOST_EXPORTS) \
+	$(POSTSTAGE1_HOST_EXPORTS)  \
+	cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	$(MAKE) $(BASE_FLAGS_TO_PASS) \
+		CFLAGS="$(STAGEprofile_CFLAGS)" \
+		CXXFLAGS="$(STAGEprofile_CXXFLAGS)" \
+		LIBCFLAGS="$(STAGEprofile_CFLAGS)" \
+		CFLAGS_FOR_TARGET="$(CFLAGS_FOR_TARGET)" \
+		CXXFLAGS_FOR_TARGET="$(CXXFLAGS_FOR_TARGET)" \
+		LIBCFLAGS_FOR_TARGET="$(LIBCFLAGS_FOR_TARGET)" \
+		$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  \
+		TFLAGS="$(STAGEprofile_TFLAGS)" \
+		$(TARGET-stageprofile-function_reordering_plugin)
+
+maybe-clean-stageprofile-function_reordering_plugin: clean-stageprofile-function_reordering_plugin
+clean-stageprofile: clean-stageprofile-function_reordering_plugin
+clean-stageprofile-function_reordering_plugin:
+	@if [ $(current_stage) = stageprofile ]; then \
+	  [ -f $(HOST_SUBDIR)/function_reordering_plugin/Makefile ] || exit 0; \
+	else \
+	  [ -f $(HOST_SUBDIR)/stageprofile-function_reordering_plugin/Makefile ] || exit 0; \
+	  $(MAKE) stageprofile-start; \
+	fi; \
+	cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	$(MAKE) $(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  clean
+@endif function_reordering_plugin-bootstrap
+
+
+.PHONY: all-stagefeedback-function_reordering_plugin maybe-all-stagefeedback-function_reordering_plugin
+.PHONY: clean-stagefeedback-function_reordering_plugin maybe-clean-stagefeedback-function_reordering_plugin
+maybe-all-stagefeedback-function_reordering_plugin:
+maybe-clean-stagefeedback-function_reordering_plugin:
+@if function_reordering_plugin-bootstrap
+maybe-all-stagefeedback-function_reordering_plugin: all-stagefeedback-function_reordering_plugin
+all-stagefeedback: all-stagefeedback-function_reordering_plugin
+TARGET-stagefeedback-function_reordering_plugin = $(TARGET-function_reordering_plugin)
+all-stagefeedback-function_reordering_plugin: configure-stagefeedback-function_reordering_plugin
+	@[ $(current_stage) = stagefeedback ] || $(MAKE) stagefeedback-start
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	TFLAGS="$(STAGEfeedback_TFLAGS)"; \
+	$(HOST_EXPORTS) \
+	$(POSTSTAGE1_HOST_EXPORTS)  \
+	cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	$(MAKE) $(BASE_FLAGS_TO_PASS) \
+		CFLAGS="$(STAGEfeedback_CFLAGS)" \
+		CXXFLAGS="$(STAGEfeedback_CXXFLAGS)" \
+		LIBCFLAGS="$(STAGEfeedback_CFLAGS)" \
+		CFLAGS_FOR_TARGET="$(CFLAGS_FOR_TARGET)" \
+		CXXFLAGS_FOR_TARGET="$(CXXFLAGS_FOR_TARGET)" \
+		LIBCFLAGS_FOR_TARGET="$(LIBCFLAGS_FOR_TARGET)" \
+		$(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  \
+		TFLAGS="$(STAGEfeedback_TFLAGS)" \
+		$(TARGET-stagefeedback-function_reordering_plugin)
+
+maybe-clean-stagefeedback-function_reordering_plugin: clean-stagefeedback-function_reordering_plugin
+clean-stagefeedback: clean-stagefeedback-function_reordering_plugin
+clean-stagefeedback-function_reordering_plugin:
+	@if [ $(current_stage) = stagefeedback ]; then \
+	  [ -f $(HOST_SUBDIR)/function_reordering_plugin/Makefile ] || exit 0; \
+	else \
+	  [ -f $(HOST_SUBDIR)/stagefeedback-function_reordering_plugin/Makefile ] || exit 0; \
+	  $(MAKE) stagefeedback-start; \
+	fi; \
+	cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	$(MAKE) $(EXTRA_HOST_FLAGS) $(POSTSTAGE1_FLAGS_TO_PASS)  clean
+@endif function_reordering_plugin-bootstrap
+
+
+
+
+
+.PHONY: check-function_reordering_plugin maybe-check-function_reordering_plugin
+maybe-check-function_reordering_plugin:
+@if function_reordering_plugin
+maybe-check-function_reordering_plugin: check-function_reordering_plugin
+
+check-function_reordering_plugin:
+	@: $(MAKE); $(unstage)
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	(cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	  $(MAKE) $(FLAGS_TO_PASS)  check)
+
+@endif function_reordering_plugin
+
+.PHONY: install-function_reordering_plugin maybe-install-function_reordering_plugin
+maybe-install-function_reordering_plugin:
+@if function_reordering_plugin
+maybe-install-function_reordering_plugin: install-function_reordering_plugin
+
+install-function_reordering_plugin: installdirs
+	@: $(MAKE); $(unstage)
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	(cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	  $(MAKE) $(FLAGS_TO_PASS)  install)
+
+@endif function_reordering_plugin
+
+.PHONY: install-strip-function_reordering_plugin maybe-install-strip-function_reordering_plugin
+maybe-install-strip-function_reordering_plugin:
+@if function_reordering_plugin
+maybe-install-strip-function_reordering_plugin: install-strip-function_reordering_plugin
+
+install-strip-function_reordering_plugin: installdirs
+	@: $(MAKE); $(unstage)
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	(cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	  $(MAKE) $(FLAGS_TO_PASS)  install-strip)
+
+@endif function_reordering_plugin
+
+# Other targets (info, dvi, pdf, etc.)
+
+.PHONY: maybe-info-function_reordering_plugin info-function_reordering_plugin
+maybe-info-function_reordering_plugin:
+@if function_reordering_plugin
+maybe-info-function_reordering_plugin: info-function_reordering_plugin
+
+info-function_reordering_plugin: \
+    configure-function_reordering_plugin 
+	@[ -f ./function_reordering_plugin/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing info in function_reordering_plugin" ; \
+	(cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          info) \
+	  || exit 1
+
+@endif function_reordering_plugin
+
+.PHONY: maybe-dvi-function_reordering_plugin dvi-function_reordering_plugin
+maybe-dvi-function_reordering_plugin:
+@if function_reordering_plugin
+maybe-dvi-function_reordering_plugin: dvi-function_reordering_plugin
+
+dvi-function_reordering_plugin: \
+    configure-function_reordering_plugin 
+	@[ -f ./function_reordering_plugin/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing dvi in function_reordering_plugin" ; \
+	(cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          dvi) \
+	  || exit 1
+
+@endif function_reordering_plugin
+
+.PHONY: maybe-pdf-function_reordering_plugin pdf-function_reordering_plugin
+maybe-pdf-function_reordering_plugin:
+@if function_reordering_plugin
+maybe-pdf-function_reordering_plugin: pdf-function_reordering_plugin
+
+pdf-function_reordering_plugin: \
+    configure-function_reordering_plugin 
+	@[ -f ./function_reordering_plugin/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing pdf in function_reordering_plugin" ; \
+	(cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          pdf) \
+	  || exit 1
+
+@endif function_reordering_plugin
+
+.PHONY: maybe-html-function_reordering_plugin html-function_reordering_plugin
+maybe-html-function_reordering_plugin:
+@if function_reordering_plugin
+maybe-html-function_reordering_plugin: html-function_reordering_plugin
+
+html-function_reordering_plugin: \
+    configure-function_reordering_plugin 
+	@[ -f ./function_reordering_plugin/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing html in function_reordering_plugin" ; \
+	(cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          html) \
+	  || exit 1
+
+@endif function_reordering_plugin
+
+.PHONY: maybe-TAGS-function_reordering_plugin TAGS-function_reordering_plugin
+maybe-TAGS-function_reordering_plugin:
+@if function_reordering_plugin
+maybe-TAGS-function_reordering_plugin: TAGS-function_reordering_plugin
+
+TAGS-function_reordering_plugin: \
+    configure-function_reordering_plugin 
+	@[ -f ./function_reordering_plugin/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing TAGS in function_reordering_plugin" ; \
+	(cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          TAGS) \
+	  || exit 1
+
+@endif function_reordering_plugin
+
+.PHONY: maybe-install-info-function_reordering_plugin install-info-function_reordering_plugin
+maybe-install-info-function_reordering_plugin:
+@if function_reordering_plugin
+maybe-install-info-function_reordering_plugin: install-info-function_reordering_plugin
+
+install-info-function_reordering_plugin: \
+    configure-function_reordering_plugin \
+    info-function_reordering_plugin 
+	@[ -f ./function_reordering_plugin/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing install-info in function_reordering_plugin" ; \
+	(cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          install-info) \
+	  || exit 1
+
+@endif function_reordering_plugin
+
+.PHONY: maybe-install-pdf-function_reordering_plugin install-pdf-function_reordering_plugin
+maybe-install-pdf-function_reordering_plugin:
+@if function_reordering_plugin
+maybe-install-pdf-function_reordering_plugin: install-pdf-function_reordering_plugin
+
+install-pdf-function_reordering_plugin: \
+    configure-function_reordering_plugin \
+    pdf-function_reordering_plugin 
+	@[ -f ./function_reordering_plugin/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing install-pdf in function_reordering_plugin" ; \
+	(cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          install-pdf) \
+	  || exit 1
+
+@endif function_reordering_plugin
+
+.PHONY: maybe-install-html-function_reordering_plugin install-html-function_reordering_plugin
+maybe-install-html-function_reordering_plugin:
+@if function_reordering_plugin
+maybe-install-html-function_reordering_plugin: install-html-function_reordering_plugin
+
+install-html-function_reordering_plugin: \
+    configure-function_reordering_plugin \
+    html-function_reordering_plugin 
+	@[ -f ./function_reordering_plugin/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing install-html in function_reordering_plugin" ; \
+	(cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          install-html) \
+	  || exit 1
+
+@endif function_reordering_plugin
+
+.PHONY: maybe-installcheck-function_reordering_plugin installcheck-function_reordering_plugin
+maybe-installcheck-function_reordering_plugin:
+@if function_reordering_plugin
+maybe-installcheck-function_reordering_plugin: installcheck-function_reordering_plugin
+
+installcheck-function_reordering_plugin: \
+    configure-function_reordering_plugin 
+	@[ -f ./function_reordering_plugin/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing installcheck in function_reordering_plugin" ; \
+	(cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          installcheck) \
+	  || exit 1
+
+@endif function_reordering_plugin
+
+.PHONY: maybe-mostlyclean-function_reordering_plugin mostlyclean-function_reordering_plugin
+maybe-mostlyclean-function_reordering_plugin:
+@if function_reordering_plugin
+maybe-mostlyclean-function_reordering_plugin: mostlyclean-function_reordering_plugin
+
+mostlyclean-function_reordering_plugin: 
+	@[ -f ./function_reordering_plugin/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing mostlyclean in function_reordering_plugin" ; \
+	(cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          mostlyclean) \
+	  || exit 1
+
+@endif function_reordering_plugin
+
+.PHONY: maybe-clean-function_reordering_plugin clean-function_reordering_plugin
+maybe-clean-function_reordering_plugin:
+@if function_reordering_plugin
+maybe-clean-function_reordering_plugin: clean-function_reordering_plugin
+
+clean-function_reordering_plugin: 
+	@[ -f ./function_reordering_plugin/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing clean in function_reordering_plugin" ; \
+	(cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          clean) \
+	  || exit 1
+
+@endif function_reordering_plugin
+
+.PHONY: maybe-distclean-function_reordering_plugin distclean-function_reordering_plugin
+maybe-distclean-function_reordering_plugin:
+@if function_reordering_plugin
+maybe-distclean-function_reordering_plugin: distclean-function_reordering_plugin
+
+distclean-function_reordering_plugin: 
+	@[ -f ./function_reordering_plugin/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing distclean in function_reordering_plugin" ; \
+	(cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          distclean) \
+	  || exit 1
+
+@endif function_reordering_plugin
+
+.PHONY: maybe-maintainer-clean-function_reordering_plugin maintainer-clean-function_reordering_plugin
+maybe-maintainer-clean-function_reordering_plugin:
+@if function_reordering_plugin
+maybe-maintainer-clean-function_reordering_plugin: maintainer-clean-function_reordering_plugin
+
+maintainer-clean-function_reordering_plugin: 
+	@[ -f ./function_reordering_plugin/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing maintainer-clean in function_reordering_plugin" ; \
+	(cd $(HOST_SUBDIR)/function_reordering_plugin && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          maintainer-clean) \
+	  || exit 1
+
+@endif function_reordering_plugin
+
+
+
 # ---------------------------------------
 # Modules which run on the target machine
 # ---------------------------------------
@@ -43516,6 +44409,11 @@ stage1-start::
 	  mkdir stage1-lto-plugin; \
 	mv stage1-lto-plugin lto-plugin 
 @endif lto-plugin
+@if function_reordering_plugin
+	@cd $(HOST_SUBDIR); [ -d stage1-function_reordering_plugin ] || \
+	  mkdir stage1-function_reordering_plugin; \
+	mv stage1-function_reordering_plugin function_reordering_plugin 
+@endif function_reordering_plugin
 	@[ -d stage1-$(TARGET_SUBDIR) ] || \
 	  mkdir stage1-$(TARGET_SUBDIR); \
 	mv stage1-$(TARGET_SUBDIR) $(TARGET_SUBDIR) 
@@ -43621,6 +44519,11 @@ stage1-end::
 	  cd $(HOST_SUBDIR); mv lto-plugin stage1-lto-plugin  ; \
 	fi
 @endif lto-plugin
+@if function_reordering_plugin
+	@if test -d $(HOST_SUBDIR)/function_reordering_plugin ; then \
+	  cd $(HOST_SUBDIR); mv function_reordering_plugin stage1-function_reordering_plugin  ; \
+	fi
+@endif function_reordering_plugin
 	@if test -d $(TARGET_SUBDIR) ; then \
 	  mv $(TARGET_SUBDIR) stage1-$(TARGET_SUBDIR)  ; \
 	fi
@@ -43789,6 +44692,12 @@ stage2-start::
 	mv stage2-lto-plugin lto-plugin  ; \
 	mv stage1-lto-plugin prev-lto-plugin || test -f stage1-lean 
 @endif lto-plugin
+@if function_reordering_plugin
+	@cd $(HOST_SUBDIR); [ -d stage2-function_reordering_plugin ] || \
+	  mkdir stage2-function_reordering_plugin; \
+	mv stage2-function_reordering_plugin function_reordering_plugin  ; \
+	mv stage1-function_reordering_plugin prev-function_reordering_plugin || test -f stage1-lean 
+@endif function_reordering_plugin
 	@[ -d stage2-$(TARGET_SUBDIR) ] || \
 	  mkdir stage2-$(TARGET_SUBDIR); \
 	mv stage2-$(TARGET_SUBDIR) $(TARGET_SUBDIR)  ; \
@@ -43915,6 +44824,12 @@ stage2-end::
 	  mv prev-lto-plugin stage1-lto-plugin ; :  ; \
 	fi
 @endif lto-plugin
+@if function_reordering_plugin
+	@if test -d $(HOST_SUBDIR)/function_reordering_plugin ; then \
+	  cd $(HOST_SUBDIR); mv function_reordering_plugin stage2-function_reordering_plugin ; \
+	  mv prev-function_reordering_plugin stage1-function_reordering_plugin ; :  ; \
+	fi
+@endif function_reordering_plugin
 	@if test -d $(TARGET_SUBDIR) ; then \
 	  mv $(TARGET_SUBDIR) stage2-$(TARGET_SUBDIR)  ; \
 	  mv prev-$(TARGET_SUBDIR) stage1-$(TARGET_SUBDIR) ; :  ; \
@@ -44107,6 +45022,12 @@ stage3-start::
 	mv stage3-lto-plugin lto-plugin  ; \
 	mv stage2-lto-plugin prev-lto-plugin || test -f stage2-lean 
 @endif lto-plugin
+@if function_reordering_plugin
+	@cd $(HOST_SUBDIR); [ -d stage3-function_reordering_plugin ] || \
+	  mkdir stage3-function_reordering_plugin; \
+	mv stage3-function_reordering_plugin function_reordering_plugin  ; \
+	mv stage2-function_reordering_plugin prev-function_reordering_plugin || test -f stage2-lean 
+@endif function_reordering_plugin
 	@[ -d stage3-$(TARGET_SUBDIR) ] || \
 	  mkdir stage3-$(TARGET_SUBDIR); \
 	mv stage3-$(TARGET_SUBDIR) $(TARGET_SUBDIR)  ; \
@@ -44233,6 +45154,12 @@ stage3-end::
 	  mv prev-lto-plugin stage2-lto-plugin ; :  ; \
 	fi
 @endif lto-plugin
+@if function_reordering_plugin
+	@if test -d $(HOST_SUBDIR)/function_reordering_plugin ; then \
+	  cd $(HOST_SUBDIR); mv function_reordering_plugin stage3-function_reordering_plugin ; \
+	  mv prev-function_reordering_plugin stage2-function_reordering_plugin ; :  ; \
+	fi
+@endif function_reordering_plugin
 	@if test -d $(TARGET_SUBDIR) ; then \
 	  mv $(TARGET_SUBDIR) stage3-$(TARGET_SUBDIR)  ; \
 	  mv prev-$(TARGET_SUBDIR) stage2-$(TARGET_SUBDIR) ; :  ; \
@@ -44481,6 +45408,12 @@ stage4-start::
 	mv stage4-lto-plugin lto-plugin  ; \
 	mv stage3-lto-plugin prev-lto-plugin || test -f stage3-lean 
 @endif lto-plugin
+@if function_reordering_plugin
+	@cd $(HOST_SUBDIR); [ -d stage4-function_reordering_plugin ] || \
+	  mkdir stage4-function_reordering_plugin; \
+	mv stage4-function_reordering_plugin function_reordering_plugin  ; \
+	mv stage3-function_reordering_plugin prev-function_reordering_plugin || test -f stage3-lean 
+@endif function_reordering_plugin
 	@[ -d stage4-$(TARGET_SUBDIR) ] || \
 	  mkdir stage4-$(TARGET_SUBDIR); \
 	mv stage4-$(TARGET_SUBDIR) $(TARGET_SUBDIR)  ; \
@@ -44607,6 +45540,12 @@ stage4-end::
 	  mv prev-lto-plugin stage3-lto-plugin ; :  ; \
 	fi
 @endif lto-plugin
+@if function_reordering_plugin
+	@if test -d $(HOST_SUBDIR)/function_reordering_plugin ; then \
+	  cd $(HOST_SUBDIR); mv function_reordering_plugin stage4-function_reordering_plugin ; \
+	  mv prev-function_reordering_plugin stage3-function_reordering_plugin ; :  ; \
+	fi
+@endif function_reordering_plugin
 	@if test -d $(TARGET_SUBDIR) ; then \
 	  mv $(TARGET_SUBDIR) stage4-$(TARGET_SUBDIR)  ; \
 	  mv prev-$(TARGET_SUBDIR) stage3-$(TARGET_SUBDIR) ; :  ; \
@@ -44843,6 +45782,12 @@ stageprofile-start::
 	mv stageprofile-lto-plugin lto-plugin  ; \
 	mv stage1-lto-plugin prev-lto-plugin || test -f stage1-lean 
 @endif lto-plugin
+@if function_reordering_plugin
+	@cd $(HOST_SUBDIR); [ -d stageprofile-function_reordering_plugin ] || \
+	  mkdir stageprofile-function_reordering_plugin; \
+	mv stageprofile-function_reordering_plugin function_reordering_plugin  ; \
+	mv stage1-function_reordering_plugin prev-function_reordering_plugin || test -f stage1-lean 
+@endif function_reordering_plugin
 	@[ -d stageprofile-$(TARGET_SUBDIR) ] || \
 	  mkdir stageprofile-$(TARGET_SUBDIR); \
 	mv stageprofile-$(TARGET_SUBDIR) $(TARGET_SUBDIR)  ; \
@@ -44969,6 +45914,12 @@ stageprofile-end::
 	  mv prev-lto-plugin stage1-lto-plugin ; :  ; \
 	fi
 @endif lto-plugin
+@if function_reordering_plugin
+	@if test -d $(HOST_SUBDIR)/function_reordering_plugin ; then \
+	  cd $(HOST_SUBDIR); mv function_reordering_plugin stageprofile-function_reordering_plugin ; \
+	  mv prev-function_reordering_plugin stage1-function_reordering_plugin ; :  ; \
+	fi
+@endif function_reordering_plugin
 	@if test -d $(TARGET_SUBDIR) ; then \
 	  mv $(TARGET_SUBDIR) stageprofile-$(TARGET_SUBDIR)  ; \
 	  mv prev-$(TARGET_SUBDIR) stage1-$(TARGET_SUBDIR) ; :  ; \
@@ -45138,6 +46089,12 @@ stagefeedback-start::
 	mv stagefeedback-lto-plugin lto-plugin  ; \
 	mv stageprofile-lto-plugin prev-lto-plugin || test -f stageprofile-lean 
 @endif lto-plugin
+@if function_reordering_plugin
+	@cd $(HOST_SUBDIR); [ -d stagefeedback-function_reordering_plugin ] || \
+	  mkdir stagefeedback-function_reordering_plugin; \
+	mv stagefeedback-function_reordering_plugin function_reordering_plugin  ; \
+	mv stageprofile-function_reordering_plugin prev-function_reordering_plugin || test -f stageprofile-lean 
+@endif function_reordering_plugin
 	@[ -d stagefeedback-$(TARGET_SUBDIR) ] || \
 	  mkdir stagefeedback-$(TARGET_SUBDIR); \
 	mv stagefeedback-$(TARGET_SUBDIR) $(TARGET_SUBDIR)  ; \
@@ -45264,6 +46221,12 @@ stagefeedback-end::
 	  mv prev-lto-plugin stageprofile-lto-plugin ; :  ; \
 	fi
 @endif lto-plugin
+@if function_reordering_plugin
+	@if test -d $(HOST_SUBDIR)/function_reordering_plugin ; then \
+	  cd $(HOST_SUBDIR); mv function_reordering_plugin stagefeedback-function_reordering_plugin ; \
+	  mv prev-function_reordering_plugin stageprofile-function_reordering_plugin ; :  ; \
+	fi
+@endif function_reordering_plugin
 	@if test -d $(TARGET_SUBDIR) ; then \
 	  mv $(TARGET_SUBDIR) stagefeedback-$(TARGET_SUBDIR)  ; \
 	  mv prev-$(TARGET_SUBDIR) stageprofile-$(TARGET_SUBDIR) ; :  ; \
@@ -45491,6 +46454,14 @@ configure-stage3-gcc: maybe-all-stage3-lto-plugin
 configure-stage4-gcc: maybe-all-stage4-lto-plugin
 configure-stageprofile-gcc: maybe-all-stageprofile-lto-plugin
 configure-stagefeedback-gcc: maybe-all-stagefeedback-lto-plugin
+configure-gcc: maybe-all-function_reordering_plugin
+
+configure-stage1-gcc: maybe-all-stage1-function_reordering_plugin
+configure-stage2-gcc: maybe-all-stage2-function_reordering_plugin
+configure-stage3-gcc: maybe-all-stage3-function_reordering_plugin
+configure-stage4-gcc: maybe-all-stage4-function_reordering_plugin
+configure-stageprofile-gcc: maybe-all-stageprofile-function_reordering_plugin
+configure-stagefeedback-gcc: maybe-all-stagefeedback-function_reordering_plugin
 configure-gcc: maybe-all-binutils
 
 configure-stage1-gcc: maybe-all-stage1-binutils
@@ -45660,6 +46631,14 @@ all-stage3-gcc: maybe-all-stage3-lto-plugin
 all-stage4-gcc: maybe-all-stage4-lto-plugin
 all-stageprofile-gcc: maybe-all-stageprofile-lto-plugin
 all-stagefeedback-gcc: maybe-all-stagefeedback-lto-plugin
+all-gcc: maybe-all-function_reordering_plugin
+
+all-stage1-gcc: maybe-all-stage1-function_reordering_plugin
+all-stage2-gcc: maybe-all-stage2-function_reordering_plugin
+all-stage3-gcc: maybe-all-stage3-function_reordering_plugin
+all-stage4-gcc: maybe-all-stage4-function_reordering_plugin
+all-stageprofile-gcc: maybe-all-stageprofile-function_reordering_plugin
+all-stagefeedback-gcc: maybe-all-stagefeedback-function_reordering_plugin
 info-gcc: maybe-all-build-libiberty
 
 info-stage1-gcc: maybe-all-build-libiberty
@@ -45694,8 +46673,10 @@ html-stageprofile-gcc: maybe-all-build-libiberty
 html-stagefeedback-gcc: maybe-all-build-libiberty
 install-gcc: maybe-install-fixincludes
 install-gcc: maybe-install-lto-plugin
+install-gcc: maybe-install-function_reordering_plugin
 install-strip-gcc: maybe-install-strip-fixincludes
 install-strip-gcc: maybe-install-strip-lto-plugin
+install-strip-gcc: maybe-install-strip-function_reordering_plugin
 configure-libcpp: configure-libiberty
 
 configure-stage1-libcpp: configure-stage1-libiberty
@@ -45738,6 +46719,14 @@ all-stage3-lto-plugin: maybe-all-stage3-libiberty
 all-stage4-lto-plugin: maybe-all-stage4-libiberty
 all-stageprofile-lto-plugin: maybe-all-stageprofile-libiberty
 all-stagefeedback-lto-plugin: maybe-all-stagefeedback-libiberty
+all-function_reordering_plugin: maybe-all-libiberty
+
+all-stage1-function_reordering_plugin: maybe-all-stage1-libiberty
+all-stage2-function_reordering_plugin: maybe-all-stage2-libiberty
+all-stage3-function_reordering_plugin: maybe-all-stage3-libiberty
+all-stage4-function_reordering_plugin: maybe-all-stage4-libiberty
+all-stageprofile-function_reordering_plugin: maybe-all-stageprofile-libiberty
+all-stagefeedback-function_reordering_plugin: maybe-all-stagefeedback-libiberty
 all-utils: maybe-all-libiberty
 configure-mpfr: maybe-all-gmp
 
@@ -46179,6 +47168,7 @@ all-target-libjava: maybe-all-target-boehm-gc
 all-target-libjava: maybe-all-target-libffi
 configure-target-libobjc: maybe-configure-target-boehm-gc
 all-target-libobjc: maybe-all-target-boehm-gc
+configure-target-libmudflap: maybe-configure-target-libstdc++-v3
 configure-target-libstdc++-v3: maybe-configure-target-libgomp
 
 configure-stage1-target-libstdc++-v3: maybe-configure-stage1-target-libgomp
diff --git a/Makefile.tpl b/Makefile.tpl
index 3233a78..a908fbb 100644
--- a/Makefile.tpl
+++ b/Makefile.tpl
@@ -227,9 +227,6 @@ HOST_EXPORTS = \
 	CLOOGINC="$(HOST_CLOOGINC)"; export CLOOGINC; \
 	LIBELFLIBS="$(HOST_LIBELFLIBS)" ; export LIBELFLIBS; \
 	LIBELFINC="$(HOST_LIBELFINC)" ; export LIBELFINC; \
-@if gcc-bootstrap
-	$(RPATH_ENVVAR)=`echo "$(TARGET_LIB_PATH)$$$(RPATH_ENVVAR)" | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; export $(RPATH_ENVVAR); \
-@endif gcc-bootstrap
 	$(RPATH_ENVVAR)=`echo "$(HOST_LIB_PATH)$$$(RPATH_ENVVAR)" | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; export $(RPATH_ENVVAR);
 
 POSTSTAGE1_CXX_EXPORT = \
@@ -293,9 +290,6 @@ BASE_TARGET_EXPORTS = \
 	STRIP="$(STRIP_FOR_TARGET)"; export STRIP; \
 	WINDRES="$(WINDRES_FOR_TARGET)"; export WINDRES; \
 	WINDMC="$(WINDMC_FOR_TARGET)"; export WINDMC; \
-@if gcc-bootstrap
-	$(RPATH_ENVVAR)=`echo "$(TARGET_LIB_PATH)$$$(RPATH_ENVVAR)" | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; export $(RPATH_ENVVAR); \
-@endif gcc-bootstrap
 	$(RPATH_ENVVAR)=`echo "$(HOST_LIB_PATH)$$$(RPATH_ENVVAR)" | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; export $(RPATH_ENVVAR); \
 	TARGET_CONFIGDIRS="$(TARGET_CONFIGDIRS)"; export TARGET_CONFIGDIRS;
 
diff --git a/boehm-gc/configure b/boehm-gc/configure
index 6020e98..5ddc20e 100755
--- a/boehm-gc/configure
+++ b/boehm-gc/configure
@@ -7886,7 +7886,22 @@ fi
 
 # Check whether --with-pic was given.
 if test "${with_pic+set}" = set; then :
-  withval=$with_pic; pic_mode="$withval"
+  withval=$with_pic; p=${PACKAGE-default}
+    case "$withval" in
+    yes|no) pic_mode="$withval" ;;
+    *)
+      pic_mode=default
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $withval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  pic_mode=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
 else
   pic_mode=default
 fi
@@ -11312,7 +11327,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11315 "configure"
+#line 11330 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11418,7 +11433,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11421 "configure"
+#line 11436 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
diff --git a/configure b/configure
index b790d65..a7508ce 100755
--- a/configure
+++ b/configure
@@ -3601,6 +3601,9 @@ case "${target}" in
   arc-*-*)
     noconfigdirs="$noconfigdirs target-libgloss"
     ;;
+  arm*-*-linux-androideabi)
+    noconfigdirs="$noconfigdirs target-libiberty"
+    ;;
   arm-*-pe*)
     noconfigdirs="$noconfigdirs target-libgloss"
     ;;
@@ -6187,6 +6190,8 @@ esac
 if test $target_elf = yes; then :
   # ELF platforms build the lto-plugin always.
   build_lto_plugin=yes
+  # Allow ELF platforms to build the function_reordering_plugin always.
+  build_function_reordering_plugin=yes
 
 else
   if test x"$default_enable_lto" = x"yes" ; then
@@ -6330,6 +6335,11 @@ if test -d ${srcdir}/gcc; then
       extra_host_libiberty_configure_flags=--enable-shared
     fi
   fi
+  if test "${build_function_reordering_plugin}" = "yes" ; then
+    configdirs="$configdirs function_reordering_plugin"
+    extra_host_libiberty_configure_flags=--enable-shared
+  fi
+
 
 
   missing_languages=`echo ",$enable_languages," | sed -e s/,all,/,/ -e s/,c,/,/ `
diff --git a/configure.ac b/configure.ac
index 93a456f..cb41edc 100644
--- a/configure.ac
+++ b/configure.ac
@@ -940,6 +940,9 @@ case "${target}" in
   arc-*-*)
     noconfigdirs="$noconfigdirs target-libgloss"
     ;;
+  arm*-*-linux-androideabi)
+    noconfigdirs="$noconfigdirs target-libiberty"
+    ;;
   arm-*-pe*)
     noconfigdirs="$noconfigdirs target-libgloss"
     ;;
@@ -1677,6 +1680,8 @@ enable_lto=yes; default_enable_lto=yes)
 
 ACX_ELF_TARGET_IFELSE([# ELF platforms build the lto-plugin always.
   build_lto_plugin=yes
+  # Allow ELF platforms to build the function_reordering_plugin always.
+  build_function_reordering_plugin=yes
 ],[if test x"$default_enable_lto" = x"yes" ; then
     case $target in
       *-apple-darwin9* | *-cygwin* | *-mingw*) ;;
@@ -1816,6 +1821,11 @@ if test -d ${srcdir}/gcc; then
       extra_host_libiberty_configure_flags=--enable-shared
     fi
   fi
+  if test "${build_function_reordering_plugin}" = "yes" ; then
+    configdirs="$configdirs function_reordering_plugin"
+    extra_host_libiberty_configure_flags=--enable-shared
+  fi
+
   AC_SUBST(extra_host_libiberty_configure_flags)
 
   missing_languages=`echo ",$enable_languages," | sed -e s/,all,/,/ -e s/,c,/,/ `
diff --git a/contrib/testsuite-management/arm-grtev2-linux-gnueabi.xfail b/contrib/testsuite-management/arm-grtev2-linux-gnueabi.xfail
new file mode 100644
index 0000000..cec59b0
--- /dev/null
+++ b/contrib/testsuite-management/arm-grtev2-linux-gnueabi.xfail
@@ -0,0 +1,126 @@
+# Failures in ./gcc/testsuite/gcc/gcc.sum:
+# *** gcc:
+FAIL: gcc.c-torture/compile/920928-2.c  -Os  (internal compiler error)
+FAIL: gcc.c-torture/compile/920928-2.c  -Os  (test for excess errors)
+FAIL: gcc.dg/builtin-apply2.c execution test
+FAIL: gcc.dg/cproj-fails-with-broken-glibc.c execution test
+FAIL: gcc.dg/di-longlong64-sync-1.c (test for excess errors)
+UNRESOLVED: gcc.dg/di-longlong64-sync-1.c compilation failed to produce executable
+FAIL: gcc.dg/di-sync-multithread.c execution test
+FAIL: gcc.dg/pr49994-3.c (test for excess errors)
+FAIL: gcc.dg/tls/pr42894.c (test for excess errors)
+FAIL: gcc.dg/torture/stackalign/builtin-apply-2.c  -O0  execution test
+FAIL: gcc.dg/torture/stackalign/builtin-apply-2.c  -O0  execution test
+FAIL: gcc.dg/torture/stackalign/builtin-apply-2.c  -O1  execution test
+FAIL: gcc.dg/torture/stackalign/builtin-apply-2.c  -Os  execution test
+
+# There are flaky when running on QEMU
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O0  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O1  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O2  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -fomit-frame-pointer  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -g  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -Os  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O0  -fpic  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O1  -fpic  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O2  -fpic  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -fomit-frame-pointer  -fpic  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -g  -fpic  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -Os  -fpic  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O0  -fPIC  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O1  -fPIC  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O2  -fPIC  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -fomit-frame-pointer  -fPIC  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -g  -fPIC  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -Os  -fPIC  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O0  -pie -fpie  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O1  -pie -fpie  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O2  -pie -fpie  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -fomit-frame-pointer  -pie -fpie  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -g  -pie -fpie  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -Os  -pie -fpie  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O0  -pie -fPIE  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O1  -pie -fPIE  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O2  -pie -fPIE  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -fomit-frame-pointer  -pie -fPIE  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -g  -pie -fPIE  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -Os  -pie -fPIE  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  execution test
+
+FAIL: gcc.dg/tree-ssa/sra-12.c scan-tree-dump-times release_ssa "l;" 0
+FAIL: gcc.dg/vect/vect-104.c scan-tree-dump-times vect "possible dependence between data-refs" 1
+FAIL: gcc.dg/vect/vect-multitypes-11.c scan-tree-dump-times vect "vectorized 1 loops" 1
+FAIL: gcc.dg/vect/vect-multitypes-12.c scan-tree-dump-times vect "vectorized 1 loops" 1
+FAIL: gcc.dg/vect/vect-outer-1-big-array.c scan-tree-dump-times vect "strided access in outer loop" 1
+FAIL: gcc.dg/vect/vect-outer-1.c scan-tree-dump-times vect "strided access in outer loop" 1
+FAIL: gcc.dg/vect/vect-outer-1a-big-array.c scan-tree-dump-times vect "strided access in outer loop" 1
+FAIL: gcc.dg/vect/vect-outer-1a.c scan-tree-dump-times vect "strided access in outer loop" 1
+FAIL: gcc.dg/vect/vect-outer-1b-big-array.c scan-tree-dump-times vect "strided access in outer loop" 1
+FAIL: gcc.dg/vect/vect-outer-1b.c scan-tree-dump-times vect "strided access in outer loop" 1
+FAIL: gcc.dg/vect/vect-outer-2b.c scan-tree-dump-times vect "strided access in outer loop" 1
+FAIL: gcc.dg/vect/vect-outer-3a-big-array.c scan-tree-dump-times vect "step doesn't divide the vector-size" 2
+FAIL: gcc.dg/vect/vect-outer-3a.c scan-tree-dump-times vect "step doesn't divide the vector-size" 2
+FAIL: gcc.dg/vect/vect-outer-3b.c scan-tree-dump-times vect "strided access in outer loop" 2
+FAIL: gcc.dg/vect/vect-reduc-dot-s16b.c scan-tree-dump-times vect "vectorized 1 loops" 0
+FAIL: gcc.dg/vect/vect-reduc-dot-s8b.c scan-tree-dump-times vect "vect_recog_widen_mult_pattern: detected" 1
+FAIL: gcc.dg/vect/vect-reduc-pattern-1a.c scan-tree-dump-times vect "vectorized 1 loops" 0
+FAIL: gcc.dg/vect/vect-reduc-pattern-1b-big-array.c scan-tree-dump-times vect "vectorized 1 loops" 0
+FAIL: gcc.dg/vect/vect-reduc-pattern-1b.c scan-tree-dump-times vect "vectorized 1 loops" 0
+FAIL: gcc.dg/vect/vect-reduc-pattern-1c-big-array.c scan-tree-dump-times vect "vectorized 1 loops" 0
+FAIL: gcc.dg/vect/vect-reduc-pattern-1c.c scan-tree-dump-times vect "vectorized 1 loops" 0
+FAIL: gcc.dg/vect/vect-reduc-pattern-2a.c scan-tree-dump-times vect "vectorized 1 loops" 0
+FAIL: gcc.dg/vect/vect-reduc-pattern-2b-big-array.c scan-tree-dump-times vect "vectorized 1 loops" 0
+FAIL: gcc.dg/vect/vect-reduc-pattern-2b.c scan-tree-dump-times vect "vectorized 1 loops" 0
+FAIL: gcc.dg/vect/slp-perm-8.c scan-tree-dump-times vect "vectorized 1 loops" 2
+XPASS: gcc.dg/vect/slp-reduc-3.c scan-tree-dump-times vect "vectorizing stmts using SLP" 1
+FAIL: gcc.dg/vect/vect-104.c -flto scan-tree-dump-times vect "possible dependence between data-refs" 1
+FAIL: gcc.dg/vect/vect-multitypes-11.c -flto scan-tree-dump-times vect "vectorized 1 loops" 1
+FAIL: gcc.dg/vect/vect-multitypes-12.c -flto scan-tree-dump-times vect "vectorized 1 loops" 1
+FAIL: gcc.dg/vect/vect-outer-1-big-array.c -flto scan-tree-dump-times vect "strided access in outer loop" 1
+FAIL: gcc.dg/vect/vect-outer-1.c -flto scan-tree-dump-times vect "strided access in outer loop" 1
+FAIL: gcc.dg/vect/vect-outer-1a-big-array.c -flto scan-tree-dump-times vect "strided access in outer loop" 1
+FAIL: gcc.dg/vect/vect-outer-1a.c -flto scan-tree-dump-times vect "strided access in outer loop" 1
+FAIL: gcc.dg/vect/vect-outer-1b-big-array.c -flto scan-tree-dump-times vect "strided access in outer loop" 1
+FAIL: gcc.dg/vect/vect-outer-1b.c -flto scan-tree-dump-times vect "strided access in outer loop" 1
+FAIL: gcc.dg/vect/vect-outer-2b.c -flto scan-tree-dump-times vect "strided access in outer loop" 1
+FAIL: gcc.dg/vect/vect-outer-3a-big-array.c -flto scan-tree-dump-times vect "step doesn't divide the vector-size" 2
+FAIL: gcc.dg/vect/vect-outer-3a.c -flto scan-tree-dump-times vect "step doesn't divide the vector-size" 2
+FAIL: gcc.dg/vect/vect-outer-3b.c -flto scan-tree-dump-times vect "strided access in outer loop" 2
+FAIL: gcc.dg/vect/vect-reduc-dot-s16b.c -flto scan-tree-dump-times vect "vectorized 1 loops" 0
+FAIL: gcc.dg/vect/vect-reduc-dot-s8b.c -flto scan-tree-dump-times vect "vect_recog_widen_mult_pattern: detected" 1
+FAIL: gcc.dg/vect/vect-reduc-pattern-1a.c -flto scan-tree-dump-times vect "vectorized 1 loops" 0
+FAIL: gcc.dg/vect/vect-reduc-pattern-1b-big-array.c -flto scan-tree-dump-times vect "vectorized 1 loops" 0
+FAIL: gcc.dg/vect/vect-reduc-pattern-1b.c -flto scan-tree-dump-times vect "vectorized 1 loops" 0
+FAIL: gcc.dg/vect/vect-reduc-pattern-1c-big-array.c -flto scan-tree-dump-times vect "vectorized 1 loops" 0
+FAIL: gcc.dg/vect/vect-reduc-pattern-1c.c -flto scan-tree-dump-times vect "vectorized 1 loops" 0
+FAIL: gcc.dg/vect/vect-reduc-pattern-2a.c -flto scan-tree-dump-times vect "vectorized 1 loops" 0
+FAIL: gcc.dg/vect/vect-reduc-pattern-2b-big-array.c -flto scan-tree-dump-times vect "vectorized 1 loops" 0
+FAIL: gcc.dg/vect/vect-reduc-pattern-2b.c -flto scan-tree-dump-times vect "vectorized 1 loops" 0
+FAIL: gcc.dg/vect/slp-perm-8.c -flto scan-tree-dump-times vect "vectorized 1 loops" 2
+XPASS: gcc.dg/vect/slp-reduc-3.c -flto scan-tree-dump-times vect "vectorizing stmts using SLP" 1
+FAIL: gcc.dg/vect/no-vfa-vect-101.c scan-tree-dump-times vect "can't determine dependence" 1
+FAIL: gcc.dg/vect/no-vfa-vect-102.c scan-tree-dump-times vect "possible dependence between data-refs" 1
+FAIL: gcc.dg/vect/no-vfa-vect-102a.c scan-tree-dump-times vect "possible dependence between data-refs" 1
+FAIL: gcc.dg/vect/no-vfa-vect-37.c scan-tree-dump-times vect "can't determine dependence" 2
+FAIL: gcc.dg/vect/no-vfa-vect-79.c scan-tree-dump-times vect "can't determine dependence" 1
+FAIL: gcc.dg/vect/wrapv-vect-reduc-pattern-2c.c scan-tree-dump-times vect "vectorized 1 loops" 0
+XPASS: gcc.dg/vect/no-scevccp-outer-16.c scan-tree-dump-times vect "OUTER LOOP VECTORIZED." 1
+XPASS: gcc.dg/vect/no-scevccp-outer-17.c scan-tree-dump-times vect "OUTER LOOP VECTORIZED." 1
+XPASS: gcc.dg/vect/no-scevccp-outer-19.c scan-tree-dump-times vect "OUTER LOOP VECTORIZED." 1
+XPASS: gcc.dg/vect/no-scevccp-outer-21.c scan-tree-dump-times vect "OUTER LOOP VECTORIZED." 1
+FAIL: gcc.target/arm/pr42575.c scan-assembler-not mov
+FAIL: gcc.target/arm/thumb-ltu.c (test for excess errors)
+UNRESOLVED: gcc.target/arm/thumb-ltu.c scan-assembler-not uxtb
+FAIL: gcc.target/arm/tlscall.c (test for excess errors)
+
+# Failures in ./gcc/testsuite/gfortran/gfortran.sum:
+# *** gfortran:
+FAIL: gfortran.dg/vect/pr19049.f90  -O  scan-tree-dump-times vect "complicated access pattern" 1
+FAIL: gfortran.dg/vect/pr32380.f  -O  scan-tree-dump-times vect "vectorized 7 loops" 1
+FAIL: gfortran.dg/vect/fast-math-pr38968.f90 execution test
+
+# Failures in ./gcc/testsuite/g++/g++.sum:
+# *** g++:
+FAIL: g++.dg/abi/forced.C -std=gnu++98 execution test
+FAIL: g++.dg/abi/forced.C -std=gnu++11 execution test
diff --git a/contrib/testsuite-management/powerpc-grtev3-linux-gnu.xfail b/contrib/testsuite-management/powerpc-grtev3-linux-gnu.xfail
new file mode 100644
index 0000000..f78c904
--- /dev/null
+++ b/contrib/testsuite-management/powerpc-grtev3-linux-gnu.xfail
@@ -0,0 +1,220 @@
+# Ignore r194995 for gcc pr55852.
+FAIL: gfortran.dg/intrinsic_size_3.f90 -O   scan-tree-dump-times original "iszs = \\(integer\\(kind=2\\)\\) MAX_EXPR <\\(D.....->dim.0..ubound - D.....->dim.0..lbound\\) \\+ 1, 0>;" 1
+# Ignore gcc pr54127.
+FAIL: gcc.dg/torture/pr53589.c -O3 -g  (test for excess errors)
+FAIL: gcc.dg/torture/pr53589.c  -O3 -g  (internal compiler error)
+# Ignore Google ref b/6983319.
+FAIL: gcc.target/powerpc/regnames-1.c (test for excess errors)
+FAIL: gcc.target/powerpc/regnames-1.c (internal compiler error)
+
+FAIL: gfortran.dg/bessel_6.f90  -O0  execution test
+FAIL: gfortran.dg/bessel_6.f90  -O1  execution test
+FAIL: gfortran.dg/bessel_6.f90  -O2  execution test
+FAIL: gfortran.dg/bessel_6.f90  -O3 -fomit-frame-pointer  execution test
+FAIL: gfortran.dg/bessel_6.f90  -O3 -fomit-frame-pointer -funroll-loops  execution test
+FAIL: gfortran.dg/bessel_6.f90  -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  execution test
+FAIL: gfortran.dg/bessel_6.f90  -O3 -g  execution test
+FAIL: gfortran.dg/bessel_6.f90  -Os  execution test
+XPASS: gfortran.dg/nint_2.f90  -O0  execution test
+FAIL: gfortran.dg/unf_io_convert_3.f90  -O0  execution test
+FAIL: gfortran.dg/unf_io_convert_3.f90  -O1  execution test
+FAIL: gfortran.dg/unf_io_convert_3.f90  -O2  execution test
+FAIL: gfortran.dg/unf_io_convert_3.f90  -O3 -fomit-frame-pointer  execution test
+FAIL: gfortran.dg/unf_io_convert_3.f90  -O3 -fomit-frame-pointer -funroll-loops  execution test
+FAIL: gfortran.dg/unf_io_convert_3.f90  -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  execution test
+FAIL: gfortran.dg/unf_io_convert_3.f90  -O3 -g  execution test
+FAIL: gfortran.dg/unf_io_convert_3.f90  -Os  execution test
+FAIL: gfortran.dg/x_slash_2.f  -O0  execution test
+FAIL: g++.dg/abi/forced.C -std=gnu++98 execution test
+FAIL: g++.dg/abi/forced.C -std=gnu++11 execution test
+FAIL: g++.dg/ext/cleanup-10.C -std=gnu++98 execution test
+FAIL: g++.dg/ext/cleanup-10.C -std=gnu++11 execution test
+FAIL: g++.dg/ext/cleanup-11.C -std=gnu++98 execution test
+FAIL: g++.dg/ext/cleanup-11.C -std=gnu++11 execution test
+FAIL: g++.dg/ext/cleanup-8.C -std=gnu++98 execution test
+FAIL: g++.dg/ext/cleanup-8.C -std=gnu++11 execution test
+FAIL: g++.dg/ext/cleanup-9.C -std=gnu++98 execution test
+FAIL: g++.dg/ext/cleanup-9.C -std=gnu++11 execution test
+FAIL: g++.dg/warn/Wself-assign-2.C -std=gnu++11  (test for warnings, line 12)
+FAIL: g++.dg/tree-prof/lipo/vcall1_0.C scan-ipa-dump-times profile "Indirect call -> direct call" 2
+FAIL: g++.dg/tree-prof/lipo/vcall1_0.C scan-ipa-dump-times profile "Indirect call -> direct call" 2
+FAIL: g++.dg/tree-prof/lipo/vcall1_0.C scan-ipa-dump-times profile "Indirect call -> direct call" 2
+FAIL: g++.dg/tree-prof/lipo/vcall1_0.C scan-ipa-dump-times profile "Indirect call -> direct call" 2
+FAIL: g++.dg/tree-prof/lipo/vcall1_0.C scan-ipa-dump-times profile "Indirect call -> direct call" 2
+FAIL: g++.dg/tree-prof/lipo/vcall1_0.C scan-ipa-dump-times profile "Indirect call -> direct call" 2
+FAIL: g++.dg/tree-prof/lipo/vcall1_0.C scan-ipa-dump-times profile "Indirect call -> direct call" 2
+UNRESOLVED: g++.dg/tree-prof/callgraph-profiles.C scan-file Callgraph group : main _Z3barv _Z3foov\n
+UNRESOLVED: g++.dg/tree-prof/callgraph-profiles.C scan-file .text.*.main\n.text.*._Z3barv\n.text.*._Z3foov\n.text.*._Z9notcalledv
+UNRESOLVED: g++.dg/tree-prof/callgraph-profiles.C scan-file Callgraph group : main _Z3barv _Z3foov\n
+UNRESOLVED: g++.dg/tree-prof/callgraph-profiles.C scan-file .text.*.main\n.text.*._Z3barv\n.text.*._Z3foov\n.text.*._Z9notcalledv
+UNRESOLVED: g++.dg/tree-prof/callgraph-profiles.C scan-file Callgraph group : main _Z3barv _Z3foov\n
+UNRESOLVED: g++.dg/tree-prof/callgraph-profiles.C scan-file .text.*.main\n.text.*._Z3barv\n.text.*._Z3foov\n.text.*._Z9notcalledv
+UNRESOLVED: g++.dg/tree-prof/callgraph-profiles.C scan-file Callgraph group : main _Z3barv _Z3foov\n
+UNRESOLVED: g++.dg/tree-prof/callgraph-profiles.C scan-file .text.*.main\n.text.*._Z3barv\n.text.*._Z3foov\n.text.*._Z9notcalledv
+UNRESOLVED: g++.dg/tree-prof/callgraph-profiles.C scan-file Callgraph group : main _Z3barv _Z3foov\n
+UNRESOLVED: g++.dg/tree-prof/callgraph-profiles.C scan-file .text.*.main\n.text.*._Z3barv\n.text.*._Z3foov\n.text.*._Z9notcalledv
+UNRESOLVED: g++.dg/tree-prof/callgraph-profiles.C scan-file Callgraph group : main _Z3barv _Z3foov\n
+UNRESOLVED: g++.dg/tree-prof/callgraph-profiles.C scan-file .text.*.main\n.text.*._Z3barv\n.text.*._Z3foov\n.text.*._Z9notcalledv
+UNRESOLVED: g++.dg/tree-prof/callgraph-profiles.C scan-file Callgraph group : main _Z3barv _Z3foov\n
+UNRESOLVED: g++.dg/tree-prof/callgraph-profiles.C scan-file .text.*.main\n.text.*._Z3barv\n.text.*._Z3foov\n.text.*._Z9notcalledv
+UNRESOLVED: g++.dg/tree-prof/callgraph-profiles.C scan-file Moving 1 section\\(s\\) to new segment
+FAIL: g++.dg/tree-prof/mversn15.C execution,    -g  -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/mversn15.C compilation,  -g  -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/mversn15.C execution,    -g  -fprofile-use
+FAIL: g++.dg/tree-prof/mversn15.C execution,    -O0  -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/mversn15.C compilation,  -O0  -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/mversn15.C execution,    -O0  -fprofile-use
+FAIL: g++.dg/tree-prof/mversn15.C execution,    -O1  -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/mversn15.C compilation,  -O1  -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/mversn15.C execution,    -O1  -fprofile-use
+FAIL: g++.dg/tree-prof/mversn15.C execution,    -O2  -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/mversn15.C compilation,  -O2  -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/mversn15.C execution,    -O2  -fprofile-use
+FAIL: g++.dg/tree-prof/mversn15.C execution,    -O3  -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/mversn15.C compilation,  -O3  -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/mversn15.C execution,    -O3  -fprofile-use
+FAIL: g++.dg/tree-prof/mversn15.C execution,    -O3 -g  -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/mversn15.C compilation,  -O3 -g  -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/mversn15.C execution,    -O3 -g  -fprofile-use
+FAIL: g++.dg/tree-prof/mversn15.C execution,    -Os  -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/mversn15.C compilation,  -Os  -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/mversn15.C execution,    -Os  -fprofile-use
+FAIL: g++.dg/tree-prof/mversn15a.C execution,    -g  -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/mversn15a.C compilation,  -g  -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/mversn15a.C execution,    -g  -fprofile-use
+FAIL: g++.dg/tree-prof/mversn15a.C execution,    -O0  -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/mversn15a.C compilation,  -O0  -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/mversn15a.C execution,    -O0  -fprofile-use
+FAIL: g++.dg/tree-prof/mversn15a.C execution,    -O1  -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/mversn15a.C compilation,  -O1  -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/mversn15a.C execution,    -O1  -fprofile-use
+FAIL: g++.dg/tree-prof/mversn15a.C execution,    -O2  -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/mversn15a.C compilation,  -O2  -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/mversn15a.C execution,    -O2  -fprofile-use
+FAIL: g++.dg/tree-prof/mversn15a.C execution,    -O3  -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/mversn15a.C compilation,  -O3  -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/mversn15a.C execution,    -O3  -fprofile-use
+FAIL: g++.dg/tree-prof/mversn15a.C execution,    -O3 -g  -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/mversn15a.C compilation,  -O3 -g  -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/mversn15a.C execution,    -O3 -g  -fprofile-use
+FAIL: g++.dg/tree-prof/mversn15a.C execution,    -Os  -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/mversn15a.C compilation,  -Os  -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/mversn15a.C execution,    -Os  -fprofile-use
+FAIL: gcc.dg/and-1.c scan-assembler-not nand
+FAIL: gcc.dg/cleanup-10.c execution test
+FAIL: gcc.dg/cleanup-11.c execution test
+FAIL: gcc.dg/cleanup-8.c execution test
+FAIL: gcc.dg/cleanup-9.c execution test
+FAIL: gcc.dg/pr46728-6.c scan-assembler-not pow
+FAIL: gcc.dg/pr53060.c (test for excess errors)
+FAIL: gcc.dg/thread_annot_lock-23.c  (test for warnings, line 10)
+FAIL: gcc.dg/thread_annot_lock-23.c  (test for warnings, line 13)
+FAIL: gcc.dg/thread_annot_lock-23.c  (test for warnings, line 15)
+FAIL: gcc.dg/thread_annot_lock-23.c  (test for warnings, line 18)
+FAIL: gcc.dg/thread_annot_lock-23.c  (test for warnings, line 19)
+FAIL: gcc.dg/thread_annot_lock-24.c  (test for warnings, line 8)
+FAIL: gcc.dg/thread_annot_lock-24.c  (test for warnings, line 9)
+FAIL: gcc.dg/thread_annot_lock-24.c  (test for warnings, line 10)
+FAIL: gcc.dg/thread_annot_lock-25.c  (test for warnings, line 8)
+FAIL: gcc.dg/thread_annot_lock-25.c  (test for warnings, line 9)
+FAIL: gcc.dg/thread_annot_lock-25.c  (test for warnings, line 10)
+FAIL: gcc.dg/thread_annot_lock-25.c  (test for warnings, line 22)
+FAIL: gcc.dg/thread_annot_lock-25.c  (test for warnings, line 30)
+FAIL: gcc.dg/thread_annot_lock-42.c  (test for warnings, line 9)
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O0  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O0  -fpic  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O0  -fPIC  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O0  -pie -fpie  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O0  -pie -fPIE  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O1  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O1  -fpic  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O1  -fPIC  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O1  -pie -fpie  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O1  -pie -fPIE  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O2  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O2  -fpic  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O2  -fPIC  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O2  -pie -fpie  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O2  -pie -fPIE  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -fomit-frame-pointer  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -fomit-frame-pointer  -fpic  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -fomit-frame-pointer  -fPIC  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -fomit-frame-pointer  -pie -fpie  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -fomit-frame-pointer  -pie -fPIE  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -g  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -g  -fpic  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -g  -fPIC  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -g  -pie -fpie  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -g  -pie -fPIE  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -Os  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -Os  -fpic  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -Os  -fPIC  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -Os  -pie -fpie  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -Os  -pie -fPIE  execution test
+FAIL: gcc.dg/tree-prof/lipo/ic-misattribution-1_0.c scan-ipa-dump-times profile "Indirect call -> direct call" 2
+FAIL: gcc.dg/tree-prof/lipo/indir-call-prof_0.c scan-ipa-dump profile "Indirect call -> direct call.* a1"
+FAIL: gcc.dg/tree-prof/lipo/lipo_inline1_0.c scan-tree-dump-not optimized "foo"
+FAIL: gcc.dg/tree-prof/lipo/lipo_inline1_0.c scan-tree-dump-not optimized "goo"
+FAIL: gcc.dg/tree-ssa/sra-12.c scan-tree-dump-times release_ssa "l;" 0
+FAIL: gcc.dg/tree-ssa/ssa-dom-thread-4.c scan-tree-dump-times dom1 "Threaded" 3
+FAIL: gcc.dg/tree-ssa/vrp47.c scan-tree-dump-times vrp1 "[xy][^ ]* !=" 0
+FAIL: gcc.dg/tree-ssa/vrp47.c scan-tree-dump-times dom2 "x[^ ]* & y" 1
+FAIL: gcc.dg/vect/pr48765.c (test for excess errors)
+FAIL: gcc.dg/vect/pr48765.c -flto (test for excess errors)
+FAIL: gcc.target/powerpc/405-dlmzb-strlen-1.c scan-assembler dlmzb\\. 
+FAIL: gcc.target/powerpc/440-dlmzb-strlen-1.c scan-assembler dlmzb\\. 
+FAIL: gcc.target/powerpc/ppc-vector-memcpy.c scan-assembler lvx
+FAIL: gcc.target/powerpc/pr46728-1.c scan-assembler-not pow
+FAIL: gcc.target/powerpc/pr46728-10.c execution test
+FAIL: gcc.target/powerpc/pr46728-11.c execution test
+FAIL: gcc.target/powerpc/pr46728-13.c execution test
+FAIL: gcc.target/powerpc/pr46728-14.c execution test
+FAIL: gcc.target/powerpc/pr46728-2.c scan-assembler-not pow
+FAIL: gcc.target/powerpc/pr46728-3.c scan-assembler-not pow
+FAIL: gcc.target/powerpc/pr46728-4.c scan-assembler-not pow
+FAIL: gcc.target/powerpc/pr46728-7.c scan-assembler-not pow
+FAIL: gcc.target/powerpc/pr46728-8.c scan-assembler-not pow
+
+# Entries due to soft-float.
+FAIL: g++.dg/cdce3.C -std=gnu++98 execution test
+FAIL: g++.dg/cdce3.C -std=gnu++11 execution test
+FAIL: g++.dg/tree-prof/mversn15.C execution,    -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/mversn15.C execution,    -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/mversn15.C compilation,  -fprofile-use
+FAIL: g++.dg/tree-prof/mversn15a.C execution,    -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/mversn15a.C execution,    -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/mversn15a.C compilation,  -fprofile-use
+FAIL: gcc.dg/torture/fp-int-convert-long-double.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  execution test
+FAIL: gcc.target/powerpc/lhs-1.c scan-assembler-times nop 3
+FAIL: gcc.target/powerpc/lhs-2.c scan-assembler ori 1,1,0
+FAIL: gcc.target/powerpc/lhs-3.c scan-assembler ori 2,2,0
+FAIL: gcc.target/powerpc/loop_align.c scan-assembler .p2align 5,,31
+FAIL: gcc.target/powerpc/pr46728-1.c scan-assembler-times fsqrt 2
+FAIL: gcc.target/powerpc/pr46728-16.c scan-assembler fmadd
+FAIL: gcc.target/powerpc/pr46728-2.c scan-assembler-times fsqrt 4
+FAIL: gcc.target/powerpc/pr46728-3.c scan-assembler-times sqrt 4
+FAIL: gcc.target/powerpc/pr46728-5.c scan-assembler-times cbrt 2
+FAIL: gcc.target/powerpc/pr52775.c scan-assembler-times fcfid 2
+FAIL: gfortran.dg/actual_array_constructor_3.f90 -O3 -fomit-frame-pointer -funroll-loops  execution test
+FAIL: gfortran.dg/actual_array_constructor_3.f90 -O3 -g  execution test
+FAIL: gfortran.dg/actual_array_constructor_3.f90 -O2  execution test
+FAIL: gfortran.dg/actual_array_constructor_3.f90 -O3 -fomit-frame-pointer  execution test
+FAIL: gfortran.dg/actual_array_constructor_3.f90 -O1  execution test
+FAIL: gfortran.dg/actual_array_constructor_3.f90 -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  execution test
+FAIL: gfortran.dg/actual_array_constructor_3.f90 -Os  execution test
+FAIL: gfortran.dg/actual_array_constructor_3.f90 -O0  execution test
+FAIL: gfortran.dg/norm2_3.f90 -O3 -fomit-frame-pointer -funroll-loops  execution test
+FAIL: gfortran.dg/norm2_3.f90 -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  execution test
+FAIL: gfortran.dg/norm2_3.f90 -O0  execution test
+FAIL: gfortran.dg/norm2_3.f90 -Os  execution test
+FAIL: gfortran.dg/norm2_3.f90 -O2  execution test
+FAIL: gfortran.dg/norm2_3.f90 -O3 -g  execution test
+FAIL: gfortran.dg/norm2_3.f90 -O3 -fomit-frame-pointer  execution test
+FAIL: gfortran.dg/norm2_3.f90 -O1  execution test
+
+# See http://gcc.gnu.org/ml/gcc-patches/2012-08/msg00141.html.  Revert once
+# that is resolved.
+UNRESOLVED: 23_containers/map/element_access/2.cc compilation failed to produce executable
+FAIL: 23_containers/map/element_access/2.cc (test for excess errors)
diff --git a/contrib/testsuite-management/powerpc64-grtev2-linux-gnu.xfail b/contrib/testsuite-management/powerpc64-grtev2-linux-gnu.xfail
new file mode 100644
index 0000000..ddd2908
--- /dev/null
+++ b/contrib/testsuite-management/powerpc64-grtev2-linux-gnu.xfail
@@ -0,0 +1,111 @@
+# *** gcc:
+FAIL: gcc.c-torture/execute/builtins/memcpy-chk.c compilation,  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects 
+UNRESOLVED: gcc.c-torture/execute/builtins/memcpy-chk.c execution,  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects 
+FAIL: gcc.c-torture/execute/builtins/memmove-chk.c compilation,  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects 
+UNRESOLVED: gcc.c-torture/execute/builtins/memmove-chk.c execution,  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects 
+FAIL: gcc.c-torture/execute/builtins/mempcpy-chk.c compilation,  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects 
+UNRESOLVED: gcc.c-torture/execute/builtins/mempcpy-chk.c execution,  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects 
+FAIL: gcc.c-torture/execute/20020226-1.c execution,  -O0 
+FAIL: gcc.c-torture/execute/20020226-1.c execution,  -O1 
+FAIL: gcc.c-torture/execute/20020226-1.c execution,  -O2 
+FAIL: gcc.c-torture/execute/20020226-1.c execution,  -O3 -fomit-frame-pointer 
+FAIL: gcc.c-torture/execute/20020226-1.c execution,  -O3 -g 
+FAIL: gcc.c-torture/execute/20020226-1.c execution,  -Os 
+FAIL: gcc.c-torture/execute/20020226-1.c execution,  -O2 -flto -fno-use-linker-plugin -flto-partition=none 
+FAIL: gcc.c-torture/execute/20020508-1.c execution,  -O0 
+FAIL: gcc.c-torture/execute/20020508-1.c execution,  -O1 
+FAIL: gcc.c-torture/execute/20020508-1.c execution,  -O2 
+FAIL: gcc.c-torture/execute/20020508-1.c execution,  -O3 -fomit-frame-pointer 
+FAIL: gcc.c-torture/execute/20020508-1.c execution,  -O3 -g 
+FAIL: gcc.c-torture/execute/20020508-1.c execution,  -Os 
+FAIL: gcc.c-torture/execute/20020508-1.c execution,  -O2 -flto -fno-use-linker-plugin -flto-partition=none 
+FAIL: gcc.c-torture/execute/pr52129.c compilation,  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects 
+UNRESOLVED: gcc.c-torture/execute/pr52129.c execution,  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects 
+FAIL: gcc.dg/and-1.c scan-assembler-not nand
+FAIL: gcc.dg/cleanup-10.c execution test
+FAIL: gcc.dg/cleanup-11.c execution test
+FAIL: gcc.dg/cleanup-8.c execution test
+FAIL: gcc.dg/cleanup-9.c execution test
+FAIL: gcc.dg/cproj-fails-with-broken-glibc.c execution test
+FAIL: gcc.dg/pr44194-1.c scan-rtl-dump dse1 "global deletions = 2"
+FAIL: gcc.dg/pr46728-6.c scan-assembler-not pow
+FAIL: gcc.dg/torture/vec-cvt-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+
+# These are flaky when tested with QEMU (they exceed the timeout)
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O0  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O1  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O2  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -fomit-frame-pointer  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -g  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -Os  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O0  -fpic  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O1  -fpic  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O2  -fpic  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -fomit-frame-pointer  -fpic  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -g  -fpic  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -Os  -fpic  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O0  -fPIC  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O1  -fPIC  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O2  -fPIC  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -fomit-frame-pointer  -fPIC  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -g  -fPIC  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -Os  -fPIC  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O0  -pie -fpie  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O1  -pie -fpie  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O2  -pie -fpie  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -fomit-frame-pointer  -pie -fpie  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -g  -pie -fpie  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -Os  -pie -fpie  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O0  -pie -fPIE  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O1  -pie -fPIE  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O2  -pie -fPIE  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -fomit-frame-pointer  -pie -fPIE  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O3 -g  -pie -fPIE  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -Os  -pie -fPIE  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  execution test
+flaky | FAIL: gcc.dg/torture/tls/tls-test.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  execution test
+
+FAIL: gcc.dg/tree-prof/bb-reorg.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-ssa/ssa-dom-thread-4.c scan-tree-dump-times dom1 "Threaded" 3
+FAIL: gcc.dg/tree-ssa/vrp47.c scan-tree-dump-times vrp1 "[xy][^ ]* !=" 0
+FAIL: gcc.dg/tree-ssa/vrp47.c scan-tree-dump-times dom2 "x[^ ]* & y" 1
+FAIL: gcc.dg/vect/vect-reduc-2short.c -flto execution test
+FAIL: gcc.dg/vmx/3a-03.c  -O0  execution test
+FAIL: gcc.dg/vmx/3a-03.c  -O1  execution test
+FAIL: gcc.dg/vmx/3a-03.c  -O2  execution test
+FAIL: gcc.dg/vmx/3a-03.c  -O3 -fomit-frame-pointer  execution test
+FAIL: gcc.dg/vmx/3a-03.c  -O3 -g  execution test
+FAIL: gcc.dg/vmx/3a-03.c  -Os  execution test
+FAIL: gcc.dg/vmx/3a-03.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  execution test
+FAIL: gcc.dg/vmx/3a-03.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  execution test
+FAIL: gcc.dg/vmx/3a-03m.c  -O0  execution test
+FAIL: gcc.dg/vmx/3a-03m.c  -O1  execution test
+FAIL: gcc.dg/vmx/3a-03m.c  -O2  execution test
+FAIL: gcc.dg/vmx/3a-03m.c  -O3 -fomit-frame-pointer  execution test
+FAIL: gcc.dg/vmx/3a-03m.c  -O3 -g  execution test
+FAIL: gcc.dg/vmx/3a-03m.c  -Os  execution test
+FAIL: gcc.dg/vmx/3a-03m.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  execution test
+FAIL: gcc.dg/vmx/3a-03m.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  execution test
+FAIL: gcc.target/powerpc/ppc-vector-memcpy.c scan-assembler lvx
+FAIL: gcc.target/powerpc/pr46728-1.c scan-assembler-not pow
+FAIL: gcc.target/powerpc/pr46728-2.c scan-assembler-not pow
+FAIL: gcc.target/powerpc/pr46728-3.c scan-assembler-not pow
+FAIL: gcc.target/powerpc/pr46728-4.c scan-assembler-not pow
+FAIL: gcc.target/powerpc/pr46728-7.c scan-assembler-not pow
+FAIL: gcc.target/powerpc/pr46728-8.c scan-assembler-not pow
+
+# *** gfortran:
+XPASS: gfortran.dg/nint_2.f90  -O0  execution test
+FAIL: gfortran.dg/vect/fast-math-pr38968.f90 execution test
+
+# *** g++:
+FAIL: g++.dg/abi/forced.C -std=gnu++98 execution test
+FAIL: g++.dg/abi/forced.C -std=gnu++11 execution test
+FAIL: g++.dg/ext/cleanup-10.C -std=gnu++98 execution test
+FAIL: g++.dg/ext/cleanup-10.C -std=gnu++11 execution test
+FAIL: g++.dg/ext/cleanup-11.C -std=gnu++98 execution test
+FAIL: g++.dg/ext/cleanup-11.C -std=gnu++11 execution test
+FAIL: g++.dg/ext/cleanup-8.C -std=gnu++98 execution test
+FAIL: g++.dg/ext/cleanup-8.C -std=gnu++11 execution test
+FAIL: g++.dg/ext/cleanup-9.C -std=gnu++98 execution test
+FAIL: g++.dg/ext/cleanup-9.C -std=gnu++11 execution test
diff --git a/contrib/testsuite-management/powerpc64-grtev3-linux-gnu.xfail b/contrib/testsuite-management/powerpc64-grtev3-linux-gnu.xfail
new file mode 100644
index 0000000..86ea509
--- /dev/null
+++ b/contrib/testsuite-management/powerpc64-grtev3-linux-gnu.xfail
@@ -0,0 +1,728 @@
+# Marked test failures for v17-powerpc64 toolchain.
+
+# *** gcc:
+
+# Also xfailed in x86; REAL bug in google/main
+FAIL: gcc.dg/wself-assign-1.c  (test for warnings, line 15)
+FAIL: gcc.dg/wself-assign-1.c  (test for warnings, line 19)
+FAIL: gcc.dg/wself-assign-1.c  (test for warnings, line 20)
+FAIL: gcc.dg/wself-assign-1.c  (test for warnings, line 21)
+FAIL: gcc.dg/wself-assign-1.c  (test for warnings, line 22)
+
+# Also xfailed in x86; Inline failures not seen outside of google/main.
+FAIL: gcc.dg/inline_3.c (test for excess errors)
+FAIL: gcc.dg/inline_4.c (test for excess errors)
+
+# Also xfailed in x86; REAL bug in google/main
+FAIL: gcc.dg/ipa/ipcp-agg-7.c scan-ipa-dump-times cp "Clone of foo" 1
+FAIL: gcc.dg/ipa/ipcp-agg-7.c scan-tree-dump-not optimized "->c;"
+
+# PPC-specific.  From PR33512, still failing in truck despite resolved PR.
+FAIL: gcc.dg/and-1.c scan-assembler-not nand
+
+# PPC-specific.  Appears to affect many 64-bit non-x86 archs; see PR49414.
+FAIL: gcc.dg/pr44194-1.c scan-rtl-dump dse1 "global deletions = (2|3)"
+
+# PPC-specific.  Test error; Power should be handled like MIPS for same reason.
+FAIL: gcc.dg/tree-ssa/ssa-dom-thread-4.c scan-tree-dump-times dom1 "Threaded" 3
+
+# PPC-specific.  Also failing in trunk.  Related to PR38219 and
+# LOGICAL_OP_NON_SHORT_CIRCUIT definition.
+FAIL: gcc.dg/tree-ssa/vrp47.c scan-tree-dump-times vrp1 "[xy][^ ]* !=" 0
+FAIL: gcc.dg/tree-ssa/vrp47.c scan-tree-dump-times dom2 "x[^ ]* & y" 1
+
+# PPC-specific.  Also failing in trunk.  (PR57955; PPC64 is using ld, not lvx.)
+FAIL: gcc.target/powerpc/ppc-vector-memcpy.c scan-assembler lvx
+
+# PPC-specific.  Artifact of Google test environment.
+FAIL: gcc.dg/di-sync-multithread.c execution test
+
+# PPC-specific, introduced 2013-06-04.  TODO: Needs investigation.  (This is
+# not PR52614)
+FAIL: gcc.dg/vect/costmodel/ppc/costmodel-bb-slp-9a.c scan-tree-dump-times slp "basic block vectorized using SLP" 1
+
+
+# *** g++:
+
+# Also xfailed in x86; explanation unknown.
+FAIL: g++.dg/ipa/devirt-11.C -std=gnu++98  scan-ipa-dump-times inline "and turned into root of the clone tree" 1
+FAIL: g++.dg/ipa/devirt-11.C -std=gnu++11  scan-ipa-dump-times inline "and turned into root of the clone tree" 1
+
+# Also xfailed in x86; REAL bug in google/main
+FAIL: g++.dg/warn/Wself-assign-2.C -std=gnu++11  (test for warnings, line 12)
+
+# PPC-specific: -flto appears to break exception handling.  Google bug b/9226891.
+FAIL: g++.dg/lto/20081109 cp_lto_20081109_0.o-cp_lto_20081109_1.o execute -O0 -flto -flto-partition=none -fuse-linker-plugin
+FAIL: g++.dg/lto/20081109 cp_lto_20081109_0.o-cp_lto_20081109_1.o execute -O2 -flto -flto-partition=none -fuse-linker-plugin -fno-fat-lto-objects
+FAIL: g++.dg/lto/20081109 cp_lto_20081109_0.o-cp_lto_20081109_1.o execute -O0 -flto -fuse-linker-plugin -fno-fat-lto-objects
+FAIL: g++.dg/lto/20081109 cp_lto_20081109_0.o-cp_lto_20081109_1.o execute -O2 -flto -fuse-linker-plugin
+FAIL: g++.dg/torture/pr49115.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  execution test
+FAIL: g++.dg/torture/stackalign/eh-alloca-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  execution test
+FAIL: g++.dg/torture/stackalign/eh-alloca-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects -fpic execution test
+FAIL: g++.dg/torture/stackalign/eh-global-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  execution test
+FAIL: g++.dg/torture/stackalign/eh-global-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects -fpic execution test
+FAIL: g++.dg/torture/stackalign/eh-inline-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  execution test
+FAIL: g++.dg/torture/stackalign/eh-inline-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects -fpic execution test
+FAIL: g++.dg/torture/stackalign/eh-inline-2.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  execution test
+FAIL: g++.dg/torture/stackalign/eh-inline-2.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects -fpic execution test
+FAIL: g++.dg/torture/stackalign/eh-vararg-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  execution test
+FAIL: g++.dg/torture/stackalign/eh-vararg-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects -fpic execution test
+FAIL: g++.dg/torture/stackalign/eh-vararg-2.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  execution test
+FAIL: g++.dg/torture/stackalign/eh-vararg-2.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects -fpic execution test
+FAIL: g++.dg/torture/stackalign/throw-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  execution test
+FAIL: g++.dg/torture/stackalign/throw-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects -fpic execution test
+FAIL: g++.dg/torture/stackalign/throw-2.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  execution test
+FAIL: g++.dg/torture/stackalign/throw-2.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects -fpic execution test
+FAIL: g++.dg/torture/stackalign/throw-3.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  execution test
+FAIL: g++.dg/torture/stackalign/throw-3.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects -fpic execution test
+
+
+# Fortran failures are not important to us so far.
+# *** gfortran:
+FAIL: gfortran.dg/bessel_6.f90  -O0  execution test
+FAIL: gfortran.dg/bessel_6.f90  -O1  execution test
+FAIL: gfortran.dg/bessel_6.f90  -O2  execution test
+FAIL: gfortran.dg/bessel_6.f90  -O3 -fomit-frame-pointer  execution test
+FAIL: gfortran.dg/bessel_6.f90  -O3 -fomit-frame-pointer -funroll-loops  execution test
+FAIL: gfortran.dg/bessel_6.f90  -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  execution test
+FAIL: gfortran.dg/bessel_6.f90  -O3 -g  execution test
+FAIL: gfortran.dg/bessel_6.f90  -Os  execution test
+XPASS: gfortran.dg/nint_2.f90  -O0  execution test
+
+
+# *** libstdc++:
+# PPC-specific.  TODO: Needs investigation.
+FAIL: libstdc++-abi/abi_check
+
+# PPC-specific, recent.  TODO: Needs investigation.
+FAIL: 27_io/basic_filebuf/close/char/1.cc execution test
+FAIL: 27_io/basic_filebuf/is_open/char/1.cc execution test
+FAIL: 27_io/basic_filebuf/open/char/1.cc execution test
+FAIL: 27_io/basic_filebuf/sbumpc/char/1-io.cc execution test
+FAIL: 27_io/basic_filebuf/sbumpc/char/2-io.cc execution test
+FAIL: 27_io/basic_filebuf/seekoff/char/1-io.cc execution test
+FAIL: 27_io/basic_filebuf/seekoff/char/1-out.cc execution test
+FAIL: 27_io/basic_filebuf/seekoff/char/2-io.cc execution test
+FAIL: 27_io/basic_filebuf/seekoff/char/2-out.cc execution test
+FAIL: 27_io/basic_filebuf/seekoff/char/3-io.cc execution test
+FAIL: 27_io/basic_filebuf/seekoff/char/3-out.cc execution test
+FAIL: 27_io/basic_filebuf/seekpos/char/1-io.cc execution test
+FAIL: 27_io/basic_filebuf/seekpos/char/1-out.cc execution test
+FAIL: 27_io/basic_filebuf/seekpos/char/2-io.cc execution test
+FAIL: 27_io/basic_filebuf/seekpos/char/2-out.cc execution test
+FAIL: 27_io/basic_filebuf/seekpos/char/3-io.cc execution test
+FAIL: 27_io/basic_filebuf/seekpos/char/3-out.cc execution test
+FAIL: 27_io/basic_filebuf/setbuf/char/1.cc execution test
+FAIL: 27_io/basic_filebuf/sgetc/char/1-io.cc execution test
+FAIL: 27_io/basic_filebuf/sgetc/char/2-io.cc execution test
+FAIL: 27_io/basic_filebuf/sgetn/char/1-io.cc execution test
+FAIL: 27_io/basic_filebuf/sgetn/char/2-io.cc execution test
+FAIL: 27_io/basic_filebuf/snextc/char/1-io.cc execution test
+FAIL: 27_io/basic_filebuf/snextc/char/2-io.cc execution test
+FAIL: 27_io/basic_istream/seekg/char/fstream.cc execution test
+FAIL: 27_io/basic_istream/seekg/wchar_t/fstream.cc execution test
+FAIL: 27_io/basic_istream/tellg/char/fstream.cc execution test
+FAIL: 27_io/basic_istream/tellg/wchar_t/fstream.cc execution test
+
+
+# *** libgomp:
+# TODO: This testsuite is currently not working.
+ERROR: No sysroot directory found!
+
+
+# ASAN-specific.
+# These tests are currently failing due to linker issues.
+FAIL: c-c++-common/asan/global-overflow-1.c  -O0  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/global-overflow-1.c  -O0  compilation failed to produce executable
+FAIL: c-c++-common/asan/global-overflow-1.c  -O1  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/global-overflow-1.c  -O1  compilation failed to produce executable
+FAIL: c-c++-common/asan/global-overflow-1.c  -O2  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/global-overflow-1.c  -O2  compilation failed to produce executable
+FAIL: c-c++-common/asan/global-overflow-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/global-overflow-1.c  -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: c-c++-common/asan/global-overflow-1.c  -O3 -g  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/global-overflow-1.c  -O3 -g  compilation failed to produce executable
+FAIL: c-c++-common/asan/global-overflow-1.c  -Os  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/global-overflow-1.c  -Os  compilation failed to produce executable
+FAIL: c-c++-common/asan/global-overflow-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/global-overflow-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+FAIL: c-c++-common/asan/global-overflow-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/global-overflow-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+FAIL: c-c++-common/asan/heap-overflow-1.c  -O0  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/heap-overflow-1.c  -O0  compilation failed to produce executable
+FAIL: c-c++-common/asan/heap-overflow-1.c  -O1  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/heap-overflow-1.c  -O1  compilation failed to produce executable
+FAIL: c-c++-common/asan/heap-overflow-1.c  -O2  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/heap-overflow-1.c  -O2  compilation failed to produce executable
+FAIL: c-c++-common/asan/heap-overflow-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/heap-overflow-1.c  -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: c-c++-common/asan/heap-overflow-1.c  -O3 -g  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/heap-overflow-1.c  -O3 -g  compilation failed to produce executable
+FAIL: c-c++-common/asan/heap-overflow-1.c  -Os  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/heap-overflow-1.c  -Os  compilation failed to produce executable
+FAIL: c-c++-common/asan/heap-overflow-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/heap-overflow-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+FAIL: c-c++-common/asan/heap-overflow-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/heap-overflow-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+FAIL: c-c++-common/asan/memcmp-1.c  -O0  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/memcmp-1.c  -O0  compilation failed to produce executable
+FAIL: c-c++-common/asan/memcmp-1.c  -O1  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/memcmp-1.c  -O1  compilation failed to produce executable
+FAIL: c-c++-common/asan/memcmp-1.c  -O2  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/memcmp-1.c  -O2  compilation failed to produce executable
+FAIL: c-c++-common/asan/memcmp-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/memcmp-1.c  -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: c-c++-common/asan/memcmp-1.c  -O3 -g  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/memcmp-1.c  -O3 -g  compilation failed to produce executable
+FAIL: c-c++-common/asan/memcmp-1.c  -Os  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/memcmp-1.c  -Os  compilation failed to produce executable
+FAIL: c-c++-common/asan/memcmp-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/memcmp-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+FAIL: c-c++-common/asan/memcmp-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/memcmp-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+FAIL: c-c++-common/asan/null-deref-1.c  -O0  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/null-deref-1.c  -O0  compilation failed to produce executable
+FAIL: c-c++-common/asan/null-deref-1.c  -O1  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/null-deref-1.c  -O1  compilation failed to produce executable
+FAIL: c-c++-common/asan/null-deref-1.c  -O2  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/null-deref-1.c  -O2  compilation failed to produce executable
+FAIL: c-c++-common/asan/null-deref-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/null-deref-1.c  -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: c-c++-common/asan/null-deref-1.c  -O3 -g  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/null-deref-1.c  -O3 -g  compilation failed to produce executable
+FAIL: c-c++-common/asan/null-deref-1.c  -Os  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/null-deref-1.c  -Os  compilation failed to produce executable
+FAIL: c-c++-common/asan/null-deref-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/null-deref-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+FAIL: c-c++-common/asan/null-deref-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/null-deref-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -O0  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c  -O0  compilation failed to produce executable
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -O1  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c  -O1  compilation failed to produce executable
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -O2  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c  -O2  compilation failed to produce executable
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c  -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -O3 -g  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c  -O3 -g  compilation failed to produce executable
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -Os  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c  -Os  compilation failed to produce executable
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+FAIL: c-c++-common/asan/sleep-before-dying-1.c  -O2  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/sleep-before-dying-1.c  -O2  compilation failed to produce executable
+FAIL: c-c++-common/asan/sleep-before-dying-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/sleep-before-dying-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+FAIL: c-c++-common/asan/sleep-before-dying-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/sleep-before-dying-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+FAIL: c-c++-common/asan/stack-overflow-1.c  -O0  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/stack-overflow-1.c  -O0  compilation failed to produce executable
+FAIL: c-c++-common/asan/stack-overflow-1.c  -O1  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/stack-overflow-1.c  -O1  compilation failed to produce executable
+FAIL: c-c++-common/asan/stack-overflow-1.c  -O2  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/stack-overflow-1.c  -O2  compilation failed to produce executable
+FAIL: c-c++-common/asan/stack-overflow-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/stack-overflow-1.c  -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: c-c++-common/asan/stack-overflow-1.c  -O3 -g  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/stack-overflow-1.c  -O3 -g  compilation failed to produce executable
+FAIL: c-c++-common/asan/stack-overflow-1.c  -Os  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/stack-overflow-1.c  -Os  compilation failed to produce executable
+FAIL: c-c++-common/asan/stack-overflow-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/stack-overflow-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+FAIL: c-c++-common/asan/stack-overflow-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/stack-overflow-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+FAIL: c-c++-common/asan/strip-path-prefix-1.c  -O2  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/strip-path-prefix-1.c  -O2  compilation failed to produce executable
+FAIL: c-c++-common/asan/strip-path-prefix-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/strip-path-prefix-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+FAIL: c-c++-common/asan/strip-path-prefix-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/strip-path-prefix-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -O0  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c  -O0  compilation failed to produce executable
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -O1  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c  -O1  compilation failed to produce executable
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -O2  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c  -O2  compilation failed to produce executable
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c  -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -O3 -g  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c  -O3 -g  compilation failed to produce executable
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -Os  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c  -Os  compilation failed to produce executable
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+FAIL: c-c++-common/asan/use-after-free-1.c  -O0  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/use-after-free-1.c  -O0  compilation failed to produce executable
+FAIL: c-c++-common/asan/use-after-free-1.c  -O1  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/use-after-free-1.c  -O1  compilation failed to produce executable
+FAIL: c-c++-common/asan/use-after-free-1.c  -O2  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/use-after-free-1.c  -O2  compilation failed to produce executable
+FAIL: c-c++-common/asan/use-after-free-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/use-after-free-1.c  -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: c-c++-common/asan/use-after-free-1.c  -O3 -g  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/use-after-free-1.c  -O3 -g  compilation failed to produce executable
+FAIL: c-c++-common/asan/use-after-free-1.c  -Os  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/use-after-free-1.c  -Os  compilation failed to produce executable
+FAIL: c-c++-common/asan/use-after-free-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/use-after-free-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+FAIL: c-c++-common/asan/use-after-free-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/use-after-free-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+FAIL: g++.dg/asan/deep-stack-uaf-1.C  -O0  (test for excess errors)
+UNRESOLVED: g++.dg/asan/deep-stack-uaf-1.C  -O0  compilation failed to produce executable
+FAIL: g++.dg/asan/deep-stack-uaf-1.C  -O1  (test for excess errors)
+UNRESOLVED: g++.dg/asan/deep-stack-uaf-1.C  -O1  compilation failed to produce executable
+FAIL: g++.dg/asan/deep-stack-uaf-1.C  -O2  (test for excess errors)
+UNRESOLVED: g++.dg/asan/deep-stack-uaf-1.C  -O2  compilation failed to produce executable
+FAIL: g++.dg/asan/deep-stack-uaf-1.C  -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: g++.dg/asan/deep-stack-uaf-1.C  -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: g++.dg/asan/deep-stack-uaf-1.C  -O3 -g  (test for excess errors)
+UNRESOLVED: g++.dg/asan/deep-stack-uaf-1.C  -O3 -g  compilation failed to produce executable
+FAIL: g++.dg/asan/deep-stack-uaf-1.C  -Os  (test for excess errors)
+UNRESOLVED: g++.dg/asan/deep-stack-uaf-1.C  -Os  compilation failed to produce executable
+FAIL: g++.dg/asan/deep-tail-call-1.C  -O0  (test for excess errors)
+UNRESOLVED: g++.dg/asan/deep-tail-call-1.C  -O0  compilation failed to produce executable
+FAIL: g++.dg/asan/deep-tail-call-1.C  -O1  (test for excess errors)
+UNRESOLVED: g++.dg/asan/deep-tail-call-1.C  -O1  compilation failed to produce executable
+FAIL: g++.dg/asan/deep-tail-call-1.C  -O2  (test for excess errors)
+UNRESOLVED: g++.dg/asan/deep-tail-call-1.C  -O2  compilation failed to produce executable
+FAIL: g++.dg/asan/deep-tail-call-1.C  -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: g++.dg/asan/deep-tail-call-1.C  -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: g++.dg/asan/deep-tail-call-1.C  -O3 -g  (test for excess errors)
+UNRESOLVED: g++.dg/asan/deep-tail-call-1.C  -O3 -g  compilation failed to produce executable
+FAIL: g++.dg/asan/deep-tail-call-1.C  -Os  (test for excess errors)
+UNRESOLVED: g++.dg/asan/deep-tail-call-1.C  -Os  compilation failed to produce executable
+FAIL: g++.dg/asan/deep-tail-call-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+UNRESOLVED: g++.dg/asan/deep-tail-call-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+FAIL: g++.dg/asan/deep-tail-call-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: g++.dg/asan/deep-tail-call-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+FAIL: g++.dg/asan/deep-thread-stack-1.C  -O0  (test for excess errors)
+UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C  -O0  compilation failed to produce executable
+FAIL: g++.dg/asan/deep-thread-stack-1.C  -O1  (test for excess errors)
+UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C  -O1  compilation failed to produce executable
+FAIL: g++.dg/asan/deep-thread-stack-1.C  -O2  (test for excess errors)
+UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C  -O2  compilation failed to produce executable
+FAIL: g++.dg/asan/deep-thread-stack-1.C  -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C  -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: g++.dg/asan/deep-thread-stack-1.C  -O3 -g  (test for excess errors)
+UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C  -O3 -g  compilation failed to produce executable
+FAIL: g++.dg/asan/deep-thread-stack-1.C  -Os  (test for excess errors)
+UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C  -Os  compilation failed to produce executable
+FAIL: g++.dg/asan/deep-thread-stack-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+FAIL: g++.dg/asan/deep-thread-stack-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+FAIL: g++.dg/asan/default-options-1.C  -O0  (test for excess errors)
+UNRESOLVED: g++.dg/asan/default-options-1.C  -O0  compilation failed to produce executable
+FAIL: g++.dg/asan/default-options-1.C  -O1  (test for excess errors)
+UNRESOLVED: g++.dg/asan/default-options-1.C  -O1  compilation failed to produce executable
+FAIL: g++.dg/asan/default-options-1.C  -O2  (test for excess errors)
+UNRESOLVED: g++.dg/asan/default-options-1.C  -O2  compilation failed to produce executable
+FAIL: g++.dg/asan/default-options-1.C  -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: g++.dg/asan/default-options-1.C  -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: g++.dg/asan/default-options-1.C  -O3 -g  (test for excess errors)
+UNRESOLVED: g++.dg/asan/default-options-1.C  -O3 -g  compilation failed to produce executable
+FAIL: g++.dg/asan/default-options-1.C  -Os  (test for excess errors)
+UNRESOLVED: g++.dg/asan/default-options-1.C  -Os  compilation failed to produce executable
+FAIL: g++.dg/asan/default-options-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+UNRESOLVED: g++.dg/asan/default-options-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+FAIL: g++.dg/asan/default-options-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: g++.dg/asan/default-options-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-failure-test-1.C  -O0  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-failure-test-1.C  -O0  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-failure-test-1.C  -O1  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-failure-test-1.C  -O1  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-failure-test-1.C  -O2  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-failure-test-1.C  -O2  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-failure-test-1.C  -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-failure-test-1.C  -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-failure-test-1.C  -O3 -g  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-failure-test-1.C  -O3 -g  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-failure-test-1.C  -Os  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-failure-test-1.C  -Os  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-failure-test-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-failure-test-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-failure-test-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-failure-test-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-malloc-test-1.C  -O0  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C  -O0  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-malloc-test-1.C  -O1  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C  -O1  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-malloc-test-1.C  -O2  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C  -O2  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-malloc-test-1.C  -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C  -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-malloc-test-1.C  -O3 -g  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C  -O3 -g  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-malloc-test-1.C  -Os  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C  -Os  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-malloc-test-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-malloc-test-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-test-1.C  -O0  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-test-1.C  -O0  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-test-1.C  -O1  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-test-1.C  -O1  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-test-1.C  -O2  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-test-1.C  -O2  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-test-1.C  -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-test-1.C  -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-test-1.C  -O3 -g  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-test-1.C  -O3 -g  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-test-1.C  -Os  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-test-1.C  -Os  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-test-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-test-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+FAIL: g++.dg/asan/interception-test-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: g++.dg/asan/interception-test-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+FAIL: g++.dg/asan/large-func-test-1.C  -O0  (test for excess errors)
+UNRESOLVED: g++.dg/asan/large-func-test-1.C  -O0  compilation failed to produce executable
+FAIL: g++.dg/asan/large-func-test-1.C  -O1  (test for excess errors)
+UNRESOLVED: g++.dg/asan/large-func-test-1.C  -O1  compilation failed to produce executable
+FAIL: g++.dg/asan/large-func-test-1.C  -O2  (test for excess errors)
+UNRESOLVED: g++.dg/asan/large-func-test-1.C  -O2  compilation failed to produce executable
+FAIL: g++.dg/asan/large-func-test-1.C  -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: g++.dg/asan/large-func-test-1.C  -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: g++.dg/asan/large-func-test-1.C  -O3 -g  (test for excess errors)
+UNRESOLVED: g++.dg/asan/large-func-test-1.C  -O3 -g  compilation failed to produce executable
+FAIL: g++.dg/asan/large-func-test-1.C  -Os  (test for excess errors)
+UNRESOLVED: g++.dg/asan/large-func-test-1.C  -Os  compilation failed to produce executable
+FAIL: g++.dg/asan/large-func-test-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+UNRESOLVED: g++.dg/asan/large-func-test-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+FAIL: g++.dg/asan/large-func-test-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: g++.dg/asan/large-func-test-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+FAIL: g++.dg/asan/pr55617.C  -O0  (test for excess errors)
+UNRESOLVED: g++.dg/asan/pr55617.C  -O0  compilation failed to produce executable
+FAIL: g++.dg/asan/pr55617.C  -O1  (test for excess errors)
+UNRESOLVED: g++.dg/asan/pr55617.C  -O1  compilation failed to produce executable
+FAIL: g++.dg/asan/pr55617.C  -O2  (test for excess errors)
+UNRESOLVED: g++.dg/asan/pr55617.C  -O2  compilation failed to produce executable
+FAIL: g++.dg/asan/pr55617.C  -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: g++.dg/asan/pr55617.C  -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: g++.dg/asan/pr55617.C  -O3 -g  (test for excess errors)
+UNRESOLVED: g++.dg/asan/pr55617.C  -O3 -g  compilation failed to produce executable
+FAIL: g++.dg/asan/pr55617.C  -Os  (test for excess errors)
+UNRESOLVED: g++.dg/asan/pr55617.C  -Os  compilation failed to produce executable
+FAIL: g++.dg/asan/pr55617.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+UNRESOLVED: g++.dg/asan/pr55617.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+FAIL: g++.dg/asan/pr55617.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: g++.dg/asan/pr55617.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+FAIL: g++.dg/asan/symbolize-callback-1.C  -O2  (test for excess errors)
+UNRESOLVED: g++.dg/asan/symbolize-callback-1.C  -O2  compilation failed to produce executable
+FAIL: g++.dg/asan/symbolize-callback-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+UNRESOLVED: g++.dg/asan/symbolize-callback-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+FAIL: g++.dg/asan/symbolize-callback-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: g++.dg/asan/symbolize-callback-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+
+
+# Our test method is not currently copying data files to the target or
+# copying profile data back to the host, so a number of tests fail due
+# to nonexistent files.
+FAIL: g++.dg/bprob/g++-bprob-1.C execution: file g++-bprob-1.gcda does not exist,  -g  -fprofile-arcs
+UNRESOLVED: g++.dg/bprob/g++-bprob-1.C compilation,  -g  -fbranch-probabilities
+UNRESOLVED: g++.dg/bprob/g++-bprob-1.C execution,    -g  -fbranch-probabilities
+FAIL: g++.dg/bprob/g++-bprob-1.C execution: file g++-bprob-1.gcda does not exist,  -O0  -fprofile-arcs
+UNRESOLVED: g++.dg/bprob/g++-bprob-1.C compilation,  -O0  -fbranch-probabilities
+UNRESOLVED: g++.dg/bprob/g++-bprob-1.C execution,    -O0  -fbranch-probabilities
+FAIL: g++.dg/bprob/g++-bprob-1.C execution: file g++-bprob-1.gcda does not exist,  -O1  -fprofile-arcs
+UNRESOLVED: g++.dg/bprob/g++-bprob-1.C compilation,  -O1  -fbranch-probabilities
+UNRESOLVED: g++.dg/bprob/g++-bprob-1.C execution,    -O1  -fbranch-probabilities
+FAIL: g++.dg/bprob/g++-bprob-1.C execution: file g++-bprob-1.gcda does not exist,  -O2  -fprofile-arcs
+UNRESOLVED: g++.dg/bprob/g++-bprob-1.C compilation,  -O2  -fbranch-probabilities
+UNRESOLVED: g++.dg/bprob/g++-bprob-1.C execution,    -O2  -fbranch-probabilities
+FAIL: g++.dg/bprob/g++-bprob-1.C execution: file g++-bprob-1.gcda does not exist,  -O3  -fprofile-arcs
+UNRESOLVED: g++.dg/bprob/g++-bprob-1.C compilation,  -O3  -fbranch-probabilities
+UNRESOLVED: g++.dg/bprob/g++-bprob-1.C execution,    -O3  -fbranch-probabilities
+FAIL: g++.dg/bprob/g++-bprob-1.C execution: file g++-bprob-1.gcda does not exist,  -O3 -g  -fprofile-arcs
+UNRESOLVED: g++.dg/bprob/g++-bprob-1.C compilation,  -O3 -g  -fbranch-probabilities
+UNRESOLVED: g++.dg/bprob/g++-bprob-1.C execution,    -O3 -g  -fbranch-probabilities
+FAIL: g++.dg/bprob/g++-bprob-1.C execution: file g++-bprob-1.gcda does not exist,  -Os  -fprofile-arcs
+UNRESOLVED: g++.dg/bprob/g++-bprob-1.C compilation,  -Os  -fbranch-probabilities
+UNRESOLVED: g++.dg/bprob/g++-bprob-1.C execution,    -Os  -fbranch-probabilities
+FAIL: g++.dg/bprob/g++-bprob-2.C execution: file g++-bprob-2.gcda does not exist,  -g  -fprofile-arcs
+UNRESOLVED: g++.dg/bprob/g++-bprob-2.C compilation,  -g  -fbranch-probabilities
+UNRESOLVED: g++.dg/bprob/g++-bprob-2.C execution,    -g  -fbranch-probabilities
+FAIL: g++.dg/bprob/g++-bprob-2.C execution: file g++-bprob-2.gcda does not exist,  -O0  -fprofile-arcs
+UNRESOLVED: g++.dg/bprob/g++-bprob-2.C compilation,  -O0  -fbranch-probabilities
+UNRESOLVED: g++.dg/bprob/g++-bprob-2.C execution,    -O0  -fbranch-probabilities
+FAIL: g++.dg/bprob/g++-bprob-2.C execution: file g++-bprob-2.gcda does not exist,  -O1  -fprofile-arcs
+UNRESOLVED: g++.dg/bprob/g++-bprob-2.C compilation,  -O1  -fbranch-probabilities
+UNRESOLVED: g++.dg/bprob/g++-bprob-2.C execution,    -O1  -fbranch-probabilities
+FAIL: g++.dg/bprob/g++-bprob-2.C execution: file g++-bprob-2.gcda does not exist,  -O2  -fprofile-arcs
+UNRESOLVED: g++.dg/bprob/g++-bprob-2.C compilation,  -O2  -fbranch-probabilities
+UNRESOLVED: g++.dg/bprob/g++-bprob-2.C execution,    -O2  -fbranch-probabilities
+FAIL: g++.dg/bprob/g++-bprob-2.C execution: file g++-bprob-2.gcda does not exist,  -O3  -fprofile-arcs
+UNRESOLVED: g++.dg/bprob/g++-bprob-2.C compilation,  -O3  -fbranch-probabilities
+UNRESOLVED: g++.dg/bprob/g++-bprob-2.C execution,    -O3  -fbranch-probabilities
+FAIL: g++.dg/bprob/g++-bprob-2.C execution: file g++-bprob-2.gcda does not exist,  -O3 -g  -fprofile-arcs
+UNRESOLVED: g++.dg/bprob/g++-bprob-2.C compilation,  -O3 -g  -fbranch-probabilities
+UNRESOLVED: g++.dg/bprob/g++-bprob-2.C execution,    -O3 -g  -fbranch-probabilities
+FAIL: g++.dg/bprob/g++-bprob-2.C execution: file g++-bprob-2.gcda does not exist,  -Os  -fprofile-arcs
+UNRESOLVED: g++.dg/bprob/g++-bprob-2.C compilation,  -Os  -fbranch-probabilities
+UNRESOLVED: g++.dg/bprob/g++-bprob-2.C execution,    -Os  -fbranch-probabilities
+FAIL: gcc.misc-tests/bprob-1.c execution: file bprob-1.gcda does not exist,  -O2  -fprofile-arcs
+UNRESOLVED: gcc.misc-tests/bprob-1.c compilation,  -O2  -fbranch-probabilities
+UNRESOLVED: gcc.misc-tests/bprob-1.c execution,    -O2  -fbranch-probabilities
+FAIL: gcc.misc-tests/bprob-1.c execution: file bprob-1.gcda does not exist,  -O3   -fprofile-arcs
+UNRESOLVED: gcc.misc-tests/bprob-1.c compilation,  -O3   -fbranch-probabilities
+UNRESOLVED: gcc.misc-tests/bprob-1.c execution,    -O3   -fbranch-probabilities
+FAIL: gcc.misc-tests/bprob-2.c execution: file bprob-2.gcda does not exist,  -O2  -fprofile-arcs
+UNRESOLVED: gcc.misc-tests/bprob-2.c compilation,  -O2  -fbranch-probabilities
+UNRESOLVED: gcc.misc-tests/bprob-2.c execution,    -O2  -fbranch-probabilities
+FAIL: gcc.misc-tests/bprob-2.c execution: file bprob-2.gcda does not exist,  -O3   -fprofile-arcs
+UNRESOLVED: gcc.misc-tests/bprob-2.c compilation,  -O3   -fbranch-probabilities
+UNRESOLVED: gcc.misc-tests/bprob-2.c execution,    -O3   -fbranch-probabilities
+FAIL: g++.dg/tree-prof/indir-call-prof-2.C execution: file indir-call-prof-2.gcda does not exist,  -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/indir-call-prof-2.C compilation,  -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/indir-call-prof-2.C execution,    -fprofile-use
+FAIL: g++.dg/tree-prof/indir-call-prof.C execution: file indir-call-prof.gcda does not exist,  -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/indir-call-prof.C compilation,  -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/indir-call-prof.C execution,    -fprofile-use
+FAIL: g++.dg/tree-prof/inline_mismatch_args.C execution: file inline_mismatch_args.gcda does not exist,  -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/inline_mismatch_args.C compilation,  -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/inline_mismatch_args.C execution,    -fprofile-use
+FAIL: g++.dg/tree-prof/lipo/indir-call-prof-2_0.C execution: file indir-call-prof-2_0.gcda does not exist,  -fprofile-generate -fripa -fno-section-anchors
+FAIL: g++.dg/tree-prof/lipo/indir-call-prof-2_0.C execution: file indir-call-prof-2_0.gcda.imports does not exist,  -fprofile-generate -fripa -fno-section-anchors
+UNRESOLVED: g++.dg/tree-prof/lipo/indir-call-prof-2_0.C compilation,  -fprofile-use -fripa -fno-section-anchors
+UNRESOLVED: g++.dg/tree-prof/lipo/indir-call-prof-2_0.C execution,    -fprofile-use -fripa -fno-section-anchors
+FAIL: g++.dg/tree-prof/lipo/indir-call-prof_0.C execution: file indir-call-prof_0.gcda does not exist,  -fprofile-generate -fripa -fno-section-anchors
+FAIL: g++.dg/tree-prof/lipo/indir-call-prof_0.C execution: file indir-call-prof_0.gcda.imports does not exist,  -fprofile-generate -fripa -fno-section-anchors
+UNRESOLVED: g++.dg/tree-prof/lipo/indir-call-prof_0.C compilation,  -fprofile-use -fripa -fno-section-anchors
+UNRESOLVED: g++.dg/tree-prof/lipo/indir-call-prof_0.C execution,    -fprofile-use -fripa -fno-section-anchors
+FAIL: g++.dg/tree-prof/lipo/inline_mismatch_args_0.C execution: file inline_mismatch_args_0.gcda does not exist,  -fprofile-generate -fripa -fno-section-anchors
+FAIL: g++.dg/tree-prof/lipo/inline_mismatch_args_0.C execution: file inline_mismatch_args_0.gcda.imports does not exist,  -fprofile-generate -fripa -fno-section-anchors
+UNRESOLVED: g++.dg/tree-prof/lipo/inline_mismatch_args_0.C compilation,  -fprofile-use -fripa -fno-section-anchors
+UNRESOLVED: g++.dg/tree-prof/lipo/inline_mismatch_args_0.C execution,    -fprofile-use -fripa -fno-section-anchors
+FAIL: g++.dg/tree-prof/lipo/partition1_0.C execution: file partition1_0.gcda does not exist,  -fprofile-generate -fripa -fno-section-anchors
+FAIL: g++.dg/tree-prof/lipo/partition1_0.C execution: file partition1_0.gcda.imports does not exist,  -fprofile-generate -fripa -fno-section-anchors
+UNRESOLVED: g++.dg/tree-prof/lipo/partition1_0.C compilation,  -fprofile-use -fripa -fno-section-anchors
+UNRESOLVED: g++.dg/tree-prof/lipo/partition1_0.C execution,    -fprofile-use -fripa -fno-section-anchors
+FAIL: g++.dg/tree-prof/lipo/partition2_0.C execution: file partition2_0.gcda does not exist,  -fprofile-generate -fripa -fno-section-anchors
+FAIL: g++.dg/tree-prof/lipo/partition2_0.C execution: file partition2_0.gcda.imports does not exist,  -fprofile-generate -fripa -fno-section-anchors
+UNRESOLVED: g++.dg/tree-prof/lipo/partition2_0.C compilation,  -fprofile-use -fripa -fno-section-anchors
+UNRESOLVED: g++.dg/tree-prof/lipo/partition2_0.C execution,    -fprofile-use -fripa -fno-section-anchors
+FAIL: g++.dg/tree-prof/lipo/partition3_0.C execution: file partition3_0.gcda does not exist,  -fprofile-generate -fripa -fno-section-anchors
+FAIL: g++.dg/tree-prof/lipo/partition3_0.C execution: file partition3_0.gcda.imports does not exist,  -fprofile-generate -fripa -fno-section-anchors
+UNRESOLVED: g++.dg/tree-prof/lipo/partition3_0.C compilation,  -fprofile-use -fripa -fno-section-anchors
+UNRESOLVED: g++.dg/tree-prof/lipo/partition3_0.C execution,    -fprofile-use -fripa -fno-section-anchors
+FAIL: g++.dg/tree-prof/lipo/vcall1_0.C execution: file vcall1_0.gcda does not exist,  -fprofile-generate -fripa -fno-section-anchors
+FAIL: g++.dg/tree-prof/lipo/vcall1_0.C execution: file vcall1_0.gcda.imports does not exist,  -fprofile-generate -fripa -fno-section-anchors
+FAIL: g++.dg/tree-prof/lipo/vcall1_0.C execution: file vcall1_1.gcda does not exist,  -fprofile-generate -fripa -fno-section-anchors
+FAIL: g++.dg/tree-prof/lipo/vcall1_0.C execution: file vcall1_1.gcda.imports does not exist,  -fprofile-generate -fripa -fno-section-anchors
+FAIL: g++.dg/tree-prof/lipo/vcall1_0.C execution: file vcall1_2.gcda does not exist,  -fprofile-generate -fripa -fno-section-anchors
+FAIL: g++.dg/tree-prof/lipo/vcall1_0.C execution: file vcall1_2.gcda.imports does not exist,  -fprofile-generate -fripa -fno-section-anchors
+UNRESOLVED: g++.dg/tree-prof/lipo/vcall1_0.C compilation,  -fprofile-use -fripa -fno-section-anchors
+UNRESOLVED: g++.dg/tree-prof/lipo/vcall1_0.C execution,    -fprofile-use -fripa -fno-section-anchors
+FAIL: g++.dg/tree-prof/partition1.C execution: file partition1.gcda does not exist,  -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/partition1.C compilation,  -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/partition1.C execution,    -fprofile-use
+FAIL: g++.dg/tree-prof/partition2.C execution: file partition2.gcda does not exist,  -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/partition2.C compilation,  -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/partition2.C execution,    -fprofile-use
+FAIL: g++.dg/tree-prof/partition3.C execution: file partition3.gcda does not exist,  -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/partition3.C compilation,  -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/partition3.C execution,    -fprofile-use
+FAIL: g++.dg/tree-prof/pr51719.C execution: file pr51719.gcda does not exist,  -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/pr51719.C compilation,  -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/pr51719.C execution,    -fprofile-use
+FAIL: g++.dg/tree-prof/pr53460.C execution: file pr53460.gcda does not exist,  -fprofile-generate
+UNRESOLVED: g++.dg/tree-prof/pr53460.C compilation,  -fprofile-use
+UNRESOLVED: g++.dg/tree-prof/pr53460.C execution,    -fprofile-use
+FAIL: gcc.dg/tree-prof/bb-reorg.c execution: file bb-reorg.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/bb-reorg.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/bb-reorg.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/ic-misattribution-1.c execution: file ic-misattribution-1.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/ic-misattribution-1.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/ic-misattribution-1.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/ic-misattribution-1a.c execution: file ic-misattribution-1a.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/ic-misattribution-1a.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/ic-misattribution-1a.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/indir-call-prof.c execution: file indir-call-prof.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/indir-call-prof.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/indir-call-prof.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/inliner-1.c execution: file inliner-1.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/inliner-1.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/inliner-1.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/lipo/bb-reorg_0.c execution: file bb-reorg_0.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/bb-reorg_0.c execution: file bb-reorg_0.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/bb-reorg_0.c compilation,  -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/bb-reorg_0.c execution,    -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/ic-misattribution-1_0.c execution: file ic-misattribution-1_0.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/ic-misattribution-1_0.c execution: file ic-misattribution-1_0.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/ic-misattribution-1_0.c execution: file ic-misattribution-1_1.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/ic-misattribution-1_0.c execution: file ic-misattribution-1_1.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/ic-misattribution-1_0.c compilation,  -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/ic-misattribution-1_0.c execution,    -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/indir-call-prof-single_0.c execution: file indir-call-prof-single_0.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/indir-call-prof-single_0.c execution: file indir-call-prof-single_0.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/indir-call-prof-single_0.c compilation,  -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/indir-call-prof-single_0.c execution,    -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/indir-call-prof_0.c execution: file indir-call-prof_0.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/indir-call-prof_0.c execution: file indir-call-prof_0.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/indir-call-prof_0.c execution: file indir-call-prof_1.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/indir-call-prof_0.c execution: file indir-call-prof_1.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/indir-call-prof_0.c compilation,  -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/indir-call-prof_0.c execution,    -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/inliner-1_0.c execution: file inliner-1_0.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/inliner-1_0.c execution: file inliner-1_0.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/inliner-1_0.c compilation,  -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/inliner-1_0.c execution,    -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/lipo_inline1_0.c execution: file lipo_inline1_0.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/lipo_inline1_0.c execution: file lipo_inline1_0.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/lipo_inline1_0.c execution: file lipo_inline1_1.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/lipo_inline1_0.c execution: file lipo_inline1_1.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/lipo_inline1_0.c execution: file lipo_inline1_2.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/lipo_inline1_0.c execution: file lipo_inline1_2.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/lipo_inline1_0.c compilation,  -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/lipo_inline1_0.c execution,    -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/pr34999_0.c execution: file pr34999_0.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/pr34999_0.c execution: file pr34999_0.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/pr34999_0.c compilation,  -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/pr34999_0.c execution,    -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/pr45354_0.c execution: file pr45354_0.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/pr45354_0.c execution: file pr45354_0.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/pr45354_0.c compilation,  -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/pr45354_0.c execution,    -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/pr47187_0.c execution: file pr47187_0.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/pr47187_0.c execution: file pr47187_0.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/pr47187_0.c compilation,  -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/pr47187_0.c execution,    -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/stringop-1_0.c execution: file stringop-1_0.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/stringop-1_0.c execution: file stringop-1_0.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/stringop-1_0.c compilation,  -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/stringop-1_0.c execution,    -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/stringop-2_0.c execution: file stringop-2_0.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/stringop-2_0.c execution: file stringop-2_0.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/stringop-2_0.c compilation,  -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/stringop-2_0.c execution,    -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/tracer-1_0.c execution: file tracer-1_0.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/tracer-1_0.c execution: file tracer-1_0.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/tracer-1_0.c compilation,  -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/tracer-1_0.c execution,    -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/update-cunroll-2_0.c execution: file update-cunroll-2_0.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/update-cunroll-2_0.c execution: file update-cunroll-2_0.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/update-cunroll-2_0.c compilation,  -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/update-cunroll-2_0.c execution,    -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/update-loopch_0.c execution: file update-loopch_0.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/update-loopch_0.c execution: file update-loopch_0.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/update-loopch_0.c compilation,  -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/update-loopch_0.c execution,    -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/update-tailcall_0.c execution: file update-tailcall_0.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/update-tailcall_0.c execution: file update-tailcall_0.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/update-tailcall_0.c compilation,  -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/update-tailcall_0.c execution,    -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/val-prof-1_0.c execution: file val-prof-1_0.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/val-prof-1_0.c execution: file val-prof-1_0.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/val-prof-1_0.c compilation,  -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/val-prof-1_0.c execution,    -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/val-prof-2_0.c execution: file val-prof-2_0.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/val-prof-2_0.c execution: file val-prof-2_0.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/val-prof-2_0.c compilation,  -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/val-prof-2_0.c execution,    -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/val-prof-3_0.c execution: file val-prof-3_0.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/val-prof-3_0.c execution: file val-prof-3_0.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/val-prof-3_0.c compilation,  -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/val-prof-3_0.c execution,    -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/val-prof-4_0.c execution: file val-prof-4_0.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/val-prof-4_0.c execution: file val-prof-4_0.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/val-prof-4_0.c compilation,  -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/val-prof-4_0.c execution,    -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/val-prof-5_0.c execution: file val-prof-5_0.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/val-prof-5_0.c execution: file val-prof-5_0.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/val-prof-5_0.c compilation,  -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/val-prof-5_0.c execution,    -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/val-prof-6_0.c execution: file val-prof-6_0.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/val-prof-6_0.c execution: file val-prof-6_0.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/val-prof-6_0.c compilation,  -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/val-prof-6_0.c execution,    -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/wcoverage-mismatch_0.c execution: file wcoverage-mismatch_0.gcda does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/lipo/wcoverage-mismatch_0.c execution: file wcoverage-mismatch_0.gcda.imports does not exist,  -fprofile-generate -fripa -D_PROFILE_GENERATE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/wcoverage-mismatch_0.c compilation,  -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+UNRESOLVED: gcc.dg/tree-prof/lipo/wcoverage-mismatch_0.c execution,    -fprofile-use -fripa -D_PROFILE_USE -fno-section-anchors
+FAIL: gcc.dg/tree-prof/peel-1.c execution: file peel-1.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/peel-1.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/peel-1.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/pr34999.c execution: file pr34999.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/pr34999.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/pr34999.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/pr44777.c execution: file pr44777.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/pr44777.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/pr44777.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/pr45354.c execution: file pr45354.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/pr45354.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/pr45354.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/pr47187.c execution: file pr47187.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/pr47187.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/pr47187.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/pr49299-1.c execution: file pr49299-1.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/pr49299-1.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/pr49299-1.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/pr49299-2.c execution: file pr49299-2.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/pr49299-2.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/pr49299-2.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/pr50907.c execution: file pr50907.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/pr50907.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/pr50907.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/pr52027.c execution: file pr52027.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/pr52027.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/pr52027.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/pr52150.c execution: file pr52150.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/pr52150.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/pr52150.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/prof-robust-1.c execution: file prof-robust-1.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/prof-robust-1.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/prof-robust-1.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/stringop-1.c execution: file stringop-1.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/stringop-1.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/stringop-1.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/stringop-2.c execution: file stringop-2.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/stringop-2.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/stringop-2.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/switch-case-1.c execution: file switch-case-1.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/switch-case-1.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/switch-case-1.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/switch-case-2.c execution: file switch-case-2.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/switch-case-2.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/switch-case-2.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/tracer-1.c execution: file tracer-1.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/tracer-1.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/tracer-1.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/unroll-1.c execution: file unroll-1.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/unroll-1.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/unroll-1.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/update-cunroll-2.c execution: file update-cunroll-2.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/update-cunroll-2.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/update-cunroll-2.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/update-loopch.c execution: file update-loopch.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/update-loopch.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/update-loopch.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/update-tailcall.c execution: file update-tailcall.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/update-tailcall.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/update-tailcall.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/val-prof-1.c execution: file val-prof-1.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/val-prof-1.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/val-prof-1.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/val-prof-2.c execution: file val-prof-2.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/val-prof-2.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/val-prof-2.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/val-prof-3.c execution: file val-prof-3.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/val-prof-3.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/val-prof-3.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/val-prof-4.c execution: file val-prof-4.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/val-prof-4.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/val-prof-4.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/val-prof-5.c execution: file val-prof-5.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/val-prof-5.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/val-prof-5.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/val-prof-6.c execution: file val-prof-6.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/val-prof-6.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/val-prof-6.c execution,    -fprofile-use -D_PROFILE_USE
+FAIL: gcc.dg/tree-prof/wcoverage-mismatch.c execution: file wcoverage-mismatch.gcda does not exist,  -fprofile-generate -D_PROFILE_GENERATE
+UNRESOLVED: gcc.dg/tree-prof/wcoverage-mismatch.c compilation,  -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/tree-prof/wcoverage-mismatch.c execution,    -fprofile-use -D_PROFILE_USE
+UNRESOLVED: gcc.dg/pr47793.c scan-file .
diff --git a/contrib/testsuite-management/validate_failures.py b/contrib/testsuite-management/validate_failures.py
index 74dbcfb..2779050 100755
--- a/contrib/testsuite-management/validate_failures.py
+++ b/contrib/testsuite-management/validate_failures.py
@@ -119,20 +119,15 @@ class TestResult(object):
 
   def __init__(self, summary_line, ordinal=-1):
     try:
-      self.attrs = ''
-      if '|' in summary_line:
-        (self.attrs, summary_line) = summary_line.split('|', 1)
+      (self.attrs, summary_line) = SplitAttributesFromSummaryLine(summary_line)
       try:
         (self.state,
          self.name,
-         self.description) = re.match(r' *([A-Z]+):\s*(\S+)\s+(.*)',
+         self.description) = re.match(r'([A-Z]+):\s*(\S+)\s*(.*)',
                                       summary_line).groups()
       except:
         print 'Failed to parse summary line: "%s"' % summary_line
         raise
-      self.attrs = self.attrs.strip()
-      self.state = self.state.strip()
-      self.description = self.description.strip()
       self.ordinal = ordinal
     except ValueError:
       Error('Cannot parse summary line "%s"' % summary_line)
@@ -196,11 +191,9 @@ def GetMakefileValue(makefile_name, value_name):
   return None
 
 
-def ValidBuildDirectory(builddir, target):
+def ValidBuildDirectory(builddir):
   if (not os.path.exists(builddir) or
-      not os.path.exists('%s/Makefile' % builddir) or
-      (not os.path.exists('%s/build-%s' % (builddir, target)) and
-       not os.path.exists('%s/%s' % (builddir, target)))):
+      not os.path.exists('%s/Makefile' % builddir)):
     return False
   return True
 
@@ -210,11 +203,20 @@ def IsComment(line):
   return line.startswith('#')
 
 
+def SplitAttributesFromSummaryLine(line):
+  """Splits off attributes from a summary line, if present."""
+  if '|' in line and not _VALID_TEST_RESULTS_REX.match(line):
+    (attrs, line) = line.split('|', 1)
+    attrs = attrs.strip()
+  else:
+    attrs = ''
+  line = line.strip()
+  return (attrs, line)
+
+
 def IsInterestingResult(line):
   """Return True if line is one of the summary lines we care about."""
-  if '|' in line:
-    (_, line) = line.split('|', 1)
-    line = line.strip()
+  (_, line) = SplitAttributesFromSummaryLine(line)
   return bool(_VALID_TEST_RESULTS_REX.match(line))
 
 
@@ -362,14 +364,17 @@ def GetManifestPath(srcdir, target, user_provided_must_exist):
       Error('Manifest does not exist: %s' % manifest_path)
     return manifest_path
   else:
-    assert srcdir and target
+    if not srcdir:
+      Error('Could not determine the location of GCC\'s source tree. '
+            'The Makefile does not contain a definition for "srcdir".')
+    if not target:
+      Error('Could not determine the target triplet for this build. '
+            'The Makefile does not contain a definition for "target_alias".')
     return _MANIFEST_PATH_PATTERN % (srcdir, _MANIFEST_SUBDIR, target)
 
 
 def GetBuildData():
-  srcdir = GetMakefileValue('%s/Makefile' % _OPTIONS.build_dir, 'srcdir =')
-  target = GetMakefileValue('%s/Makefile' % _OPTIONS.build_dir, 'target_alias=')
-  if not ValidBuildDirectory(_OPTIONS.build_dir, target):
+  if not ValidBuildDirectory(_OPTIONS.build_dir):
     # If we have been given a set of results to use, we may
     # not be inside a valid GCC build directory.  In that case,
     # the user must provide both a manifest file and a set
@@ -380,6 +385,8 @@ def GetBuildData():
             _OPTIONS.build_dir)
     else:
       return None, None
+  srcdir = GetMakefileValue('%s/Makefile' % _OPTIONS.build_dir, 'srcdir =')
+  target = GetMakefileValue('%s/Makefile' % _OPTIONS.build_dir, 'target_alias=')
   print 'Source directory: %s' % srcdir
   print 'Build target:     %s' % target
   return srcdir, target
@@ -413,8 +420,9 @@ def PerformComparison(expected, actual, ignore_missing_failures):
   if not ignore_missing_failures and len(expected_vs_actual) > 0:
     PrintSummary('Expected results not present in this build (fixed tests)'
                  '\n\nNOTE: This is not a failure.  It just means that these '
-                 'tests were expected\nto fail, but they worked in this '
-                 'configuration.\n', expected_vs_actual)
+                 'tests were expected\nto fail, but either they worked in '
+                 'this configuration or they were not\npresent at all.\n',
+                 expected_vs_actual)
 
   if tests_ok:
     print '\nSUCCESS: No unexpected failures.'
diff --git a/contrib/testsuite-management/x86_64-grtev3-linux-gnu.xfail b/contrib/testsuite-management/x86_64-grtev3-linux-gnu.xfail
new file mode 100644
index 0000000..0bf9de2
--- /dev/null
+++ b/contrib/testsuite-management/x86_64-grtev3-linux-gnu.xfail
@@ -0,0 +1,1301 @@
+# Known failures from trunk.
+FAIL: gfortran.dg/class_optional_2.f90 -Os  execution test
+FAIL: gfortran.dg/lto/pr45586 f_lto_pr45586_0.o-f_lto_pr45586_0.o link, -O0 -flto -flto-partition=1to1 -fno-use-linker-plugin  (internal compiler error)
+FAIL: gfortran.dg/lto/pr45586 f_lto_pr45586_0.o-f_lto_pr45586_0.o link, -O0 -flto -flto-partition=none -fuse-linker-plugin (internal compiler error)
+FAIL: gfortran.dg/lto/pr45586 f_lto_pr45586_0.o-f_lto_pr45586_0.o link, -O0 -flto -fuse-linker-plugin -fno-fat-lto-objects  (internal compiler error)
+FAIL: gfortran.dg/lto/pr45586-2 f_lto_pr45586-2_0.o-f_lto_pr45586-2_0.o link, -O0 -flto -flto-partition=1to1 -fno-use-linker-plugin  (internal compiler error)
+FAIL: gfortran.dg/lto/pr45586-2 f_lto_pr45586-2_0.o-f_lto_pr45586-2_0.o link, -O0 -flto -flto-partition=none -fuse-linker-plugin (internal compiler error)
+FAIL: gfortran.dg/lto/pr45586-2 f_lto_pr45586-2_0.o-f_lto_pr45586-2_0.o link, -O0 -flto -fuse-linker-plugin -fno-fat-lto-objects  (internal compiler error)
+UNRESOLVED: gfortran.dg/lto/pr45586 f_lto_pr45586_0.o-f_lto_pr45586_0.o execute -O0 -flto -flto-partition=1to1 -fno-use-linker-plugin
+UNRESOLVED: gfortran.dg/lto/pr45586 f_lto_pr45586_0.o-f_lto_pr45586_0.o execute -O0 -flto -flto-partition=none -fuse-linker-plugin
+UNRESOLVED: gfortran.dg/lto/pr45586 f_lto_pr45586_0.o-f_lto_pr45586_0.o execute -O0 -flto -fuse-linker-plugin -fno-fat-lto-objects
+UNRESOLVED: gfortran.dg/lto/pr45586-2 f_lto_pr45586-2_0.o-f_lto_pr45586-2_0.o execute -O0 -flto -flto-partition=1to1 -fno-use-linker-plugin
+UNRESOLVED: gfortran.dg/lto/pr45586-2 f_lto_pr45586-2_0.o-f_lto_pr45586-2_0.o execute -O0 -flto -flto-partition=none -fuse-linker-plugin
+UNRESOLVED: gfortran.dg/lto/pr45586-2 f_lto_pr45586-2_0.o-f_lto_pr45586-2_0.o execute -O0 -flto -fuse-linker-plugin -fno-fat-lto-objects
+XPASS: gcc.dg/inline_3.c (test for excess errors)
+XPASS: gcc.dg/inline_4.c (test for excess errors)
+XPASS: gcc.dg/unroll_2.c (test for excess errors)
+XPASS: gcc.dg/unroll_3.c (test for excess errors)
+XPASS: gcc.dg/unroll_4.c (test for excess errors)
+XPASS: gfortran.dg/do_1.f90 -O0  execution test
+XPASS: gfortran.dg/do_1.f90 -O1  execution test
+FAIL: gfortran.dg/class_optional_2.f90 -O1  execution test
+FAIL: 20_util/duration/cons/2.cc execution test
+FAIL: 29_atomics/atomic/cons/user_pod.cc (test for excess errors)
+FAIL: gcc.target/i386/memcpy-1.c scan-assembler-not test
+FAIL: 20_util/hash/chi2_quality.cc (test for excess errors)
+UNRESOLVED: 20_util/hash/chi2_quality.cc compilation failed to produce executable
+FAIL: 25_algorithms/copy_n/50119.cc (test for excess errors)
+UNRESOLVED: 25_algorithms/copy_n/50119.cc compilation failed to produce executable
+XPASS: gfortran.dg/do_1.f90 -O2  execution test
+XPASS: gfortran.dg/do_1.f90 -O3 -fomit-frame-pointer  execution test
+XPASS: gfortran.dg/do_1.f90 -O3 -fomit-frame-pointer -funroll-loops  execution test
+XPASS: gfortran.dg/do_1.f90 -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  execution test
+XPASS: gfortran.dg/do_1.f90 -O3 -g  execution test
+XPASS: gfortran.dg/do_1.f90 -Os  execution test
+FAIL: 29_atomics/atomic_flag/test_and_set/explicit-hle.cc scan-assembler-times xacquire|.byte[^\n\r]*0xf2 14
+FAIL: 29_atomics/atomic_flag/test_and_set/explicit-hle.cc scan-assembler-times xrelease|.byte[^\n\r]*0xf3 14
+
+# These failures only occur when testing is distributed.  These tests
+# have dependencies that are not explicitly handled by the driver script.
+# They assume that DejaGNU is proceeding sequentially through the whole
+# list.  See http://gcc.gnu.org/ml/fortran/2013-02/msg00106.html for
+# details.
+flaky | FAIL: gfortran.dg/binding_label_tests_11_main.f03 -O   (test for errors, line 8)
+flaky | FAIL: gfortran.dg/binding_label_tests_11_main.f03 -O   (test for errors, line 15)
+flaky | FAIL: gfortran.dg/binding_label_tests_11_main.f03 -O  (test for excess errors)
+flaky | FAIL: gfortran.dg/binding_label_tests_10_main.f03  -O   (test for errors, line 7)
+flaky | FAIL: gfortran.dg/binding_label_tests_10_main.f03  -O   (test for errors, line 11)
+flaky | FAIL: gfortran.dg/binding_label_tests_10_main.f03  -O  (test for excess errors)
+
+
+# Mudflap is completely unreliable.  It should be disabled.
+flaky|FAIL: libmudflap.c++/pass41-frag.cxx (-O2) execution test
+flaky|FAIL: libmudflap.c++/pass41-frag.cxx ( -O) execution test
+flaky|FAIL: libmudflap.c++/pass41-frag.cxx (-O3) execution test
+flaky|FAIL: libmudflap.c++/pass55-frag.cxx (-O2) execution test
+flaky|FAIL: libmudflap.c++/pass55-frag.cxx (-O3) execution test
+flaky|FAIL: libmudflap.c++/pass55-frag.cxx ( -O) execution test
+flaky|FAIL: libmudflap.c/fail37-frag.c (-O3) output pattern test
+flaky|FAIL: libmudflap.c/fail37-frag.c (-O2) crash test
+flaky|FAIL: libmudflap.c/fail37-frag.c (-O2) output pattern test
+flaky|FAIL: libmudflap.c++/pass41-frag.cxx (-static) execution test
+flaky|FAIL: libmudflap.c++/pass55-frag.cxx (-static) execution test
+flaky|FAIL: libmudflap.c/fail37-frag.c (-O3) crash test
+
+# libatomic is failing to find standard header files like stdlib.h.
+# Seems like an include path configuration issue.
+FAIL: libatomic.c/atomic-generic.c (test for excess errors)
+FAIL: libatomic.c/generic-2.c (test for excess errors)
+FAIL: libitm.c++/dropref.C (test for excess errors)
+FAIL: libitm.c++/eh-1.C (test for excess errors)
+FAIL: libitm.c++/throwdown.C (test for excess errors)
+FAIL: libitm.c/cancel.c (test for excess errors)
+FAIL: libitm.c/clone-1.c (test for excess errors)
+FAIL: libitm.c/dropref-2.c (test for excess errors)
+FAIL: libitm.c/dropref.c (test for excess errors)
+FAIL: libitm.c/memcpy-1.c (test for excess errors)
+FAIL: libitm.c/memset-1.c (test for excess errors)
+FAIL: libitm.c/notx.c (test for excess errors)
+FAIL: libitm.c/reentrant.c (test for excess errors)
+FAIL: libitm.c/simple-1.c (test for excess errors)
+FAIL: libitm.c/simple-2.c (test for excess errors)
+FAIL: libitm.c/stackundo.c (test for excess errors)
+FAIL: libitm.c/txrelease.c (test for excess errors)
+UNRESOLVED: libatomic.c/atomic-generic.c compilation failed to produce executable
+UNRESOLVED: libatomic.c/generic-2.c compilation failed to produce executable
+UNRESOLVED: libitm.c++/dropref.C compilation failed to produce executable
+UNRESOLVED: libitm.c++/eh-1.C compilation failed to produce executable
+UNRESOLVED: libitm.c/cancel.c compilation failed to produce executable
+UNRESOLVED: libitm.c/clone-1.c compilation failed to produce executable
+UNRESOLVED: libitm.c/dropref-2.c compilation failed to produce executable
+UNRESOLVED: libitm.c/dropref.c compilation failed to produce executable
+UNRESOLVED: libitm.c/memcpy-1.c compilation failed to produce executable
+UNRESOLVED: libitm.c/memset-1.c compilation failed to produce executable
+UNRESOLVED: libitm.c/notx.c compilation failed to produce executable
+UNRESOLVED: libitm.c/reentrant.c compilation failed to produce executable
+UNRESOLVED: libitm.c/simple-1.c compilation failed to produce executable
+UNRESOLVED: libitm.c/simple-2.c compilation failed to produce executable
+UNRESOLVED: libitm.c/stackundo.c compilation failed to produce executable
+UNRESOLVED: libitm.c/txrelease.c compilation failed to produce executable
+
+# These failures are likely due to misconfiguration during the
+# build.  Leaving as expected for now.
+expire=20130315 | UNRESOLVED: c-c++-common/asan/memcmp-1.c -O1  compilation failed to produce executable
+expire=20130315 | FAIL: c-c++-common/asan/memcmp-1.c -O1  (test for excess errors)
+expire=20130315 | FAIL: c-c++-common/asan/memcmp-1.c -Os  (test for excess errors)
+expire=20130315 | UNRESOLVED: c-c++-common/asan/memcmp-1.c -O0  compilation failed to produce executable
+expire=20130315 | UNRESOLVED: c-c++-common/asan/memcmp-1.c -O3 -g  compilation failed to produce executable
+expire=20130315 | UNRESOLVED: c-c++-common/asan/memcmp-1.c -O2  compilation failed to produce executable
+expire=20130315 | UNRESOLVED: c-c++-common/asan/memcmp-1.c -O3 -fomit-frame-pointer  compilation failed to produce executable
+expire=20130315 | FAIL: c-c++-common/asan/memcmp-1.c -O3 -fomit-frame-pointer  (test for excess errors)
+expire=20130315 | FAIL: c-c++-common/asan/memcmp-1.c -O2  (test for excess errors)
+expire=20130315 | FAIL: c-c++-common/asan/memcmp-1.c -O0  (test for excess errors)
+expire=20130315 | UNRESOLVED: c-c++-common/asan/memcmp-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+expire=20130315 | FAIL: c-c++-common/asan/memcmp-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+expire=20130315 | UNRESOLVED: c-c++-common/asan/memcmp-1.c -Os  compilation failed to produce executable
+expire=20130315 | FAIL: c-c++-common/asan/memcmp-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+expire=20130315 | FAIL: c-c++-common/asan/memcmp-1.c -O3 -g  (test for excess errors)
+expire=20130315 | UNRESOLVED: c-c++-common/asan/memcmp-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+expire=20130315 | UNRESOLVED: libatomic.c/atomic-generic.c compilation failed to produce executable
+expire=20130315 | FAIL: libatomic.c/atomic-generic.c (test for excess errors)
+expire=20130315 | FAIL: libatomic.c/generic-2.c (test for excess errors)
+expire=20130315 | UNRESOLVED: libatomic.c/generic-2.c compilation failed to produce executable
+expire=20130315 | UNRESOLVED: libitm.c++/dropref.C compilation failed to produce executable
+expire=20130315 | FAIL: libitm.c++/dropref.C (test for excess errors)
+expire=20130315 | FAIL: libitm.c++/throwdown.C (test for excess errors)
+expire=20130315 | FAIL: libitm.c/cancel.c (test for excess errors)
+expire=20130315 | UNRESOLVED: libitm.c/cancel.c compilation failed to produce executable
+expire=20130315 | FAIL: libitm.c/clone-1.c (test for excess errors)
+expire=20130315 | UNRESOLVED: libitm.c/clone-1.c compilation failed to produce executable
+expire=20130315 | UNRESOLVED: libitm.c/dropref-2.c compilation failed to produce executable
+expire=20130315 | FAIL: libitm.c/dropref-2.c (test for excess errors)
+expire=20130315 | FAIL: libitm.c/dropref.c (test for excess errors)
+expire=20130315 | UNRESOLVED: libitm.c/dropref.c compilation failed to produce executable
+expire=20130315 | FAIL: libitm.c/memcpy-1.c (test for excess errors)
+expire=20130315 | UNRESOLVED: libitm.c/memcpy-1.c compilation failed to produce executable
+expire=20130315 | UNRESOLVED: libitm.c/memset-1.c compilation failed to produce executable
+expire=20130315 | FAIL: libitm.c/memset-1.c (test for excess errors)
+expire=20130315 | UNRESOLVED: libitm.c/notx.c compilation failed to produce executable
+expire=20130315 | FAIL: libitm.c/notx.c (test for excess errors)
+expire=20130315 | UNRESOLVED: libitm.c/reentrant.c compilation failed to produce executable
+expire=20130315 | FAIL: libitm.c/reentrant.c (test for excess errors)
+expire=20130315 | FAIL: libitm.c/simple-1.c (test for excess errors)
+expire=20130315 | UNRESOLVED: libitm.c/simple-1.c compilation failed to produce executable
+expire=20130315 | UNRESOLVED: libitm.c/simple-2.c compilation failed to produce executable
+expire=20130315 | FAIL: libitm.c/simple-2.c (test for excess errors)
+expire=20130315 | FAIL: libitm.c/txrelease.c (test for excess errors)
+expire=20130315 | UNRESOLVED: libitm.c/txrelease.c compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/global-overflow-1.c -O2  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/global-overflow-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/global-overflow-1.c -O3 -fomit-frame-pointer  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/global-overflow-1.c -O3 -fomit-frame-pointer  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/global-overflow-1.c -O0  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/global-overflow-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/global-overflow-1.c -O1  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/global-overflow-1.c -Os  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/global-overflow-1.c -Os  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/global-overflow-1.c -O2  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/global-overflow-1.c -O3 -g  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/global-overflow-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/global-overflow-1.c -O3 -g  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/global-overflow-1.c -O1  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/global-overflow-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/global-overflow-1.c -O0  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/heap-overflow-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/heap-overflow-1.c -O3 -g  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/heap-overflow-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/heap-overflow-1.c -O1  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/heap-overflow-1.c -O0  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/heap-overflow-1.c -O3 -fomit-frame-pointer  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/heap-overflow-1.c -O3 -fomit-frame-pointer  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/heap-overflow-1.c -O2  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/heap-overflow-1.c -O0  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/heap-overflow-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/heap-overflow-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/heap-overflow-1.c -Os  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/heap-overflow-1.c -Os  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/heap-overflow-1.c -O1  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/heap-overflow-1.c -O2  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/heap-overflow-1.c -O3 -g  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/null-deref-1.c -Os  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/null-deref-1.c -O1  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/null-deref-1.c -O3 -g  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/null-deref-1.c -O2  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/null-deref-1.c -O3 -fomit-frame-pointer  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/null-deref-1.c -O3 -fomit-frame-pointer  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/null-deref-1.c -O2  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/null-deref-1.c -O0  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/null-deref-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/null-deref-1.c -Os  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/null-deref-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/null-deref-1.c -O1  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/null-deref-1.c -O0  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/null-deref-1.c -O3 -g  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/null-deref-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/null-deref-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/sanity-check-pure-c-1.c -O1  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/sanity-check-pure-c-1.c -O3 -g  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c -O2  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c -O3 -g  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c -O0  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/sanity-check-pure-c-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c -O1  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/sanity-check-pure-c-1.c -Os  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/sanity-check-pure-c-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c -Os  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/sanity-check-pure-c-1.c -O0  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c -O3 -fomit-frame-pointer  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/sanity-check-pure-c-1.c -O3 -fomit-frame-pointer  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/sanity-check-pure-c-1.c -O2  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/sleep-before-dying-1.c -O2  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/sleep-before-dying-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/sleep-before-dying-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/sleep-before-dying-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/sleep-before-dying-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/sleep-before-dying-1.c -O2  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/stack-overflow-1.c -O3 -g  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/stack-overflow-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/stack-overflow-1.c -O1  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/stack-overflow-1.c -O0  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/stack-overflow-1.c -O0  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/stack-overflow-1.c -O3 -fomit-frame-pointer  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/stack-overflow-1.c -O3 -fomit-frame-pointer  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/stack-overflow-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/stack-overflow-1.c -O2  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/stack-overflow-1.c -Os  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/stack-overflow-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/stack-overflow-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/stack-overflow-1.c -Os  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/stack-overflow-1.c -O3 -g  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/stack-overflow-1.c -O2  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/stack-overflow-1.c -O1  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/strip-path-prefix-1.c -O2  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/strip-path-prefix-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/strip-path-prefix-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/strip-path-prefix-1.c -O2  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/strip-path-prefix-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/strip-path-prefix-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c -O2  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/strncpy-overflow-1.c -Os  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c -O3 -g  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c -O1  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/strncpy-overflow-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/strncpy-overflow-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/strncpy-overflow-1.c -O3 -fomit-frame-pointer  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c -O3 -fomit-frame-pointer  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/strncpy-overflow-1.c -O0  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/strncpy-overflow-1.c -O2  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/strncpy-overflow-1.c -O1  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c -O0  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/strncpy-overflow-1.c -O3 -g  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c -Os  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/use-after-free-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/use-after-free-1.c -O3 -g  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/use-after-free-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/use-after-free-1.c -O0  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/use-after-free-1.c -O2  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/use-after-free-1.c -O3 -fomit-frame-pointer  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/use-after-free-1.c -O3 -fomit-frame-pointer  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/use-after-free-1.c -O2  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/use-after-free-1.c -O0  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/use-after-free-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/use-after-free-1.c -Os  compilation failed to produce executable
+expire=20130315 |FAIL: c-c++-common/asan/use-after-free-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/use-after-free-1.c -Os  (test for excess errors)
+expire=20130315 |FAIL: c-c++-common/asan/use-after-free-1.c -O1  (test for excess errors)
+expire=20130315 |UNRESOLVED: c-c++-common/asan/use-after-free-1.c -O3 -g  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: c-c++-common/asan/use-after-free-1.c -O1  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/deep-stack-uaf-1.C -O1  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/deep-stack-uaf-1.C -O3 -g  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/deep-stack-uaf-1.C -O1  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/deep-stack-uaf-1.C -O0  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/deep-stack-uaf-1.C -Os  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/deep-stack-uaf-1.C -O3 -g  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/deep-stack-uaf-1.C -O2  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/deep-stack-uaf-1.C -O2  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/deep-stack-uaf-1.C -O3 -fomit-frame-pointer  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/deep-stack-uaf-1.C -O3 -fomit-frame-pointer  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/deep-stack-uaf-1.C -Os  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/deep-stack-uaf-1.C -O0  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/deep-tail-call-1.C -O1  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/deep-tail-call-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/deep-tail-call-1.C -O0  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/deep-tail-call-1.C -O2  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/deep-tail-call-1.C -O1  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/deep-tail-call-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/deep-tail-call-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/deep-tail-call-1.C -O3 -g  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/deep-tail-call-1.C -O3 -g  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/deep-tail-call-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/deep-tail-call-1.C -Os  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/deep-tail-call-1.C -O3 -fomit-frame-pointer  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/deep-tail-call-1.C -O0  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/deep-tail-call-1.C -O3 -fomit-frame-pointer  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/deep-tail-call-1.C -O2  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/deep-tail-call-1.C -Os  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C -O3 -g  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/deep-thread-stack-1.C -O3 -g  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/deep-thread-stack-1.C -O1  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C -O0  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/deep-thread-stack-1.C -O0  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/deep-thread-stack-1.C -O2  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C -O3 -fomit-frame-pointer  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/deep-thread-stack-1.C -O3 -fomit-frame-pointer  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/deep-thread-stack-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C -O2  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C -O1  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/deep-thread-stack-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C -Os  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/deep-thread-stack-1.C -Os  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/default-options-1.C -O2  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/default-options-1.C -O3 -g  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/default-options-1.C -O1  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/default-options-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/default-options-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/default-options-1.C -Os  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/default-options-1.C -O3 -fomit-frame-pointer  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/default-options-1.C -O3 -fomit-frame-pointer  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/default-options-1.C -O2  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/default-options-1.C -O0  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/default-options-1.C -O0  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/default-options-1.C -O3 -g  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/default-options-1.C -O1  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/default-options-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/default-options-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/default-options-1.C -Os  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-failure-test-1.C -O3 -fomit-frame-pointer  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/interception-failure-test-1.C -Os  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-failure-test-1.C -O1  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-failure-test-1.C -O2  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-failure-test-1.C -O3 -g  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/interception-failure-test-1.C -O0  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/interception-failure-test-1.C -O2  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/interception-failure-test-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-failure-test-1.C -Os  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-failure-test-1.C -O0  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/interception-failure-test-1.C -O3 -fomit-frame-pointer  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/interception-failure-test-1.C -O1  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/interception-failure-test-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-failure-test-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-failure-test-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/interception-failure-test-1.C -O3 -g  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/interception-malloc-test-1.C -O3 -g  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/interception-malloc-test-1.C -O1  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C -O0  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/interception-malloc-test-1.C -O0  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/interception-malloc-test-1.C -O2  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C -O3 -fomit-frame-pointer  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/interception-malloc-test-1.C -O3 -fomit-frame-pointer  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/interception-malloc-test-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C -Os  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/interception-malloc-test-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C -O1  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/interception-malloc-test-1.C -Os  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C -O3 -g  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C -O2  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/interception-test-1.C -O2  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/interception-test-1.C -O3 -fomit-frame-pointer  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/interception-test-1.C -O0  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/interception-test-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-test-1.C -Os  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/interception-test-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/interception-test-1.C -Os  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-test-1.C -O1  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-test-1.C -O3 -g  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-test-1.C -O2  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-test-1.C -O3 -fomit-frame-pointer  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/interception-test-1.C -O3 -g  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-test-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-test-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/interception-test-1.C -O1  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/interception-test-1.C -O0  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/large-func-test-1.C -O1  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/large-func-test-1.C -Os  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/large-func-test-1.C -O3 -g  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/large-func-test-1.C -O2  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/large-func-test-1.C -O3 -fomit-frame-pointer  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/large-func-test-1.C -O3 -fomit-frame-pointer  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/large-func-test-1.C -O0  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/large-func-test-1.C -O2  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/large-func-test-1.C -Os  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/large-func-test-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/large-func-test-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/large-func-test-1.C -O1  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/large-func-test-1.C -O0  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/large-func-test-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+expire=20130315 |UNRESOLVED: g++.dg/asan/large-func-test-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/large-func-test-1.C -O3 -g  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/symbolize-callback-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/symbolize-callback-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+expire=20130315 |FAIL: g++.dg/asan/symbolize-callback-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/symbolize-callback-1.C -O2  compilation failed to produce executable
+expire=20130315 |FAIL: g++.dg/asan/symbolize-callback-1.C -O2  (test for excess errors)
+expire=20130315 |UNRESOLVED: g++.dg/asan/symbolize-callback-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+
+
+# GOOGLE-MAIN cleanup
+
+# ASAN specific
+FAIL: c-c++-common/asan/global-overflow-1.c  -O0  (test for excess errors)
+FAIL: c-c++-common/asan/global-overflow-1.c  -O1  (test for excess errors)
+FAIL: c-c++-common/asan/global-overflow-1.c  -O2  (test for excess errors)
+FAIL: c-c++-common/asan/global-overflow-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/global-overflow-1.c  -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/global-overflow-1.c  -Os  (test for excess errors)
+FAIL: c-c++-common/asan/global-overflow-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/global-overflow-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c  -O0  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c  -O1  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c  -O2  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c  -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c  -Os  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c  -O0  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c  -O1  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c  -O2  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c  -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c  -Os  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c  -O0  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c  -O1  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c  -O2  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c  -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c  -Os  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -O0  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -O1  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -O2  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -Os  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/sleep-before-dying-1.c  -O2  (test for excess errors)
+FAIL: c-c++-common/asan/sleep-before-dying-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/sleep-before-dying-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c  -O0  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c  -O1  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c  -O2  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c  -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c  -Os  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/strip-path-prefix-1.c  -O2  (test for excess errors)
+FAIL: c-c++-common/asan/strip-path-prefix-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/strip-path-prefix-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -O0  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -O1  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -O2  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -Os  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c  -O0  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c  -O1  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c  -O2  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c  -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c  -Os  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/global-overflow-1.c  -O0  (test for excess errors)
+FAIL: c-c++-common/asan/global-overflow-1.c  -O1  (test for excess errors)
+FAIL: c-c++-common/asan/global-overflow-1.c  -O2  (test for excess errors)
+FAIL: c-c++-common/asan/global-overflow-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/global-overflow-1.c  -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/global-overflow-1.c  -Os  (test for excess errors)
+FAIL: c-c++-common/asan/global-overflow-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/global-overflow-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c  -O0  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c  -O1  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c  -O2  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c  -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c  -Os  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c  -O0  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c  -O1  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c  -O2  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c  -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c  -Os  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c  -O0  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c  -O1  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c  -O2  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c  -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c  -Os  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -O0  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -O1  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -O2  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -Os  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/sleep-before-dying-1.c  -O2  (test for excess errors)
+FAIL: c-c++-common/asan/sleep-before-dying-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/sleep-before-dying-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c  -O0  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c  -O1  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c  -O2  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c  -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c  -Os  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/strip-path-prefix-1.c  -O2  (test for excess errors)
+FAIL: c-c++-common/asan/strip-path-prefix-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/strip-path-prefix-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -O0  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -O1  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -O2  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -Os  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c  -O0  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c  -O1  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c  -O2  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c  -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c  -Os  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: g++.dg/asan/deep-stack-uaf-1.C  -O0  (test for excess errors)
+FAIL: g++.dg/asan/deep-stack-uaf-1.C  -O1  (test for excess errors)
+FAIL: g++.dg/asan/deep-stack-uaf-1.C  -O2  (test for excess errors)
+FAIL: g++.dg/asan/deep-stack-uaf-1.C  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: g++.dg/asan/deep-stack-uaf-1.C  -O3 -g  (test for excess errors)
+FAIL: g++.dg/asan/deep-stack-uaf-1.C  -Os  (test for excess errors)
+FAIL: g++.dg/asan/deep-tail-call-1.C  -O0  (test for excess errors)
+FAIL: g++.dg/asan/deep-tail-call-1.C  -O1  (test for excess errors)
+FAIL: g++.dg/asan/deep-tail-call-1.C  -O2  (test for excess errors)
+FAIL: g++.dg/asan/deep-tail-call-1.C  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: g++.dg/asan/deep-tail-call-1.C  -O3 -g  (test for excess errors)
+FAIL: g++.dg/asan/deep-tail-call-1.C  -Os  (test for excess errors)
+FAIL: g++.dg/asan/deep-tail-call-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: g++.dg/asan/deep-tail-call-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: g++.dg/asan/deep-thread-stack-1.C  -O0  (test for excess errors)
+FAIL: g++.dg/asan/deep-thread-stack-1.C  -O1  (test for excess errors)
+FAIL: g++.dg/asan/deep-thread-stack-1.C  -O2  (test for excess errors)
+FAIL: g++.dg/asan/deep-thread-stack-1.C  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: g++.dg/asan/deep-thread-stack-1.C  -O3 -g  (test for excess errors)
+FAIL: g++.dg/asan/deep-thread-stack-1.C  -Os  (test for excess errors)
+FAIL: g++.dg/asan/deep-thread-stack-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: g++.dg/asan/deep-thread-stack-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: g++.dg/asan/default-options-1.C  -O0  (test for excess errors)
+FAIL: g++.dg/asan/default-options-1.C  -O1  (test for excess errors)
+FAIL: g++.dg/asan/default-options-1.C  -O2  (test for excess errors)
+FAIL: g++.dg/asan/default-options-1.C  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: g++.dg/asan/default-options-1.C  -O3 -g  (test for excess errors)
+FAIL: g++.dg/asan/default-options-1.C  -Os  (test for excess errors)
+FAIL: g++.dg/asan/default-options-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: g++.dg/asan/default-options-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: g++.dg/asan/interception-failure-test-1.C  -O0  (test for excess errors)
+FAIL: g++.dg/asan/interception-failure-test-1.C  -O1  (test for excess errors)
+FAIL: g++.dg/asan/interception-failure-test-1.C  -O2  (test for excess errors)
+FAIL: g++.dg/asan/interception-failure-test-1.C  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: g++.dg/asan/interception-failure-test-1.C  -O3 -g  (test for excess errors)
+FAIL: g++.dg/asan/interception-failure-test-1.C  -Os  (test for excess errors)
+FAIL: g++.dg/asan/interception-failure-test-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: g++.dg/asan/interception-failure-test-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: g++.dg/asan/interception-malloc-test-1.C  -O0  (test for excess errors)
+FAIL: g++.dg/asan/interception-malloc-test-1.C  -O1  (test for excess errors)
+FAIL: g++.dg/asan/interception-malloc-test-1.C  -O2  (test for excess errors)
+FAIL: g++.dg/asan/interception-malloc-test-1.C  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: g++.dg/asan/interception-malloc-test-1.C  -O3 -g  (test for excess errors)
+FAIL: g++.dg/asan/interception-malloc-test-1.C  -Os  (test for excess errors)
+FAIL: g++.dg/asan/interception-malloc-test-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: g++.dg/asan/interception-malloc-test-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: g++.dg/asan/interception-test-1.C  -O0  (test for excess errors)
+FAIL: g++.dg/asan/interception-test-1.C  -O1  (test for excess errors)
+FAIL: g++.dg/asan/interception-test-1.C  -O2  (test for excess errors)
+FAIL: g++.dg/asan/interception-test-1.C  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: g++.dg/asan/interception-test-1.C  -O3 -g  (test for excess errors)
+FAIL: g++.dg/asan/interception-test-1.C  -Os  (test for excess errors)
+FAIL: g++.dg/asan/interception-test-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: g++.dg/asan/interception-test-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: g++.dg/asan/large-func-test-1.C  -O0  (test for excess errors)
+FAIL: g++.dg/asan/large-func-test-1.C  -O1  (test for excess errors)
+FAIL: g++.dg/asan/large-func-test-1.C  -O2  (test for excess errors)
+FAIL: g++.dg/asan/large-func-test-1.C  -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: g++.dg/asan/large-func-test-1.C  -O3 -g  (test for excess errors)
+FAIL: g++.dg/asan/large-func-test-1.C  -Os  (test for excess errors)
+FAIL: g++.dg/asan/large-func-test-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: g++.dg/asan/large-func-test-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: g++.dg/asan/symbolize-callback-1.C  -O2  (test for excess errors)
+FAIL: g++.dg/asan/symbolize-callback-1.C  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: g++.dg/asan/symbolize-callback-1.C  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+
+# REAL bug in google/main
+FAIL: gcc.dg/wself-assign-1.c  (test for warnings, line 15)
+FAIL: gcc.dg/wself-assign-1.c  (test for warnings, line 19)
+FAIL: gcc.dg/wself-assign-1.c  (test for warnings, line 20)
+FAIL: gcc.dg/wself-assign-1.c  (test for warnings, line 21)
+FAIL: gcc.dg/wself-assign-1.c  (test for warnings, line 22)
+FAIL: g++.dg/warn/Wself-assign-2.C -std=gnu++11  (test for warnings, line 12)
+
+# REAL bug in google/main
+FAIL: gcc.dg/ipa/ipcp-agg-7.c scan-ipa-dump-times cp "Clone of foo" 1
+FAIL: gcc.dg/ipa/ipcp-agg-7.c scan-tree-dump-not optimized "->c;"
+
+
+
+# 32 bit only -- also failed in trunk
+FAIL: c-c++-common/torture/vector-compare-1.c -O2  (internal compiler error)
+FAIL: c-c++-common/torture/vector-compare-1.c -O2  (test for excess errors)
+UNRESOLVED: c-c++-common/torture/vector-compare-1.c -O2  compilation failed to produce executable
+FAIL: c-c++-common/torture/vector-compare-1.c -O3 -fomit-frame-pointer  (internal compiler error)
+FAIL: c-c++-common/torture/vector-compare-1.c -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: c-c++-common/torture/vector-compare-1.c -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: c-c++-common/torture/vector-compare-1.c -O3 -fomit-frame-pointer -funroll-loops  (internal compiler error)
+FAIL: c-c++-common/torture/vector-compare-1.c -O3 -fomit-frame-pointer -funroll-loops  (test for excess errors)
+UNRESOLVED: c-c++-common/torture/vector-compare-1.c -O3 -fomit-frame-pointer -funroll-loops  compilation failed to produce executable
+FAIL: c-c++-common/torture/vector-compare-1.c -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  (internal compiler error)
+FAIL: c-c++-common/torture/vector-compare-1.c -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  (test for excess errors)
+UNRESOLVED: c-c++-common/torture/vector-compare-1.c -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  compilation failed to produce executable
+FAIL: c-c++-common/torture/vector-compare-1.c -O3 -g  (internal compiler error)
+FAIL: c-c++-common/torture/vector-compare-1.c -O3 -g  (test for excess errors)
+UNRESOLVED: c-c++-common/torture/vector-compare-1.c -O3 -g  compilation failed to produce executable
+FAIL: c-c++-common/torture/vector-compare-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (internal compiler error)
+FAIL: c-c++-common/torture/vector-compare-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+UNRESOLVED: c-c++-common/torture/vector-compare-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+FAIL: c-c++-common/torture/vector-compare-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (internal compiler error)
+FAIL: c-c++-common/torture/vector-compare-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: c-c++-common/torture/vector-compare-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+FAIL: c-c++-common/torture/vshuf-v16qi.c -O1  (internal compiler error)
+FAIL: c-c++-common/torture/vshuf-v16qi.c -O1  (test for excess errors)
+FAIL: c-c++-common/torture/vshuf-v16qi.c -O2  (internal compiler error)
+FAIL: c-c++-common/torture/vshuf-v16qi.c -O2  (test for excess errors)
+FAIL: c-c++-common/torture/vshuf-v16qi.c -O3 -fomit-frame-pointer  (internal compiler error)
+FAIL: c-c++-common/torture/vshuf-v16qi.c -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/torture/vshuf-v16qi.c -O3 -g  (internal compiler error)
+FAIL: c-c++-common/torture/vshuf-v16qi.c -O3 -g  (test for excess errors)
+FAIL: c-c++-common/torture/vshuf-v16qi.c -Os  (internal compiler error)
+FAIL: c-c++-common/torture/vshuf-v16qi.c -Os  (test for excess errors)
+FAIL: c-c++-common/torture/vshuf-v16qi.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (internal compiler error)
+FAIL: c-c++-common/torture/vshuf-v16qi.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/torture/vshuf-v8hi.c -O1  (internal compiler error)
+FAIL: c-c++-common/torture/vshuf-v8hi.c -O1  (test for excess errors)
+FAIL: c-c++-common/torture/vshuf-v8hi.c -O2  (internal compiler error)
+FAIL: c-c++-common/torture/vshuf-v8hi.c -O2  (test for excess errors)
+FAIL: c-c++-common/torture/vshuf-v8hi.c -O3 -fomit-frame-pointer  (internal compiler error)
+FAIL: c-c++-common/torture/vshuf-v8hi.c -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/torture/vshuf-v8hi.c -O3 -g  (internal compiler error)
+FAIL: c-c++-common/torture/vshuf-v8hi.c -O3 -g  (test for excess errors)
+FAIL: c-c++-common/torture/vshuf-v8hi.c -Os  (internal compiler error)
+FAIL: c-c++-common/torture/vshuf-v8hi.c -Os  (test for excess errors)
+FAIL: c-c++-common/torture/vshuf-v8hi.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (internal compiler error)
+FAIL: c-c++-common/torture/vshuf-v8hi.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: g++.dg/torture/vshuf-v16qi.C -O1  (internal compiler error)
+FAIL: g++.dg/torture/vshuf-v16qi.C -O1  (test for excess errors)
+UNRESOLVED: g++.dg/torture/vshuf-v16qi.C -O1  compilation failed to produce executable
+FAIL: g++.dg/torture/vshuf-v16qi.C -O2  (internal compiler error)
+FAIL: g++.dg/torture/vshuf-v16qi.C -O2  (test for excess errors)
+UNRESOLVED: g++.dg/torture/vshuf-v16qi.C -O2  compilation failed to produce executable
+FAIL: g++.dg/torture/vshuf-v16qi.C -O3 -fomit-frame-pointer  (internal compiler error)
+FAIL: g++.dg/torture/vshuf-v16qi.C -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: g++.dg/torture/vshuf-v16qi.C -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: g++.dg/torture/vshuf-v16qi.C -O3 -g  (internal compiler error)
+FAIL: g++.dg/torture/vshuf-v16qi.C -O3 -g  (test for excess errors)
+UNRESOLVED: g++.dg/torture/vshuf-v16qi.C -O3 -g  compilation failed to produce executable
+FAIL: g++.dg/torture/vshuf-v16qi.C -Os  (internal compiler error)
+FAIL: g++.dg/torture/vshuf-v16qi.C -Os  (test for excess errors)
+UNRESOLVED: g++.dg/torture/vshuf-v16qi.C -Os  compilation failed to produce executable
+FAIL: g++.dg/torture/vshuf-v16qi.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  (internal compiler error)
+FAIL: g++.dg/torture/vshuf-v16qi.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+UNRESOLVED: g++.dg/torture/vshuf-v16qi.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+FAIL: g++.dg/torture/vshuf-v16qi.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (internal compiler error)
+FAIL: g++.dg/torture/vshuf-v16qi.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: g++.dg/torture/vshuf-v16qi.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+FAIL: g++.dg/torture/vshuf-v8hi.C -O1  (internal compiler error)
+FAIL: g++.dg/torture/vshuf-v8hi.C -O1  (test for excess errors)
+UNRESOLVED: g++.dg/torture/vshuf-v8hi.C -O1  compilation failed to produce executable
+FAIL: g++.dg/torture/vshuf-v8hi.C -O2  (internal compiler error)
+FAIL: g++.dg/torture/vshuf-v8hi.C -O2  (test for excess errors)
+UNRESOLVED: g++.dg/torture/vshuf-v8hi.C -O2  compilation failed to produce executable
+FAIL: g++.dg/torture/vshuf-v8hi.C -O3 -fomit-frame-pointer  (internal compiler error)
+FAIL: g++.dg/torture/vshuf-v8hi.C -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: g++.dg/torture/vshuf-v8hi.C -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: g++.dg/torture/vshuf-v8hi.C -O3 -g  (internal compiler error)
+FAIL: g++.dg/torture/vshuf-v8hi.C -O3 -g  (test for excess errors)
+UNRESOLVED: g++.dg/torture/vshuf-v8hi.C -O3 -g  compilation failed to produce executable
+FAIL: g++.dg/torture/vshuf-v8hi.C -Os  (internal compiler error)
+FAIL: g++.dg/torture/vshuf-v8hi.C -Os  (test for excess errors)
+UNRESOLVED: g++.dg/torture/vshuf-v8hi.C -Os  compilation failed to produce executable
+FAIL: g++.dg/torture/vshuf-v8hi.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  (internal compiler error)
+FAIL: g++.dg/torture/vshuf-v8hi.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+UNRESOLVED: g++.dg/torture/vshuf-v8hi.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+FAIL: g++.dg/torture/vshuf-v8hi.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (internal compiler error)
+FAIL: g++.dg/torture/vshuf-v8hi.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: g++.dg/torture/vshuf-v8hi.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+
+FAIL: gcc.c-torture/unsorted/xopt.c, -Og -g
+FAIL: gcc.c-torture/unsorted/xopt.c, -O2 -flto -fno-use-linker-plugin -flto-partition=none
+FAIL: gcc.c-torture/unsorted/xopt.c, -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects
+FAIL: gcc.c-torture/unsorted/xor.c, -O0
+FAIL: gcc.c-torture/unsorted/xor.c, -O1
+FAIL: gcc.c-torture/unsorted/xor.c, -O2
+FAIL: gcc.c-torture/unsorted/xor.c, -O3 -fomit-frame-pointer
+FAIL: gcc.c-torture/unsorted/xor.c, -O3 -g
+FAIL: gcc.c-torture/unsorted/xor.c, -Os
+FAIL: gcc.c-torture/unsorted/xor.c, -Og -g
+FAIL: gcc.c-torture/unsorted/xor.c, -O2 -flto -fno-use-linker-plugin -flto-partition=none
+FAIL: gcc.c-torture/unsorted/xor.c, -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects
+FAIL: gcc.c-torture/unsorted/xorn.c, -O0
+FAIL: gcc.c-torture/unsorted/xorn.c, -O1
+FAIL: gcc.c-torture/unsorted/xorn.c, -O2
+FAIL: gcc.c-torture/unsorted/xorn.c, -O3 -fomit-frame-pointer
+FAIL: gcc.c-torture/unsorted/xorn.c, -O3 -fomit-frame-pointer -funroll-loops
+FAIL: gcc.c-torture/unsorted/xorn.c, -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions
+FAIL: gcc.c-torture/unsorted/xorn.c, -O3 -g
+FAIL: gcc.c-torture/unsorted/xorn.c, -Os
+FAIL: gcc.c-torture/unsorted/xorn.c, -Og -g
+FAIL: gcc.c-torture/unsorted/xorn.c, -O2 -flto -fno-use-linker-plugin -flto-partition=none
+FAIL: gcc.c-torture/unsorted/xorn.c, -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects
+FAIL: gcc.c-torture/unsorted/xp.c, -O0
+FAIL: gcc.c-torture/unsorted/xp.c, -O1
+FAIL: gcc.c-torture/unsorted/xp.c, -O2
+FAIL: gcc.c-torture/unsorted/xp.c, -O3 -fomit-frame-pointer
+FAIL: gcc.c-torture/unsorted/xp.c, -O3 -g
+FAIL: gcc.c-torture/unsorted/xp.c, -Os
+FAIL: gcc.c-torture/unsorted/xp.c, -Og -g
+FAIL: gcc.c-torture/unsorted/xp.c, -O2 -flto -fno-use-linker-plugin -flto-partition=none
+FAIL: gcc.c-torture/unsorted/xp.c, -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects
+FAIL: gcc.c-torture/unsorted/xpp.c, -O0
+FAIL: gcc.c-torture/unsorted/xpp.c, -O1
+FAIL: gcc.c-torture/unsorted/xpp.c, -O2
+FAIL: gcc.c-torture/unsorted/xpp.c, -O3 -fomit-frame-pointer
+FAIL: gcc.c-torture/unsorted/xpp.c, -O3 -g
+FAIL: gcc.c-torture/unsorted/xpp.c, -Os
+FAIL: gcc.c-torture/unsorted/xpp.c, -Og -g
+FAIL: gcc.c-torture/unsorted/xpp.c, -O2 -flto -fno-use-linker-plugin -flto-partition=none
+FAIL: gcc.c-torture/unsorted/xpp.c, -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects
+FAIL: gcc.c-torture/unsorted/xs.c, -O0
+FAIL: gcc.c-torture/unsorted/xs.c, -O1
+FAIL: gcc.c-torture/unsorted/xs.c, -O2
+FAIL: gcc.c-torture/unsorted/xs.c, -O3 -fomit-frame-pointer
+FAIL: gcc.c-torture/unsorted/xs.c, -O3 -fomit-frame-pointer -funroll-loops
+FAIL: gcc.c-torture/unsorted/xs.c, -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions
+FAIL: gcc.c-torture/unsorted/xs.c, -O3 -g
+FAIL: gcc.c-torture/unsorted/xs.c, -Os
+FAIL: gcc.c-torture/unsorted/xs.c, -Og -g
+FAIL: gcc.c-torture/unsorted/xs.c, -O2 -flto -fno-use-linker-plugin -flto-partition=none
+FAIL: gcc.c-torture/unsorted/xs.c, -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects
+FAIL: gcc.c-torture/unsorted/xsh.c, -O0
+FAIL: gcc.c-torture/unsorted/xsh.c, -O1
+FAIL: gcc.c-torture/unsorted/xsh.c, -O2
+FAIL: gcc.c-torture/unsorted/xsh.c, -O3 -fomit-frame-pointer
+FAIL: gcc.c-torture/unsorted/xsh.c, -O3 -g
+FAIL: gcc.c-torture/unsorted/xsh.c, -Os
+FAIL: gcc.c-torture/unsorted/xsh.c, -Og -g
+FAIL: gcc.c-torture/unsorted/xsh.c, -O2 -flto -fno-use-linker-plugin -flto-partition=none
+FAIL: gcc.c-torture/unsorted/xsh.c, -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects
+FAIL: gcc.c-torture/unsorted/xz.c, -O0
+FAIL: gcc.c-torture/unsorted/xz.c, -O1
+FAIL: gcc.c-torture/unsorted/xz.c, -O2
+FAIL: gcc.c-torture/unsorted/xz.c, -O3 -fomit-frame-pointer
+FAIL: gcc.c-torture/unsorted/xz.c, -O3 -g
+FAIL: gcc.c-torture/unsorted/xz.c, -Os
+FAIL: gcc.c-torture/unsorted/xz.c, -Og -g
+FAIL: gcc.c-torture/unsorted/xz.c, -O2 -flto -fno-use-linker-plugin -flto-partition=none
+FAIL: gcc.c-torture/unsorted/xz.c, -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects
+FAIL: gcc.c-torture/unsorted/xzz.c, -O0
+FAIL: gcc.c-torture/unsorted/xzz.c, -O1
+FAIL: gcc.c-torture/unsorted/xzz.c, -O2
+FAIL: gcc.c-torture/unsorted/xzz.c, -O3 -fomit-frame-pointer
+FAIL: gcc.c-torture/unsorted/xzz.c, -O3 -g
+FAIL: gcc.c-torture/unsorted/xzz.c, -Os
+FAIL: gcc.c-torture/unsorted/xzz.c, -Og -g
+FAIL: gcc.c-torture/unsorted/xzz.c, -O2 -flto -fno-use-linker-plugin -flto-partition=none
+FAIL: gcc.c-torture/unsorted/xzz.c, -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects
+FAIL: gcc.dg/torture/builtin-convert-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: gcc.dg/torture/builtin-convert-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: gcc.dg/torture/builtin-convert-2.c -O0  (test for excess errors)
+FAIL: gcc.dg/torture/builtin-convert-2.c -O1  (test for excess errors)
+FAIL: gcc.dg/torture/builtin-convert-2.c -O2  (test for excess errors)
+FAIL: gcc.dg/torture/builtin-convert-2.c -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: gcc.dg/torture/builtin-ctype-1.c -O3 -g  (test for excess errors)
+FAIL: gcc.dg/torture/builtin-ctype-1.c -Os  (test for excess errors)
+FAIL: gcc.dg/torture/builtin-ctype-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: gcc.dg/torture/builtin-ctype-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: gcc.dg/torture/stackalign/nested-3.c -O0 -mforce-drap (test for excess errors)
+UNRESOLVED: gcc.dg/torture/stackalign/nested-3.c -O0 -mforce-drap compilation failed to produce executable
+FAIL: gcc.dg/torture/stackalign/nested-3.c -O0 -mforce-drap -fpic (test for excess errors)
+UNRESOLVED: gcc.dg/torture/stackalign/nested-3.c -O0 -mforce-drap -fpic compilation failed to produce executable
+FAIL: gcc.dg/torture/stackalign/nested-3.c -O1  (test for excess errors)
+UNRESOLVED: gcc.dg/torture/stackalign/nested-3.c -O1  compilation failed to produce executable
+FAIL: gcc.dg/torture/stackalign/nested-3.c -O1 -fpic (test for excess errors)
+UNRESOLVED: gcc.dg/torture/stackalign/nested-3.c -O1 -fpic compilation failed to produce executable
+FAIL: gcc.dg/torture/stackalign/nested-3.c -O1 -mforce-drap (test for excess errors)
+UNRESOLVED: gcc.dg/torture/stackalign/nested-3.c -O1 -mforce-drap compilation failed to produce executable
+FAIL: gcc.dg/torture/stackalign/nested-3.c -O1 -mforce-drap -fpic (test for excess errors)
+UNRESOLVED: gcc.dg/torture/stackalign/nested-3.c -O1 -mforce-drap -fpic compilation failed to produce executable
+FAIL: gcc.dg/torture/stackalign/nested-3.c -O2  (test for excess errors)
+UNRESOLVED: gcc.dg/torture/stackalign/nested-3.c -O2  compilation failed to produce executable
+FAIL: gcc.dg/torture/stackalign/nested-4.c -O1 -fpic (test for excess errors)
+UNRESOLVED: gcc.dg/torture/stackalign/nested-4.c -O1 -fpic compilation failed to produce executable
+FAIL: gcc.dg/torture/stackalign/nested-4.c -O1 -mforce-drap (test for excess errors)
+UNRESOLVED: gcc.dg/torture/stackalign/nested-4.c -O1 -mforce-drap compilation failed to produce executable
+FAIL: gcc.dg/torture/stackalign/nested-4.c -O1 -mforce-drap -fpic (test for excess errors)
+UNRESOLVED: gcc.dg/torture/stackalign/nested-4.c -O1 -mforce-drap -fpic compilation failed to produce executable
+FAIL: gcc.dg/torture/stackalign/nested-4.c -O2  (test for excess errors)
+UNRESOLVED: gcc.dg/torture/stackalign/nested-4.c -O2  compilation failed to produce executable
+FAIL: gcc.dg/torture/stackalign/nested-4.c -O2 -fpic (test for excess errors)
+UNRESOLVED: gcc.dg/torture/stackalign/nested-4.c -O2 -fpic compilation failed to produce executable
+FAIL: gcc.dg/torture/stackalign/nested-4.c -O2 -mforce-drap (test for excess errors)
+UNRESOLVED: gcc.dg/torture/stackalign/nested-4.c -O2 -mforce-drap compilation failed to produce executable
+FAIL: gcc.dg/torture/stackalign/nested-4.c -O2 -mforce-drap -fpic (test for excess errors)
+UNRESOLVED: gcc.dg/torture/stackalign/nested-4.c -O2 -mforce-drap -fpic compilation failed to produce executable
+FAIL: gcc.dg/torture/stackalign/nested-5.c -O3 -g -mforce-drap -fpic (test for excess errors)
+UNRESOLVED: gcc.dg/torture/stackalign/nested-5.c -O3 -g -mforce-drap -fpic compilation failed to produce executable
+FAIL: gcc.dg/torture/stackalign/nested-5.c -Os  (test for excess errors)
+UNRESOLVED: gcc.dg/torture/stackalign/nested-5.c -Os  compilation failed to produce executable
+FAIL: gcc.dg/torture/stackalign/nested-5.c -Os -fpic (test for excess errors)
+UNRESOLVED: gcc.dg/torture/stackalign/nested-5.c -Os -fpic compilation failed to produce executable
+FAIL: gcc.dg/torture/stackalign/nested-5.c -Os -mforce-drap (test for excess errors)
+UNRESOLVED: gcc.dg/torture/stackalign/nested-5.c -Os -mforce-drap compilation failed to produce executable
+UNRESOLVED: gcc.dg/torture/vshuf-v8hi.c -O2  compilation failed to produce executable
+FAIL: gcc.dg/vect/pr18400.c (test for excess errors)
+UNRESOLVED: gcc.dg/vect/pr18400.c compilation failed to produce executable
+FAIL: gcc.dg/vect/pr18425.c (test for excess errors)
+UNRESOLVED: gcc.dg/vect/pr18425.c scan-tree-dump-times vect "vectorized 1 loops" 1
+FAIL: gcc.dg/vect/pr18536.c (test for excess errors)
+UNRESOLVED: gcc.dg/vect/pr18536.c compilation failed to produce executable
+UNRESOLVED: gcc.dg/vect/pr18536.c scan-tree-dump-times vect "vectorized 1 loops" 1
+FAIL: gcc.dg/vect/pr20122.c (test for excess errors)
+UNRESOLVED: gcc.dg/vect/pr20122.c compilation failed to produce executable
+UNRESOLVED: gcc.dg/vect/pr20122.c scan-tree-dump-times vect "vectorized 1 loops" 3
+
+# also failed in trunk
+
+FAIL: gcc.c-torture/execute/scal-to-vec2.c compilation,  -O1  (internal compiler error)
+UNRESOLVED: gcc.c-torture/execute/scal-to-vec2.c execution,  -O1
+FAIL: gcc.c-torture/execute/scal-to-vec2.c compilation,  -O2  (internal compiler error)
+UNRESOLVED: gcc.c-torture/execute/scal-to-vec2.c execution,  -O2
+FAIL: gcc.c-torture/execute/scal-to-vec2.c compilation,  -O3 -fomit-frame-pointer  (internal compiler error)
+UNRESOLVED: gcc.c-torture/execute/scal-to-vec2.c execution,  -O3 -fomit-frame-pointer
+FAIL: gcc.c-torture/execute/scal-to-vec2.c compilation,  -O3 -fomit-frame-pointer -funroll-loops  (internal compiler error)
+UNRESOLVED: gcc.c-torture/execute/scal-to-vec2.c execution,  -O3 -fomit-frame-pointer -funroll-loops
+FAIL: gcc.c-torture/execute/scal-to-vec2.c compilation,  -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  (internal compiler error)
+UNRESOLVED: gcc.c-torture/execute/scal-to-vec2.c execution,  -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions
+FAIL: gcc.c-torture/execute/scal-to-vec2.c compilation,  -O3 -g  (internal compiler error)
+UNRESOLVED: gcc.c-torture/execute/scal-to-vec2.c execution,  -O3 -g
+FAIL: gcc.c-torture/execute/scal-to-vec2.c compilation,  -Og -g  (internal compiler error)
+UNRESOLVED: gcc.c-torture/execute/scal-to-vec2.c execution,  -Og -g
+FAIL: gcc.c-torture/execute/scal-to-vec2.c compilation,  -O2 -flto -fno-use-linker-plugin -flto-partition=none  (internal compiler error)
+UNRESOLVED: gcc.c-torture/execute/scal-to-vec2.c execution,  -O2 -flto -fno-use-linker-plugin -flto-partition=none
+FAIL: gcc.c-torture/execute/scal-to-vec2.c compilation,  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (internal compiler error)
+UNRESOLVED: gcc.c-torture/execute/scal-to-vec2.c execution,  -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects
+FAIL: gcc.dg/torture/pr53390.c -O3 -fomit-frame-pointer  (internal compiler error)
+FAIL: gcc.dg/torture/pr53390.c -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: gcc.dg/torture/pr53390.c -O3 -fomit-frame-pointer -funroll-loops  (internal compiler error)
+FAIL: gcc.dg/torture/pr53390.c -O3 -fomit-frame-pointer -funroll-loops  (test for excess errors)
+FAIL: gcc.dg/torture/pr53390.c -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  (internal compiler error)
+FAIL: gcc.dg/torture/pr53390.c -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  (test for excess errors)
+FAIL: gcc.dg/torture/pr53390.c -O3 -g  (internal compiler error)
+FAIL: gcc.dg/torture/pr53390.c -O3 -g  (test for excess errors)
+FAIL: gcc.dg/torture/vshuf-v16qi.c -O2  (internal compiler error)
+FAIL: gcc.dg/torture/vshuf-v16qi.c -O2  (test for excess errors)
+UNRESOLVED: gcc.dg/torture/vshuf-v16qi.c -O2  compilation failed to produce executable
+FAIL: gcc.dg/torture/vshuf-v8hi.c -O2  (internal compiler error)
+FAIL: gcc.dg/torture/vshuf-v8hi.c -O2  (test for excess errors)
+
+XPASS: gfortran.dg/do_1.f90  -O0  execution test
+XPASS: gfortran.dg/do_1.f90  -O1  execution test
+
+FAIL: c-c++-common/asan/global-overflow-1.c -O0  (test for excess errors)
+FAIL: c-c++-common/asan/global-overflow-1.c -O1  (test for excess errors)
+FAIL: c-c++-common/asan/global-overflow-1.c -O2  (test for excess errors)
+FAIL: c-c++-common/asan/global-overflow-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/global-overflow-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/global-overflow-1.c -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/global-overflow-1.c -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/global-overflow-1.c -Os  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c -O0  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c -O1  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c -O2  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/heap-overflow-1.c -Os  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c -O0  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c -O1  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c -O2  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/memcmp-1.c -Os  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c -O0  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c -O1  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c -O2  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/null-deref-1.c -Os  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c -O0  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c -O1  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c -O2  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/sanity-check-pure-c-1.c -Os  (test for excess errors)
+FAIL: c-c++-common/asan/sleep-before-dying-1.c -O2  (test for excess errors)
+FAIL: c-c++-common/asan/sleep-before-dying-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/sleep-before-dying-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c -O0  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c -O1  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c -O2  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/stack-overflow-1.c -Os  (test for excess errors)
+FAIL: c-c++-common/asan/strip-path-prefix-1.c -O2  (test for excess errors)
+FAIL: c-c++-common/asan/strip-path-prefix-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/strip-path-prefix-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c -O0  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c -O1  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c -O2  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/strncpy-overflow-1.c -Os  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c -O0  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c -O1  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c -O2  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c -O3 -g  (test for excess errors)
+FAIL: c-c++-common/asan/use-after-free-1.c -Os  (test for excess errors)
+FAIL: g++.dg/asan/deep-stack-uaf-1.C -O0  (test for excess errors)
+FAIL: g++.dg/asan/deep-stack-uaf-1.C -O1  (test for excess errors)
+FAIL: g++.dg/asan/deep-stack-uaf-1.C -O2  (test for excess errors)
+FAIL: g++.dg/asan/deep-stack-uaf-1.C -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: g++.dg/asan/deep-stack-uaf-1.C -O3 -g  (test for excess errors)
+FAIL: g++.dg/asan/deep-stack-uaf-1.C -Os  (test for excess errors)
+FAIL: g++.dg/asan/deep-tail-call-1.C -O0  (test for excess errors)
+FAIL: g++.dg/asan/deep-tail-call-1.C -O1  (test for excess errors)
+FAIL: g++.dg/asan/deep-tail-call-1.C -O2  (test for excess errors)
+FAIL: g++.dg/asan/deep-tail-call-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: g++.dg/asan/deep-tail-call-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: g++.dg/asan/deep-tail-call-1.C -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: g++.dg/asan/deep-tail-call-1.C -O3 -g  (test for excess errors)
+FAIL: g++.dg/asan/deep-tail-call-1.C -Os  (test for excess errors)
+FAIL: g++.dg/asan/deep-thread-stack-1.C -O0  (test for excess errors)
+FAIL: g++.dg/asan/deep-thread-stack-1.C -O1  (test for excess errors)
+FAIL: g++.dg/asan/deep-thread-stack-1.C -O2  (test for excess errors)
+FAIL: g++.dg/asan/deep-thread-stack-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: g++.dg/asan/deep-thread-stack-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: g++.dg/asan/deep-thread-stack-1.C -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: g++.dg/asan/deep-thread-stack-1.C -O3 -g  (test for excess errors)
+FAIL: g++.dg/asan/deep-thread-stack-1.C -Os  (test for excess errors)
+FAIL: g++.dg/asan/default-options-1.C -O0  (test for excess errors)
+FAIL: g++.dg/asan/default-options-1.C -O1  (test for excess errors)
+FAIL: g++.dg/asan/default-options-1.C -O2  (test for excess errors)
+FAIL: g++.dg/asan/default-options-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: g++.dg/asan/default-options-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: g++.dg/asan/default-options-1.C -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: g++.dg/asan/default-options-1.C -O3 -g  (test for excess errors)
+FAIL: g++.dg/asan/default-options-1.C -Os  (test for excess errors)
+FAIL: g++.dg/asan/interception-failure-test-1.C -O0  (test for excess errors)
+FAIL: g++.dg/asan/interception-failure-test-1.C -O1  (test for excess errors)
+FAIL: g++.dg/asan/interception-failure-test-1.C -O2  (test for excess errors)
+FAIL: g++.dg/asan/interception-failure-test-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: g++.dg/asan/interception-failure-test-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: g++.dg/asan/interception-failure-test-1.C -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: g++.dg/asan/interception-failure-test-1.C -O3 -g  (test for excess errors)
+FAIL: g++.dg/asan/interception-failure-test-1.C -Os  (test for excess errors)
+FAIL: g++.dg/asan/interception-malloc-test-1.C -O0  (test for excess errors)
+FAIL: g++.dg/asan/interception-malloc-test-1.C -O1  (test for excess errors)
+FAIL: g++.dg/asan/interception-malloc-test-1.C -O2  (test for excess errors)
+FAIL: g++.dg/asan/interception-malloc-test-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: g++.dg/asan/interception-malloc-test-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: g++.dg/asan/interception-malloc-test-1.C -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: g++.dg/asan/interception-malloc-test-1.C -O3 -g  (test for excess errors)
+FAIL: g++.dg/asan/interception-malloc-test-1.C -Os  (test for excess errors)
+FAIL: g++.dg/asan/interception-test-1.C -O0  (test for excess errors)
+FAIL: g++.dg/asan/interception-test-1.C -O1  (test for excess errors)
+FAIL: g++.dg/asan/interception-test-1.C -O2  (test for excess errors)
+FAIL: g++.dg/asan/interception-test-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: g++.dg/asan/interception-test-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: g++.dg/asan/interception-test-1.C -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: g++.dg/asan/interception-test-1.C -O3 -g  (test for excess errors)
+FAIL: g++.dg/asan/interception-test-1.C -Os  (test for excess errors)
+FAIL: g++.dg/asan/large-func-test-1.C -O0  (test for excess errors)
+FAIL: g++.dg/asan/large-func-test-1.C -O1  (test for excess errors)
+FAIL: g++.dg/asan/large-func-test-1.C -O2  (test for excess errors)
+FAIL: g++.dg/asan/large-func-test-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: g++.dg/asan/large-func-test-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+FAIL: g++.dg/asan/large-func-test-1.C -O3 -fomit-frame-pointer  (test for excess errors)
+FAIL: g++.dg/asan/large-func-test-1.C -O3 -g  (test for excess errors)
+FAIL: g++.dg/asan/large-func-test-1.C -Os  (test for excess errors)
+FAIL: g++.dg/asan/symbolize-callback-1.C -O2  (test for excess errors)
+FAIL: g++.dg/asan/symbolize-callback-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+FAIL: g++.dg/asan/symbolize-callback-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: c-c++-common/asan/global-overflow-1.c -O0  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/global-overflow-1.c -O1  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/global-overflow-1.c -O2  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/global-overflow-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/global-overflow-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/global-overflow-1.c -O3 -fomit-frame-pointer  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/global-overflow-1.c -O3 -g  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/global-overflow-1.c -Os  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/heap-overflow-1.c -O0  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/heap-overflow-1.c -O1  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/heap-overflow-1.c -O2  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/heap-overflow-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/heap-overflow-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/heap-overflow-1.c -O3 -fomit-frame-pointer  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/heap-overflow-1.c -O3 -g  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/heap-overflow-1.c -Os  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/memcmp-1.c -O0  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/memcmp-1.c -O1  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/memcmp-1.c -O2  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/memcmp-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/memcmp-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/memcmp-1.c -O3 -fomit-frame-pointer  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/memcmp-1.c -O3 -g  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/memcmp-1.c -Os  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/null-deref-1.c -O0  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/null-deref-1.c -O1  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/null-deref-1.c -O2  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/null-deref-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/null-deref-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/null-deref-1.c -O3 -fomit-frame-pointer  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/null-deref-1.c -O3 -g  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/null-deref-1.c -Os  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c -O0  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c -O1  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c -O2  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c -O3 -fomit-frame-pointer  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c -O3 -g  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/sanity-check-pure-c-1.c -Os  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/sleep-before-dying-1.c -O2  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/sleep-before-dying-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/sleep-before-dying-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/stack-overflow-1.c -O0  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/stack-overflow-1.c -O1  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/stack-overflow-1.c -O2  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/stack-overflow-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/stack-overflow-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/stack-overflow-1.c -O3 -fomit-frame-pointer  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/stack-overflow-1.c -O3 -g  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/stack-overflow-1.c -Os  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/strip-path-prefix-1.c -O2  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/strip-path-prefix-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/strip-path-prefix-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c -O0  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c -O1  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c -O2  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c -O3 -fomit-frame-pointer  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c -O3 -g  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/strncpy-overflow-1.c -Os  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/use-after-free-1.c -O0  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/use-after-free-1.c -O1  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/use-after-free-1.c -O2  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/use-after-free-1.c -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/use-after-free-1.c -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/use-after-free-1.c -O3 -fomit-frame-pointer  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/use-after-free-1.c -O3 -g  compilation failed to produce executable
+UNRESOLVED: c-c++-common/asan/use-after-free-1.c -Os  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/deep-stack-uaf-1.C -O0  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/deep-stack-uaf-1.C -O1  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/deep-stack-uaf-1.C -O2  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/deep-stack-uaf-1.C -O3 -fomit-frame-pointer  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/deep-stack-uaf-1.C -O3 -g  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/deep-stack-uaf-1.C -Os  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/deep-tail-call-1.C -O0  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/deep-tail-call-1.C -O1  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/deep-tail-call-1.C -O2  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/deep-tail-call-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/deep-tail-call-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/deep-tail-call-1.C -O3 -fomit-frame-pointer  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/deep-tail-call-1.C -O3 -g  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/deep-tail-call-1.C -Os  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C -O0  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C -O1  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C -O2  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C -O3 -fomit-frame-pointer  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C -O3 -g  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/deep-thread-stack-1.C -Os  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/default-options-1.C -O0  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/default-options-1.C -O1  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/default-options-1.C -O2  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/default-options-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/default-options-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/default-options-1.C -O3 -fomit-frame-pointer  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/default-options-1.C -O3 -g  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/default-options-1.C -Os  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-failure-test-1.C -O0  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-failure-test-1.C -O1  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-failure-test-1.C -O2  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-failure-test-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-failure-test-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-failure-test-1.C -O3 -fomit-frame-pointer  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-failure-test-1.C -O3 -g  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-failure-test-1.C -Os  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C -O0  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C -O1  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C -O2  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C -O3 -fomit-frame-pointer  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C -O3 -g  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-malloc-test-1.C -Os  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-test-1.C -O0  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-test-1.C -O1  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-test-1.C -O2  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-test-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-test-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-test-1.C -O3 -fomit-frame-pointer  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-test-1.C -O3 -g  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/interception-test-1.C -Os  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/large-func-test-1.C -O0  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/large-func-test-1.C -O1  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/large-func-test-1.C -O2  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/large-func-test-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/large-func-test-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/large-func-test-1.C -O3 -fomit-frame-pointer  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/large-func-test-1.C -O3 -g  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/large-func-test-1.C -Os  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/symbolize-callback-1.C -O2  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/symbolize-callback-1.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+UNRESOLVED: g++.dg/asan/symbolize-callback-1.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+
+
+# All of these failures are due to a Fortran FE bug.
+# http://gcc.gnu.org/bugzilla/show_bug.cgi?id=56224
+FAIL: libgomp.fortran/appendix-a/a.18.1.f90 -O0  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.18.1.f90 -O0  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.18.1.f90 -O1  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.18.1.f90 -O1  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.18.1.f90 -O2  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.18.1.f90 -O2  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.18.1.f90 -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.18.1.f90 -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.18.1.f90 -O3 -fomit-frame-pointer -funroll-loops  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.18.1.f90 -O3 -fomit-frame-pointer -funroll-loops  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.18.1.f90 -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.18.1.f90 -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.18.1.f90 -O3 -g  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.18.1.f90 -O3 -g  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.18.1.f90 -Os  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.18.1.f90 -Os  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.2.1.f90 -O0  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.2.1.f90 -O0  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.2.1.f90 -O1  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.2.1.f90 -O1  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.2.1.f90 -O2  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.2.1.f90 -O2  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.2.1.f90 -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.2.1.f90 -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.2.1.f90 -O3 -fomit-frame-pointer -funroll-loops  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.2.1.f90 -O3 -fomit-frame-pointer -funroll-loops  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.2.1.f90 -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.2.1.f90 -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.2.1.f90 -O3 -g  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.2.1.f90 -O3 -g  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.2.1.f90 -Os  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.2.1.f90 -Os  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.39.1.f90 -O0  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.39.1.f90 -O0  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.39.1.f90 -O1  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.39.1.f90 -O1  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.39.1.f90 -O2  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.39.1.f90 -O2  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.39.1.f90 -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.39.1.f90 -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.39.1.f90 -O3 -fomit-frame-pointer -funroll-loops  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.39.1.f90 -O3 -fomit-frame-pointer -funroll-loops  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.39.1.f90 -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.39.1.f90 -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.39.1.f90 -O3 -g  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.39.1.f90 -O3 -g  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.39.1.f90 -Os  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.39.1.f90 -Os  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.4.1.f90 -O0  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.4.1.f90 -O0  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.4.1.f90 -O1  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.4.1.f90 -O1  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.4.1.f90 -O2  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.4.1.f90 -O2  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.4.1.f90 -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.4.1.f90 -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.4.1.f90 -O3 -fomit-frame-pointer -funroll-loops  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.4.1.f90 -O3 -fomit-frame-pointer -funroll-loops  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.4.1.f90 -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.4.1.f90 -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.4.1.f90 -O3 -g  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.4.1.f90 -O3 -g  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.4.1.f90 -Os  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.4.1.f90 -Os  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.5.1.f90 -O0  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.5.1.f90 -O0  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.5.1.f90 -O1  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.5.1.f90 -O1  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.5.1.f90 -O2  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.5.1.f90 -O2  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.5.1.f90 -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.5.1.f90 -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.5.1.f90 -O3 -fomit-frame-pointer -funroll-loops  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.5.1.f90 -O3 -fomit-frame-pointer -funroll-loops  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.5.1.f90 -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.5.1.f90 -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.5.1.f90 -O3 -g  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.5.1.f90 -O3 -g  compilation failed to produce executable
+FAIL: libgomp.fortran/appendix-a/a.5.1.f90 -Os  (test for excess errors)
+UNRESOLVED: libgomp.fortran/appendix-a/a.5.1.f90 -Os  compilation failed to produce executable
+FAIL: libgomp.fortran/jacobi.f -O0  (test for excess errors)
+UNRESOLVED: libgomp.fortran/jacobi.f -O0  compilation failed to produce executable
+FAIL: libgomp.fortran/jacobi.f -O1  (test for excess errors)
+UNRESOLVED: libgomp.fortran/jacobi.f -O1  compilation failed to produce executable
+FAIL: libgomp.fortran/jacobi.f -O2  (test for excess errors)
+UNRESOLVED: libgomp.fortran/jacobi.f -O2  compilation failed to produce executable
+FAIL: libgomp.fortran/jacobi.f -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: libgomp.fortran/jacobi.f -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: libgomp.fortran/jacobi.f -O3 -fomit-frame-pointer -funroll-loops  (test for excess errors)
+UNRESOLVED: libgomp.fortran/jacobi.f -O3 -fomit-frame-pointer -funroll-loops  compilation failed to produce executable
+FAIL: libgomp.fortran/jacobi.f -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  (test for excess errors)
+UNRESOLVED: libgomp.fortran/jacobi.f -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  compilation failed to produce executable
+FAIL: libgomp.fortran/jacobi.f -O3 -g  (test for excess errors)
+UNRESOLVED: libgomp.fortran/jacobi.f -O3 -g  compilation failed to produce executable
+FAIL: libgomp.fortran/jacobi.f -Os  (test for excess errors)
+UNRESOLVED: libgomp.fortran/jacobi.f -Os  compilation failed to produce executable
+FAIL: libgomp.fortran/lib3.f -O0  (test for excess errors)
+UNRESOLVED: libgomp.fortran/lib3.f -O0  compilation failed to produce executable
+FAIL: libgomp.fortran/lib3.f -O1  (test for excess errors)
+UNRESOLVED: libgomp.fortran/lib3.f -O1  compilation failed to produce executable
+FAIL: libgomp.fortran/lib3.f -O2  (test for excess errors)
+UNRESOLVED: libgomp.fortran/lib3.f -O2  compilation failed to produce executable
+FAIL: libgomp.fortran/lib3.f -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: libgomp.fortran/lib3.f -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: libgomp.fortran/lib3.f -O3 -fomit-frame-pointer -funroll-loops  (test for excess errors)
+UNRESOLVED: libgomp.fortran/lib3.f -O3 -fomit-frame-pointer -funroll-loops  compilation failed to produce executable
+FAIL: libgomp.fortran/lib3.f -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  (test for excess errors)
+UNRESOLVED: libgomp.fortran/lib3.f -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  compilation failed to produce executable
+FAIL: libgomp.fortran/lib3.f -O3 -g  (test for excess errors)
+UNRESOLVED: libgomp.fortran/lib3.f -O3 -g  compilation failed to produce executable
+FAIL: libgomp.fortran/lib3.f -Os  (test for excess errors)
+UNRESOLVED: libgomp.fortran/lib3.f -Os  compilation failed to produce executable
+
+FAIL: g++.dg/asan/pr55617.C -O0  (test for excess errors)
+UNRESOLVED: g++.dg/asan/pr55617.C -O0  compilation failed to produce executable
+FAIL: g++.dg/asan/pr55617.C -O1  (test for excess errors)
+UNRESOLVED: g++.dg/asan/pr55617.C -O1  compilation failed to produce executable
+FAIL: g++.dg/asan/pr55617.C -O2  (test for excess errors)
+UNRESOLVED: g++.dg/asan/pr55617.C -O2  compilation failed to produce executable
+FAIL: g++.dg/asan/pr55617.C -O3 -fomit-frame-pointer  (test for excess errors)
+UNRESOLVED: g++.dg/asan/pr55617.C -O3 -fomit-frame-pointer  compilation failed to produce executable
+FAIL: g++.dg/asan/pr55617.C -O3 -g  (test for excess errors)
+UNRESOLVED: g++.dg/asan/pr55617.C -O3 -g  compilation failed to produce executable
+FAIL: g++.dg/asan/pr55617.C -Os  (test for excess errors)
+UNRESOLVED: g++.dg/asan/pr55617.C -Os  compilation failed to produce executable
+FAIL: g++.dg/asan/pr55617.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  (test for excess errors)
+UNRESOLVED: g++.dg/asan/pr55617.C -O2 -flto -fno-use-linker-plugin -flto-partition=none  compilation failed to produce executable
+FAIL: g++.dg/asan/pr55617.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  (test for excess errors)
+UNRESOLVED: g++.dg/asan/pr55617.C -O2 -flto -fuse-linker-plugin -fno-fat-lto-objects  compilation failed to produce executable
+FAIL: g++.dg/ipa/devirt-11.C -std=gnu++98  scan-ipa-dump-times inline "and turned into root of the clone tree" 1
+FAIL: g++.dg/ipa/devirt-11.C -std=gnu++11  scan-ipa-dump-times inline "and turned into root of the clone tree" 1
+
+# Inline failures not seen outside of google/main.
+# These fail with excess errors:
+# gcc.dg/inline_3.c:4:37: warning: always_inline function might not be inlinable [-Wattributes]
+FAIL: gcc.dg/inline_3.c (test for excess errors)
+FAIL: gcc.dg/inline_4.c (test for excess errors)
diff --git a/contrib/testsuite-management/x86_64-unknown-linux-gnu.xfail b/contrib/testsuite-management/x86_64-unknown-linux-gnu.xfail
index 4446061..8ef5680 100644
--- a/contrib/testsuite-management/x86_64-unknown-linux-gnu.xfail
+++ b/contrib/testsuite-management/x86_64-unknown-linux-gnu.xfail
@@ -1,135 +1,44 @@
-FAIL: g++.dg/other/anon5.C -std=gnu++98 (test for excess errors)
-FAIL: g++.dg/other/anon5.C -std=gnu++11 (test for excess errors)
-FAIL: gcc.c-torture/compile/pr44119.c -Os  (test for excess errors)
-FAIL: gcc.c-torture/compile/pr44119.c -O3 -fomit-frame-pointer  (internal compiler error)
-FAIL: gcc.c-torture/compile/pr44119.c -O3 -fomit-frame-pointer -funroll-loops  (test for excess errors)
-FAIL: gcc.c-torture/compile/pr44119.c -O2 -flto -flto-partition=none  (internal compiler error)
-FAIL: gcc.c-torture/compile/pr44119.c -O2 -flto -flto-partition=none  (test for excess errors)
-FAIL: gcc.c-torture/compile/pr44119.c -O2  (test for excess errors)
-FAIL: gcc.c-torture/compile/pr44119.c -O2 -flto  (internal compiler error)
-FAIL: gcc.c-torture/compile/pr44119.c -O3 -g  (internal compiler error)
-FAIL: gcc.c-torture/compile/pr44119.c -O2 -flto  (test for excess errors)
-FAIL: gcc.c-torture/compile/pr44119.c -O1  (test for excess errors)
-FAIL: gcc.c-torture/compile/pr44119.c -O3 -fomit-frame-pointer  (test for excess errors)
-FAIL: gcc.c-torture/compile/pr44119.c -O3 -g  (test for excess errors)
-FAIL: gcc.c-torture/compile/pr44119.c -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  (test for excess errors)
-FAIL: gcc.c-torture/compile/pr44119.c -O2  (internal compiler error)
-FAIL: gcc.c-torture/compile/pr44119.c -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  (internal compiler error)
-FAIL: gcc.c-torture/compile/pr44119.c -Os  (internal compiler error)
-FAIL: gcc.c-torture/compile/pr44119.c -O1  (internal compiler error)
-FAIL: gcc.c-torture/compile/pr44119.c -O3 -fomit-frame-pointer -funroll-loops  (internal compiler error)
-UNRESOLVED: gcc.dg/attr-weakref-1.c compilation failed to produce executable
-FAIL: gcc.dg/attr-weakref-1.c (test for excess errors)
-FAIL: gcc.dg/autopar/pr49960.c scan-tree-dump-times optimized "loopfn" 0
-FAIL: gcc.dg/autopar/pr49960.c scan-tree-dump-times parloops "SUCCESS: may be parallelized" 0
-FAIL: gcc.dg/builtin-object-size-8.c execution test
-FAIL: gcc.dg/cproj-fails-with-broken-glibc.c execution test
-XPASS: gcc.dg/guality/example.c -O2  execution test
-XPASS: gcc.dg/guality/example.c -O2 -flto  execution test
-XPASS: gcc.dg/guality/example.c -O0  execution test
-XPASS: gcc.dg/guality/example.c -O2 -flto -flto-partition=none  execution test
-XPASS: gcc.dg/guality/guality.c -O2 -flto -flto-partition=none  execution test
-XPASS: gcc.dg/guality/guality.c -O3 -fomit-frame-pointer  execution test
-XPASS: gcc.dg/guality/guality.c -O0  execution test
-XPASS: gcc.dg/guality/guality.c -O3 -g  execution test
-XPASS: gcc.dg/guality/guality.c -Os  execution test
-XPASS: gcc.dg/guality/guality.c -O2 -flto  execution test
-XPASS: gcc.dg/guality/guality.c -O2  execution test
-XPASS: gcc.dg/guality/guality.c -O1  execution test
-XPASS: gcc.dg/guality/inline-params.c -O2  execution test
-XPASS: gcc.dg/guality/inline-params.c -O3 -fomit-frame-pointer  execution test
-XPASS: gcc.dg/guality/inline-params.c -O2 -flto  execution test
-XPASS: gcc.dg/guality/inline-params.c -Os  execution test
-XPASS: gcc.dg/guality/inline-params.c -O3 -g  execution test
-XPASS: gcc.dg/guality/inline-params.c -O2 -flto -flto-partition=none  execution test
-XPASS: gcc.dg/guality/pr41353-1.c -O3 -g  line 28 j == 28 + 37
-XPASS: gcc.dg/guality/pr41353-1.c -O1  line 28 j == 28 + 37
-XPASS: gcc.dg/guality/pr41353-1.c -O2 -flto -flto-partition=none  line 28 j == 28 + 37
-XPASS: gcc.dg/guality/pr41353-1.c -O2  line 28 j == 28 + 37
-XPASS: gcc.dg/guality/pr41353-1.c -O2 -flto  line 28 j == 28 + 37
-XPASS: gcc.dg/guality/pr41353-1.c -Os  line 28 j == 28 + 37
-XPASS: gcc.dg/guality/pr41353-1.c -O3 -fomit-frame-pointer  line 28 j == 28 + 37
-XPASS: gcc.dg/guality/pr41353-1.c -O0  line 28 j == 28 + 37
-XPASS: gcc.dg/guality/pr41447-1.c -O1  execution test
-XPASS: gcc.dg/guality/pr41447-1.c -Os  execution test
-XPASS: gcc.dg/guality/pr41447-1.c -O2  execution test
-XPASS: gcc.dg/guality/pr41447-1.c -O3 -fomit-frame-pointer  execution test
-XPASS: gcc.dg/guality/pr41447-1.c -O0  execution test
-XPASS: gcc.dg/guality/pr41447-1.c -O3 -g  execution test
-XPASS: gcc.dg/guality/pr41616-1.c -O2 -flto -flto-partition=none  execution test
-XPASS: gcc.dg/guality/pr41616-1.c -O0  execution test
-XPASS: gcc.dg/guality/pr41616-1.c -O3 -fomit-frame-pointer  execution test
-XPASS: gcc.dg/guality/pr41616-1.c -O3 -g  execution test
-XPASS: gcc.dg/guality/pr41616-1.c -O1  execution test
-XPASS: gcc.dg/guality/pr41616-1.c -Os  execution test
-XPASS: gcc.dg/guality/pr41616-1.c -O2  execution test
-XPASS: gcc.dg/guality/pr41616-1.c -O2 -flto  execution test
-FAIL: gcc.dg/guality/pr54200.c -Os  line 20 z == 3
-FAIL: gcc.dg/guality/pr54519-1.c -O2 -flto -flto-partition=none  line 23 y == 117
-FAIL: gcc.dg/guality/pr54519-1.c -O2 -flto  line 20 y == 25
-FAIL: gcc.dg/guality/pr54519-1.c -O2 -flto  line 23 z == 8
-FAIL: gcc.dg/guality/pr54519-1.c -O2 -flto  line 20 z == 6
-FAIL: gcc.dg/guality/pr54519-1.c -O2 -flto -flto-partition=none  line 23 z == 8
-FAIL: gcc.dg/guality/pr54519-1.c -O2 -flto  line 23 y == 117
-FAIL: gcc.dg/guality/pr54519-1.c -O2 -flto -flto-partition=none  line 20 z == 6
-FAIL: gcc.dg/guality/pr54519-1.c -O2 -flto -flto-partition=none  line 20 y == 25
-FAIL: gcc.dg/guality/pr54519-2.c -O2 -flto -flto-partition=none  line 17 y == 25
-FAIL: gcc.dg/guality/pr54519-2.c -O2 -flto  line 17 y == 25
-FAIL: gcc.dg/guality/pr54519-5.c -O2 -flto  line 17 y == 25
-FAIL: gcc.dg/guality/pr54519-5.c -O2 -flto -flto-partition=none  line 17 y == 25
-FAIL: gcc.dg/guality/pr54519-5.c -Os  line 17 y == 25
-FAIL: gcc.dg/guality/pr54519-5.c -O3 -fomit-frame-pointer  line 17 y == 25
-FAIL: gcc.dg/guality/pr54519-5.c -O2  line 17 y == 25
-FAIL: gcc.dg/guality/pr54519-5.c -O3 -g  line 17 y == 25
-FAIL: gcc.dg/guality/vla-1.c -O2 -flto  line 24 sizeof (a) == 17 * sizeof (short)
-FAIL: gcc.dg/guality/vla-1.c -O2 -flto  line 17 sizeof (a) == 6
-FAIL: gcc.dg/guality/vla-1.c -O3 -g  line 24 sizeof (a) == 17 * sizeof (short)
-FAIL: gcc.dg/guality/vla-1.c -O3 -fomit-frame-pointer  line 24 sizeof (a) == 17 * sizeof (short)
-FAIL: gcc.dg/guality/vla-1.c -O1  line 24 sizeof (a) == 17 * sizeof (short)
-FAIL: gcc.dg/guality/vla-1.c -Os  line 17 sizeof (a) == 6
-FAIL: gcc.dg/guality/vla-1.c -O2 -flto -flto-partition=none  line 17 sizeof (a) == 6
-FAIL: gcc.dg/guality/vla-1.c -O2  line 17 sizeof (a) == 6
-FAIL: gcc.dg/guality/vla-1.c -O3 -fomit-frame-pointer  line 17 sizeof (a) == 6
-FAIL: gcc.dg/guality/vla-1.c -O0  line 24 sizeof (a) == 17 * sizeof (short)
-FAIL: gcc.dg/guality/vla-1.c -O2 -flto -flto-partition=none  line 24 sizeof (a) == 17 * sizeof (short)
-FAIL: gcc.dg/guality/vla-1.c -O2  line 24 sizeof (a) == 17 * sizeof (short)
-FAIL: gcc.dg/guality/vla-1.c -O1  line 17 sizeof (a) == 6
-FAIL: gcc.dg/guality/vla-1.c -O3 -g  line 17 sizeof (a) == 6
-FAIL: gcc.dg/guality/vla-1.c -O0  line 17 sizeof (a) == 6
-FAIL: gcc.dg/guality/vla-1.c -Os  line 24 sizeof (a) == 17 * sizeof (short)
-FAIL: gcc.dg/guality/vla-2.c -O3 -g  line 25 sizeof (a) == 6 * sizeof (int)
-FAIL: gcc.dg/guality/vla-2.c -O0  line 25 sizeof (a) == 6 * sizeof (int)
-FAIL: gcc.dg/guality/vla-2.c -O0  line 16 sizeof (a) == 5 * sizeof (int)
-FAIL: gcc.dg/guality/vla-2.c -O3 -fomit-frame-pointer  line 16 sizeof (a) == 5 * sizeof (int)
-FAIL: gcc.dg/guality/vla-2.c -O2 -flto  line 25 sizeof (a) == 6 * sizeof (int)
-FAIL: gcc.dg/guality/vla-2.c -Os  line 25 sizeof (a) == 6 * sizeof (int)
-FAIL: gcc.dg/guality/vla-2.c -O2  line 16 sizeof (a) == 5 * sizeof (int)
-FAIL: gcc.dg/guality/vla-2.c -O1  line 25 sizeof (a) == 6 * sizeof (int)
-FAIL: gcc.dg/guality/vla-2.c -O2 -flto  line 16 sizeof (a) == 5 * sizeof (int)
-FAIL: gcc.dg/guality/vla-2.c -O3 -g  line 16 sizeof (a) == 5 * sizeof (int)
-FAIL: gcc.dg/guality/vla-2.c -O1  line 16 sizeof (a) == 5 * sizeof (int)
-FAIL: gcc.dg/guality/vla-2.c -O2  line 25 sizeof (a) == 6 * sizeof (int)
-FAIL: gcc.dg/guality/vla-2.c -O2 -flto -flto-partition=none  line 25 sizeof (a) == 6 * sizeof (int)
-FAIL: gcc.dg/guality/vla-2.c -O2 -flto -flto-partition=none  line 16 sizeof (a) == 5 * sizeof (int)
-FAIL: gcc.dg/guality/vla-2.c -Os  line 16 sizeof (a) == 5 * sizeof (int)
-FAIL: gcc.dg/guality/vla-2.c -O3 -fomit-frame-pointer  line 25 sizeof (a) == 6 * sizeof (int)
+XPASS: libffi.call/va_1.c -O0 -W -Wall output pattern test, 5 6 10 11 12 13 14 7 8 uc=9 sc=10 11 12 13 14 15 16 2.120000 3.130000?
+XPASS: libffi.call/va_1.c -O2 output pattern test, 5 6 10 11 12 13 14 7 8 uc=9 sc=10 11 12 13 14 15 16 2.120000 3.130000?
+XPASS: libffi.call/va_1.c -O3 output pattern test, 5 6 10 11 12 13 14 7 8 uc=9 sc=10 11 12 13 14 15 16 2.120000 3.130000?
+XPASS: libffi.call/va_1.c -Os output pattern test, 5 6 10 11 12 13 14 7 8 uc=9 sc=10 11 12 13 14 15 16 2.120000 3.130000?
+XPASS: libffi.call/va_1.c -O2 -fomit-frame-pointer output pattern test, 5 6 10 11 12 13 14 7 8 uc=9 sc=10 11 12 13 14 15 16 2.120000 3.130000?
 XPASS: gcc.dg/inline_3.c (test for excess errors)
 XPASS: gcc.dg/inline_4.c (test for excess errors)
-FAIL: gcc.dg/torture/pr51106-2.c -O2 -flto  (test for excess errors)
-FAIL: gcc.dg/torture/pr51106-2.c -O1  (test for excess errors)
-FAIL: gcc.dg/torture/pr51106-2.c -O3 -g  (test for excess errors)
-FAIL: gcc.dg/torture/pr51106-2.c -Os  (test for excess errors)
-FAIL: gcc.dg/torture/pr51106-2.c -O0  (test for excess errors)
-FAIL: gcc.dg/torture/pr51106-2.c -O3 -fomit-frame-pointer  (test for excess errors)
-FAIL: gcc.dg/torture/pr51106-2.c -O2 -flto -flto-partition=none  (test for excess errors)
-FAIL: gcc.dg/torture/pr51106-2.c -O2  (test for excess errors)
 XPASS: gcc.dg/unroll_2.c (test for excess errors)
 XPASS: gcc.dg/unroll_3.c (test for excess errors)
 XPASS: gcc.dg/unroll_4.c (test for excess errors)
-FAIL: libmudflap.c++/pass55-frag.cxx (-O2) execution test
-FAIL: libmudflap.c++/pass55-frag.cxx ( -O) execution test
-FAIL: libmudflap.c++/pass55-frag.cxx (-O3) execution test
-FAIL: libmudflap.c/fail37-frag.c (-O3) output pattern test
-FAIL: libmudflap.c/fail37-frag.c (-O2) output pattern test
-FAIL: libmudflap.c/fail37-frag.c (-O3) crash test
-FAIL: libmudflap.c/fail37-frag.c (-O2) crash test
+XPASS: gfortran.dg/do_1.f90 -O0  execution test
+XPASS: gfortran.dg/do_1.f90 -O1  execution test
+FAIL: gfortran.dg/lto/pr45586 f_lto_pr45586_0.o-f_lto_pr45586_0.o link, -O0 -flto -flto-partition=1to1 -fno-use-linker-plugin  (internal compiler error)
+FAIL: gfortran.dg/lto/pr45586 f_lto_pr45586_0.o-f_lto_pr45586_0.o link, -O0 -flto -flto-partition=none -fuse-linker-plugin (internal compiler error)
+UNRESOLVED: gfortran.dg/lto/pr45586 f_lto_pr45586_0.o-f_lto_pr45586_0.o execute -O0 -flto -flto-partition=1to1 -fno-use-linker-plugin
+FAIL: gfortran.dg/lto/pr45586 f_lto_pr45586_0.o-f_lto_pr45586_0.o link, -O0 -flto -fuse-linker-plugin -fno-fat-lto-objects  (internal compiler error)
+UNRESOLVED: gfortran.dg/lto/pr45586 f_lto_pr45586_0.o-f_lto_pr45586_0.o execute -O0 -flto -fuse-linker-plugin -fno-fat-lto-objects
+UNRESOLVED: gfortran.dg/lto/pr45586 f_lto_pr45586_0.o-f_lto_pr45586_0.o execute -O0 -flto -flto-partition=none -fuse-linker-plugin
+FAIL: gfortran.dg/lto/pr45586-2 f_lto_pr45586-2_0.o-f_lto_pr45586-2_0.o link, -O0 -flto -fuse-linker-plugin -fno-fat-lto-objects  (internal compiler error)
+FAIL: gfortran.dg/lto/pr45586-2 f_lto_pr45586-2_0.o-f_lto_pr45586-2_0.o link, -O0 -flto -flto-partition=1to1 -fno-use-linker-plugin  (internal compiler error)
+UNRESOLVED: gfortran.dg/lto/pr45586-2 f_lto_pr45586-2_0.o-f_lto_pr45586-2_0.o execute -O0 -flto -fuse-linker-plugin -fno-fat-lto-objects
+FAIL: gfortran.dg/lto/pr45586-2 f_lto_pr45586-2_0.o-f_lto_pr45586-2_0.o link, -O0 -flto -flto-partition=none -fuse-linker-plugin (internal compiler error)
+UNRESOLVED: gfortran.dg/lto/pr45586-2 f_lto_pr45586-2_0.o-f_lto_pr45586-2_0.o execute -O0 -flto -flto-partition=none -fuse-linker-plugin
+UNRESOLVED: gfortran.dg/lto/pr45586-2 f_lto_pr45586-2_0.o-f_lto_pr45586-2_0.o execute -O0 -flto -flto-partition=1to1 -fno-use-linker-plugin
+flaky | FAIL: libmudflap.c++/pass41-frag.cxx ( -O) execution test
+flaky | FAIL: libmudflap.c++/pass41-frag.cxx (-O3) execution test
+flaky | FAIL: libmudflap.c++/pass41-frag.cxx (-O2) execution test
+flaky | FAIL: libmudflap.c++/pass55-frag.cxx ( -O) execution test
+flaky | FAIL: libmudflap.c++/pass55-frag.cxx (-O3) execution test
+flaky | FAIL: libmudflap.c++/pass55-frag.cxx (-O2) execution test
+flaky | FAIL: libmudflap.c/fail37-frag.c (-O3) output pattern test
+flaky | FAIL: libmudflap.c/fail37-frag.c (-O2) crash test
+flaky | FAIL: libmudflap.c/fail37-frag.c (-O3) crash test
+flaky | FAIL: libmudflap.c/fail37-frag.c (-O2) output pattern test
+FAIL: sourcelocation -findirect-dispatch output - source compiled test
+FAIL: sourcelocation output - source compiled test
+FAIL: sourcelocation -O3 output - source compiled test
+FAIL: gfortran.dg/class_optional_2.f90 -Os  execution test
+XPASS: gfortran.dg/do_1.f90 -O2  execution test
+XPASS: gfortran.dg/do_1.f90 -O3 -fomit-frame-pointer  execution test
+XPASS: gfortran.dg/do_1.f90 -O3 -fomit-frame-pointer -funroll-loops  execution test
+XPASS: gfortran.dg/do_1.f90 -O3 -fomit-frame-pointer -funroll-all-loops -finline-functions  execution test
+XPASS: gfortran.dg/do_1.f90 -O3 -g  execution test
+XPASS: gfortran.dg/do_1.f90 -Os  execution test
diff --git a/function_reordering_plugin/ChangeLog.google-4_7 b/function_reordering_plugin/ChangeLog.google-4_7
new file mode 100644
index 0000000..e6d32e1
--- /dev/null
+++ b/function_reordering_plugin/ChangeLog.google-4_7
@@ -0,0 +1,14 @@
+2012-05-16  Sriraman Tallam  <tmsriram@google.com>
+
+	Port from google/gcc-4_6 
+	r177289, r177308, r179104, r179289, r179303, r179404, r182447
+
+	* config.h.in: Generate.
+	* configure: Generate.
+	* Makefile.in: New file.
+	* configure.ac: New file.
+	* callgraph.h: New file.
+	* callgraph.c: New file.
+	* function_reordering_plugin.c: New file.
+	* Makefile.am: Generate.
+	* aclocal.m4: Generate.
diff --git a/function_reordering_plugin/Makefile.am b/function_reordering_plugin/Makefile.am
new file mode 100644
index 0000000..7bf34b0
--- /dev/null
+++ b/function_reordering_plugin/Makefile.am
@@ -0,0 +1,38 @@
+# Makefile.am is used by automake 1.11 to generate Makefile.in.
+
+ACLOCAL_AMFLAGS = -I .. -I ../config
+AUTOMAKE_OPTIONS = no-dependencies
+
+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)
+target_noncanonical := @target_noncanonical@
+libexecsubdir := $(libexecdir)/gcc/$(target_noncanonical)/$(gcc_version)
+
+AM_CPPFLAGS = -I$(top_srcdir)/../include $(DEFS)
+AM_CFLAGS = -Wall -Werror
+AM_LIBTOOLFLAGS = --tag=disable-static
+
+libexecsub_LTLIBRARIES = libfunction_reordering_plugin.la
+gcc_build_dir = ../$(host_subdir)/gcc
+in_gcc_libs = $(foreach lib, $(libexecsub_LTLIBRARIES), $(gcc_build_dir)/$(lib))
+
+# Can be removed when libiberty becomes a normal convenience library
+Wc=-Wc,
+
+libfunction_reordering_plugin_la_SOURCES =  function_reordering_plugin.c callgraph.c
+libfunction_reordering_plugin_la_LIBADD = \
+	$(if $(wildcard ../libiberty/pic/libiberty.a),$(Wc)../libiberty/pic/libiberty.a,)
+# Note that we intentionally override the bindir supplied by ACX_LT_HOST_FLAGS
+libfunction_reordering_plugin_la_LDFLAGS = $(lt_host_flags) -module -bindir $(libexecsubdir) \
+	$(if $(wildcard ../libiberty/pic/libiberty.a),,-Wc,../libiberty/libiberty.a)
+libfunction_reordering_plugin_la_DEPENDENCIES = $(if $(wildcard \
+	../libiberty/pic/libiberty.a),../libiberty/pic/libiberty.a,) callgraph.h
+
+all-local: $(in_gcc_libs)
+
+$(in_gcc_libs) : $(gcc_build_dir)/%: %
+	@if test "X`dlname=; . ./$*; echo dlname:$$dlname`" = "Xdlname:"; then \
+	  echo WARNING: $* is static, not copying to $@ >&2 ; \
+	else \
+	  $(mkinstalldirs) $(gcc_build_dir) && \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $* `pwd`/$@ ; \
+	fi
diff --git a/function_reordering_plugin/Makefile.in b/function_reordering_plugin/Makefile.in
new file mode 100644
index 0000000..447d436
--- /dev/null
+++ b/function_reordering_plugin/Makefile.in
@@ -0,0 +1,548 @@
+# Makefile.in generated by automake 1.11 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+# Makefile.am is used by automake 1.11 to generate Makefile.in.
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+subdir = .
+DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
+	$(top_srcdir)/configure $(am__configure_deps) \
+	$(srcdir)/config.h.in $(srcdir)/../mkinstalldirs
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \
+	$(top_srcdir)/../config/depstand.m4 \
+	$(top_srcdir)/../config/lead-dot.m4 \
+	$(top_srcdir)/../config/lthostflags.m4 \
+	$(top_srcdir)/../config/override.m4 $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
+ configure.lineno config.status.lineno
+mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs
+CONFIG_HEADER = config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__installdirs = "$(DESTDIR)$(libexecsubdir)"
+LTLIBRARIES = $(libexecsub_LTLIBRARIES)
+am_libfunction_reordering_plugin_la_OBJECTS =  \
+	function_reordering_plugin.lo callgraph.lo
+libfunction_reordering_plugin_la_OBJECTS =  \
+	$(am_libfunction_reordering_plugin_la_OBJECTS)
+libfunction_reordering_plugin_la_LINK = $(LIBTOOL) --tag=CC \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
+	$(AM_CFLAGS) $(CFLAGS) \
+	$(libfunction_reordering_plugin_la_LDFLAGS) $(LDFLAGS) -o $@
+DEFAULT_INCLUDES = -I.@am__isrc@
+depcomp =
+am__depfiles_maybe =
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libfunction_reordering_plugin_la_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_libsubdir = @build_libsubdir@
+build_os = @build_os@
+build_subdir = @build_subdir@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_subdir = @host_subdir@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_host_flags = @lt_host_flags@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_noncanonical := @target_noncanonical@
+target_os = @target_os@
+target_subdir = @target_subdir@
+target_vendor = @target_vendor@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+ACLOCAL_AMFLAGS = -I .. -I ../config
+AUTOMAKE_OPTIONS = no-dependencies
+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)
+libexecsubdir := $(libexecdir)/gcc/$(target_noncanonical)/$(gcc_version)
+AM_CPPFLAGS = -I$(top_srcdir)/../include $(DEFS)
+AM_CFLAGS = -Wall -Werror
+AM_LIBTOOLFLAGS = --tag=disable-static
+libexecsub_LTLIBRARIES = libfunction_reordering_plugin.la
+gcc_build_dir = ../$(host_subdir)/gcc
+in_gcc_libs = $(foreach lib, $(libexecsub_LTLIBRARIES), $(gcc_build_dir)/$(lib))
+
+# Can be removed when libiberty becomes a normal convenience library
+Wc = -Wc,
+libfunction_reordering_plugin_la_SOURCES = function_reordering_plugin.c callgraph.c
+libfunction_reordering_plugin_la_LIBADD = \
+	$(if $(wildcard ../libiberty/pic/libiberty.a),$(Wc)../libiberty/pic/libiberty.a,)
+
+# Note that we intentionally override the bindir supplied by ACX_LT_HOST_FLAGS
+libfunction_reordering_plugin_la_LDFLAGS = $(lt_host_flags) -module -bindir $(libexecsubdir) \
+	$(if $(wildcard ../libiberty/pic/libiberty.a),,-Wc,../libiberty/libiberty.a)
+
+libfunction_reordering_plugin_la_DEPENDENCIES = $(if $(wildcard \
+	../libiberty/pic/libiberty.a),../libiberty/pic/libiberty.a,) callgraph.h
+
+all: config.h
+	$(MAKE) $(AM_MAKEFLAGS) all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+am--refresh:
+	@:
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \
+	      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    echo ' $(SHELL) ./config.status'; \
+	    $(SHELL) ./config.status;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	$(SHELL) ./config.status --recheck
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	$(am__cd) $(srcdir) && $(AUTOCONF)
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
+$(am__aclocal_m4_deps):
+
+config.h: stamp-h1
+	@if test ! -f $@; then \
+	  rm -f stamp-h1; \
+	  $(MAKE) $(AM_MAKEFLAGS) stamp-h1; \
+	else :; fi
+
+stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status
+	@rm -f stamp-h1
+	cd $(top_builddir) && $(SHELL) ./config.status config.h
+$(srcdir)/config.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps) 
+	($(am__cd) $(top_srcdir) && $(AUTOHEADER))
+	rm -f stamp-h1
+	touch $@
+
+distclean-hdr:
+	-rm -f config.h stamp-h1
+install-libexecsubLTLIBRARIES: $(libexecsub_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	test -z "$(libexecsubdir)" || $(MKDIR_P) "$(DESTDIR)$(libexecsubdir)"
+	@list='$(libexecsub_LTLIBRARIES)'; test -n "$(libexecsubdir)" || list=; \
+	list2=; for p in $$list; do \
+	  if test -f $$p; then \
+	    list2="$$list2 $$p"; \
+	  else :; fi; \
+	done; \
+	test -z "$$list2" || { \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(libexecsubdir)'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(libexecsubdir)"; \
+	}
+
+uninstall-libexecsubLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libexecsub_LTLIBRARIES)'; test -n "$(libexecsubdir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(libexecsubdir)/$$f'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(libexecsubdir)/$$f"; \
+	done
+
+clean-libexecsubLTLIBRARIES:
+	-test -z "$(libexecsub_LTLIBRARIES)" || rm -f $(libexecsub_LTLIBRARIES)
+	@list='$(libexecsub_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libfunction_reordering_plugin.la: $(libfunction_reordering_plugin_la_OBJECTS) $(libfunction_reordering_plugin_la_DEPENDENCIES) 
+	$(libfunction_reordering_plugin_la_LINK) -rpath $(libexecsubdir) $(libfunction_reordering_plugin_la_OBJECTS) $(libfunction_reordering_plugin_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+.c.o:
+	$(COMPILE) -c $<
+
+.c.obj:
+	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool config.lt
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) config.h all-local
+installdirs:
+	for dir in "$(DESTDIR)$(libexecsubdir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libexecsubLTLIBRARIES clean-libtool \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-hdr distclean-libtool distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am: install-libexecsubLTLIBRARIES
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf $(top_srcdir)/autom4te.cache
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-libexecsubLTLIBRARIES
+
+.MAKE: all install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am all-local am--refresh check check-am \
+	clean clean-generic clean-libexecsubLTLIBRARIES clean-libtool \
+	ctags distclean distclean-compile distclean-generic \
+	distclean-hdr distclean-libtool distclean-tags dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-libexecsubLTLIBRARIES install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags uninstall uninstall-am \
+	uninstall-libexecsubLTLIBRARIES
+
+
+all-local: $(in_gcc_libs)
+
+$(in_gcc_libs) : $(gcc_build_dir)/%: %
+	@if test "X`dlname=; . ./$*; echo dlname:$$dlname`" = "Xdlname:"; then \
+	  echo WARNING: $* is static, not copying to $@ >&2 ; \
+	else \
+	  $(mkinstalldirs) $(gcc_build_dir) && \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $* `pwd`/$@ ; \
+	fi
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/function_reordering_plugin/aclocal.m4 b/function_reordering_plugin/aclocal.m4
new file mode 100644
index 0000000..0037535
--- /dev/null
+++ b/function_reordering_plugin/aclocal.m4
@@ -0,0 +1,9008 @@
+# generated automatically by aclocal 1.11 -*- Autoconf -*-
+
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
+# 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+m4_ifndef([AC_AUTOCONF_VERSION],
+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
+m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.64],,
+[m4_warning([this file was generated for autoconf 2.64.
+You have another version of autoconf.  It may work, but is not guaranteed to.
+If you have problems, you may need to regenerate the build system entirely.
+To do so, use the procedure documented by the package, typically `autoreconf'.])])
+
+# libtool.m4 - Configure libtool for the host system. -*-Autoconf-*-
+#
+#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
+#                 2006, 2007, 2008, 2009, 2010 Free Software Foundation,
+#                 Inc.
+#   Written by Gordon Matzigkeit, 1996
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+m4_define([_LT_COPYING], [dnl
+#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
+#                 2006, 2007, 2008, 2009, 2010 Free Software Foundation,
+#                 Inc.
+#   Written by Gordon Matzigkeit, 1996
+#
+#   This file is part of GNU Libtool.
+#
+# GNU Libtool is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# As a special exception to the GNU General Public License,
+# if you distribute this file as part of a program or library that
+# is built using GNU Libtool, you may include this file under the
+# same distribution terms that you use for the rest of that program.
+#
+# GNU Libtool is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Libtool; see the file COPYING.  If not, a copy
+# can be downloaded from http://www.gnu.org/licenses/gpl.html, or
+# obtained by writing to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+])
+
+# serial 56 LT_INIT
+
+
+# LT_PREREQ(VERSION)
+# ------------------
+# Complain and exit if this libtool version is less that VERSION.
+m4_defun([LT_PREREQ],
+[m4_if(m4_version_compare(m4_defn([LT_PACKAGE_VERSION]), [$1]), -1,
+       [m4_default([$3],
+		   [m4_fatal([Libtool version $1 or higher is required],
+		             63)])],
+       [$2])])
+
+
+# _LT_CHECK_BUILDDIR
+# ------------------
+# Complain if the absolute build directory name contains unusual characters
+m4_defun([_LT_CHECK_BUILDDIR],
+[case `pwd` in
+  *\ * | *\	*)
+    AC_MSG_WARN([Libtool does not cope well with whitespace in `pwd`]) ;;
+esac
+])
+
+
+# LT_INIT([OPTIONS])
+# ------------------
+AC_DEFUN([LT_INIT],
+[AC_PREREQ([2.58])dnl We use AC_INCLUDES_DEFAULT
+AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])dnl
+AC_BEFORE([$0], [LT_LANG])dnl
+AC_BEFORE([$0], [LT_OUTPUT])dnl
+AC_BEFORE([$0], [LTDL_INIT])dnl
+m4_require([_LT_CHECK_BUILDDIR])dnl
+
+dnl Autoconf doesn't catch unexpanded LT_ macros by default:
+m4_pattern_forbid([^_?LT_[A-Z_]+$])dnl
+m4_pattern_allow([^(_LT_EOF|LT_DLGLOBAL|LT_DLLAZY_OR_NOW|LT_MULTI_MODULE)$])dnl
+dnl aclocal doesn't pull ltoptions.m4, ltsugar.m4, or ltversion.m4
+dnl unless we require an AC_DEFUNed macro:
+AC_REQUIRE([LTOPTIONS_VERSION])dnl
+AC_REQUIRE([LTSUGAR_VERSION])dnl
+AC_REQUIRE([LTVERSION_VERSION])dnl
+AC_REQUIRE([LTOBSOLETE_VERSION])dnl
+m4_require([_LT_PROG_LTMAIN])dnl
+
+_LT_SHELL_INIT([SHELL=${CONFIG_SHELL-/bin/sh}])
+
+dnl Parse OPTIONS
+_LT_SET_OPTIONS([$0], [$1])
+
+# This can be used to rebuild libtool when needed
+LIBTOOL_DEPS="$ltmain"
+
+# Always use our own libtool.
+LIBTOOL='$(SHELL) $(top_builddir)/libtool'
+AC_SUBST(LIBTOOL)dnl
+
+_LT_SETUP
+
+# Only expand once:
+m4_define([LT_INIT])
+])# LT_INIT
+
+# Old names:
+AU_ALIAS([AC_PROG_LIBTOOL], [LT_INIT])
+AU_ALIAS([AM_PROG_LIBTOOL], [LT_INIT])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_PROG_LIBTOOL], [])
+dnl AC_DEFUN([AM_PROG_LIBTOOL], [])
+
+
+# _LT_CC_BASENAME(CC)
+# -------------------
+# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.
+m4_defun([_LT_CC_BASENAME],
+[for cc_temp in $1""; do
+  case $cc_temp in
+    compile | *[[\\/]]compile | ccache | *[[\\/]]ccache ) ;;
+    distcc | *[[\\/]]distcc | purify | *[[\\/]]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
+done
+cc_basename=`$ECHO "$cc_temp" | $SED "s%.*/%%; s%^$host_alias-%%"`
+])
+
+
+# _LT_FILEUTILS_DEFAULTS
+# ----------------------
+# It is okay to use these file commands and assume they have been set
+# sensibly after `m4_require([_LT_FILEUTILS_DEFAULTS])'.
+m4_defun([_LT_FILEUTILS_DEFAULTS],
+[: ${CP="cp -f"}
+: ${MV="mv -f"}
+: ${RM="rm -f"}
+])# _LT_FILEUTILS_DEFAULTS
+
+
+# _LT_SETUP
+# ---------
+m4_defun([_LT_SETUP],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_REQUIRE([AC_CANONICAL_BUILD])dnl
+AC_REQUIRE([_LT_PREPARE_SED_QUOTE_VARS])dnl
+AC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])dnl
+
+_LT_DECL([], [host_alias], [0], [The host system])dnl
+_LT_DECL([], [host], [0])dnl
+_LT_DECL([], [host_os], [0])dnl
+dnl
+_LT_DECL([], [build_alias], [0], [The build system])dnl
+_LT_DECL([], [build], [0])dnl
+_LT_DECL([], [build_os], [0])dnl
+dnl
+AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([LT_PATH_LD])dnl
+AC_REQUIRE([LT_PATH_NM])dnl
+dnl
+AC_REQUIRE([AC_PROG_LN_S])dnl
+test -z "$LN_S" && LN_S="ln -s"
+_LT_DECL([], [LN_S], [1], [Whether we need soft or hard links])dnl
+dnl
+AC_REQUIRE([LT_CMD_MAX_LEN])dnl
+_LT_DECL([objext], [ac_objext], [0], [Object file suffix (normally "o")])dnl
+_LT_DECL([], [exeext], [0], [Executable file suffix (normally "")])dnl
+dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_CHECK_SHELL_FEATURES])dnl
+m4_require([_LT_CMD_RELOAD])dnl
+m4_require([_LT_CHECK_MAGIC_METHOD])dnl
+m4_require([_LT_CMD_OLD_ARCHIVE])dnl
+m4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl
+
+_LT_CONFIG_LIBTOOL_INIT([
+# See if we are running on zsh, and set the options which allow our
+# commands through without removal of \ escapes INIT.
+if test -n "\${ZSH_VERSION+set}" ; then
+   setopt NO_GLOB_SUBST
+fi
+])
+if test -n "${ZSH_VERSION+set}" ; then
+   setopt NO_GLOB_SUBST
+fi
+
+_LT_CHECK_OBJDIR
+
+m4_require([_LT_TAG_COMPILER])dnl
+
+case $host_os in
+aix3*)
+  # AIX sometimes has problems with the GCC collect2 program.  For some
+  # reason, if we set the COLLECT_NAMES environment variable, the problems
+  # vanish in a puff of smoke.
+  if test "X${COLLECT_NAMES+set}" != Xset; then
+    COLLECT_NAMES=
+    export COLLECT_NAMES
+  fi
+  ;;
+esac
+
+# Global variables:
+ofile=libtool
+can_build_shared=yes
+
+# All known linkers require a `.a' archive for static linking (except MSVC,
+# which needs '.lib').
+libext=a
+
+with_gnu_ld="$lt_cv_prog_gnu_ld"
+
+old_CC="$CC"
+old_CFLAGS="$CFLAGS"
+
+# Set sane defaults for various variables
+test -z "$CC" && CC=cc
+test -z "$LTCC" && LTCC=$CC
+test -z "$LTCFLAGS" && LTCFLAGS=$CFLAGS
+test -z "$LD" && LD=ld
+test -z "$ac_objext" && ac_objext=o
+
+_LT_CC_BASENAME([$compiler])
+
+# Only perform the check for file, if the check method requires it
+test -z "$MAGIC_CMD" && MAGIC_CMD=file
+case $deplibs_check_method in
+file_magic*)
+  if test "$file_magic_cmd" = '$MAGIC_CMD'; then
+    _LT_PATH_MAGIC
+  fi
+  ;;
+esac
+
+# Use C for the default configuration in the libtool script
+LT_SUPPORTED_TAG([CC])
+_LT_LANG_C_CONFIG
+_LT_LANG_DEFAULT_CONFIG
+_LT_CONFIG_COMMANDS
+])# _LT_SETUP
+
+
+# _LT_PREPARE_SED_QUOTE_VARS
+# --------------------------
+# Define a few sed substitution that help us do robust quoting.
+m4_defun([_LT_PREPARE_SED_QUOTE_VARS],
+[# Backslashify metacharacters that are still active within
+# double-quoted strings.
+sed_quote_subst='s/\([["`$\\]]\)/\\\1/g'
+
+# Same as above, but do not quote variable references.
+double_quote_subst='s/\([["`\\]]\)/\\\1/g'
+
+# Sed substitution to delay expansion of an escaped shell variable in a
+# double_quote_subst'ed string.
+delay_variable_subst='s/\\\\\\\\\\\$/\\\\\\$/g'
+
+# Sed substitution to delay expansion of an escaped single quote.
+delay_single_quote_subst='s/'\''/'\'\\\\\\\'\''/g'
+
+# Sed substitution to avoid accidental globbing in evaled expressions
+no_glob_subst='s/\*/\\\*/g'
+])
+
+# _LT_PROG_LTMAIN
+# ---------------
+# Note that this code is called both from `configure', and `config.status'
+# now that we use AC_CONFIG_COMMANDS to generate libtool.  Notably,
+# `config.status' has no value for ac_aux_dir unless we are using Automake,
+# so we pass a copy along to make sure it has a sensible value anyway.
+m4_defun([_LT_PROG_LTMAIN],
+[m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([ltmain.sh])])dnl
+_LT_CONFIG_LIBTOOL_INIT([ac_aux_dir='$ac_aux_dir'])
+ltmain="$ac_aux_dir/ltmain.sh"
+])# _LT_PROG_LTMAIN
+
+
+
+# So that we can recreate a full libtool script including additional
+# tags, we accumulate the chunks of code to send to AC_CONFIG_COMMANDS
+# in macros and then make a single call at the end using the `libtool'
+# label.
+
+
+# _LT_CONFIG_LIBTOOL_INIT([INIT-COMMANDS])
+# ----------------------------------------
+# Register INIT-COMMANDS to be passed to AC_CONFIG_COMMANDS later.
+m4_define([_LT_CONFIG_LIBTOOL_INIT],
+[m4_ifval([$1],
+          [m4_append([_LT_OUTPUT_LIBTOOL_INIT],
+                     [$1
+])])])
+
+# Initialize.
+m4_define([_LT_OUTPUT_LIBTOOL_INIT])
+
+
+# _LT_CONFIG_LIBTOOL([COMMANDS])
+# ------------------------------
+# Register COMMANDS to be passed to AC_CONFIG_COMMANDS later.
+m4_define([_LT_CONFIG_LIBTOOL],
+[m4_ifval([$1],
+          [m4_append([_LT_OUTPUT_LIBTOOL_COMMANDS],
+                     [$1
+])])])
+
+# Initialize.
+m4_define([_LT_OUTPUT_LIBTOOL_COMMANDS])
+
+
+# _LT_CONFIG_SAVE_COMMANDS([COMMANDS], [INIT_COMMANDS])
+# -----------------------------------------------------
+m4_defun([_LT_CONFIG_SAVE_COMMANDS],
+[_LT_CONFIG_LIBTOOL([$1])
+_LT_CONFIG_LIBTOOL_INIT([$2])
+])
+
+
+# _LT_FORMAT_COMMENT([COMMENT])
+# -----------------------------
+# Add leading comment marks to the start of each line, and a trailing
+# full-stop to the whole comment if one is not present already.
+m4_define([_LT_FORMAT_COMMENT],
+[m4_ifval([$1], [
+m4_bpatsubst([m4_bpatsubst([$1], [^ *], [# ])],
+              [['`$\]], [\\\&])]m4_bmatch([$1], [[!?.]$], [], [.])
+)])
+
+
+
+
+
+# _LT_DECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION], [IS-TAGGED?])
+# -------------------------------------------------------------------
+# CONFIGNAME is the name given to the value in the libtool script.
+# VARNAME is the (base) name used in the configure script.
+# VALUE may be 0, 1 or 2 for a computed quote escaped value based on
+# VARNAME.  Any other value will be used directly.
+m4_define([_LT_DECL],
+[lt_if_append_uniq([lt_decl_varnames], [$2], [, ],
+    [lt_dict_add_subkey([lt_decl_dict], [$2], [libtool_name],
+	[m4_ifval([$1], [$1], [$2])])
+    lt_dict_add_subkey([lt_decl_dict], [$2], [value], [$3])
+    m4_ifval([$4],
+	[lt_dict_add_subkey([lt_decl_dict], [$2], [description], [$4])])
+    lt_dict_add_subkey([lt_decl_dict], [$2],
+	[tagged?], [m4_ifval([$5], [yes], [no])])])
+])
+
+
+# _LT_TAGDECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION])
+# --------------------------------------------------------
+m4_define([_LT_TAGDECL], [_LT_DECL([$1], [$2], [$3], [$4], [yes])])
+
+
+# lt_decl_tag_varnames([SEPARATOR], [VARNAME1...])
+# ------------------------------------------------
+m4_define([lt_decl_tag_varnames],
+[_lt_decl_filter([tagged?], [yes], $@)])
+
+
+# _lt_decl_filter(SUBKEY, VALUE, [SEPARATOR], [VARNAME1..])
+# ---------------------------------------------------------
+m4_define([_lt_decl_filter],
+[m4_case([$#],
+  [0], [m4_fatal([$0: too few arguments: $#])],
+  [1], [m4_fatal([$0: too few arguments: $#: $1])],
+  [2], [lt_dict_filter([lt_decl_dict], [$1], [$2], [], lt_decl_varnames)],
+  [3], [lt_dict_filter([lt_decl_dict], [$1], [$2], [$3], lt_decl_varnames)],
+  [lt_dict_filter([lt_decl_dict], $@)])[]dnl
+])
+
+
+# lt_decl_quote_varnames([SEPARATOR], [VARNAME1...])
+# --------------------------------------------------
+m4_define([lt_decl_quote_varnames],
+[_lt_decl_filter([value], [1], $@)])
+
+
+# lt_decl_dquote_varnames([SEPARATOR], [VARNAME1...])
+# ---------------------------------------------------
+m4_define([lt_decl_dquote_varnames],
+[_lt_decl_filter([value], [2], $@)])
+
+
+# lt_decl_varnames_tagged([SEPARATOR], [VARNAME1...])
+# ---------------------------------------------------
+m4_define([lt_decl_varnames_tagged],
+[m4_assert([$# <= 2])dnl
+_$0(m4_quote(m4_default([$1], [[, ]])),
+    m4_ifval([$2], [[$2]], [m4_dquote(lt_decl_tag_varnames)]),
+    m4_split(m4_normalize(m4_quote(_LT_TAGS)), [ ]))])
+m4_define([_lt_decl_varnames_tagged],
+[m4_ifval([$3], [lt_combine([$1], [$2], [_], $3)])])
+
+
+# lt_decl_all_varnames([SEPARATOR], [VARNAME1...])
+# ------------------------------------------------
+m4_define([lt_decl_all_varnames],
+[_$0(m4_quote(m4_default([$1], [[, ]])),
+     m4_if([$2], [],
+	   m4_quote(lt_decl_varnames),
+	m4_quote(m4_shift($@))))[]dnl
+])
+m4_define([_lt_decl_all_varnames],
+[lt_join($@, lt_decl_varnames_tagged([$1],
+			lt_decl_tag_varnames([[, ]], m4_shift($@))))dnl
+])
+
+
+# _LT_CONFIG_STATUS_DECLARE([VARNAME])
+# ------------------------------------
+# Quote a variable value, and forward it to `config.status' so that its
+# declaration there will have the same value as in `configure'.  VARNAME
+# must have a single quote delimited value for this to work.
+m4_define([_LT_CONFIG_STATUS_DECLARE],
+[$1='`$ECHO "$][$1" | $SED "$delay_single_quote_subst"`'])
+
+
+# _LT_CONFIG_STATUS_DECLARATIONS
+# ------------------------------
+# We delimit libtool config variables with single quotes, so when
+# we write them to config.status, we have to be sure to quote all
+# embedded single quotes properly.  In configure, this macro expands
+# each variable declared with _LT_DECL (and _LT_TAGDECL) into:
+#
+#    <var>='`$ECHO "$<var>" | $SED "$delay_single_quote_subst"`'
+m4_defun([_LT_CONFIG_STATUS_DECLARATIONS],
+[m4_foreach([_lt_var], m4_quote(lt_decl_all_varnames),
+    [m4_n([_LT_CONFIG_STATUS_DECLARE(_lt_var)])])])
+
+
+# _LT_LIBTOOL_TAGS
+# ----------------
+# Output comment and list of tags supported by the script
+m4_defun([_LT_LIBTOOL_TAGS],
+[_LT_FORMAT_COMMENT([The names of the tagged configurations supported by this script])dnl
+available_tags="_LT_TAGS"dnl
+])
+
+
+# _LT_LIBTOOL_DECLARE(VARNAME, [TAG])
+# -----------------------------------
+# Extract the dictionary values for VARNAME (optionally with TAG) and
+# expand to a commented shell variable setting:
+#
+#    # Some comment about what VAR is for.
+#    visible_name=$lt_internal_name
+m4_define([_LT_LIBTOOL_DECLARE],
+[_LT_FORMAT_COMMENT(m4_quote(lt_dict_fetch([lt_decl_dict], [$1],
+					   [description])))[]dnl
+m4_pushdef([_libtool_name],
+    m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [libtool_name])))[]dnl
+m4_case(m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [value])),
+    [0], [_libtool_name=[$]$1],
+    [1], [_libtool_name=$lt_[]$1],
+    [2], [_libtool_name=$lt_[]$1],
+    [_libtool_name=lt_dict_fetch([lt_decl_dict], [$1], [value])])[]dnl
+m4_ifval([$2], [_$2])[]m4_popdef([_libtool_name])[]dnl
+])
+
+
+# _LT_LIBTOOL_CONFIG_VARS
+# -----------------------
+# Produce commented declarations of non-tagged libtool config variables
+# suitable for insertion in the LIBTOOL CONFIG section of the `libtool'
+# script.  Tagged libtool config variables (even for the LIBTOOL CONFIG
+# section) are produced by _LT_LIBTOOL_TAG_VARS.
+m4_defun([_LT_LIBTOOL_CONFIG_VARS],
+[m4_foreach([_lt_var],
+    m4_quote(_lt_decl_filter([tagged?], [no], [], lt_decl_varnames)),
+    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var)])])])
+
+
+# _LT_LIBTOOL_TAG_VARS(TAG)
+# -------------------------
+m4_define([_LT_LIBTOOL_TAG_VARS],
+[m4_foreach([_lt_var], m4_quote(lt_decl_tag_varnames),
+    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var, [$1])])])])
+
+
+# _LT_TAGVAR(VARNAME, [TAGNAME])
+# ------------------------------
+m4_define([_LT_TAGVAR], [m4_ifval([$2], [$1_$2], [$1])])
+
+
+# _LT_CONFIG_COMMANDS
+# -------------------
+# Send accumulated output to $CONFIG_STATUS.  Thanks to the lists of
+# variables for single and double quote escaping we saved from calls
+# to _LT_DECL, we can put quote escaped variables declarations
+# into `config.status', and then the shell code to quote escape them in
+# for loops in `config.status'.  Finally, any additional code accumulated
+# from calls to _LT_CONFIG_LIBTOOL_INIT is expanded.
+m4_defun([_LT_CONFIG_COMMANDS],
+[AC_PROVIDE_IFELSE([LT_OUTPUT],
+	dnl If the libtool generation code has been placed in $CONFIG_LT,
+	dnl instead of duplicating it all over again into config.status,
+	dnl then we will have config.status run $CONFIG_LT later, so it
+	dnl needs to know what name is stored there:
+        [AC_CONFIG_COMMANDS([libtool],
+            [$SHELL $CONFIG_LT || AS_EXIT(1)], [CONFIG_LT='$CONFIG_LT'])],
+    dnl If the libtool generation code is destined for config.status,
+    dnl expand the accumulated commands and init code now:
+    [AC_CONFIG_COMMANDS([libtool],
+        [_LT_OUTPUT_LIBTOOL_COMMANDS], [_LT_OUTPUT_LIBTOOL_COMMANDS_INIT])])
+])#_LT_CONFIG_COMMANDS
+
+
+# Initialize.
+m4_define([_LT_OUTPUT_LIBTOOL_COMMANDS_INIT],
+[
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+sed_quote_subst='$sed_quote_subst'
+double_quote_subst='$double_quote_subst'
+delay_variable_subst='$delay_variable_subst'
+_LT_CONFIG_STATUS_DECLARATIONS
+LTCC='$LTCC'
+LTCFLAGS='$LTCFLAGS'
+compiler='$compiler_DEFAULT'
+
+# A function that is used when there is no print builtin or printf.
+func_fallback_echo ()
+{
+  eval 'cat <<_LTECHO_EOF
+\$[]1
+_LTECHO_EOF'
+}
+
+# Quote evaled strings.
+for var in lt_decl_all_varnames([[ \
+]], lt_decl_quote_varnames); do
+    case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
+    *[[\\\\\\\`\\"\\\$]]*)
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED \\"\\\$sed_quote_subst\\"\\\`\\\\\\""
+      ;;
+    *)
+      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
+      ;;
+    esac
+done
+
+# Double-quote double-evaled strings.
+for var in lt_decl_all_varnames([[ \
+]], lt_decl_dquote_varnames); do
+    case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
+    *[[\\\\\\\`\\"\\\$]]*)
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED -e \\"\\\$double_quote_subst\\" -e \\"\\\$sed_quote_subst\\" -e \\"\\\$delay_variable_subst\\"\\\`\\\\\\""
+      ;;
+    *)
+      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
+      ;;
+    esac
+done
+
+_LT_OUTPUT_LIBTOOL_INIT
+])
+
+# _LT_GENERATED_FILE_INIT(FILE, [COMMENT])
+# ------------------------------------
+# Generate a child script FILE with all initialization necessary to
+# reuse the environment learned by the parent script, and make the
+# file executable.  If COMMENT is supplied, it is inserted after the
+# `#!' sequence but before initialization text begins.  After this
+# macro, additional text can be appended to FILE to form the body of
+# the child script.  The macro ends with non-zero status if the
+# file could not be fully written (such as if the disk is full).
+m4_ifdef([AS_INIT_GENERATED],
+[m4_defun([_LT_GENERATED_FILE_INIT],[AS_INIT_GENERATED($@)])],
+[m4_defun([_LT_GENERATED_FILE_INIT],
+[m4_require([AS_PREPARE])]dnl
+[m4_pushdef([AS_MESSAGE_LOG_FD])]dnl
+[lt_write_fail=0
+cat >$1 <<_ASEOF || lt_write_fail=1
+#! $SHELL
+# Generated by $as_me.
+$2
+SHELL=\${CONFIG_SHELL-$SHELL}
+export SHELL
+_ASEOF
+cat >>$1 <<\_ASEOF || lt_write_fail=1
+AS_SHELL_SANITIZE
+_AS_PREPARE
+exec AS_MESSAGE_FD>&1
+_ASEOF
+test $lt_write_fail = 0 && chmod +x $1[]dnl
+m4_popdef([AS_MESSAGE_LOG_FD])])])# _LT_GENERATED_FILE_INIT
+
+# LT_OUTPUT
+# ---------
+# This macro allows early generation of the libtool script (before
+# AC_OUTPUT is called), incase it is used in configure for compilation
+# tests.
+AC_DEFUN([LT_OUTPUT],
+[: ${CONFIG_LT=./config.lt}
+AC_MSG_NOTICE([creating $CONFIG_LT])
+_LT_GENERATED_FILE_INIT(["$CONFIG_LT"],
+[# Run this file to recreate a libtool stub with the current configuration.])
+
+cat >>"$CONFIG_LT" <<\_LTEOF
+lt_cl_silent=false
+exec AS_MESSAGE_LOG_FD>>config.log
+{
+  echo
+  AS_BOX([Running $as_me.])
+} >&AS_MESSAGE_LOG_FD
+
+lt_cl_help="\
+\`$as_me' creates a local libtool stub from the current configuration,
+for use in further configure time tests before the real libtool is
+generated.
+
+Usage: $[0] [[OPTIONS]]
+
+  -h, --help      print this help, then exit
+  -V, --version   print version number, then exit
+  -q, --quiet     do not print progress messages
+  -d, --debug     don't remove temporary files
+
+Report bugs to <bug-libtool@gnu.org>."
+
+lt_cl_version="\
+m4_ifset([AC_PACKAGE_NAME], [AC_PACKAGE_NAME ])config.lt[]dnl
+m4_ifset([AC_PACKAGE_VERSION], [ AC_PACKAGE_VERSION])
+configured by $[0], generated by m4_PACKAGE_STRING.
+
+Copyright (C) 2010 Free Software Foundation, Inc.
+This config.lt script is free software; the Free Software Foundation
+gives unlimited permision to copy, distribute and modify it."
+
+while test $[#] != 0
+do
+  case $[1] in
+    --version | --v* | -V )
+      echo "$lt_cl_version"; exit 0 ;;
+    --help | --h* | -h )
+      echo "$lt_cl_help"; exit 0 ;;
+    --debug | --d* | -d )
+      debug=: ;;
+    --quiet | --q* | --silent | --s* | -q )
+      lt_cl_silent=: ;;
+
+    -*) AC_MSG_ERROR([unrecognized option: $[1]
+Try \`$[0] --help' for more information.]) ;;
+
+    *) AC_MSG_ERROR([unrecognized argument: $[1]
+Try \`$[0] --help' for more information.]) ;;
+  esac
+  shift
+done
+
+if $lt_cl_silent; then
+  exec AS_MESSAGE_FD>/dev/null
+fi
+_LTEOF
+
+cat >>"$CONFIG_LT" <<_LTEOF
+_LT_OUTPUT_LIBTOOL_COMMANDS_INIT
+_LTEOF
+
+cat >>"$CONFIG_LT" <<\_LTEOF
+AC_MSG_NOTICE([creating $ofile])
+_LT_OUTPUT_LIBTOOL_COMMANDS
+AS_EXIT(0)
+_LTEOF
+chmod +x "$CONFIG_LT"
+
+# configure is writing to config.log, but config.lt does its own redirection,
+# appending to config.log, which fails on DOS, as config.log is still kept
+# open by configure.  Here we exec the FD to /dev/null, effectively closing
+# config.log, so it can be properly (re)opened and appended to by config.lt.
+lt_cl_success=:
+test "$silent" = yes &&
+  lt_config_lt_args="$lt_config_lt_args --quiet"
+exec AS_MESSAGE_LOG_FD>/dev/null
+$SHELL "$CONFIG_LT" $lt_config_lt_args || lt_cl_success=false
+exec AS_MESSAGE_LOG_FD>>config.log
+$lt_cl_success || AS_EXIT(1)
+])# LT_OUTPUT
+
+
+# _LT_CONFIG(TAG)
+# ---------------
+# If TAG is the built-in tag, create an initial libtool script with a
+# default configuration from the untagged config vars.  Otherwise add code
+# to config.status for appending the configuration named by TAG from the
+# matching tagged config vars.
+m4_defun([_LT_CONFIG],
+[m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+_LT_CONFIG_SAVE_COMMANDS([
+  m4_define([_LT_TAG], m4_if([$1], [], [C], [$1]))dnl
+  m4_if(_LT_TAG, [C], [
+    # See if we are running on zsh, and set the options which allow our
+    # commands through without removal of \ escapes.
+    if test -n "${ZSH_VERSION+set}" ; then
+      setopt NO_GLOB_SUBST
+    fi
+
+    cfgfile="${ofile}T"
+    trap "$RM \"$cfgfile\"; exit 1" 1 2 15
+    $RM "$cfgfile"
+
+    cat <<_LT_EOF >> "$cfgfile"
+#! $SHELL
+
+# `$ECHO "$ofile" | sed 's%^.*/%%'` - Provide generalized library-building support services.
+# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION
+# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
+# NOTE: Changes made to this file will be lost: look at ltmain.sh.
+#
+_LT_COPYING
+_LT_LIBTOOL_TAGS
+
+# ### BEGIN LIBTOOL CONFIG
+_LT_LIBTOOL_CONFIG_VARS
+_LT_LIBTOOL_TAG_VARS
+# ### END LIBTOOL CONFIG
+
+_LT_EOF
+
+  case $host_os in
+  aix3*)
+    cat <<\_LT_EOF >> "$cfgfile"
+# AIX sometimes has problems with the GCC collect2 program.  For some
+# reason, if we set the COLLECT_NAMES environment variable, the problems
+# vanish in a puff of smoke.
+if test "X${COLLECT_NAMES+set}" != Xset; then
+  COLLECT_NAMES=
+  export COLLECT_NAMES
+fi
+_LT_EOF
+    ;;
+  esac
+
+  _LT_PROG_LTMAIN
+
+  # We use sed instead of cat because bash on DJGPP gets confused if
+  # if finds mixed CR/LF and LF-only lines.  Since sed operates in
+  # text mode, it properly converts lines to CR/LF.  This bash problem
+  # is reportedly fixed, but why not run on old versions too?
+  sed '/^# Generated shell functions inserted here/q' "$ltmain" >> "$cfgfile" \
+    || (rm -f "$cfgfile"; exit 1)
+
+  _LT_PROG_XSI_SHELLFNS
+
+  sed -n '/^# Generated shell functions inserted here/,$p' "$ltmain" >> "$cfgfile" \
+    || (rm -f "$cfgfile"; exit 1)
+
+  mv -f "$cfgfile" "$ofile" ||
+    (rm -f "$ofile" && cp "$cfgfile" "$ofile" && rm -f "$cfgfile")
+  chmod +x "$ofile"
+],
+[cat <<_LT_EOF >> "$ofile"
+
+dnl Unfortunately we have to use $1 here, since _LT_TAG is not expanded
+dnl in a comment (ie after a #).
+# ### BEGIN LIBTOOL TAG CONFIG: $1
+_LT_LIBTOOL_TAG_VARS(_LT_TAG)
+# ### END LIBTOOL TAG CONFIG: $1
+_LT_EOF
+])dnl /m4_if
+],
+[m4_if([$1], [], [
+    PACKAGE='$PACKAGE'
+    VERSION='$VERSION'
+    TIMESTAMP='$TIMESTAMP'
+    RM='$RM'
+    ofile='$ofile'], [])
+])dnl /_LT_CONFIG_SAVE_COMMANDS
+])# _LT_CONFIG
+
+
+# LT_SUPPORTED_TAG(TAG)
+# ---------------------
+# Trace this macro to discover what tags are supported by the libtool
+# --tag option, using:
+#    autoconf --trace 'LT_SUPPORTED_TAG:$1'
+AC_DEFUN([LT_SUPPORTED_TAG], [])
+
+
+# C support is built-in for now
+m4_define([_LT_LANG_C_enabled], [])
+m4_define([_LT_TAGS], [])
+
+
+# LT_LANG(LANG)
+# -------------
+# Enable libtool support for the given language if not already enabled.
+AC_DEFUN([LT_LANG],
+[AC_BEFORE([$0], [LT_OUTPUT])dnl
+m4_case([$1],
+  [C],			[_LT_LANG(C)],
+  [C++],		[_LT_LANG(CXX)],
+  [Java],		[_LT_LANG(GCJ)],
+  [Fortran 77],		[_LT_LANG(F77)],
+  [Fortran],		[_LT_LANG(FC)],
+  [Windows Resource],	[_LT_LANG(RC)],
+  [m4_ifdef([_LT_LANG_]$1[_CONFIG],
+    [_LT_LANG($1)],
+    [m4_fatal([$0: unsupported language: "$1"])])])dnl
+])# LT_LANG
+
+
+# _LT_LANG(LANGNAME)
+# ------------------
+m4_defun([_LT_LANG],
+[m4_ifdef([_LT_LANG_]$1[_enabled], [],
+  [LT_SUPPORTED_TAG([$1])dnl
+  m4_append([_LT_TAGS], [$1 ])dnl
+  m4_define([_LT_LANG_]$1[_enabled], [])dnl
+  _LT_LANG_$1_CONFIG($1)])dnl
+])# _LT_LANG
+
+
+# _LT_LANG_DEFAULT_CONFIG
+# -----------------------
+m4_defun([_LT_LANG_DEFAULT_CONFIG],
+[AC_PROVIDE_IFELSE([AC_PROG_CXX],
+  [LT_LANG(CXX)],
+  [m4_define([AC_PROG_CXX], defn([AC_PROG_CXX])[LT_LANG(CXX)])])
+
+AC_PROVIDE_IFELSE([AC_PROG_F77],
+  [LT_LANG(F77)],
+  [m4_define([AC_PROG_F77], defn([AC_PROG_F77])[LT_LANG(F77)])])
+
+AC_PROVIDE_IFELSE([AC_PROG_FC],
+  [LT_LANG(FC)],
+  [m4_define([AC_PROG_FC], defn([AC_PROG_FC])[LT_LANG(FC)])])
+
+dnl The call to [A][M_PROG_GCJ] is quoted like that to stop aclocal
+dnl pulling things in needlessly.
+AC_PROVIDE_IFELSE([AC_PROG_GCJ],
+  [LT_LANG(GCJ)],
+  [AC_PROVIDE_IFELSE([A][M_PROG_GCJ],
+    [LT_LANG(GCJ)],
+    [AC_PROVIDE_IFELSE([LT_PROG_GCJ],
+      [LT_LANG(GCJ)],
+      [m4_ifdef([AC_PROG_GCJ],
+	[m4_define([AC_PROG_GCJ], defn([AC_PROG_GCJ])[LT_LANG(GCJ)])])
+       m4_ifdef([A][M_PROG_GCJ],
+	[m4_define([A][M_PROG_GCJ], defn([A][M_PROG_GCJ])[LT_LANG(GCJ)])])
+       m4_ifdef([LT_PROG_GCJ],
+	[m4_define([LT_PROG_GCJ], defn([LT_PROG_GCJ])[LT_LANG(GCJ)])])])])])
+
+AC_PROVIDE_IFELSE([LT_PROG_RC],
+  [LT_LANG(RC)],
+  [m4_define([LT_PROG_RC], defn([LT_PROG_RC])[LT_LANG(RC)])])
+])# _LT_LANG_DEFAULT_CONFIG
+
+# Obsolete macros:
+AU_DEFUN([AC_LIBTOOL_CXX], [LT_LANG(C++)])
+AU_DEFUN([AC_LIBTOOL_F77], [LT_LANG(Fortran 77)])
+AU_DEFUN([AC_LIBTOOL_FC], [LT_LANG(Fortran)])
+AU_DEFUN([AC_LIBTOOL_GCJ], [LT_LANG(Java)])
+AU_DEFUN([AC_LIBTOOL_RC], [LT_LANG(Windows Resource)])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_CXX], [])
+dnl AC_DEFUN([AC_LIBTOOL_F77], [])
+dnl AC_DEFUN([AC_LIBTOOL_FC], [])
+dnl AC_DEFUN([AC_LIBTOOL_GCJ], [])
+dnl AC_DEFUN([AC_LIBTOOL_RC], [])
+
+
+# _LT_TAG_COMPILER
+# ----------------
+m4_defun([_LT_TAG_COMPILER],
+[AC_REQUIRE([AC_PROG_CC])dnl
+
+_LT_DECL([LTCC], [CC], [1], [A C compiler])dnl
+_LT_DECL([LTCFLAGS], [CFLAGS], [1], [LTCC compiler flags])dnl
+_LT_TAGDECL([CC], [compiler], [1], [A language specific compiler])dnl
+_LT_TAGDECL([with_gcc], [GCC], [0], [Is the compiler the GNU compiler?])dnl
+
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
+
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
+
+# Allow CC to be a program name with arguments.
+compiler=$CC
+])# _LT_TAG_COMPILER
+
+
+# _LT_COMPILER_BOILERPLATE
+# ------------------------
+# Check for compiler boilerplate output or warnings with
+# the simple compiler test code.
+m4_defun([_LT_COMPILER_BOILERPLATE],
+[m4_require([_LT_DECL_SED])dnl
+ac_outfile=conftest.$ac_objext
+echo "$lt_simple_compile_test_code" >conftest.$ac_ext
+eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_compiler_boilerplate=`cat conftest.err`
+$RM conftest*
+])# _LT_COMPILER_BOILERPLATE
+
+
+# _LT_LINKER_BOILERPLATE
+# ----------------------
+# Check for linker boilerplate output or warnings with
+# the simple link test code.
+m4_defun([_LT_LINKER_BOILERPLATE],
+[m4_require([_LT_DECL_SED])dnl
+ac_outfile=conftest.$ac_objext
+echo "$lt_simple_link_test_code" >conftest.$ac_ext
+eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_linker_boilerplate=`cat conftest.err`
+$RM -r conftest*
+])# _LT_LINKER_BOILERPLATE
+
+# _LT_REQUIRED_DARWIN_CHECKS
+# -------------------------
+m4_defun_once([_LT_REQUIRED_DARWIN_CHECKS],[
+  case $host_os in
+    rhapsody* | darwin*)
+    AC_CHECK_TOOL([DSYMUTIL], [dsymutil], [:])
+    AC_CHECK_TOOL([NMEDIT], [nmedit], [:])
+    AC_CHECK_TOOL([LIPO], [lipo], [:])
+    AC_CHECK_TOOL([OTOOL], [otool], [:])
+    AC_CHECK_TOOL([OTOOL64], [otool64], [:])
+    _LT_DECL([], [DSYMUTIL], [1],
+      [Tool to manipulate archived DWARF debug symbol files on Mac OS X])
+    _LT_DECL([], [NMEDIT], [1],
+      [Tool to change global to local symbols on Mac OS X])
+    _LT_DECL([], [LIPO], [1],
+      [Tool to manipulate fat objects and archives on Mac OS X])
+    _LT_DECL([], [OTOOL], [1],
+      [ldd/readelf like tool for Mach-O binaries on Mac OS X])
+    _LT_DECL([], [OTOOL64], [1],
+      [ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4])
+
+    AC_CACHE_CHECK([for -single_module linker flag],[lt_cv_apple_cc_single_mod],
+      [lt_cv_apple_cc_single_mod=no
+      if test -z "${LT_MULTI_MODULE}"; then
+	# By default we will add the -single_module flag. You can override
+	# by either setting the environment variable LT_MULTI_MODULE
+	# non-empty at configure time, or by adding -multi_module to the
+	# link flags.
+	rm -rf libconftest.dylib*
+	echo "int foo(void){return 1;}" > conftest.c
+	echo "$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
+-dynamiclib -Wl,-single_module conftest.c" >&AS_MESSAGE_LOG_FD
+	$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
+	  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err
+        _lt_result=$?
+	if test -f libconftest.dylib && test ! -s conftest.err && test $_lt_result = 0; then
+	  lt_cv_apple_cc_single_mod=yes
+	else
+	  cat conftest.err >&AS_MESSAGE_LOG_FD
+	fi
+	rm -rf libconftest.dylib*
+	rm -f conftest.*
+      fi])
+    AC_CACHE_CHECK([for -exported_symbols_list linker flag],
+      [lt_cv_ld_exported_symbols_list],
+      [lt_cv_ld_exported_symbols_list=no
+      save_LDFLAGS=$LDFLAGS
+      echo "_main" > conftest.sym
+      LDFLAGS="$LDFLAGS -Wl,-exported_symbols_list,conftest.sym"
+      AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],
+	[lt_cv_ld_exported_symbols_list=yes],
+	[lt_cv_ld_exported_symbols_list=no])
+	LDFLAGS="$save_LDFLAGS"
+    ])
+    AC_CACHE_CHECK([for -force_load linker flag],[lt_cv_ld_force_load],
+      [lt_cv_ld_force_load=no
+      cat > conftest.c << _LT_EOF
+int forced_loaded() { return 2;}
+_LT_EOF
+      echo "$LTCC $LTCFLAGS -c -o conftest.o conftest.c" >&AS_MESSAGE_LOG_FD
+      $LTCC $LTCFLAGS -c -o conftest.o conftest.c 2>&AS_MESSAGE_LOG_FD
+      echo "$AR cru libconftest.a conftest.o" >&AS_MESSAGE_LOG_FD
+      $AR cru libconftest.a conftest.o 2>&AS_MESSAGE_LOG_FD
+      echo "$RANLIB libconftest.a" >&AS_MESSAGE_LOG_FD
+      $RANLIB libconftest.a 2>&AS_MESSAGE_LOG_FD
+      cat > conftest.c << _LT_EOF
+int main() { return 0;}
+_LT_EOF
+      echo "$LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a" >&AS_MESSAGE_LOG_FD
+      $LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a 2>conftest.err
+      _lt_result=$?
+      if test -f conftest && test ! -s conftest.err && test $_lt_result = 0 && $GREP forced_load conftest 2>&1 >/dev/null; then
+	lt_cv_ld_force_load=yes
+      else
+	cat conftest.err >&AS_MESSAGE_LOG_FD
+      fi
+        rm -f conftest.err libconftest.a conftest conftest.c
+        rm -rf conftest.dSYM
+    ])
+    case $host_os in
+    rhapsody* | darwin1.[[012]])
+      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;
+    darwin1.*)
+      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+    darwin*) # darwin 5.x on
+      # if running on 10.5 or later, the deployment target defaults
+      # to the OS version, if on x86, and 10.4, the deployment
+      # target defaults to 10.4. Don't you love it?
+      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in
+	10.0,*86*-darwin8*|10.0,*-darwin[[91]]*)
+	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+	10.[[012]]*)
+	  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+	10.*)
+	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+      esac
+    ;;
+  esac
+    if test "$lt_cv_apple_cc_single_mod" = "yes"; then
+      _lt_dar_single_mod='$single_module'
+    fi
+    if test "$lt_cv_ld_exported_symbols_list" = "yes"; then
+      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
+    else
+      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'
+    fi
+    if test "$DSYMUTIL" != ":" && test "$lt_cv_ld_force_load" = "no"; then
+      _lt_dsymutil='~$DSYMUTIL $lib || :'
+    else
+      _lt_dsymutil=
+    fi
+    ;;
+  esac
+])
+
+
+# _LT_DARWIN_LINKER_FEATURES
+# --------------------------
+# Checks for linker and compiler features on darwin
+m4_defun([_LT_DARWIN_LINKER_FEATURES],
+[
+  m4_require([_LT_REQUIRED_DARWIN_CHECKS])
+  _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+  _LT_TAGVAR(hardcode_direct, $1)=no
+  _LT_TAGVAR(hardcode_automatic, $1)=yes
+  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported
+  if test "$lt_cv_ld_force_load" = "yes"; then
+    _LT_TAGVAR(whole_archive_flag_spec, $1)='`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience ${wl}-force_load,$conv\"; done; func_echo_all \"$new_convenience\"`'
+  else
+    _LT_TAGVAR(whole_archive_flag_spec, $1)=''
+  fi
+  _LT_TAGVAR(link_all_deplibs, $1)=yes
+  _LT_TAGVAR(allow_undefined_flag, $1)="$_lt_dar_allow_undefined"
+  case $cc_basename in
+     ifort*) _lt_dar_can_shared=yes ;;
+     *) _lt_dar_can_shared=$GCC ;;
+  esac
+  if test "$_lt_dar_can_shared" = "yes"; then
+    output_verbose_link_cmd=func_echo_all
+    _LT_TAGVAR(archive_cmds, $1)="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
+    _LT_TAGVAR(module_cmds, $1)="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
+    _LT_TAGVAR(archive_expsym_cmds, $1)="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
+    _LT_TAGVAR(module_expsym_cmds, $1)="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
+    m4_if([$1], [CXX],
+[   if test "$lt_cv_apple_cc_single_mod" != "yes"; then
+      _LT_TAGVAR(archive_cmds, $1)="\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dsymutil}"
+      _LT_TAGVAR(archive_expsym_cmds, $1)="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dar_export_syms}${_lt_dsymutil}"
+    fi
+],[])
+  else
+  _LT_TAGVAR(ld_shlibs, $1)=no
+  fi
+])
+
+# _LT_SYS_MODULE_PATH_AIX
+# -----------------------
+# Links a minimal program and checks the executable
+# for the system default hardcoded library path. In most cases,
+# this is /usr/lib:/lib, but when the MPI compilers are used
+# the location of the communication and MPI libs are included too.
+# If we don't find anything, use the default library path according
+# to the aix ld manual.
+m4_defun([_LT_SYS_MODULE_PATH_AIX],
+[m4_require([_LT_DECL_SED])dnl
+AC_LINK_IFELSE(AC_LANG_PROGRAM,[
+lt_aix_libpath_sed='
+    /Import File Strings/,/^$/ {
+	/^0/ {
+	    s/^0  *\(.*\)$/\1/
+	    p
+	}
+    }'
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then
+  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+fi],[])
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
+])# _LT_SYS_MODULE_PATH_AIX
+
+
+# _LT_SHELL_INIT(ARG)
+# -------------------
+m4_define([_LT_SHELL_INIT],
+[m4_divert_text([M4SH-INIT], [$1
+])])# _LT_SHELL_INIT
+
+
+
+# _LT_PROG_ECHO_BACKSLASH
+# -----------------------
+# Find how we can fake an echo command that does not interpret backslash.
+# In particular, with Autoconf 2.60 or later we add some code to the start
+# of the generated configure script which will find a shell with a builtin
+# printf (which we can use as an echo command).
+m4_defun([_LT_PROG_ECHO_BACKSLASH],
+[ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO
+ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO
+
+AC_MSG_CHECKING([how to print strings])
+# Test print first, because it will be a builtin if present.
+if test "X`print -r -- -n 2>/dev/null`" = X-n && \
+   test "X`print -r -- $ECHO 2>/dev/null`" = "X$ECHO"; then
+  ECHO='print -r --'
+elif test "X`printf %s $ECHO 2>/dev/null`" = "X$ECHO"; then
+  ECHO='printf %s\n'
+else
+  # Use this function as a fallback that always works.
+  func_fallback_echo ()
+  {
+    eval 'cat <<_LTECHO_EOF
+$[]1
+_LTECHO_EOF'
+  }
+  ECHO='func_fallback_echo'
+fi
+
+# func_echo_all arg...
+# Invoke $ECHO with all args, space-separated.
+func_echo_all ()
+{
+    $ECHO "$*" 
+}
+
+case "$ECHO" in
+  printf*) AC_MSG_RESULT([printf]) ;;
+  print*) AC_MSG_RESULT([print -r]) ;;
+  *) AC_MSG_RESULT([cat]) ;;
+esac
+
+m4_ifdef([_AS_DETECT_SUGGESTED],
+[_AS_DETECT_SUGGESTED([
+  test -n "${ZSH_VERSION+set}${BASH_VERSION+set}" || (
+    ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO
+    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO
+    PATH=/empty FPATH=/empty; export PATH FPATH
+    test "X`printf %s $ECHO`" = "X$ECHO" \
+      || test "X`print -r -- $ECHO`" = "X$ECHO" )])])
+
+_LT_DECL([], [SHELL], [1], [Shell to use when invoking shell scripts])
+_LT_DECL([], [ECHO], [1], [An echo program that protects backslashes])
+])# _LT_PROG_ECHO_BACKSLASH
+
+
+# _LT_ENABLE_LOCK
+# ---------------
+m4_defun([_LT_ENABLE_LOCK],
+[AC_ARG_ENABLE([libtool-lock],
+  [AS_HELP_STRING([--disable-libtool-lock],
+    [avoid locking (might break parallel builds)])])
+test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
+
+# Some flags need to be propagated to the compiler or linker for good
+# libtool support.
+case $host in
+ia64-*-hpux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if AC_TRY_EVAL(ac_compile); then
+    case `/usr/bin/file conftest.$ac_objext` in
+      *ELF-32*)
+	HPUX_IA64_MODE="32"
+	;;
+      *ELF-64*)
+	HPUX_IA64_MODE="64"
+	;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+*-*-irix6*)
+  # Find out which ABI we are using.
+  echo '[#]line '$LINENO' "configure"' > conftest.$ac_ext
+  if AC_TRY_EVAL(ac_compile); then
+    if test "$lt_cv_prog_gnu_ld" = yes; then
+      case `/usr/bin/file conftest.$ac_objext` in
+	*32-bit*)
+	  LD="${LD-ld} -melf32bsmip"
+	  ;;
+	*N32*)
+	  LD="${LD-ld} -melf32bmipn32"
+	  ;;
+	*64-bit*)
+	  LD="${LD-ld} -melf64bmip"
+	;;
+      esac
+    else
+      case `/usr/bin/file conftest.$ac_objext` in
+	*32-bit*)
+	  LD="${LD-ld} -32"
+	  ;;
+	*N32*)
+	  LD="${LD-ld} -n32"
+	  ;;
+	*64-bit*)
+	  LD="${LD-ld} -64"
+	  ;;
+      esac
+    fi
+  fi
+  rm -rf conftest*
+  ;;
+
+x86_64-*kfreebsd*-gnu|x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*| \
+s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if AC_TRY_EVAL(ac_compile); then
+    case `/usr/bin/file conftest.o` in
+      *32-bit*)
+	case $host in
+	  x86_64-*kfreebsd*-gnu)
+	    LD="${LD-ld} -m elf_i386_fbsd"
+	    ;;
+	  x86_64-*linux*)
+	    LD="${LD-ld} -m elf_i386"
+	    ;;
+	  ppc64-*linux*|powerpc64-*linux*)
+	    LD="${LD-ld} -m elf32ppclinux"
+	    ;;
+	  s390x-*linux*)
+	    LD="${LD-ld} -m elf_s390"
+	    ;;
+	  sparc64-*linux*)
+	    LD="${LD-ld} -m elf32_sparc"
+	    ;;
+	esac
+	;;
+      *64-bit*)
+	case $host in
+	  x86_64-*kfreebsd*-gnu)
+	    LD="${LD-ld} -m elf_x86_64_fbsd"
+	    ;;
+	  x86_64-*linux*)
+	    LD="${LD-ld} -m elf_x86_64"
+	    ;;
+	  ppc*-*linux*|powerpc*-*linux*)
+	    LD="${LD-ld} -m elf64ppc"
+	    ;;
+	  s390*-*linux*|s390*-*tpf*)
+	    LD="${LD-ld} -m elf64_s390"
+	    ;;
+	  sparc*-*linux*)
+	    LD="${LD-ld} -m elf64_sparc"
+	    ;;
+	esac
+	;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+
+*-*-sco3.2v5*)
+  # On SCO OpenServer 5, we need -belf to get full-featured binaries.
+  SAVE_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS -belf"
+  AC_CACHE_CHECK([whether the C compiler needs -belf], lt_cv_cc_needs_belf,
+    [AC_LANG_PUSH(C)
+     AC_LINK_IFELSE([AC_LANG_PROGRAM([[]],[[]])],[lt_cv_cc_needs_belf=yes],[lt_cv_cc_needs_belf=no])
+     AC_LANG_POP])
+  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
+    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
+    CFLAGS="$SAVE_CFLAGS"
+  fi
+  ;;
+sparc*-*solaris*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if AC_TRY_EVAL(ac_compile); then
+    case `/usr/bin/file conftest.o` in
+    *64-bit*)
+      case $lt_cv_prog_gnu_ld in
+      yes*) LD="${LD-ld} -m elf64_sparc" ;;
+      *)
+	if ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then
+	  LD="${LD-ld} -64"
+	fi
+	;;
+      esac
+      ;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+esac
+
+need_locks="$enable_libtool_lock"
+])# _LT_ENABLE_LOCK
+
+
+# _LT_CMD_OLD_ARCHIVE
+# -------------------
+m4_defun([_LT_CMD_OLD_ARCHIVE],
+[AC_CHECK_TOOL(AR, ar, false)
+test -z "$AR" && AR=ar
+test -z "$AR_FLAGS" && AR_FLAGS=cru
+_LT_DECL([], [AR], [1], [The archiver])
+_LT_DECL([], [AR_FLAGS], [1])
+
+AC_CHECK_TOOL(STRIP, strip, :)
+test -z "$STRIP" && STRIP=:
+_LT_DECL([], [STRIP], [1], [A symbol stripping program])
+
+AC_CHECK_TOOL(RANLIB, ranlib, :)
+test -z "$RANLIB" && RANLIB=:
+_LT_DECL([], [RANLIB], [1],
+    [Commands used to install an old-style archive])
+
+# Determine commands to create old-style static archives.
+old_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'
+old_postinstall_cmds='chmod 644 $oldlib'
+old_postuninstall_cmds=
+
+if test -n "$RANLIB"; then
+  case $host_os in
+  openbsd*)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB -t \$oldlib"
+    ;;
+  *)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB \$oldlib"
+    ;;
+  esac
+  old_archive_cmds="$old_archive_cmds~\$RANLIB \$oldlib"
+fi
+
+case $host_os in
+  darwin*)
+    lock_old_archive_extraction=yes ;;
+  *)
+    lock_old_archive_extraction=no ;;
+esac
+_LT_DECL([], [old_postinstall_cmds], [2])
+_LT_DECL([], [old_postuninstall_cmds], [2])
+_LT_TAGDECL([], [old_archive_cmds], [2],
+    [Commands used to build an old-style archive])
+_LT_DECL([], [lock_old_archive_extraction], [0],
+    [Whether to use a lock for old archive extraction])
+])# _LT_CMD_OLD_ARCHIVE
+
+
+# _LT_COMPILER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,
+#		[OUTPUT-FILE], [ACTION-SUCCESS], [ACTION-FAILURE])
+# ----------------------------------------------------------------
+# Check whether the given compiler option works
+AC_DEFUN([_LT_COMPILER_OPTION],
+[m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_SED])dnl
+AC_CACHE_CHECK([$1], [$2],
+  [$2=no
+   m4_if([$4], , [ac_outfile=conftest.$ac_objext], [ac_outfile=$4])
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="$3"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [[^ ]]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&AS_MESSAGE_LOG_FD)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&AS_MESSAGE_LOG_FD
+   echo "$as_me:$LINENO: \$? = $ac_status" >&AS_MESSAGE_LOG_FD
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       $2=yes
+     fi
+   fi
+   $RM conftest*
+])
+
+if test x"[$]$2" = xyes; then
+    m4_if([$5], , :, [$5])
+else
+    m4_if([$6], , :, [$6])
+fi
+])# _LT_COMPILER_OPTION
+
+# Old name:
+AU_ALIAS([AC_LIBTOOL_COMPILER_OPTION], [_LT_COMPILER_OPTION])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_COMPILER_OPTION], [])
+
+
+# _LT_LINKER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,
+#                  [ACTION-SUCCESS], [ACTION-FAILURE])
+# ----------------------------------------------------
+# Check whether the given linker option works
+AC_DEFUN([_LT_LINKER_OPTION],
+[m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_SED])dnl
+AC_CACHE_CHECK([$1], [$2],
+  [$2=no
+   save_LDFLAGS="$LDFLAGS"
+   LDFLAGS="$LDFLAGS $3"
+   echo "$lt_simple_link_test_code" > conftest.$ac_ext
+   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
+     # The linker can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     if test -s conftest.err; then
+       # Append any errors to the config.log.
+       cat conftest.err 1>&AS_MESSAGE_LOG_FD
+       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
+       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+       if diff conftest.exp conftest.er2 >/dev/null; then
+         $2=yes
+       fi
+     else
+       $2=yes
+     fi
+   fi
+   $RM -r conftest*
+   LDFLAGS="$save_LDFLAGS"
+])
+
+if test x"[$]$2" = xyes; then
+    m4_if([$4], , :, [$4])
+else
+    m4_if([$5], , :, [$5])
+fi
+])# _LT_LINKER_OPTION
+
+# Old name:
+AU_ALIAS([AC_LIBTOOL_LINKER_OPTION], [_LT_LINKER_OPTION])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_LINKER_OPTION], [])
+
+
+# LT_CMD_MAX_LEN
+#---------------
+AC_DEFUN([LT_CMD_MAX_LEN],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+# find the maximum length of command line arguments
+AC_MSG_CHECKING([the maximum length of command line arguments])
+AC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl
+  i=0
+  teststring="ABCD"
+
+  case $build_os in
+  msdosdjgpp*)
+    # On DJGPP, this test can blow up pretty badly due to problems in libc
+    # (any single argument exceeding 2000 bytes causes a buffer overrun
+    # during glob expansion).  Even if it were fixed, the result of this
+    # check would be larger than it should be.
+    lt_cv_sys_max_cmd_len=12288;    # 12K is about right
+    ;;
+
+  gnu*)
+    # Under GNU Hurd, this test is not required because there is
+    # no limit to the length of command line arguments.
+    # Libtool will interpret -1 as no limit whatsoever
+    lt_cv_sys_max_cmd_len=-1;
+    ;;
+
+  cygwin* | mingw* | cegcc*)
+    # On Win9x/ME, this test blows up -- it succeeds, but takes
+    # about 5 minutes as the teststring grows exponentially.
+    # Worse, since 9x/ME are not pre-emptively multitasking,
+    # you end up with a "frozen" computer, even though with patience
+    # the test eventually succeeds (with a max line length of 256k).
+    # Instead, let's just punt: use the minimum linelength reported by
+    # all of the supported platforms: 8192 (on NT/2K/XP).
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  mint*)
+    # On MiNT this can take a long time and run out of memory.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  amigaos*)
+    # On AmigaOS with pdksh, this test takes hours, literally.
+    # So we just punt and use a minimum line length of 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
+    # This has been around since 386BSD, at least.  Likely further.
+    if test -x /sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`
+    elif test -x /usr/sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`
+    else
+      lt_cv_sys_max_cmd_len=65536	# usable default for all BSDs
+    fi
+    # And add a safety zone
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
+    ;;
+
+  interix*)
+    # We know the value 262144 and hardcode it with a safety zone (like BSD)
+    lt_cv_sys_max_cmd_len=196608
+    ;;
+
+  osf*)
+    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure
+    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not
+    # nice to cause kernel panics so lets avoid the loop below.
+    # First set a reasonable default.
+    lt_cv_sys_max_cmd_len=16384
+    #
+    if test -x /sbin/sysconfig; then
+      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in
+        *1*) lt_cv_sys_max_cmd_len=-1 ;;
+      esac
+    fi
+    ;;
+  sco3.2v5*)
+    lt_cv_sys_max_cmd_len=102400
+    ;;
+  sysv5* | sco5v6* | sysv4.2uw2*)
+    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`
+    if test -n "$kargmax"; then
+      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[[	 ]]//'`
+    else
+      lt_cv_sys_max_cmd_len=32768
+    fi
+    ;;
+  *)
+    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`
+    if test -n "$lt_cv_sys_max_cmd_len"; then
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
+    else
+      # Make teststring a little bigger before we do anything with it.
+      # a 1K string should be a reasonable start.
+      for i in 1 2 3 4 5 6 7 8 ; do
+        teststring=$teststring$teststring
+      done
+      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}
+      # If test is not a shell built-in, we'll probably end up computing a
+      # maximum length that is only half of the actual maximum length, but
+      # we can't tell.
+      while { test "X"`func_fallback_echo "$teststring$teststring" 2>/dev/null` \
+	         = "X$teststring$teststring"; } >/dev/null 2>&1 &&
+	      test $i != 17 # 1/2 MB should be enough
+      do
+        i=`expr $i + 1`
+        teststring=$teststring$teststring
+      done
+      # Only check the string length outside the loop.
+      lt_cv_sys_max_cmd_len=`expr "X$teststring" : ".*" 2>&1`
+      teststring=
+      # Add a significant safety factor because C++ compilers can tack on
+      # massive amounts of additional arguments before passing them to the
+      # linker.  It appears as though 1/2 is a usable value.
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 2`
+    fi
+    ;;
+  esac
+])
+if test -n $lt_cv_sys_max_cmd_len ; then
+  AC_MSG_RESULT($lt_cv_sys_max_cmd_len)
+else
+  AC_MSG_RESULT(none)
+fi
+max_cmd_len=$lt_cv_sys_max_cmd_len
+_LT_DECL([], [max_cmd_len], [0],
+    [What is the maximum length of a command?])
+])# LT_CMD_MAX_LEN
+
+# Old name:
+AU_ALIAS([AC_LIBTOOL_SYS_MAX_CMD_LEN], [LT_CMD_MAX_LEN])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_SYS_MAX_CMD_LEN], [])
+
+
+# _LT_HEADER_DLFCN
+# ----------------
+m4_defun([_LT_HEADER_DLFCN],
+[AC_CHECK_HEADERS([dlfcn.h], [], [], [AC_INCLUDES_DEFAULT])dnl
+])# _LT_HEADER_DLFCN
+
+
+# _LT_TRY_DLOPEN_SELF (ACTION-IF-TRUE, ACTION-IF-TRUE-W-USCORE,
+#                      ACTION-IF-FALSE, ACTION-IF-CROSS-COMPILING)
+# ----------------------------------------------------------------
+m4_defun([_LT_TRY_DLOPEN_SELF],
+[m4_require([_LT_HEADER_DLFCN])dnl
+if test "$cross_compiling" = yes; then :
+  [$4]
+else
+  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+  lt_status=$lt_dlunknown
+  cat > conftest.$ac_ext <<_LT_EOF
+[#line $LINENO "configure"
+#include "confdefs.h"
+
+#if HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
+
+#include <stdio.h>
+
+#ifdef RTLD_GLOBAL
+#  define LT_DLGLOBAL		RTLD_GLOBAL
+#else
+#  ifdef DL_GLOBAL
+#    define LT_DLGLOBAL		DL_GLOBAL
+#  else
+#    define LT_DLGLOBAL		0
+#  endif
+#endif
+
+/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#ifndef LT_DLLAZY_OR_NOW
+#  ifdef RTLD_LAZY
+#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
+#  else
+#    ifdef DL_LAZY
+#      define LT_DLLAZY_OR_NOW		DL_LAZY
+#    else
+#      ifdef RTLD_NOW
+#        define LT_DLLAZY_OR_NOW	RTLD_NOW
+#      else
+#        ifdef DL_NOW
+#          define LT_DLLAZY_OR_NOW	DL_NOW
+#        else
+#          define LT_DLLAZY_OR_NOW	0
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+
+/* When -fvisbility=hidden is used, assume the code has been annotated
+   correspondingly for the symbols needed.  */
+#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
+void fnord () __attribute__((visibility("default")));
+#endif
+
+void fnord () { int i=42; }
+int main ()
+{
+  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
+  int status = $lt_dlunknown;
+
+  if (self)
+    {
+      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
+      else
+        {
+	  if (dlsym( self,"_fnord"))  status = $lt_dlneed_uscore;
+          else puts (dlerror ());
+	}
+      /* dlclose (self); */
+    }
+  else
+    puts (dlerror ());
+
+  return status;
+}]
+_LT_EOF
+  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext} 2>/dev/null; then
+    (./conftest; exit; ) >&AS_MESSAGE_LOG_FD 2>/dev/null
+    lt_status=$?
+    case x$lt_status in
+      x$lt_dlno_uscore) $1 ;;
+      x$lt_dlneed_uscore) $2 ;;
+      x$lt_dlunknown|x*) $3 ;;
+    esac
+  else :
+    # compilation failed
+    $3
+  fi
+fi
+rm -fr conftest*
+])# _LT_TRY_DLOPEN_SELF
+
+
+# LT_SYS_DLOPEN_SELF
+# ------------------
+AC_DEFUN([LT_SYS_DLOPEN_SELF],
+[m4_require([_LT_HEADER_DLFCN])dnl
+if test "x$enable_dlopen" != xyes; then
+  enable_dlopen=unknown
+  enable_dlopen_self=unknown
+  enable_dlopen_self_static=unknown
+else
+  lt_cv_dlopen=no
+  lt_cv_dlopen_libs=
+
+  case $host_os in
+  beos*)
+    lt_cv_dlopen="load_add_on"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+    ;;
+
+  mingw* | pw32* | cegcc*)
+    lt_cv_dlopen="LoadLibrary"
+    lt_cv_dlopen_libs=
+    ;;
+
+  cygwin*)
+    lt_cv_dlopen="dlopen"
+    lt_cv_dlopen_libs=
+    ;;
+
+  darwin*)
+  # if libdl is installed we need to link against it
+    AC_CHECK_LIB([dl], [dlopen],
+		[lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"],[
+    lt_cv_dlopen="dyld"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+    ])
+    ;;
+
+  *)
+    AC_CHECK_FUNC([shl_load],
+	  [lt_cv_dlopen="shl_load"],
+      [AC_CHECK_LIB([dld], [shl_load],
+	    [lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-ldld"],
+	[AC_CHECK_FUNC([dlopen],
+	      [lt_cv_dlopen="dlopen"],
+	  [AC_CHECK_LIB([dl], [dlopen],
+		[lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"],
+	    [AC_CHECK_LIB([svld], [dlopen],
+		  [lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"],
+	      [AC_CHECK_LIB([dld], [dld_link],
+		    [lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-ldld"])
+	      ])
+	    ])
+	  ])
+	])
+      ])
+    ;;
+  esac
+
+  if test "x$lt_cv_dlopen" != xno; then
+    enable_dlopen=yes
+  else
+    enable_dlopen=no
+  fi
+
+  case $lt_cv_dlopen in
+  dlopen)
+    save_CPPFLAGS="$CPPFLAGS"
+    test "x$ac_cv_header_dlfcn_h" = xyes && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
+
+    save_LDFLAGS="$LDFLAGS"
+    wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
+
+    save_LIBS="$LIBS"
+    LIBS="$lt_cv_dlopen_libs $LIBS"
+
+    AC_CACHE_CHECK([whether a program can dlopen itself],
+	  lt_cv_dlopen_self, [dnl
+	  _LT_TRY_DLOPEN_SELF(
+	    lt_cv_dlopen_self=yes, lt_cv_dlopen_self=yes,
+	    lt_cv_dlopen_self=no, lt_cv_dlopen_self=cross)
+    ])
+
+    if test "x$lt_cv_dlopen_self" = xyes; then
+      wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $lt_prog_compiler_static\"
+      AC_CACHE_CHECK([whether a statically linked program can dlopen itself],
+	  lt_cv_dlopen_self_static, [dnl
+	  _LT_TRY_DLOPEN_SELF(
+	    lt_cv_dlopen_self_static=yes, lt_cv_dlopen_self_static=yes,
+	    lt_cv_dlopen_self_static=no,  lt_cv_dlopen_self_static=cross)
+      ])
+    fi
+
+    CPPFLAGS="$save_CPPFLAGS"
+    LDFLAGS="$save_LDFLAGS"
+    LIBS="$save_LIBS"
+    ;;
+  esac
+
+  case $lt_cv_dlopen_self in
+  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;
+  *) enable_dlopen_self=unknown ;;
+  esac
+
+  case $lt_cv_dlopen_self_static in
+  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;
+  *) enable_dlopen_self_static=unknown ;;
+  esac
+fi
+_LT_DECL([dlopen_support], [enable_dlopen], [0],
+	 [Whether dlopen is supported])
+_LT_DECL([dlopen_self], [enable_dlopen_self], [0],
+	 [Whether dlopen of programs is supported])
+_LT_DECL([dlopen_self_static], [enable_dlopen_self_static], [0],
+	 [Whether dlopen of statically linked programs is supported])
+])# LT_SYS_DLOPEN_SELF
+
+# Old name:
+AU_ALIAS([AC_LIBTOOL_DLOPEN_SELF], [LT_SYS_DLOPEN_SELF])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_DLOPEN_SELF], [])
+
+
+# _LT_COMPILER_C_O([TAGNAME])
+# ---------------------------
+# Check to see if options -c and -o are simultaneously supported by compiler.
+# This macro does not hard code the compiler like AC_PROG_CC_C_O.
+m4_defun([_LT_COMPILER_C_O],
+[m4_require([_LT_DECL_SED])dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_TAG_COMPILER])dnl
+AC_CACHE_CHECK([if $compiler supports -c -o file.$ac_objext],
+  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)],
+  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=no
+   $RM -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [[^ ]]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&AS_MESSAGE_LOG_FD)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&AS_MESSAGE_LOG_FD
+   echo "$as_me:$LINENO: \$? = $ac_status" >&AS_MESSAGE_LOG_FD
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       _LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes
+     fi
+   fi
+   chmod u+w . 2>&AS_MESSAGE_LOG_FD
+   $RM conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
+   $RM out/* && rmdir out
+   cd ..
+   $RM -r conftest
+   $RM conftest*
+])
+_LT_TAGDECL([compiler_c_o], [lt_cv_prog_compiler_c_o], [1],
+	[Does compiler simultaneously support -c and -o options?])
+])# _LT_COMPILER_C_O
+
+
+# _LT_COMPILER_FILE_LOCKS([TAGNAME])
+# ----------------------------------
+# Check to see if we can do hard links to lock some files if needed
+m4_defun([_LT_COMPILER_FILE_LOCKS],
+[m4_require([_LT_ENABLE_LOCK])dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+_LT_COMPILER_C_O([$1])
+
+hard_links="nottested"
+if test "$_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)" = no && test "$need_locks" != no; then
+  # do not overwrite the value of need_locks provided by the user
+  AC_MSG_CHECKING([if we can lock with hard links])
+  hard_links=yes
+  $RM conftest*
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  touch conftest.a
+  ln conftest.a conftest.b 2>&5 || hard_links=no
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  AC_MSG_RESULT([$hard_links])
+  if test "$hard_links" = no; then
+    AC_MSG_WARN([`$CC' does not support `-c -o', so `make -j' may be unsafe])
+    need_locks=warn
+  fi
+else
+  need_locks=no
+fi
+_LT_DECL([], [need_locks], [1], [Must we lock files when doing compilation?])
+])# _LT_COMPILER_FILE_LOCKS
+
+
+# _LT_CHECK_OBJDIR
+# ----------------
+m4_defun([_LT_CHECK_OBJDIR],
+[AC_CACHE_CHECK([for objdir], [lt_cv_objdir],
+[rm -f .libs 2>/dev/null
+mkdir .libs 2>/dev/null
+if test -d .libs; then
+  lt_cv_objdir=.libs
+else
+  # MS-DOS does not allow filenames that begin with a dot.
+  lt_cv_objdir=_libs
+fi
+rmdir .libs 2>/dev/null])
+objdir=$lt_cv_objdir
+_LT_DECL([], [objdir], [0],
+         [The name of the directory that contains temporary libtool files])dnl
+m4_pattern_allow([LT_OBJDIR])dnl
+AC_DEFINE_UNQUOTED(LT_OBJDIR, "$lt_cv_objdir/",
+  [Define to the sub-directory in which libtool stores uninstalled libraries.])
+])# _LT_CHECK_OBJDIR
+
+
+# _LT_LINKER_HARDCODE_LIBPATH([TAGNAME])
+# --------------------------------------
+# Check hardcoding attributes.
+m4_defun([_LT_LINKER_HARDCODE_LIBPATH],
+[AC_MSG_CHECKING([how to hardcode library paths into programs])
+_LT_TAGVAR(hardcode_action, $1)=
+if test -n "$_LT_TAGVAR(hardcode_libdir_flag_spec, $1)" ||
+   test -n "$_LT_TAGVAR(runpath_var, $1)" ||
+   test "X$_LT_TAGVAR(hardcode_automatic, $1)" = "Xyes" ; then
+
+  # We can hardcode non-existent directories.
+  if test "$_LT_TAGVAR(hardcode_direct, $1)" != no &&
+     # If the only mechanism to avoid hardcoding is shlibpath_var, we
+     # have to relink, otherwise we might link with an installed library
+     # when we should be linking with a yet-to-be-installed one
+     ## test "$_LT_TAGVAR(hardcode_shlibpath_var, $1)" != no &&
+     test "$_LT_TAGVAR(hardcode_minus_L, $1)" != no; then
+    # Linking always hardcodes the temporary library directory.
+    _LT_TAGVAR(hardcode_action, $1)=relink
+  else
+    # We can link without hardcoding, and we can hardcode nonexisting dirs.
+    _LT_TAGVAR(hardcode_action, $1)=immediate
+  fi
+else
+  # We cannot hardcode anything, or else we can only hardcode existing
+  # directories.
+  _LT_TAGVAR(hardcode_action, $1)=unsupported
+fi
+AC_MSG_RESULT([$_LT_TAGVAR(hardcode_action, $1)])
+
+if test "$_LT_TAGVAR(hardcode_action, $1)" = relink ||
+   test "$_LT_TAGVAR(inherit_rpath, $1)" = yes; then
+  # Fast installation is not supported
+  enable_fast_install=no
+elif test "$shlibpath_overrides_runpath" = yes ||
+     test "$enable_shared" = no; then
+  # Fast installation is not necessary
+  enable_fast_install=needless
+fi
+_LT_TAGDECL([], [hardcode_action], [0],
+    [How to hardcode a shared library path into an executable])
+])# _LT_LINKER_HARDCODE_LIBPATH
+
+
+# _LT_CMD_STRIPLIB
+# ----------------
+m4_defun([_LT_CMD_STRIPLIB],
+[m4_require([_LT_DECL_EGREP])
+striplib=
+old_striplib=
+AC_MSG_CHECKING([whether stripping libraries is possible])
+if test -n "$STRIP" && $STRIP -V 2>&1 | $GREP "GNU strip" >/dev/null; then
+  test -z "$old_striplib" && old_striplib="$STRIP --strip-debug"
+  test -z "$striplib" && striplib="$STRIP --strip-unneeded"
+  AC_MSG_RESULT([yes])
+else
+# FIXME - insert some real tests, host_os isn't really good enough
+  case $host_os in
+  darwin*)
+    if test -n "$STRIP" ; then
+      striplib="$STRIP -x"
+      old_striplib="$STRIP -S"
+      AC_MSG_RESULT([yes])
+    else
+      AC_MSG_RESULT([no])
+    fi
+    ;;
+  *)
+    AC_MSG_RESULT([no])
+    ;;
+  esac
+fi
+_LT_DECL([], [old_striplib], [1], [Commands to strip libraries])
+_LT_DECL([], [striplib], [1])
+])# _LT_CMD_STRIPLIB
+
+
+# _LT_SYS_DYNAMIC_LINKER([TAG])
+# -----------------------------
+# PORTME Fill in your ld.so characteristics
+m4_defun([_LT_SYS_DYNAMIC_LINKER],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+m4_require([_LT_DECL_EGREP])dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_OBJDUMP])dnl
+m4_require([_LT_DECL_SED])dnl
+m4_require([_LT_CHECK_SHELL_FEATURES])dnl
+AC_MSG_CHECKING([dynamic linker characteristics])
+m4_if([$1],
+	[], [
+if test "$GCC" = yes; then
+  case $host_os in
+    darwin*) lt_awk_arg="/^libraries:/,/LR/" ;;
+    *) lt_awk_arg="/^libraries:/" ;;
+  esac
+  case $host_os in
+    mingw* | cegcc*) lt_sed_strip_eq="s,=\([[A-Za-z]]:\),\1,g" ;;
+    *) lt_sed_strip_eq="s,=/,/,g" ;;
+  esac
+  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e "s/^libraries://" -e $lt_sed_strip_eq`
+  case $lt_search_path_spec in
+  *\;*)
+    # if the path contains ";" then we assume it to be the separator
+    # otherwise default to the standard path separator (i.e. ":") - it is
+    # assumed that no part of a normal pathname contains ";" but that should
+    # okay in the real world where ";" in dirpaths is itself problematic.
+    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED 's/;/ /g'`
+    ;;
+  *)
+    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED "s/$PATH_SEPARATOR/ /g"`
+    ;;
+  esac
+  # Ok, now we have the path, separated by spaces, we can step through it
+  # and add multilib dir if necessary.
+  lt_tmp_lt_search_path_spec=
+  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`
+  for lt_sys_path in $lt_search_path_spec; do
+    if test -d "$lt_sys_path/$lt_multi_os_dir"; then
+      lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir"
+    else
+      test -d "$lt_sys_path" && \
+	lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path"
+    fi
+  done
+  lt_search_path_spec=`$ECHO "$lt_tmp_lt_search_path_spec" | awk '
+BEGIN {RS=" "; FS="/|\n";} {
+  lt_foo="";
+  lt_count=0;
+  for (lt_i = NF; lt_i > 0; lt_i--) {
+    if ($lt_i != "" && $lt_i != ".") {
+      if ($lt_i == "..") {
+        lt_count++;
+      } else {
+        if (lt_count == 0) {
+          lt_foo="/" $lt_i lt_foo;
+        } else {
+          lt_count--;
+        }
+      }
+    }
+  }
+  if (lt_foo != "") { lt_freq[[lt_foo]]++; }
+  if (lt_freq[[lt_foo]] == 1) { print lt_foo; }
+}'`
+  # AWK program above erroneously prepends '/' to C:/dos/paths
+  # for these hosts.
+  case $host_os in
+    mingw* | cegcc*) lt_search_path_spec=`$ECHO "$lt_search_path_spec" |\
+      $SED 's,/\([[A-Za-z]]:\),\1,g'` ;;
+  esac
+  sys_lib_search_path_spec=`$ECHO "$lt_search_path_spec" | $lt_NL2SP`
+else
+  sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
+fi])
+library_names_spec=
+libname_spec='lib$name'
+soname_spec=
+shrext_cmds=".so"
+postinstall_cmds=
+postuninstall_cmds=
+finish_cmds=
+finish_eval=
+shlibpath_var=
+shlibpath_overrides_runpath=unknown
+version_type=none
+dynamic_linker="$host_os ld.so"
+sys_lib_dlsearch_path_spec="/lib /usr/lib"
+need_lib_prefix=unknown
+hardcode_into_libs=no
+
+# when you set need_version to no, make sure it does not cause -set_version
+# flags to be left without arguments
+need_version=unknown
+
+case $host_os in
+aix3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
+  shlibpath_var=LIBPATH
+
+  # AIX 3 has no versioning support, so we append a major version to the name.
+  soname_spec='${libname}${release}${shared_ext}$major'
+  ;;
+
+aix[[4-9]]*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  hardcode_into_libs=yes
+  if test "$host_cpu" = ia64; then
+    # AIX 5 supports IA64
+    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+    shlibpath_var=LD_LIBRARY_PATH
+  else
+    # With GCC up to 2.95.x, collect2 would create an import file
+    # for dependence libraries.  The import file would start with
+    # the line `#! .'.  This would cause the generated library to
+    # depend on `.', always an invalid library.  This was fixed in
+    # development snapshots of GCC prior to 3.0.
+    case $host_os in
+      aix4 | aix4.[[01]] | aix4.[[01]].*)
+      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
+	   echo ' yes '
+	   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then
+	:
+      else
+	can_build_shared=no
+      fi
+      ;;
+    esac
+    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
+    # soname into executable. Probably we can add versioning support to
+    # collect2, so additional links can be useful in future.
+    if test "$aix_use_runtimelinking" = yes; then
+      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
+      # instead of lib<name>.a to let people know that these are not
+      # typical AIX shared libraries.
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    else
+      # We preserve .a as extension for shared libraries through AIX4.2
+      # and later when we are not doing run time linking.
+      library_names_spec='${libname}${release}.a $libname.a'
+      soname_spec='${libname}${release}${shared_ext}$major'
+    fi
+    shlibpath_var=LIBPATH
+  fi
+  ;;
+
+amigaos*)
+  case $host_cpu in
+  powerpc)
+    # Since July 2007 AmigaOS4 officially supports .so libraries.
+    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    ;;
+  m68k)
+    library_names_spec='$libname.ixlibrary $libname.a'
+    # Create ${libname}_ixlibrary.a entries in /sys/libs.
+    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all "$lib" | $SED '\''s%^.*/\([[^/]]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
+    ;;
+  esac
+  ;;
+
+beos*)
+  library_names_spec='${libname}${shared_ext}'
+  dynamic_linker="$host_os ld.so"
+  shlibpath_var=LIBRARY_PATH
+  ;;
+
+bsdi[[45]]*)
+  version_type=linux
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
+  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
+  # the default ld.so.conf also contains /usr/contrib/lib and
+  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
+  # libtool to hard-code these into programs
+  ;;
+
+cygwin* | mingw* | pw32* | cegcc*)
+  version_type=windows
+  shrext_cmds=".dll"
+  need_version=no
+  need_lib_prefix=no
+
+  case $GCC,$host_os in
+  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+    library_names_spec='$libname.dll.a'
+    # DLL is installed to $(libdir)/../bin by postinstall_cmds
+    postinstall_cmds='base_file=`basename \${file}`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
+      dldir=$destdir/`dirname \$dlpath`~
+      test -d \$dldir || mkdir -p \$dldir~
+      $install_prog $dir/$dlname \$dldir/$dlname~
+      chmod a+x \$dldir/$dlname~
+      if test -n '\''$stripme'\'' && test -n '\''$striplib'\''; then
+        eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
+      fi'
+    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
+      dlpath=$dir/\$dldll~
+       $RM \$dlpath'
+    shlibpath_overrides_runpath=yes
+
+    case $host_os in
+    cygwin*)
+      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
+      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
+m4_if([$1], [],[
+      sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"])
+      ;;
+    mingw* | cegcc*)
+      # MinGW DLLs use traditional 'lib' prefix
+      soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    pw32*)
+      # pw32 DLLs use 'pw' prefix rather than 'lib'
+      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    esac
+    ;;
+
+  *)
+    library_names_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext} $libname.lib'
+    ;;
+  esac
+  dynamic_linker='Win32 ld.exe'
+  # FIXME: first we should search . and the directory the executable is in
+  shlibpath_var=PATH
+  ;;
+
+darwin* | rhapsody*)
+  dynamic_linker="$host_os dyld"
+  version_type=darwin
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
+  soname_spec='${libname}${release}${major}$shared_ext'
+  shlibpath_overrides_runpath=yes
+  shlibpath_var=DYLD_LIBRARY_PATH
+  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
+m4_if([$1], [],[
+  sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/local/lib"])
+  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'
+  ;;
+
+dgux*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+freebsd1*)
+  dynamic_linker=no
+  ;;
+
+freebsd* | dragonfly*)
+  # DragonFly does not have aout.  When/if they implement a new
+  # versioning mechanism, adjust this.
+  if test -x /usr/bin/objformat; then
+    objformat=`/usr/bin/objformat`
+  else
+    case $host_os in
+    freebsd[[123]]*) objformat=aout ;;
+    *) objformat=elf ;;
+    esac
+  fi
+  version_type=freebsd-$objformat
+  case $version_type in
+    freebsd-elf*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+      need_version=no
+      need_lib_prefix=no
+      ;;
+    freebsd-*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
+      need_version=yes
+      ;;
+  esac
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_os in
+  freebsd2*)
+    shlibpath_overrides_runpath=yes
+    ;;
+  freebsd3.[[01]]* | freebsdelf3.[[01]]*)
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  freebsd3.[[2-9]]* | freebsdelf3.[[2-9]]* | \
+  freebsd4.[[0-5]] | freebsdelf4.[[0-5]] | freebsd4.1.1 | freebsdelf4.1.1)
+    shlibpath_overrides_runpath=no
+    hardcode_into_libs=yes
+    ;;
+  *) # from 4.6 on, and DragonFly
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  esac
+  ;;
+
+gnu*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  hardcode_into_libs=yes
+  ;;
+
+haiku*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  dynamic_linker="$host_os runtime_loader"
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/system/lib'
+  hardcode_into_libs=yes
+  ;;
+
+hpux9* | hpux10* | hpux11*)
+  # Give a soname corresponding to the major version so that dld.sl refuses to
+  # link against other versions.
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  case $host_cpu in
+  ia64*)
+    shrext_cmds='.so'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.so"
+    shlibpath_var=LD_LIBRARY_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    if test "X$HPUX_IA64_MODE" = X32; then
+      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
+    else
+      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
+    fi
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  hppa*64*)
+    shrext_cmds='.sl'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  *)
+    shrext_cmds='.sl'
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=SHLIB_PATH
+    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    ;;
+  esac
+  # HP-UX runs *really* slowly unless shared libraries are mode 555, ...
+  postinstall_cmds='chmod 555 $lib'
+  # or fails outright, so override atomically:
+  install_override_mode=555
+  ;;
+
+interix[[3-9]]*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $host_os in
+    nonstopux*) version_type=nonstopux ;;
+    *)
+	if test "$lt_cv_prog_gnu_ld" = yes; then
+		version_type=linux
+	else
+		version_type=irix
+	fi ;;
+  esac
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
+  case $host_os in
+  irix5* | nonstopux*)
+    libsuff= shlibsuff=
+    ;;
+  *)
+    case $LD in # libtool.m4 will add one of these switches to LD
+    *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ")
+      libsuff= shlibsuff= libmagic=32-bit;;
+    *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ")
+      libsuff=32 shlibsuff=N32 libmagic=N32;;
+    *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ")
+      libsuff=64 shlibsuff=64 libmagic=64-bit;;
+    *) libsuff= shlibsuff= libmagic=never-match;;
+    esac
+    ;;
+  esac
+  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
+  shlibpath_overrides_runpath=no
+  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
+  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
+  hardcode_into_libs=yes
+  ;;
+
+# No shared lib support for Linux oldld, aout, or coff.
+linux*oldld* | linux*aout* | linux*coff*)
+  dynamic_linker=no
+  ;;
+
+# This must be Linux ELF.
+linux* | k*bsd*-gnu | kopensolaris*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+
+  # Some binutils ld are patched to set DT_RUNPATH
+  AC_CACHE_VAL([lt_cv_shlibpath_overrides_runpath],
+    [lt_cv_shlibpath_overrides_runpath=no
+    save_LDFLAGS=$LDFLAGS
+    save_libdir=$libdir
+    eval "libdir=/foo; wl=\"$_LT_TAGVAR(lt_prog_compiler_wl, $1)\"; \
+	 LDFLAGS=\"\$LDFLAGS $_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\""
+    AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],
+      [AS_IF([ ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null],
+	 [lt_cv_shlibpath_overrides_runpath=yes])])
+    LDFLAGS=$save_LDFLAGS
+    libdir=$save_libdir
+    ])
+  shlibpath_overrides_runpath=$lt_cv_shlibpath_overrides_runpath
+
+  # This implies no fast_install, which is unacceptable.
+  # Some rework will be needed to allow for fast_install
+  # before this can be enabled.
+  hardcode_into_libs=yes
+
+  # Append ld.so.conf contents to the search path
+  if test -f /etc/ld.so.conf; then
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \[$]2)); skip = 1; } { if (!skip) print \[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/"//g;/^$/d' | tr '\n' ' '`
+    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
+  fi
+
+  # We used to test for /lib/ld.so.1 and disable shared libraries on
+  # powerpc, because MkLinux only supported shared libraries with the
+  # GNU dynamic linker.  Since this was broken with cross compilers,
+  # most powerpc-linux boxes support dynamic linking these days and
+  # people can always --disable-shared, the test was removed, and we
+  # assume the GNU/Linux dynamic linker is in use.
+  dynamic_linker='GNU/Linux ld.so'
+  ;;
+
+netbsd*)
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+    dynamic_linker='NetBSD (a.out) ld.so'
+  else
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    dynamic_linker='NetBSD ld.elf_so'
+  fi
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  ;;
+
+newsos6)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  ;;
+
+*nto* | *qnx*)
+  version_type=qnx
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='ldqnx.so'
+  ;;
+
+openbsd*)
+  version_type=sunos
+  sys_lib_dlsearch_path_spec="/usr/lib"
+  need_lib_prefix=no
+  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
+  case $host_os in
+    openbsd3.3 | openbsd3.3.*)	need_version=yes ;;
+    *)				need_version=no  ;;
+  esac
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    case $host_os in
+      openbsd2.[[89]] | openbsd2.[[89]].*)
+	shlibpath_overrides_runpath=no
+	;;
+      *)
+	shlibpath_overrides_runpath=yes
+	;;
+      esac
+  else
+    shlibpath_overrides_runpath=yes
+  fi
+  ;;
+
+os2*)
+  libname_spec='$name'
+  shrext_cmds=".dll"
+  need_lib_prefix=no
+  library_names_spec='$libname${shared_ext} $libname.a'
+  dynamic_linker='OS/2 ld.exe'
+  shlibpath_var=LIBPATH
+  ;;
+
+osf3* | osf4* | osf5*)
+  version_type=osf
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
+  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
+  ;;
+
+rdos*)
+  dynamic_linker=no
+  ;;
+
+solaris*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  # ldd complains unless libraries are executable
+  postinstall_cmds='chmod +x $lib'
+  ;;
+
+sunos4*)
+  version_type=sunos
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  if test "$with_gnu_ld" = yes; then
+    need_lib_prefix=no
+  fi
+  need_version=yes
+  ;;
+
+sysv4 | sysv4.3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_vendor in
+    sni)
+      shlibpath_overrides_runpath=no
+      need_lib_prefix=no
+      runpath_var=LD_RUN_PATH
+      ;;
+    siemens)
+      need_lib_prefix=no
+      ;;
+    motorola)
+      need_lib_prefix=no
+      need_version=no
+      shlibpath_overrides_runpath=no
+      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
+      ;;
+  esac
+  ;;
+
+sysv4*MP*)
+  if test -d /usr/nec ;then
+    version_type=linux
+    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
+    soname_spec='$libname${shared_ext}.$major'
+    shlibpath_var=LD_LIBRARY_PATH
+  fi
+  ;;
+
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  version_type=freebsd-elf
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  if test "$with_gnu_ld" = yes; then
+    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
+  else
+    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
+    case $host_os in
+      sco3.2v5*)
+        sys_lib_search_path_spec="$sys_lib_search_path_spec /lib"
+	;;
+    esac
+  fi
+  sys_lib_dlsearch_path_spec='/usr/lib'
+  ;;
+
+tpf*)
+  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+uts4*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+*)
+  dynamic_linker=no
+  ;;
+esac
+AC_MSG_RESULT([$dynamic_linker])
+test "$dynamic_linker" = no && can_build_shared=no
+
+variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
+if test "$GCC" = yes; then
+  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
+fi
+
+if test "${lt_cv_sys_lib_search_path_spec+set}" = set; then
+  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
+fi
+if test "${lt_cv_sys_lib_dlsearch_path_spec+set}" = set; then
+  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
+fi
+
+_LT_DECL([], [variables_saved_for_relink], [1],
+    [Variables whose values should be saved in libtool wrapper scripts and
+    restored at link time])
+_LT_DECL([], [need_lib_prefix], [0],
+    [Do we need the "lib" prefix for modules?])
+_LT_DECL([], [need_version], [0], [Do we need a version for libraries?])
+_LT_DECL([], [version_type], [0], [Library versioning type])
+_LT_DECL([], [runpath_var], [0],  [Shared library runtime path variable])
+_LT_DECL([], [shlibpath_var], [0],[Shared library path variable])
+_LT_DECL([], [shlibpath_overrides_runpath], [0],
+    [Is shlibpath searched before the hard-coded library search path?])
+_LT_DECL([], [libname_spec], [1], [Format of library name prefix])
+_LT_DECL([], [library_names_spec], [1],
+    [[List of archive names.  First name is the real one, the rest are links.
+    The last name is the one that the linker finds with -lNAME]])
+_LT_DECL([], [soname_spec], [1],
+    [[The coded name of the library, if different from the real name]])
+_LT_DECL([], [install_override_mode], [1],
+    [Permission mode override for installation of shared libraries])
+_LT_DECL([], [postinstall_cmds], [2],
+    [Command to use after installation of a shared archive])
+_LT_DECL([], [postuninstall_cmds], [2],
+    [Command to use after uninstallation of a shared archive])
+_LT_DECL([], [finish_cmds], [2],
+    [Commands used to finish a libtool library installation in a directory])
+_LT_DECL([], [finish_eval], [1],
+    [[As "finish_cmds", except a single script fragment to be evaled but
+    not shown]])
+_LT_DECL([], [hardcode_into_libs], [0],
+    [Whether we should hardcode library paths into libraries])
+_LT_DECL([], [sys_lib_search_path_spec], [2],
+    [Compile-time system search path for libraries])
+_LT_DECL([], [sys_lib_dlsearch_path_spec], [2],
+    [Run-time system search path for libraries])
+])# _LT_SYS_DYNAMIC_LINKER
+
+
+# _LT_PATH_TOOL_PREFIX(TOOL)
+# --------------------------
+# find a file program which can recognize shared library
+AC_DEFUN([_LT_PATH_TOOL_PREFIX],
+[m4_require([_LT_DECL_EGREP])dnl
+AC_MSG_CHECKING([for $1])
+AC_CACHE_VAL(lt_cv_path_MAGIC_CMD,
+[case $MAGIC_CMD in
+[[\\/*] |  ?:[\\/]*])
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  ;;
+*)
+  lt_save_MAGIC_CMD="$MAGIC_CMD"
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+dnl $ac_dummy forces splitting on constant user-supplied paths.
+dnl POSIX.2 word splitting is done only on the output of word expansions,
+dnl not every word.  This closes a longstanding sh security hole.
+  ac_dummy="m4_if([$2], , $PATH, [$2])"
+  for ac_dir in $ac_dummy; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$1; then
+      lt_cv_path_MAGIC_CMD="$ac_dir/$1"
+      if test -n "$file_magic_test_file"; then
+	case $deplibs_check_method in
+	"file_magic "*)
+	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
+	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
+	    $EGREP "$file_magic_regex" > /dev/null; then
+	    :
+	  else
+	    cat <<_LT_EOF 1>&2
+
+*** Warning: the command libtool uses to detect shared libraries,
+*** $file_magic_cmd, produces output that libtool cannot recognize.
+*** The result is that libtool may fail to recognize shared libraries
+*** as such.  This will affect the creation of libtool libraries that
+*** depend on shared libraries, but programs linked with such libtool
+*** libraries will work regardless of this problem.  Nevertheless, you
+*** may want to report the problem to your system manager and/or to
+*** bug-libtool@gnu.org
+
+_LT_EOF
+	  fi ;;
+	esac
+      fi
+      break
+    fi
+  done
+  IFS="$lt_save_ifs"
+  MAGIC_CMD="$lt_save_MAGIC_CMD"
+  ;;
+esac])
+MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+if test -n "$MAGIC_CMD"; then
+  AC_MSG_RESULT($MAGIC_CMD)
+else
+  AC_MSG_RESULT(no)
+fi
+_LT_DECL([], [MAGIC_CMD], [0],
+	 [Used to examine libraries when file_magic_cmd begins with "file"])dnl
+])# _LT_PATH_TOOL_PREFIX
+
+# Old name:
+AU_ALIAS([AC_PATH_TOOL_PREFIX], [_LT_PATH_TOOL_PREFIX])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_PATH_TOOL_PREFIX], [])
+
+
+# _LT_PATH_MAGIC
+# --------------
+# find a file program which can recognize a shared library
+m4_defun([_LT_PATH_MAGIC],
+[_LT_PATH_TOOL_PREFIX(${ac_tool_prefix}file, /usr/bin$PATH_SEPARATOR$PATH)
+if test -z "$lt_cv_path_MAGIC_CMD"; then
+  if test -n "$ac_tool_prefix"; then
+    _LT_PATH_TOOL_PREFIX(file, /usr/bin$PATH_SEPARATOR$PATH)
+  else
+    MAGIC_CMD=:
+  fi
+fi
+])# _LT_PATH_MAGIC
+
+
+# LT_PATH_LD
+# ----------
+# find the pathname to the GNU or non-GNU linker
+AC_DEFUN([LT_PATH_LD],
+[AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_REQUIRE([AC_CANONICAL_BUILD])dnl
+m4_require([_LT_DECL_SED])dnl
+m4_require([_LT_DECL_EGREP])dnl
+m4_require([_LT_PROG_ECHO_BACKSLASH])dnl
+
+AC_ARG_WITH([gnu-ld],
+    [AS_HELP_STRING([--with-gnu-ld],
+	[assume the C compiler uses GNU ld @<:@default=no@:>@])],
+    [test "$withval" = no || with_gnu_ld=yes],
+    [with_gnu_ld=no])dnl
+
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  AC_MSG_CHECKING([for ld used by $CC])
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [[\\/]]* | ?:[[\\/]]*)
+      re_direlt='/[[^/]][[^/]]*/\.\./'
+      # Canonicalize the pathname of ld
+      ac_prog=`$ECHO "$ac_prog"| $SED 's%\\\\%/%g'`
+      while $ECHO "$ac_prog" | $GREP "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`$ECHO $ac_prog| $SED "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  AC_MSG_CHECKING([for GNU ld])
+else
+  AC_MSG_CHECKING([for non-GNU ld])
+fi
+AC_CACHE_VAL(lt_cv_path_LD,
+[if test -z "$LD"; then
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  for ac_dir in $PATH; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      lt_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some variants of GNU ld only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      case `"$lt_cv_path_LD" -v 2>&1 </dev/null` in
+      *GNU* | *'with BFD'*)
+	test "$with_gnu_ld" != no && break
+	;;
+      *)
+	test "$with_gnu_ld" != yes && break
+	;;
+      esac
+    fi
+  done
+  IFS="$lt_save_ifs"
+else
+  lt_cv_path_LD="$LD" # Let the user override the test with a path.
+fi])
+LD="$lt_cv_path_LD"
+if test -n "$LD"; then
+  AC_MSG_RESULT($LD)
+else
+  AC_MSG_RESULT(no)
+fi
+test -z "$LD" && AC_MSG_ERROR([no acceptable ld found in \$PATH])
+_LT_PATH_LD_GNU
+AC_SUBST([LD])
+
+_LT_TAGDECL([], [LD], [1], [The linker used to build libraries])
+])# LT_PATH_LD
+
+# Old names:
+AU_ALIAS([AM_PROG_LD], [LT_PATH_LD])
+AU_ALIAS([AC_PROG_LD], [LT_PATH_LD])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AM_PROG_LD], [])
+dnl AC_DEFUN([AC_PROG_LD], [])
+
+
+# _LT_PATH_LD_GNU
+#- --------------
+m4_defun([_LT_PATH_LD_GNU],
+[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], lt_cv_prog_gnu_ld,
+[# I'd rather use --version here, but apparently some GNU lds only accept -v.
+case `$LD -v 2>&1 </dev/null` in
+*GNU* | *'with BFD'*)
+  lt_cv_prog_gnu_ld=yes
+  ;;
+*)
+  lt_cv_prog_gnu_ld=no
+  ;;
+esac])
+with_gnu_ld=$lt_cv_prog_gnu_ld
+])# _LT_PATH_LD_GNU
+
+
+# _LT_CMD_RELOAD
+# --------------
+# find reload flag for linker
+#   -- PORTME Some linkers may need a different reload flag.
+m4_defun([_LT_CMD_RELOAD],
+[AC_CACHE_CHECK([for $LD option to reload object files],
+  lt_cv_ld_reload_flag,
+  [lt_cv_ld_reload_flag='-r'])
+reload_flag=$lt_cv_ld_reload_flag
+case $reload_flag in
+"" | " "*) ;;
+*) reload_flag=" $reload_flag" ;;
+esac
+reload_cmds='$LD$reload_flag -o $output$reload_objs'
+case $host_os in
+  darwin*)
+    if test "$GCC" = yes; then
+      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'
+    else
+      reload_cmds='$LD$reload_flag -o $output$reload_objs'
+    fi
+    ;;
+esac
+_LT_TAGDECL([], [reload_flag], [1], [How to create reloadable object files])dnl
+_LT_TAGDECL([], [reload_cmds], [2])dnl
+])# _LT_CMD_RELOAD
+
+
+# _LT_CHECK_MAGIC_METHOD
+# ----------------------
+# how to check for library dependencies
+#  -- PORTME fill in with the dynamic library characteristics
+m4_defun([_LT_CHECK_MAGIC_METHOD],
+[m4_require([_LT_DECL_EGREP])
+m4_require([_LT_DECL_OBJDUMP])
+AC_CACHE_CHECK([how to recognize dependent libraries],
+lt_cv_deplibs_check_method,
+[lt_cv_file_magic_cmd='$MAGIC_CMD'
+lt_cv_file_magic_test_file=
+lt_cv_deplibs_check_method='unknown'
+# Need to set the preceding variable on all platforms that support
+# interlibrary dependencies.
+# 'none' -- dependencies not supported.
+# `unknown' -- same as none, but documents that we really don't know.
+# 'pass_all' -- all dependencies passed with no checks.
+# 'test_compile' -- check by making test program.
+# 'file_magic [[regex]]' -- check by looking for files in library path
+# which responds to the $file_magic_cmd with a given extended regex.
+# If you have `file' or equivalent on your system and you're not sure
+# whether `pass_all' will *always* work, you probably want this one.
+
+case $host_os in
+aix[[4-9]]*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+beos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+bsdi[[45]]*)
+  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib)'
+  lt_cv_file_magic_cmd='/usr/bin/file -L'
+  lt_cv_file_magic_test_file=/shlib/libc.so
+  ;;
+
+cygwin*)
+  # func_win32_libid is a shell function defined in ltmain.sh
+  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
+  lt_cv_file_magic_cmd='func_win32_libid'
+  ;;
+
+mingw* | pw32*)
+  # Base MSYS/MinGW do not provide the 'file' command needed by
+  # func_win32_libid shell function, so use a weaker test based on 'objdump',
+  # unless we find 'file', for example because we are cross-compiling.
+  # func_win32_libid assumes BSD nm, so disallow it if using MS dumpbin.
+  if ( test "$lt_cv_nm_interface" = "BSD nm" && file / ) >/dev/null 2>&1; then
+    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
+    lt_cv_file_magic_cmd='func_win32_libid'
+  else
+    # Keep this pattern in sync with the one in func_win32_libid.
+    lt_cv_deplibs_check_method='file_magic file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)'
+    lt_cv_file_magic_cmd='$OBJDUMP -f'
+  fi
+  ;;
+
+cegcc*)
+  # use the weaker test based on 'objdump'. See mingw*.
+  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'
+  lt_cv_file_magic_cmd='$OBJDUMP -f'
+  ;;
+
+darwin* | rhapsody*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+freebsd* | dragonfly*)
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+    case $host_cpu in
+    i*86 )
+      # Not sure whether the presence of OpenBSD here was a mistake.
+      # Let's accept both of them until this is cleared up.
+      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[[3-9]]86 (compact )?demand paged shared library'
+      lt_cv_file_magic_cmd=/usr/bin/file
+      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`
+      ;;
+    esac
+  else
+    lt_cv_deplibs_check_method=pass_all
+  fi
+  ;;
+
+gnu*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+haiku*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+hpux10.20* | hpux11*)
+  lt_cv_file_magic_cmd=/usr/bin/file
+  case $host_cpu in
+  ia64*)
+    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|ELF-[[0-9]][[0-9]]) shared object file - IA64'
+    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so
+    ;;
+  hppa*64*)
+    [lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF[ -][0-9][0-9])(-bit)?( [LM]SB)? shared object( file)?[, -]* PA-RISC [0-9]\.[0-9]']
+    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl
+    ;;
+  *)
+    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|PA-RISC[[0-9]]\.[[0-9]]) shared library'
+    lt_cv_file_magic_test_file=/usr/lib/libc.sl
+    ;;
+  esac
+  ;;
+
+interix[[3-9]]*)
+  # PIC code is broken on Interix 3.x, that's why |\.a not |_pic\.a here
+  lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so|\.a)$'
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $LD in
+  *-32|*"-32 ") libmagic=32-bit;;
+  *-n32|*"-n32 ") libmagic=N32;;
+  *-64|*"-64 ") libmagic=64-bit;;
+  *) libmagic=never-match;;
+  esac
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+# This must be Linux ELF.
+linux* | k*bsd*-gnu | kopensolaris*-gnu)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+netbsd*)
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so\.[[0-9]]+\.[[0-9]]+|_pic\.a)$'
+  else
+    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so|_pic\.a)$'
+  fi
+  ;;
+
+newos6*)
+  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (executable|dynamic lib)'
+  lt_cv_file_magic_cmd=/usr/bin/file
+  lt_cv_file_magic_test_file=/usr/lib/libnls.so
+  ;;
+
+*nto* | *qnx*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+openbsd*)
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so\.[[0-9]]+\.[[0-9]]+|\.so|_pic\.a)$'
+  else
+    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so\.[[0-9]]+\.[[0-9]]+|_pic\.a)$'
+  fi
+  ;;
+
+osf3* | osf4* | osf5*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+rdos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+solaris*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sysv4 | sysv4.3*)
+  case $host_vendor in
+  motorola)
+    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib) M[[0-9]][[0-9]]* Version [[0-9]]'
+    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`
+    ;;
+  ncr)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  sequent)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB (shared object|dynamic lib )'
+    ;;
+  sni)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method="file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB dynamic lib"
+    lt_cv_file_magic_test_file=/lib/libc.so
+    ;;
+  siemens)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  pc)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  esac
+  ;;
+
+tpf*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+esac
+])
+file_magic_cmd=$lt_cv_file_magic_cmd
+deplibs_check_method=$lt_cv_deplibs_check_method
+test -z "$deplibs_check_method" && deplibs_check_method=unknown
+
+_LT_DECL([], [deplibs_check_method], [1],
+    [Method to check whether dependent libraries are shared objects])
+_LT_DECL([], [file_magic_cmd], [1],
+    [Command to use when deplibs_check_method == "file_magic"])
+])# _LT_CHECK_MAGIC_METHOD
+
+
+# LT_PATH_NM
+# ----------
+# find the pathname to a BSD- or MS-compatible name lister
+AC_DEFUN([LT_PATH_NM],
+[AC_REQUIRE([AC_PROG_CC])dnl
+AC_CACHE_CHECK([for BSD- or MS-compatible name lister (nm)], lt_cv_path_NM,
+[if test -n "$NM"; then
+  # Let the user override the test.
+  lt_cv_path_NM="$NM"
+else
+  lt_nm_to_check="${ac_tool_prefix}nm"
+  if test -n "$ac_tool_prefix" && test "$build" = "$host"; then
+    lt_nm_to_check="$lt_nm_to_check nm"
+  fi
+  for lt_tmp_nm in $lt_nm_to_check; do
+    lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do
+      IFS="$lt_save_ifs"
+      test -z "$ac_dir" && ac_dir=.
+      tmp_nm="$ac_dir/$lt_tmp_nm"
+      if test -f "$tmp_nm" || test -f "$tmp_nm$ac_exeext" ; then
+	# Check to see if the nm accepts a BSD-compat flag.
+	# Adding the `sed 1q' prevents false positives on HP-UX, which says:
+	#   nm: unknown option "B" ignored
+	# Tru64's nm complains that /dev/null is an invalid object file
+	case `"$tmp_nm" -B /dev/null 2>&1 | sed '1q'` in
+	*/dev/null* | *'Invalid file or object type'*)
+	  lt_cv_path_NM="$tmp_nm -B"
+	  break
+	  ;;
+	*)
+	  case `"$tmp_nm" -p /dev/null 2>&1 | sed '1q'` in
+	  */dev/null*)
+	    lt_cv_path_NM="$tmp_nm -p"
+	    break
+	    ;;
+	  *)
+	    lt_cv_path_NM=${lt_cv_path_NM="$tmp_nm"} # keep the first match, but
+	    continue # so that we can try to find one that supports BSD flags
+	    ;;
+	  esac
+	  ;;
+	esac
+      fi
+    done
+    IFS="$lt_save_ifs"
+  done
+  : ${lt_cv_path_NM=no}
+fi])
+if test "$lt_cv_path_NM" != "no"; then
+  NM="$lt_cv_path_NM"
+else
+  # Didn't find any BSD compatible name lister, look for dumpbin.
+  if test -n "$DUMPBIN"; then :
+    # Let the user override the test.
+  else
+    AC_CHECK_TOOLS(DUMPBIN, [dumpbin "link -dump"], :)
+    case `$DUMPBIN -symbols /dev/null 2>&1 | sed '1q'` in
+    *COFF*)
+      DUMPBIN="$DUMPBIN -symbols"
+      ;;
+    *)
+      DUMPBIN=:
+      ;;
+    esac
+  fi
+  AC_SUBST([DUMPBIN])
+  if test "$DUMPBIN" != ":"; then
+    NM="$DUMPBIN"
+  fi
+fi
+test -z "$NM" && NM=nm
+AC_SUBST([NM])
+_LT_DECL([], [NM], [1], [A BSD- or MS-compatible name lister])dnl
+
+AC_CACHE_CHECK([the name lister ($NM) interface], [lt_cv_nm_interface],
+  [lt_cv_nm_interface="BSD nm"
+  echo "int some_variable = 0;" > conftest.$ac_ext
+  (eval echo "\"\$as_me:$LINENO: $ac_compile\"" >&AS_MESSAGE_LOG_FD)
+  (eval "$ac_compile" 2>conftest.err)
+  cat conftest.err >&AS_MESSAGE_LOG_FD
+  (eval echo "\"\$as_me:$LINENO: $NM \\\"conftest.$ac_objext\\\"\"" >&AS_MESSAGE_LOG_FD)
+  (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
+  cat conftest.err >&AS_MESSAGE_LOG_FD
+  (eval echo "\"\$as_me:$LINENO: output\"" >&AS_MESSAGE_LOG_FD)
+  cat conftest.out >&AS_MESSAGE_LOG_FD
+  if $GREP 'External.*some_variable' conftest.out > /dev/null; then
+    lt_cv_nm_interface="MS dumpbin"
+  fi
+  rm -f conftest*])
+])# LT_PATH_NM
+
+# Old names:
+AU_ALIAS([AM_PROG_NM], [LT_PATH_NM])
+AU_ALIAS([AC_PROG_NM], [LT_PATH_NM])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AM_PROG_NM], [])
+dnl AC_DEFUN([AC_PROG_NM], [])
+
+
+# LT_LIB_M
+# --------
+# check for math library
+AC_DEFUN([LT_LIB_M],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+LIBM=
+case $host in
+*-*-beos* | *-*-cegcc* | *-*-cygwin* | *-*-haiku* | *-*-pw32* | *-*-darwin*)
+  # These system don't have libm, or don't need it
+  ;;
+*-ncr-sysv4.3*)
+  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM="-lmw")
+  AC_CHECK_LIB(m, cos, LIBM="$LIBM -lm")
+  ;;
+*)
+  AC_CHECK_LIB(m, cos, LIBM="-lm")
+  ;;
+esac
+AC_SUBST([LIBM])
+])# LT_LIB_M
+
+# Old name:
+AU_ALIAS([AC_CHECK_LIBM], [LT_LIB_M])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_CHECK_LIBM], [])
+
+
+# _LT_COMPILER_NO_RTTI([TAGNAME])
+# -------------------------------
+m4_defun([_LT_COMPILER_NO_RTTI],
+[m4_require([_LT_TAG_COMPILER])dnl
+
+_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=
+
+if test "$GCC" = yes; then
+  case $cc_basename in
+  nvcc*)
+    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -Xcompiler -fno-builtin' ;;
+  *)
+    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin' ;;
+  esac
+
+  _LT_COMPILER_OPTION([if $compiler supports -fno-rtti -fno-exceptions],
+    lt_cv_prog_compiler_rtti_exceptions,
+    [-fno-rtti -fno-exceptions], [],
+    [_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)="$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1) -fno-rtti -fno-exceptions"])
+fi
+_LT_TAGDECL([no_builtin_flag], [lt_prog_compiler_no_builtin_flag], [1],
+	[Compiler flag to turn off builtin functions])
+])# _LT_COMPILER_NO_RTTI
+
+
+# _LT_CMD_GLOBAL_SYMBOLS
+# ----------------------
+m4_defun([_LT_CMD_GLOBAL_SYMBOLS],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([AC_PROG_AWK])dnl
+AC_REQUIRE([LT_PATH_NM])dnl
+AC_REQUIRE([LT_PATH_LD])dnl
+m4_require([_LT_DECL_SED])dnl
+m4_require([_LT_DECL_EGREP])dnl
+m4_require([_LT_TAG_COMPILER])dnl
+
+# Check for command to grab the raw symbol name followed by C symbol from nm.
+AC_MSG_CHECKING([command to parse $NM output from $compiler object])
+AC_CACHE_VAL([lt_cv_sys_global_symbol_pipe],
+[
+# These are sane defaults that work on at least a few old systems.
+# [They come from Ultrix.  What could be older than Ultrix?!! ;)]
+
+# Character class describing NM global symbol codes.
+symcode='[[BCDEGRST]]'
+
+# Regexp to match symbols that can be accessed directly from C.
+sympat='\([[_A-Za-z]][[_A-Za-z0-9]]*\)'
+
+# Define system-specific variables.
+case $host_os in
+aix*)
+  symcode='[[BCDT]]'
+  ;;
+cygwin* | mingw* | pw32* | cegcc*)
+  symcode='[[ABCDGISTW]]'
+  ;;
+hpux*)
+  if test "$host_cpu" = ia64; then
+    symcode='[[ABCDEGRST]]'
+  fi
+  ;;
+irix* | nonstopux*)
+  symcode='[[BCDEGRST]]'
+  ;;
+osf*)
+  symcode='[[BCDEGQRST]]'
+  ;;
+solaris*)
+  symcode='[[BDRT]]'
+  ;;
+sco3.2v5*)
+  symcode='[[DT]]'
+  ;;
+sysv4.2uw2*)
+  symcode='[[DT]]'
+  ;;
+sysv5* | sco5v6* | unixware* | OpenUNIX*)
+  symcode='[[ABDT]]'
+  ;;
+sysv4)
+  symcode='[[DFNSTU]]'
+  ;;
+esac
+
+# If we're using GNU nm, then use its standard symbol codes.
+case `$NM -V 2>&1` in
+*GNU* | *'with BFD'*)
+  symcode='[[ABCDGIRSTW]]' ;;
+esac
+
+# Transform an extracted symbol line into a proper C declaration.
+# Some systems (esp. on ia64) link data and code symbols differently,
+# so use this general approach.
+lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern int \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
+
+# Transform an extracted symbol line into symbol name and symbol address
+lt_cv_sys_global_symbol_to_c_name_address="sed -n -e 's/^: \([[^ ]]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([[^ ]]*\) \([[^ ]]*\)$/  {\"\2\", (void *) \&\2},/p'"
+lt_cv_sys_global_symbol_to_c_name_address_lib_prefix="sed -n -e 's/^: \([[^ ]]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([[^ ]]*\) \(lib[[^ ]]*\)$/  {\"\2\", (void *) \&\2},/p' -e 's/^$symcode* \([[^ ]]*\) \([[^ ]]*\)$/  {\"lib\2\", (void *) \&\2},/p'"
+
+# Handle CRLF in mingw tool chain
+opt_cr=
+case $build_os in
+mingw*)
+  opt_cr=`$ECHO 'x\{0,1\}' | tr x '\015'` # option cr in regexp
+  ;;
+esac
+
+# Try without a prefix underscore, then with it.
+for ac_symprfx in "" "_"; do
+
+  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.
+  symxfrm="\\1 $ac_symprfx\\2 \\2"
+
+  # Write the raw and C identifiers.
+  if test "$lt_cv_nm_interface" = "MS dumpbin"; then
+    # Fake it for dumpbin and say T for any non-static function
+    # and D for any global variable.
+    # Also find C++ and __fastcall symbols from MSVC++,
+    # which start with @ or ?.
+    lt_cv_sys_global_symbol_pipe="$AWK ['"\
+"     {last_section=section; section=\$ 3};"\
+"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};"\
+"     \$ 0!~/External *\|/{next};"\
+"     / 0+ UNDEF /{next}; / UNDEF \([^|]\)*()/{next};"\
+"     {if(hide[section]) next};"\
+"     {f=0}; \$ 0~/\(\).*\|/{f=1}; {printf f ? \"T \" : \"D \"};"\
+"     {split(\$ 0, a, /\||\r/); split(a[2], s)};"\
+"     s[1]~/^[@?]/{print s[1], s[1]; next};"\
+"     s[1]~prfx {split(s[1],t,\"@\"); print t[1], substr(t[1],length(prfx))}"\
+"     ' prfx=^$ac_symprfx]"
+  else
+    lt_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[[	 ]]\($symcode$symcode*\)[[	 ]][[	 ]]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'"
+  fi
+
+  # Check to see that the pipe works correctly.
+  pipe_works=no
+
+  rm -f conftest*
+  cat > conftest.$ac_ext <<_LT_EOF
+#ifdef __cplusplus
+extern "C" {
+#endif
+char nm_test_var;
+void nm_test_func(void);
+void nm_test_func(void){}
+#ifdef __cplusplus
+}
+#endif
+int main(){nm_test_var='a';nm_test_func();return(0);}
+_LT_EOF
+
+  if AC_TRY_EVAL(ac_compile); then
+    # Now try to grab the symbols.
+    nlist=conftest.nm
+    if AC_TRY_EVAL(NM conftest.$ac_objext \| "$lt_cv_sys_global_symbol_pipe" \> $nlist) && test -s "$nlist"; then
+      # Try sorting and uniquifying the output.
+      if sort "$nlist" | uniq > "$nlist"T; then
+	mv -f "$nlist"T "$nlist"
+      else
+	rm -f "$nlist"T
+      fi
+
+      # Make sure that we snagged all the symbols we need.
+      if $GREP ' nm_test_var$' "$nlist" >/dev/null; then
+	if $GREP ' nm_test_func$' "$nlist" >/dev/null; then
+	  cat <<_LT_EOF > conftest.$ac_ext
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+_LT_EOF
+	  # Now generate the symbol file.
+	  eval "$lt_cv_sys_global_symbol_to_cdecl"' < "$nlist" | $GREP -v main >> conftest.$ac_ext'
+
+	  cat <<_LT_EOF >> conftest.$ac_ext
+
+/* The mapping between symbol names and symbols.  */
+const struct {
+  const char *name;
+  void       *address;
+}
+lt__PROGRAM__LTX_preloaded_symbols[[]] =
+{
+  { "@PROGRAM@", (void *) 0 },
+_LT_EOF
+	  $SED "s/^$symcode$symcode* \(.*\) \(.*\)$/  {\"\2\", (void *) \&\2},/" < "$nlist" | $GREP -v main >> conftest.$ac_ext
+	  cat <<\_LT_EOF >> conftest.$ac_ext
+  {0, (void *) 0}
+};
+
+/* This works around a problem in FreeBSD linker */
+#ifdef FREEBSD_WORKAROUND
+static const void *lt_preloaded_setup() {
+  return lt__PROGRAM__LTX_preloaded_symbols;
+}
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+_LT_EOF
+	  # Now try linking the two files.
+	  mv conftest.$ac_objext conftstm.$ac_objext
+	  lt_save_LIBS="$LIBS"
+	  lt_save_CFLAGS="$CFLAGS"
+	  LIBS="conftstm.$ac_objext"
+	  CFLAGS="$CFLAGS$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)"
+	  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext}; then
+	    pipe_works=yes
+	  fi
+	  LIBS="$lt_save_LIBS"
+	  CFLAGS="$lt_save_CFLAGS"
+	else
+	  echo "cannot find nm_test_func in $nlist" >&AS_MESSAGE_LOG_FD
+	fi
+      else
+	echo "cannot find nm_test_var in $nlist" >&AS_MESSAGE_LOG_FD
+      fi
+    else
+      echo "cannot run $lt_cv_sys_global_symbol_pipe" >&AS_MESSAGE_LOG_FD
+    fi
+  else
+    echo "$progname: failed program was:" >&AS_MESSAGE_LOG_FD
+    cat conftest.$ac_ext >&5
+  fi
+  rm -rf conftest* conftst*
+
+  # Do not use the global_symbol_pipe unless it works.
+  if test "$pipe_works" = yes; then
+    break
+  else
+    lt_cv_sys_global_symbol_pipe=
+  fi
+done
+])
+if test -z "$lt_cv_sys_global_symbol_pipe"; then
+  lt_cv_sys_global_symbol_to_cdecl=
+fi
+if test -z "$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl"; then
+  AC_MSG_RESULT(failed)
+else
+  AC_MSG_RESULT(ok)
+fi
+
+_LT_DECL([global_symbol_pipe], [lt_cv_sys_global_symbol_pipe], [1],
+    [Take the output of nm and produce a listing of raw symbols and C names])
+_LT_DECL([global_symbol_to_cdecl], [lt_cv_sys_global_symbol_to_cdecl], [1],
+    [Transform the output of nm in a proper C declaration])
+_LT_DECL([global_symbol_to_c_name_address],
+    [lt_cv_sys_global_symbol_to_c_name_address], [1],
+    [Transform the output of nm in a C name address pair])
+_LT_DECL([global_symbol_to_c_name_address_lib_prefix],
+    [lt_cv_sys_global_symbol_to_c_name_address_lib_prefix], [1],
+    [Transform the output of nm in a C name address pair when lib prefix is needed])
+]) # _LT_CMD_GLOBAL_SYMBOLS
+
+
+# _LT_COMPILER_PIC([TAGNAME])
+# ---------------------------
+m4_defun([_LT_COMPILER_PIC],
+[m4_require([_LT_TAG_COMPILER])dnl
+_LT_TAGVAR(lt_prog_compiler_wl, $1)=
+_LT_TAGVAR(lt_prog_compiler_pic, $1)=
+_LT_TAGVAR(lt_prog_compiler_static, $1)=
+
+AC_MSG_CHECKING([for $compiler option to produce PIC])
+m4_if([$1], [CXX], [
+  # C++ specific cases for pic, static, wl, etc.
+  if test "$GXX" = yes; then
+    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+
+    case $host_os in
+    aix*)
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+        ;;
+      m68k)
+            # FIXME: we need at least 68020 code to build shared libraries, but
+            # adding the `-m68020' flag to GCC prevents building anything better,
+            # like `-m68040'.
+            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'
+        ;;
+      esac
+      ;;
+
+    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
+    mingw* | cygwin* | os2* | pw32* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      # Although the cygwin gcc ignores -fPIC, still need this for old-style
+      # (--disable-auto-import) libraries
+      m4_if([$1], [GCJ], [],
+	[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])
+      ;;
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'
+      ;;
+    *djgpp*)
+      # DJGPP does not support shared libraries at all
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)=
+      ;;
+    haiku*)
+      # PIC is the default for Haiku.
+      # The "-static" flag exists, but is broken.
+      _LT_TAGVAR(lt_prog_compiler_static, $1)=
+      ;;
+    interix[[3-9]]*)
+      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
+      # Instead, we relocate shared libraries at runtime.
+      ;;
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic
+      fi
+      ;;
+    hpux*)
+      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
+      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
+      # sets the default TLS model and affects inlining.
+      case $host_cpu in
+      hppa*64*)
+	;;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	;;
+      esac
+      ;;
+    *qnx* | *nto*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'
+      ;;
+    *)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+      ;;
+    esac
+  else
+    case $host_os in
+      aix[[4-9]]*)
+	# All AIX code is PIC.
+	if test "$host_cpu" = ia64; then
+	  # AIX 5 now supports IA64 processor
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	else
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'
+	fi
+	;;
+      chorus*)
+	case $cc_basename in
+	cxch68*)
+	  # Green Hills C++ Compiler
+	  # _LT_TAGVAR(lt_prog_compiler_static, $1)="--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a"
+	  ;;
+	esac
+	;;
+      dgux*)
+	case $cc_basename in
+	  ec++*)
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    ;;
+	  ghcx*)
+	    # Green Hills C++ Compiler
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      freebsd* | dragonfly*)
+	# FreeBSD uses GNU C++
+	;;
+      hpux9* | hpux10* | hpux11*)
+	case $cc_basename in
+	  CC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'
+	    if test "$host_cpu" != ia64; then
+	      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'
+	    fi
+	    ;;
+	  aCC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'
+	    case $host_cpu in
+	    hppa*64*|ia64*)
+	      # +Z the default
+	      ;;
+	    *)
+	      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'
+	      ;;
+	    esac
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      interix*)
+	# This is c89, which is MS Visual C++ (no shared libs)
+	# Anyone wants to do a port?
+	;;
+      irix5* | irix6* | nonstopux*)
+	case $cc_basename in
+	  CC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+	    # CC pic flag -KPIC is the default.
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      linux* | k*bsd*-gnu | kopensolaris*-gnu)
+	case $cc_basename in
+	  KCC*)
+	    # KAI C++ Compiler
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	    ;;
+	  ecpc* )
+	    # old Intel C++ for x86_64 which still supported -KPIC.
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+	    ;;
+	  icpc* )
+	    # Intel C++, used to be incompatible with GCC.
+	    # ICC 10 doesn't accept -KPIC any more.
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+	    ;;
+	  pgCC* | pgcpp*)
+	    # Portland Group C++ compiler
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	    ;;
+	  cxx*)
+	    # Compaq C++
+	    # Make sure the PIC flag is empty.  It appears that all Alpha
+	    # Linux and Compaq Tru64 Unix objects are PIC.
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)=
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+	    ;;
+	  xlc* | xlC* | bgxl[[cC]]* | mpixl[[cC]]*)
+	    # IBM XL 8.0, 9.0 on PPC and BlueGene
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'
+	    ;;
+	  *)
+	    case `$CC -V 2>&1 | sed 5q` in
+	    *Sun\ C*)
+	      # Sun C++ 5.9
+	      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '
+	      ;;
+	    esac
+	    ;;
+	esac
+	;;
+      lynxos*)
+	;;
+      m88k*)
+	;;
+      mvs*)
+	case $cc_basename in
+	  cxx*)
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-W c,exportall'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      netbsd*)
+	;;
+      *qnx* | *nto*)
+        # QNX uses GNU C++, but need to define -shared option too, otherwise
+        # it will coredump.
+        _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'
+        ;;
+      osf3* | osf4* | osf5*)
+	case $cc_basename in
+	  KCC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'
+	    ;;
+	  RCC*)
+	    # Rational C++ 2.4.1
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+	    ;;
+	  cxx*)
+	    # Digital/Compaq C++
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    # Make sure the PIC flag is empty.  It appears that all Alpha
+	    # Linux and Compaq Tru64 Unix objects are PIC.
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)=
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      psos*)
+	;;
+      solaris*)
+	case $cc_basename in
+	  CC* | sunCC*)
+	    # Sun C++ 4.2, 5.x and Centerline C++
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '
+	    ;;
+	  gcx*)
+	    # Green Hills C++ Compiler
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      sunos4*)
+	case $cc_basename in
+	  CC*)
+	    # Sun C++ 4.x
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	    ;;
+	  lcc*)
+	    # Lucid
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+	case $cc_basename in
+	  CC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	    ;;
+	esac
+	;;
+      tandem*)
+	case $cc_basename in
+	  NCC*)
+	    # NonStop-UX NCC 3.20
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      vxworks*)
+	;;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no
+	;;
+    esac
+  fi
+],
+[
+  if test "$GCC" = yes; then
+    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+
+    case $host_os in
+      aix*)
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+        ;;
+      m68k)
+            # FIXME: we need at least 68020 code to build shared libraries, but
+            # adding the `-m68020' flag to GCC prevents building anything better,
+            # like `-m68040'.
+            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'
+        ;;
+      esac
+      ;;
+
+    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
+
+    mingw* | cygwin* | pw32* | os2* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      # Although the cygwin gcc ignores -fPIC, still need this for old-style
+      # (--disable-auto-import) libraries
+      m4_if([$1], [GCJ], [],
+	[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])
+      ;;
+
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'
+      ;;
+
+    haiku*)
+      # PIC is the default for Haiku.
+      # The "-static" flag exists, but is broken.
+      _LT_TAGVAR(lt_prog_compiler_static, $1)=
+      ;;
+
+    hpux*)
+      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
+      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
+      # sets the default TLS model and affects inlining.
+      case $host_cpu in
+      hppa*64*)
+	# +Z the default
+	;;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	;;
+      esac
+      ;;
+
+    interix[[3-9]]*)
+      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
+      # Instead, we relocate shared libraries at runtime.
+      ;;
+
+    msdosdjgpp*)
+      # Just because we use GCC doesn't mean we suddenly get shared libraries
+      # on systems that don't support them.
+      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no
+      enable_shared=no
+      ;;
+
+    *nto* | *qnx*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic
+      fi
+      ;;
+
+    *)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+      ;;
+    esac
+
+    case $cc_basename in
+    nvcc*) # Cuda Compiler Driver 2.2
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Xlinker '
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-Xcompiler -fPIC'
+      ;;
+    esac
+  else
+    # PORTME Check for flag to pass linker flags through the system compiler.
+    case $host_os in
+    aix*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      else
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'
+      fi
+      ;;
+
+    mingw* | cygwin* | pw32* | os2* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      m4_if([$1], [GCJ], [],
+	[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])
+      ;;
+
+    hpux9* | hpux10* | hpux11*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but
+      # not for PA HP-UX.
+      case $host_cpu in
+      hppa*64*|ia64*)
+	# +Z the default
+	;;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'
+	;;
+      esac
+      # Is there a better lt_prog_compiler_static that works with the bundled CC?
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'
+      ;;
+
+    irix5* | irix6* | nonstopux*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      # PIC (with -KPIC) is the default.
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+      ;;
+
+    linux* | k*bsd*-gnu | kopensolaris*-gnu)
+      case $cc_basename in
+      # old Intel for x86_64 which still supported -KPIC.
+      ecc*)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+        ;;
+      # icc used to be incompatible with GCC.
+      # ICC 10 doesn't accept -KPIC any more.
+      icc* | ifort*)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+        ;;
+      # Lahey Fortran 8.1.
+      lf95*)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='--shared'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='--static'
+	;;
+      pgcc* | pgf77* | pgf90* | pgf95* | pgfortran*)
+        # Portland Group compilers (*not* the Pentium gcc compiler,
+	# which looks to be a dead project)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+        ;;
+      ccc*)
+        _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+        # All Alpha code is PIC.
+        _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+        ;;
+      xl* | bgxl* | bgf* | mpixl*)
+	# IBM XL C 8.0/Fortran 10.1, 11.1 on PPC and BlueGene
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'
+	;;
+      *)
+	case `$CC -V 2>&1 | sed 5q` in
+	*Sun\ F* | *Sun*Fortran*)
+	  # Sun Fortran 8.3 passes all unrecognized flags to the linker
+	  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	  _LT_TAGVAR(lt_prog_compiler_wl, $1)=''
+	  ;;
+	*Sun\ C*)
+	  # Sun C 5.9
+	  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	  ;;
+	esac
+	;;
+      esac
+      ;;
+
+    newsos6)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    *nto* | *qnx*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'
+      ;;
+
+    osf3* | osf4* | osf5*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      # All OSF/1 code is PIC.
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+      ;;
+
+    rdos*)
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+      ;;
+
+    solaris*)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      case $cc_basename in
+      f77* | f90* | f95* | sunf77* | sunf90* | sunf95*)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld ';;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,';;
+      esac
+      ;;
+
+    sunos4*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    sysv4 | sysv4.2uw2* | sysv4.3*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec ;then
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-Kconform_pic'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      fi
+      ;;
+
+    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    unicos*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no
+      ;;
+
+    uts4*)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    *)
+      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no
+      ;;
+    esac
+  fi
+])
+case $host_os in
+  # For platforms which do not support PIC, -DPIC is meaningless:
+  *djgpp*)
+    _LT_TAGVAR(lt_prog_compiler_pic, $1)=
+    ;;
+  *)
+    _LT_TAGVAR(lt_prog_compiler_pic, $1)="$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])"
+    ;;
+esac
+AC_MSG_RESULT([$_LT_TAGVAR(lt_prog_compiler_pic, $1)])
+_LT_TAGDECL([wl], [lt_prog_compiler_wl], [1],
+	[How to pass a linker flag through the compiler])
+
+#
+# Check to make sure the PIC flag actually works.
+#
+if test -n "$_LT_TAGVAR(lt_prog_compiler_pic, $1)"; then
+  _LT_COMPILER_OPTION([if $compiler PIC flag $_LT_TAGVAR(lt_prog_compiler_pic, $1) works],
+    [_LT_TAGVAR(lt_cv_prog_compiler_pic_works, $1)],
+    [$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])], [],
+    [case $_LT_TAGVAR(lt_prog_compiler_pic, $1) in
+     "" | " "*) ;;
+     *) _LT_TAGVAR(lt_prog_compiler_pic, $1)=" $_LT_TAGVAR(lt_prog_compiler_pic, $1)" ;;
+     esac],
+    [_LT_TAGVAR(lt_prog_compiler_pic, $1)=
+     _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no])
+fi
+_LT_TAGDECL([pic_flag], [lt_prog_compiler_pic], [1],
+	[Additional compiler flags for building library objects])
+
+#
+# Check to make sure the static flag actually works.
+#
+wl=$_LT_TAGVAR(lt_prog_compiler_wl, $1) eval lt_tmp_static_flag=\"$_LT_TAGVAR(lt_prog_compiler_static, $1)\"
+_LT_LINKER_OPTION([if $compiler static flag $lt_tmp_static_flag works],
+  _LT_TAGVAR(lt_cv_prog_compiler_static_works, $1),
+  $lt_tmp_static_flag,
+  [],
+  [_LT_TAGVAR(lt_prog_compiler_static, $1)=])
+_LT_TAGDECL([link_static_flag], [lt_prog_compiler_static], [1],
+	[Compiler flag to prevent dynamic linking])
+])# _LT_COMPILER_PIC
+
+
+# _LT_LINKER_SHLIBS([TAGNAME])
+# ----------------------------
+# See if the linker supports building shared libraries.
+m4_defun([_LT_LINKER_SHLIBS],
+[AC_REQUIRE([LT_PATH_LD])dnl
+AC_REQUIRE([LT_PATH_NM])dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_EGREP])dnl
+m4_require([_LT_DECL_SED])dnl
+m4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl
+m4_require([_LT_TAG_COMPILER])dnl
+AC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])
+m4_if([$1], [CXX], [
+  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  case $host_os in
+  aix[[4-9]]*)
+    # If we're using GNU nm, then we don't want the "-C" option.
+    # -C means demangle to AIX nm, but means don't demangle with GNU nm
+    # Also, AIX nm treats weak defined symbols like other global defined
+    # symbols, whereas GNU nm marks them as "W".
+    if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
+      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+    else
+      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+    fi
+    ;;
+  pw32*)
+    _LT_TAGVAR(export_symbols_cmds, $1)="$ltdll_cmds"
+  ;;
+  cygwin* | mingw* | cegcc*)
+    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\([[^ ]]*\)/\1 DATA/;/^.*[[ ]]__nm__/s/^.*[[ ]]__nm__\([[^ ]]*\)[[ ]][[^ ]]*/\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\'' | sort | uniq > $export_symbols'
+  ;;
+  *)
+    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  ;;
+  esac
+  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']
+], [
+  runpath_var=
+  _LT_TAGVAR(allow_undefined_flag, $1)=
+  _LT_TAGVAR(always_export_symbols, $1)=no
+  _LT_TAGVAR(archive_cmds, $1)=
+  _LT_TAGVAR(archive_expsym_cmds, $1)=
+  _LT_TAGVAR(compiler_needs_object, $1)=no
+  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no
+  _LT_TAGVAR(export_dynamic_flag_spec, $1)=
+  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  _LT_TAGVAR(hardcode_automatic, $1)=no
+  _LT_TAGVAR(hardcode_direct, $1)=no
+  _LT_TAGVAR(hardcode_direct_absolute, $1)=no
+  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+  _LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=
+  _LT_TAGVAR(hardcode_libdir_separator, $1)=
+  _LT_TAGVAR(hardcode_minus_L, $1)=no
+  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported
+  _LT_TAGVAR(inherit_rpath, $1)=no
+  _LT_TAGVAR(link_all_deplibs, $1)=unknown
+  _LT_TAGVAR(module_cmds, $1)=
+  _LT_TAGVAR(module_expsym_cmds, $1)=
+  _LT_TAGVAR(old_archive_from_new_cmds, $1)=
+  _LT_TAGVAR(old_archive_from_expsyms_cmds, $1)=
+  _LT_TAGVAR(thread_safe_flag_spec, $1)=
+  _LT_TAGVAR(whole_archive_flag_spec, $1)=
+  # include_expsyms should be a list of space-separated symbols to be *always*
+  # included in the symbol list
+  _LT_TAGVAR(include_expsyms, $1)=
+  # exclude_expsyms can be an extended regexp of symbols to exclude
+  # it will be wrapped by ` (' and `)$', so one must not match beginning or
+  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
+  # as well as any symbol that contains `d'.
+  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']
+  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
+  # platforms (ab)use it in PIC code, but their linkers get confused if
+  # the symbol is explicitly referenced.  Since portable code cannot
+  # rely on this symbol name, it's probably fine to never include it in
+  # preloaded symbol tables.
+  # Exclude shared library initialization/finalization symbols.
+dnl Note also adjust exclude_expsyms for C++ above.
+  extract_expsyms_cmds=
+
+  case $host_os in
+  cygwin* | mingw* | pw32* | cegcc*)
+    # FIXME: the MSVC++ port hasn't been tested in a loooong time
+    # When not using gcc, we currently assume that we are using
+    # Microsoft Visual C++.
+    if test "$GCC" != yes; then
+      with_gnu_ld=no
+    fi
+    ;;
+  interix*)
+    # we just hope/assume this is gcc and not c89 (= MSVC++)
+    with_gnu_ld=yes
+    ;;
+  openbsd*)
+    with_gnu_ld=no
+    ;;
+  esac
+
+  _LT_TAGVAR(ld_shlibs, $1)=yes
+
+  # On some targets, GNU ld is compatible enough with the native linker
+  # that we're better off using the native interface for both.
+  lt_use_gnu_ld_interface=no
+  if test "$with_gnu_ld" = yes; then
+    case $host_os in
+      aix*)
+	# The AIX port of GNU ld has always aspired to compatibility
+	# with the native linker.  However, as the warning in the GNU ld
+	# block says, versions before 2.19.5* couldn't really create working
+	# shared libraries, regardless of the interface used.
+	case `$LD -v 2>&1` in
+	  *\ \(GNU\ Binutils\)\ 2.19.5*) ;;
+	  *\ \(GNU\ Binutils\)\ 2.[[2-9]]*) ;;
+	  *\ \(GNU\ Binutils\)\ [[3-9]]*) ;;
+	  *)
+	    lt_use_gnu_ld_interface=yes
+	    ;;
+	esac
+	;;
+      *)
+	lt_use_gnu_ld_interface=yes
+	;;
+    esac
+  fi
+
+  if test "$lt_use_gnu_ld_interface" = yes; then
+    # If archive_cmds runs LD, not CC, wlarc should be empty
+    wlarc='${wl}'
+
+    # Set some defaults for GNU ld with shared library support. These
+    # are reset later if shared libraries are not supported. Putting them
+    # here allows them to be overridden if necessary.
+    runpath_var=LD_RUN_PATH
+    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+    # ancient GNU ld didn't support --whole-archive et. al.
+    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then
+      _LT_TAGVAR(whole_archive_flag_spec, $1)="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+    else
+      _LT_TAGVAR(whole_archive_flag_spec, $1)=
+    fi
+    supports_anon_versioning=no
+    case `$LD -v 2>&1` in
+      *GNU\ gold*) supports_anon_versioning=yes ;;
+      *\ [[01]].* | *\ 2.[[0-9]].* | *\ 2.10.*) ;; # catch versions < 2.11
+      *\ 2.11.93.0.2\ *) supports_anon_versioning=yes ;; # RH7.3 ...
+      *\ 2.11.92.0.12\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...
+      *\ 2.11.*) ;; # other 2.11 versions
+      *) supports_anon_versioning=yes ;;
+    esac
+
+    # See if GNU ld supports shared libraries.
+    case $host_os in
+    aix[[3-9]]*)
+      # On AIX/PPC, the GNU linker is very broken
+      if test "$host_cpu" != ia64; then
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: the GNU linker, at least up to release 2.19, is reported
+*** to be unable to reliably create shared libraries on AIX.
+*** Therefore, libtool is disabling shared libraries support.  If you
+*** really care for shared libraries, you may want to install binutils
+*** 2.20 or above, or modify your PATH so that a non-GNU linker is found.
+*** You will then need to restart the configuration process.
+
+_LT_EOF
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            _LT_TAGVAR(archive_expsym_cmds, $1)=''
+        ;;
+      m68k)
+            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+            _LT_TAGVAR(hardcode_minus_L, $1)=yes
+        ;;
+      esac
+      ;;
+
+    beos*)
+      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	_LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+	# Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+	# support --undefined.  This deserves some investigation.  FIXME
+	_LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    cygwin* | mingw* | pw32* | cegcc*)
+      # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,
+      # as there is no search path for DLLs.
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-all-symbols'
+      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+      _LT_TAGVAR(always_export_symbols, $1)=no
+      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
+      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\([[^ ]]*\)/\1 DATA/'\'' | $SED -e '\''/^[[AITW]][[ ]]/s/.*[[ ]]//'\'' | sort | uniq > $export_symbols'
+
+      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
+        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	# If the export-symbols file already is a .def file (1st line
+	# is EXPORTS), use it as is; otherwise, prepend...
+	_LT_TAGVAR(archive_expsym_cmds, $1)='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	  cp $export_symbols $output_objdir/$soname.def;
+	else
+	  echo EXPORTS > $output_objdir/$soname.def;
+	  cat $export_symbols >> $output_objdir/$soname.def;
+	fi~
+	$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    haiku*)
+      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      _LT_TAGVAR(link_all_deplibs, $1)=yes
+      ;;
+
+    interix[[3-9]]*)
+      _LT_TAGVAR(hardcode_direct, $1)=no
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
+      # Instead, shared libraries are loaded at an image base (0x10000000 by
+      # default) and relocated if they conflict, which is a slow very memory
+      # consuming and fragmenting process.  To avoid this, we pick a random,
+      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
+      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
+      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      _LT_TAGVAR(archive_expsym_cmds, $1)='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      ;;
+
+    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)
+      tmp_diet=no
+      if test "$host_os" = linux-dietlibc; then
+	case $cc_basename in
+	  diet\ *) tmp_diet=yes;;	# linux-dietlibc with static linking (!diet-dyn)
+	esac
+      fi
+      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \
+	 && test "$tmp_diet" = no
+      then
+	tmp_addflag=
+	tmp_sharedflag='-shared'
+	case $cc_basename,$host_cpu in
+        pgcc*)				# Portland Group C compiler
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag'
+	  ;;
+	pgf77* | pgf90* | pgf95* | pgfortran*)
+					# Portland Group f77 and f90 compilers
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag -Mnomain' ;;
+	ecc*,ia64* | icc*,ia64*)	# Intel C compiler on ia64
+	  tmp_addflag=' -i_dynamic' ;;
+	efc*,ia64* | ifort*,ia64*)	# Intel Fortran compiler on ia64
+	  tmp_addflag=' -i_dynamic -nofor_main' ;;
+	ifc* | ifort*)			# Intel Fortran compiler
+	  tmp_addflag=' -nofor_main' ;;
+	lf95*)				# Lahey Fortran 8.1
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)=
+	  tmp_sharedflag='--shared' ;;
+	xl[[cC]]* | bgxl[[cC]]* | mpixl[[cC]]*) # IBM XL C 8.0 on PPC (deal with xlf below)
+	  tmp_sharedflag='-qmkshrobj'
+	  tmp_addflag= ;;
+	nvcc*)	# Cuda Compiler Driver 2.2
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  _LT_TAGVAR(compiler_needs_object, $1)=yes
+	  ;;
+	esac
+	case `$CC -V 2>&1 | sed 5q` in
+	*Sun\ C*)			# Sun C 5.9
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  _LT_TAGVAR(compiler_needs_object, $1)=yes
+	  tmp_sharedflag='-G' ;;
+	*Sun\ F*)			# Sun Fortran 8.3
+	  tmp_sharedflag='-G' ;;
+	esac
+	_LT_TAGVAR(archive_cmds, $1)='$CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+
+        if test "x$supports_anon_versioning" = xyes; then
+          _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $output_objdir/$libname.ver~
+	    cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+	    echo "local: *; };" >> $output_objdir/$libname.ver~
+	    $CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+        fi
+
+	case $cc_basename in
+	xlf* | bgf* | bgxlf* | mpixlf*)
+	  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='--whole-archive$convenience --no-whole-archive'
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+	  _LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)='-rpath $libdir'
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -shared $libobjs $deplibs $linker_flags -soname $soname -o $lib'
+	  if test "x$supports_anon_versioning" = xyes; then
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $output_objdir/$libname.ver~
+	      cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+	      echo "local: *; };" >> $output_objdir/$libname.ver~
+	      $LD -shared $libobjs $deplibs $linker_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'
+	  fi
+	  ;;
+	esac
+      else
+        _LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    netbsd*)
+      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
+	wlarc=
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      fi
+      ;;
+
+    solaris*)
+      if $LD -v 2>&1 | $GREP 'BFD 2\.8' > /dev/null; then
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: The releases 2.8.* of the GNU linker cannot reliably
+*** create shared libraries on Solaris systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.9.1 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+_LT_EOF
+      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
+      case `$LD -v 2>&1` in
+        *\ [[01]].* | *\ 2.[[0-9]].* | *\ 2.1[[0-5]].*)
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not
+*** reliably create shared libraries on SCO systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+_LT_EOF
+	;;
+	*)
+	  # For security reasons, it is highly recommended that you always
+	  # use absolute paths for naming shared libraries, and exclude the
+	  # DT_RUNPATH tag from executables and libraries.  But doing so
+	  # requires that you compile everything twice, which is a pain.
+	  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	  else
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	  fi
+	;;
+      esac
+      ;;
+
+    sunos4*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      wlarc=
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    *)
+      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+    esac
+
+    if test "$_LT_TAGVAR(ld_shlibs, $1)" = no; then
+      runpath_var=
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)=
+      _LT_TAGVAR(whole_archive_flag_spec, $1)=
+    fi
+  else
+    # PORTME fill in a description of your system's linker (not GNU ld)
+    case $host_os in
+    aix3*)
+      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+      _LT_TAGVAR(always_export_symbols, $1)=yes
+      _LT_TAGVAR(archive_expsym_cmds, $1)='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'
+      # Note: this linker hardcodes the directories in LIBPATH if there
+      # are no directories specified by -L.
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      if test "$GCC" = yes && test -z "$lt_prog_compiler_static"; then
+	# Neither direct hardcoding nor static linking is supported with a
+	# broken collect2.
+	_LT_TAGVAR(hardcode_direct, $1)=unsupported
+      fi
+      ;;
+
+    aix[[4-9]]*)
+      if test "$host_cpu" = ia64; then
+	# On IA64, the linker does run time linking by default, so we don't
+	# have to do anything special.
+	aix_use_runtimelinking=no
+	exp_sym_flag='-Bexport'
+	no_entry_flag=""
+      else
+	# If we're using GNU nm, then we don't want the "-C" option.
+	# -C means demangle to AIX nm, but means don't demangle with GNU nm
+	# Also, AIX nm treats weak defined symbols like other global
+	# defined symbols, whereas GNU nm marks them as "W".
+	if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
+	  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	else
+	  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	fi
+	aix_use_runtimelinking=no
+
+	# Test if we are trying to use run time linking or normal
+	# AIX style linking. If -brtl is somewhere in LDFLAGS, we
+	# need to do runtime linking.
+	case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)
+	  for ld_flag in $LDFLAGS; do
+	  if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
+	    aix_use_runtimelinking=yes
+	    break
+	  fi
+	  done
+	  ;;
+	esac
+
+	exp_sym_flag='-bexport'
+	no_entry_flag='-bnoentry'
+      fi
+
+      # When large executables or shared objects are built, AIX ld can
+      # have problems creating the table of contents.  If linking a library
+      # or program results in "error TOC overflow" add -mminimal-toc to
+      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
+
+      _LT_TAGVAR(archive_cmds, $1)=''
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'
+      _LT_TAGVAR(link_all_deplibs, $1)=yes
+      _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'
+
+      if test "$GCC" = yes; then
+	case $host_os in aix4.[[012]]|aix4.[[012]].*)
+	# We only want to do this on AIX 4.2 and lower, the check
+	# below for broken collect2 doesn't work under 4.3+
+	  collect2name=`${CC} -print-prog-name=collect2`
+	  if test -f "$collect2name" &&
+	   strings "$collect2name" | $GREP resolve_lib_name >/dev/null
+	  then
+	  # We have reworked collect2
+	  :
+	  else
+	  # We have old collect2
+	  _LT_TAGVAR(hardcode_direct, $1)=unsupported
+	  # It fails to find uninstalled libraries when the uninstalled
+	  # path is not listed in the libpath.  Setting hardcode_minus_L
+	  # to unsupported forces relinking
+	  _LT_TAGVAR(hardcode_minus_L, $1)=yes
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+	  _LT_TAGVAR(hardcode_libdir_separator, $1)=
+	  fi
+	  ;;
+	esac
+	shared_flag='-shared'
+	if test "$aix_use_runtimelinking" = yes; then
+	  shared_flag="$shared_flag "'${wl}-G'
+	fi
+      else
+	# not using gcc
+	if test "$host_cpu" = ia64; then
+	# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
+	# chokes on -Wl,-G. The following line is correct:
+	  shared_flag='-G'
+	else
+	  if test "$aix_use_runtimelinking" = yes; then
+	    shared_flag='${wl}-G'
+	  else
+	    shared_flag='${wl}-bM:SRE'
+	  fi
+	fi
+      fi
+
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'
+      # It seems that -bexpall does not export symbols beginning with
+      # underscore (_), so it is better to generate a list of symbols to export.
+      _LT_TAGVAR(always_export_symbols, $1)=yes
+      if test "$aix_use_runtimelinking" = yes; then
+	# Warning - without using the other runtime loading flags (-brtl),
+	# -berok will link without error, but may produce a broken library.
+	_LT_TAGVAR(allow_undefined_flag, $1)='-berok'
+        # Determine the default libpath from the value encoded in an
+        # empty executable.
+        _LT_SYS_MODULE_PATH_AIX
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
+        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then func_echo_all "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+      else
+	if test "$host_cpu" = ia64; then
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'
+	  _LT_TAGVAR(allow_undefined_flag, $1)="-z nodefs"
+	  _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+	else
+	 # Determine the default libpath from the value encoded in an
+	 # empty executable.
+	 _LT_SYS_MODULE_PATH_AIX
+	 _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
+	  # Warning - without using the other run time loading flags,
+	  # -berok will link without error, but may produce a broken library.
+	  _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'
+	  _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'
+	  if test "$with_gnu_ld" = yes; then
+	    # We only use this code for GNU lds that support --whole-archive.
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	  else
+	    # Exported symbols can be pulled into shared objects from archives
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'
+	  fi
+	  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes
+	  # This is similar to how AIX traditionally builds its shared libraries.
+	  _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+	fi
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            _LT_TAGVAR(archive_expsym_cmds, $1)=''
+        ;;
+      m68k)
+            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+            _LT_TAGVAR(hardcode_minus_L, $1)=yes
+        ;;
+      esac
+      ;;
+
+    bsdi[[45]]*)
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)=-rdynamic
+      ;;
+
+    cygwin* | mingw* | pw32* | cegcc*)
+      # When not using gcc, we currently assume that we are using
+      # Microsoft Visual C++.
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '
+      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+      # Tell ltmain to make .lib files, not .a files.
+      libext=lib
+      # Tell ltmain to make .dll files, not .so files.
+      shrext_cmds=".dll"
+      # FIXME: Setting linknames here is a bad hack.
+      _LT_TAGVAR(archive_cmds, $1)='$CC -o $lib $libobjs $compiler_flags `func_echo_all "$deplibs" | $SED '\''s/ -lc$//'\''` -link -dll~linknames='
+      # The linker will automatically build a .lib file if we build a DLL.
+      _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'
+      # FIXME: Should let the user specify the lib program.
+      _LT_TAGVAR(old_archive_cmds, $1)='lib -OUT:$oldlib$oldobjs$old_deplibs'
+      _LT_TAGVAR(fix_srcfile_path, $1)='`cygpath -w "$srcfile"`'
+      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
+      ;;
+
+    darwin* | rhapsody*)
+      _LT_DARWIN_LINKER_FEATURES($1)
+      ;;
+
+    dgux*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    freebsd1*)
+      _LT_TAGVAR(ld_shlibs, $1)=no
+      ;;
+
+    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor
+    # support.  Future versions do this automatically, but an explicit c++rt0.o
+    # does not break anything, and helps significantly (at the cost of a little
+    # extra space).
+    freebsd2.2*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    # Unfortunately, older versions of FreeBSD 2 do not have this feature.
+    freebsd2*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
+    freebsd* | dragonfly*)
+      _LT_TAGVAR(archive_cmds, $1)='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    hpux9*)
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      fi
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+
+      # hardcode_minus_L: Not really in the search PATH,
+      # but as the default location of the library.
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+      ;;
+
+    hpux10*)
+      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      if test "$with_gnu_ld" = no; then
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+	_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)='+b $libdir'
+	_LT_TAGVAR(hardcode_libdir_separator, $1)=:
+	_LT_TAGVAR(hardcode_direct, $1)=yes
+	_LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	# hardcode_minus_L: Not really in the search PATH,
+	# but as the default location of the library.
+	_LT_TAGVAR(hardcode_minus_L, $1)=yes
+      fi
+      ;;
+
+    hpux11*)
+      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
+	case $host_cpu in
+	hppa*64*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	esac
+      else
+	case $host_cpu in
+	hppa*64*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	m4_if($1, [], [
+	  # Older versions of the 11.00 compiler do not understand -b yet
+	  # (HP92453-01 A.11.01.20 doesn't, HP92453-01 B.11.X.35175-35176.GP does)
+	  _LT_LINKER_OPTION([if $CC understands -b],
+	    _LT_TAGVAR(lt_cv_prog_compiler__b, $1), [-b],
+	    [_LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'],
+	    [_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'])],
+	  [_LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'])
+	  ;;
+	esac
+      fi
+      if test "$with_gnu_ld" = no; then
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+	_LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	case $host_cpu in
+	hppa*64*|ia64*)
+	  _LT_TAGVAR(hardcode_direct, $1)=no
+	  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	  ;;
+	*)
+	  _LT_TAGVAR(hardcode_direct, $1)=yes
+	  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+	  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+
+	  # hardcode_minus_L: Not really in the search PATH,
+	  # but as the default location of the library.
+	  _LT_TAGVAR(hardcode_minus_L, $1)=yes
+	  ;;
+	esac
+      fi
+      ;;
+
+    irix5* | irix6* | nonstopux*)
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	# Try to use the -exported_symbol ld option, if it does not
+	# work, assume that -exports_file does not work either and
+	# implicitly export all symbols.
+        save_LDFLAGS="$LDFLAGS"
+        LDFLAGS="$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null"
+        AC_LINK_IFELSE(int foo(void) {},
+          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'
+        )
+        LDFLAGS="$save_LDFLAGS"
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'
+      fi
+      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      _LT_TAGVAR(inherit_rpath, $1)=yes
+      _LT_TAGVAR(link_all_deplibs, $1)=yes
+      ;;
+
+    netbsd*)
+      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF
+      fi
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    newsos6)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    *nto* | *qnx*)
+      ;;
+
+    openbsd*)
+      if test -f /usr/libexec/ld.so; then
+	_LT_TAGVAR(hardcode_direct, $1)=yes
+	_LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	_LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+	if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	else
+	  case $host_os in
+	   openbsd[[01]].* | openbsd2.[[0-7]] | openbsd2.[[0-7]].*)
+	     _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+	     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+	     ;;
+	   *)
+	     _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	     ;;
+	  esac
+	fi
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    os2*)
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+      _LT_TAGVAR(archive_cmds, $1)='$ECHO "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~echo DATA >> $output_objdir/$libname.def~echo " SINGLE NONSHARED" >> $output_objdir/$libname.def~echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
+      _LT_TAGVAR(old_archive_from_new_cmds, $1)='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
+      ;;
+
+    osf3*)
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      else
+	_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \*'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+      fi
+      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      ;;
+
+    osf4* | osf5*)	# as osf3* with the addition of -msym flag
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      else
+	_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \*'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done; printf "%s\\n" "-hidden">> $lib.exp~
+	$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'
+
+	# Both c and cxx compiler support -rpath directly
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'
+      fi
+      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      ;;
+
+    solaris*)
+      _LT_TAGVAR(no_undefined_flag, $1)=' -z defs'
+      if test "$GCC" = yes; then
+	wlarc='${wl}'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $CC -shared ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+      else
+	case `$CC -V 2>&1` in
+	*"Compilers 5.0"*)
+	  wlarc=''
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'
+	  ;;
+	*)
+	  wlarc='${wl}'
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+	  ;;
+	esac
+      fi
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      case $host_os in
+      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;
+      *)
+	# The compiler driver will combine and reorder linker options,
+	# but understands `-z linker_flag'.  GCC discards it without `$wl',
+	# but is careful enough not to reorder.
+	# Supported since Solaris 2.6 (maybe 2.5.1?)
+	if test "$GCC" = yes; then
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
+	else
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'
+	fi
+	;;
+      esac
+      _LT_TAGVAR(link_all_deplibs, $1)=yes
+      ;;
+
+    sunos4*)
+      if test "x$host_vendor" = xsequent; then
+	# Use $CC to link under sequent, because it throws in some extra .o
+	# files that make .init and .fini sections work.
+	_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    sysv4)
+      case $host_vendor in
+	sni)
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  _LT_TAGVAR(hardcode_direct, $1)=yes # is this really true???
+	;;
+	siemens)
+	  ## LD is ld it makes a PLAMLIB
+	  ## CC just makes a GrossModule.
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -G -o $lib $libobjs $deplibs $linker_flags'
+	  _LT_TAGVAR(reload_cmds, $1)='$CC -r -o $output$reload_objs'
+	  _LT_TAGVAR(hardcode_direct, $1)=no
+        ;;
+	motorola)
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  _LT_TAGVAR(hardcode_direct, $1)=no #Motorola manual says yes, but my tests say they lie
+	;;
+      esac
+      runpath_var='LD_RUN_PATH'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    sysv4.3*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='-Bexport'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	_LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	_LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	runpath_var=LD_RUN_PATH
+	hardcode_runpath_var=yes
+	_LT_TAGVAR(ld_shlibs, $1)=yes
+      fi
+      ;;
+
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)
+      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
+      _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      runpath_var='LD_RUN_PATH'
+
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
+
+    sysv5* | sco3.2v5* | sco5v6*)
+      # Note: We can NOT use -z defs as we might desire, because we do not
+      # link with -lc, and that would cause any symbols used from libc to
+      # always be unresolved, which means just about no library would
+      # ever link correctly.  If we're not using GNU ld we use -z text
+      # though, which does catch some bad symbols but isn't as heavy-handed
+      # as -z defs.
+      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
+      _LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'
+      _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'
+      _LT_TAGVAR(link_all_deplibs, $1)=yes
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'
+      runpath_var='LD_RUN_PATH'
+
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
+
+    uts4*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    *)
+      _LT_TAGVAR(ld_shlibs, $1)=no
+      ;;
+    esac
+
+    if test x$host_vendor = xsni; then
+      case $host in
+      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Blargedynsym'
+	;;
+      esac
+    fi
+  fi
+])
+AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])
+test "$_LT_TAGVAR(ld_shlibs, $1)" = no && can_build_shared=no
+
+_LT_TAGVAR(with_gnu_ld, $1)=$with_gnu_ld
+
+_LT_DECL([], [libext], [0], [Old archive suffix (normally "a")])dnl
+_LT_DECL([], [shrext_cmds], [1], [Shared library suffix (normally ".so")])dnl
+_LT_DECL([], [extract_expsyms_cmds], [2],
+    [The commands to extract the exported symbol list from a shared archive])
+
+#
+# Do we need to explicitly link libc?
+#
+case "x$_LT_TAGVAR(archive_cmds_need_lc, $1)" in
+x|xyes)
+  # Assume -lc should be added
+  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes
+
+  if test "$enable_shared" = yes && test "$GCC" = yes; then
+    case $_LT_TAGVAR(archive_cmds, $1) in
+    *'~'*)
+      # FIXME: we may have to deal with multi-command sequences.
+      ;;
+    '$CC '*)
+      # Test whether the compiler implicitly links with -lc since on some
+      # systems, -lgcc has to come before -lc. If gcc already passes -lc
+      # to ld, don't add -lc before -lgcc.
+      AC_CACHE_CHECK([whether -lc should be explicitly linked in],
+	[lt_cv_]_LT_TAGVAR(archive_cmds_need_lc, $1),
+	[$RM conftest*
+	echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+	if AC_TRY_EVAL(ac_compile) 2>conftest.err; then
+	  soname=conftest
+	  lib=conftest
+	  libobjs=conftest.$ac_objext
+	  deplibs=
+	  wl=$_LT_TAGVAR(lt_prog_compiler_wl, $1)
+	  pic_flag=$_LT_TAGVAR(lt_prog_compiler_pic, $1)
+	  compiler_flags=-v
+	  linker_flags=-v
+	  verstring=
+	  output_objdir=.
+	  libname=conftest
+	  lt_save_allow_undefined_flag=$_LT_TAGVAR(allow_undefined_flag, $1)
+	  _LT_TAGVAR(allow_undefined_flag, $1)=
+	  if AC_TRY_EVAL(_LT_TAGVAR(archive_cmds, $1) 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1)
+	  then
+	    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+	  else
+	    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=yes
+	  fi
+	  _LT_TAGVAR(allow_undefined_flag, $1)=$lt_save_allow_undefined_flag
+	else
+	  cat conftest.err 1>&5
+	fi
+	$RM conftest*
+	])
+      _LT_TAGVAR(archive_cmds_need_lc, $1)=$lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)
+      ;;
+    esac
+  fi
+  ;;
+esac
+
+_LT_TAGDECL([build_libtool_need_lc], [archive_cmds_need_lc], [0],
+    [Whether or not to add -lc for building shared libraries])
+_LT_TAGDECL([allow_libtool_libs_with_static_runtimes],
+    [enable_shared_with_static_runtimes], [0],
+    [Whether or not to disallow shared libs when runtime libs are static])
+_LT_TAGDECL([], [export_dynamic_flag_spec], [1],
+    [Compiler flag to allow reflexive dlopens])
+_LT_TAGDECL([], [whole_archive_flag_spec], [1],
+    [Compiler flag to generate shared objects directly from archives])
+_LT_TAGDECL([], [compiler_needs_object], [1],
+    [Whether the compiler copes with passing no objects directly])
+_LT_TAGDECL([], [old_archive_from_new_cmds], [2],
+    [Create an old-style archive from a shared archive])
+_LT_TAGDECL([], [old_archive_from_expsyms_cmds], [2],
+    [Create a temporary old-style archive to link instead of a shared archive])
+_LT_TAGDECL([], [archive_cmds], [2], [Commands used to build a shared archive])
+_LT_TAGDECL([], [archive_expsym_cmds], [2])
+_LT_TAGDECL([], [module_cmds], [2],
+    [Commands used to build a loadable module if different from building
+    a shared archive.])
+_LT_TAGDECL([], [module_expsym_cmds], [2])
+_LT_TAGDECL([], [with_gnu_ld], [1],
+    [Whether we are building with GNU ld or not])
+_LT_TAGDECL([], [allow_undefined_flag], [1],
+    [Flag that allows shared libraries with undefined symbols to be built])
+_LT_TAGDECL([], [no_undefined_flag], [1],
+    [Flag that enforces no undefined symbols])
+_LT_TAGDECL([], [hardcode_libdir_flag_spec], [1],
+    [Flag to hardcode $libdir into a binary during linking.
+    This must work even if $libdir does not exist])
+_LT_TAGDECL([], [hardcode_libdir_flag_spec_ld], [1],
+    [[If ld is used when linking, flag to hardcode $libdir into a binary
+    during linking.  This must work even if $libdir does not exist]])
+_LT_TAGDECL([], [hardcode_libdir_separator], [1],
+    [Whether we need a single "-rpath" flag with a separated argument])
+_LT_TAGDECL([], [hardcode_direct], [0],
+    [Set to "yes" if using DIR/libNAME${shared_ext} during linking hardcodes
+    DIR into the resulting binary])
+_LT_TAGDECL([], [hardcode_direct_absolute], [0],
+    [Set to "yes" if using DIR/libNAME${shared_ext} during linking hardcodes
+    DIR into the resulting binary and the resulting library dependency is
+    "absolute", i.e impossible to change by setting ${shlibpath_var} if the
+    library is relocated])
+_LT_TAGDECL([], [hardcode_minus_L], [0],
+    [Set to "yes" if using the -LDIR flag during linking hardcodes DIR
+    into the resulting binary])
+_LT_TAGDECL([], [hardcode_shlibpath_var], [0],
+    [Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
+    into the resulting binary])
+_LT_TAGDECL([], [hardcode_automatic], [0],
+    [Set to "yes" if building a shared library automatically hardcodes DIR
+    into the library and all subsequent libraries and executables linked
+    against it])
+_LT_TAGDECL([], [inherit_rpath], [0],
+    [Set to yes if linker adds runtime paths of dependent libraries
+    to runtime path list])
+_LT_TAGDECL([], [link_all_deplibs], [0],
+    [Whether libtool must link a program against all its dependency libraries])
+_LT_TAGDECL([], [fix_srcfile_path], [1],
+    [Fix the shell variable $srcfile for the compiler])
+_LT_TAGDECL([], [always_export_symbols], [0],
+    [Set to "yes" if exported symbols are required])
+_LT_TAGDECL([], [export_symbols_cmds], [2],
+    [The commands to list exported symbols])
+_LT_TAGDECL([], [exclude_expsyms], [1],
+    [Symbols that should not be listed in the preloaded symbols])
+_LT_TAGDECL([], [include_expsyms], [1],
+    [Symbols that must always be exported])
+_LT_TAGDECL([], [prelink_cmds], [2],
+    [Commands necessary for linking programs (against libraries) with templates])
+_LT_TAGDECL([], [file_list_spec], [1],
+    [Specify filename containing input files])
+dnl FIXME: Not yet implemented
+dnl _LT_TAGDECL([], [thread_safe_flag_spec], [1],
+dnl    [Compiler flag to generate thread safe objects])
+])# _LT_LINKER_SHLIBS
+
+
+# _LT_LANG_C_CONFIG([TAG])
+# ------------------------
+# Ensure that the configuration variables for a C compiler are suitably
+# defined.  These variables are subsequently used by _LT_CONFIG to write
+# the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_C_CONFIG],
+[m4_require([_LT_DECL_EGREP])dnl
+lt_save_CC="$CC"
+AC_LANG_PUSH(C)
+
+# Source file extension for C test sources.
+ac_ext=c
+
+# Object file extension for compiled C test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# Code to be used in simple compile tests
+lt_simple_compile_test_code="int some_variable = 0;"
+
+# Code to be used in simple link tests
+lt_simple_link_test_code='int main(){return(0);}'
+
+_LT_TAG_COMPILER
+# Save the default compiler, since it gets overwritten when the other
+# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.
+compiler_DEFAULT=$CC
+
+# save warnings/boilerplate of simple test code
+_LT_COMPILER_BOILERPLATE
+_LT_LINKER_BOILERPLATE
+
+if test -n "$compiler"; then
+  _LT_COMPILER_NO_RTTI($1)
+  _LT_COMPILER_PIC($1)
+  _LT_COMPILER_C_O($1)
+  _LT_COMPILER_FILE_LOCKS($1)
+  _LT_LINKER_SHLIBS($1)
+  _LT_SYS_DYNAMIC_LINKER($1)
+  _LT_LINKER_HARDCODE_LIBPATH($1)
+  LT_SYS_DLOPEN_SELF
+  _LT_CMD_STRIPLIB
+
+  # Report which library types will actually be built
+  AC_MSG_CHECKING([if libtool supports shared libraries])
+  AC_MSG_RESULT([$can_build_shared])
+
+  AC_MSG_CHECKING([whether to build shared libraries])
+  test "$can_build_shared" = "no" && enable_shared=no
+
+  # On AIX, shared libraries and static libraries use the same namespace, and
+  # are all built from PIC.
+  case $host_os in
+  aix3*)
+    test "$enable_shared" = yes && enable_static=no
+    if test -n "$RANLIB"; then
+      archive_cmds="$archive_cmds~\$RANLIB \$lib"
+      postinstall_cmds='$RANLIB $lib'
+    fi
+    ;;
+
+  aix[[4-9]]*)
+    if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+      test "$enable_shared" = yes && enable_static=no
+    fi
+    ;;
+  esac
+  AC_MSG_RESULT([$enable_shared])
+
+  AC_MSG_CHECKING([whether to build static libraries])
+  # Make sure either enable_shared or enable_static is yes.
+  test "$enable_shared" = yes || enable_static=yes
+  AC_MSG_RESULT([$enable_static])
+
+  _LT_CONFIG($1)
+fi
+AC_LANG_POP
+CC="$lt_save_CC"
+])# _LT_LANG_C_CONFIG
+
+
+# _LT_LANG_CXX_CONFIG([TAG])
+# --------------------------
+# Ensure that the configuration variables for a C++ compiler are suitably
+# defined.  These variables are subsequently used by _LT_CONFIG to write
+# the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_CXX_CONFIG],
+[m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_EGREP])dnl
+if test -n "$CXX" && ( test "X$CXX" != "Xno" &&
+    ( (test "X$CXX" = "Xg++" && `g++ -v >/dev/null 2>&1` ) ||
+    (test "X$CXX" != "Xg++"))) ; then
+  AC_PROG_CXXCPP
+else
+  _lt_caught_CXX_error=yes
+fi
+
+AC_LANG_PUSH(C++)
+_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+_LT_TAGVAR(allow_undefined_flag, $1)=
+_LT_TAGVAR(always_export_symbols, $1)=no
+_LT_TAGVAR(archive_expsym_cmds, $1)=
+_LT_TAGVAR(compiler_needs_object, $1)=no
+_LT_TAGVAR(export_dynamic_flag_spec, $1)=
+_LT_TAGVAR(hardcode_direct, $1)=no
+_LT_TAGVAR(hardcode_direct_absolute, $1)=no
+_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=
+_LT_TAGVAR(hardcode_libdir_separator, $1)=
+_LT_TAGVAR(hardcode_minus_L, $1)=no
+_LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported
+_LT_TAGVAR(hardcode_automatic, $1)=no
+_LT_TAGVAR(inherit_rpath, $1)=no
+_LT_TAGVAR(module_cmds, $1)=
+_LT_TAGVAR(module_expsym_cmds, $1)=
+_LT_TAGVAR(link_all_deplibs, $1)=unknown
+_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds
+_LT_TAGVAR(reload_flag, $1)=$reload_flag
+_LT_TAGVAR(reload_cmds, $1)=$reload_cmds
+_LT_TAGVAR(no_undefined_flag, $1)=
+_LT_TAGVAR(whole_archive_flag_spec, $1)=
+_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no
+
+# Source file extension for C++ test sources.
+ac_ext=cpp
+
+# Object file extension for compiled C++ test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# No sense in running all these tests if we already determined that
+# the CXX compiler isn't working.  Some variables (like enable_shared)
+# are currently assumed to apply to all compilers on this platform,
+# and will be corrupted by setting them based on a non-working compiler.
+if test "$_lt_caught_CXX_error" != yes; then
+  # Code to be used in simple compile tests
+  lt_simple_compile_test_code="int some_variable = 0;"
+
+  # Code to be used in simple link tests
+  lt_simple_link_test_code='int main(int, char *[[]]) { return(0); }'
+
+  # ltmain only uses $CC for tagged configurations so make sure $CC is set.
+  _LT_TAG_COMPILER
+
+  # save warnings/boilerplate of simple test code
+  _LT_COMPILER_BOILERPLATE
+  _LT_LINKER_BOILERPLATE
+
+  # Allow CC to be a program name with arguments.
+  lt_save_CC=$CC
+  lt_save_LD=$LD
+  lt_save_GCC=$GCC
+  GCC=$GXX
+  lt_save_with_gnu_ld=$with_gnu_ld
+  lt_save_path_LD=$lt_cv_path_LD
+  if test -n "${lt_cv_prog_gnu_ldcxx+set}"; then
+    lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx
+  else
+    $as_unset lt_cv_prog_gnu_ld
+  fi
+  if test -n "${lt_cv_path_LDCXX+set}"; then
+    lt_cv_path_LD=$lt_cv_path_LDCXX
+  else
+    $as_unset lt_cv_path_LD
+  fi
+  test -z "${LDCXX+set}" || LD=$LDCXX
+  CC=${CXX-"c++"}
+  compiler=$CC
+  _LT_TAGVAR(compiler, $1)=$CC
+  _LT_CC_BASENAME([$compiler])
+
+  if test -n "$compiler"; then
+    # We don't want -fno-exception when compiling C++ code, so set the
+    # no_builtin_flag separately
+    if test "$GXX" = yes; then
+      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'
+    else
+      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=
+    fi
+
+    if test "$GXX" = yes; then
+      # Set up default GNU C++ configuration
+
+      LT_PATH_LD
+
+      # Check if GNU C++ uses GNU ld as the underlying linker, since the
+      # archiving commands below assume that GNU ld is being used.
+      if test "$with_gnu_ld" = yes; then
+        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+
+        # If archive_cmds runs LD, not CC, wlarc should be empty
+        # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to
+        #     investigate it a little bit more. (MM)
+        wlarc='${wl}'
+
+        # ancient GNU ld didn't support --whole-archive et. al.
+        if eval "`$CC -print-prog-name=ld` --help 2>&1" |
+	  $GREP 'no-whole-archive' > /dev/null; then
+          _LT_TAGVAR(whole_archive_flag_spec, $1)="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+        else
+          _LT_TAGVAR(whole_archive_flag_spec, $1)=
+        fi
+      else
+        with_gnu_ld=no
+        wlarc=
+
+        # A generic and very simple default shared library creation
+        # command for GNU C++ for the case where it uses the native
+        # linker, instead of GNU ld.  If possible, this setting should
+        # overridden to take advantage of the native linker features on
+        # the platform it is being used on.
+        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'
+      fi
+
+      # Commands to make compiler produce verbose output that lists
+      # what "hidden" libraries, object files and flags are used when
+      # linking a shared library.
+      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
+
+    else
+      GXX=no
+      with_gnu_ld=no
+      wlarc=
+    fi
+
+    # PORTME: fill in a description of your system's C++ link characteristics
+    AC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])
+    _LT_TAGVAR(ld_shlibs, $1)=yes
+    case $host_os in
+      aix3*)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+      aix[[4-9]]*)
+        if test "$host_cpu" = ia64; then
+          # On IA64, the linker does run time linking by default, so we don't
+          # have to do anything special.
+          aix_use_runtimelinking=no
+          exp_sym_flag='-Bexport'
+          no_entry_flag=""
+        else
+          aix_use_runtimelinking=no
+
+          # Test if we are trying to use run time linking or normal
+          # AIX style linking. If -brtl is somewhere in LDFLAGS, we
+          # need to do runtime linking.
+          case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)
+	    for ld_flag in $LDFLAGS; do
+	      case $ld_flag in
+	      *-brtl*)
+	        aix_use_runtimelinking=yes
+	        break
+	        ;;
+	      esac
+	    done
+	    ;;
+          esac
+
+          exp_sym_flag='-bexport'
+          no_entry_flag='-bnoentry'
+        fi
+
+        # When large executables or shared objects are built, AIX ld can
+        # have problems creating the table of contents.  If linking a library
+        # or program results in "error TOC overflow" add -mminimal-toc to
+        # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+        # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
+
+        _LT_TAGVAR(archive_cmds, $1)=''
+        _LT_TAGVAR(hardcode_direct, $1)=yes
+        _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+        _LT_TAGVAR(hardcode_libdir_separator, $1)=':'
+        _LT_TAGVAR(link_all_deplibs, $1)=yes
+        _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'
+
+        if test "$GXX" = yes; then
+          case $host_os in aix4.[[012]]|aix4.[[012]].*)
+          # We only want to do this on AIX 4.2 and lower, the check
+          # below for broken collect2 doesn't work under 4.3+
+	  collect2name=`${CC} -print-prog-name=collect2`
+	  if test -f "$collect2name" &&
+	     strings "$collect2name" | $GREP resolve_lib_name >/dev/null
+	  then
+	    # We have reworked collect2
+	    :
+	  else
+	    # We have old collect2
+	    _LT_TAGVAR(hardcode_direct, $1)=unsupported
+	    # It fails to find uninstalled libraries when the uninstalled
+	    # path is not listed in the libpath.  Setting hardcode_minus_L
+	    # to unsupported forces relinking
+	    _LT_TAGVAR(hardcode_minus_L, $1)=yes
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+	    _LT_TAGVAR(hardcode_libdir_separator, $1)=
+	  fi
+          esac
+          shared_flag='-shared'
+	  if test "$aix_use_runtimelinking" = yes; then
+	    shared_flag="$shared_flag "'${wl}-G'
+	  fi
+        else
+          # not using gcc
+          if test "$host_cpu" = ia64; then
+	  # VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
+	  # chokes on -Wl,-G. The following line is correct:
+	  shared_flag='-G'
+          else
+	    if test "$aix_use_runtimelinking" = yes; then
+	      shared_flag='${wl}-G'
+	    else
+	      shared_flag='${wl}-bM:SRE'
+	    fi
+          fi
+        fi
+
+        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'
+        # It seems that -bexpall does not export symbols beginning with
+        # underscore (_), so it is better to generate a list of symbols to
+	# export.
+        _LT_TAGVAR(always_export_symbols, $1)=yes
+        if test "$aix_use_runtimelinking" = yes; then
+          # Warning - without using the other runtime loading flags (-brtl),
+          # -berok will link without error, but may produce a broken library.
+          _LT_TAGVAR(allow_undefined_flag, $1)='-berok'
+          # Determine the default libpath from the value encoded in an empty
+          # executable.
+          _LT_SYS_MODULE_PATH_AIX
+          _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
+
+          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then func_echo_all "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+        else
+          if test "$host_cpu" = ia64; then
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'
+	    _LT_TAGVAR(allow_undefined_flag, $1)="-z nodefs"
+	    _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+          else
+	    # Determine the default libpath from the value encoded in an
+	    # empty executable.
+	    _LT_SYS_MODULE_PATH_AIX
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
+	    # Warning - without using the other run time loading flags,
+	    # -berok will link without error, but may produce a broken library.
+	    _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'
+	    _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'
+	    if test "$with_gnu_ld" = yes; then
+	      # We only use this code for GNU lds that support --whole-archive.
+	      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	    else
+	      # Exported symbols can be pulled into shared objects from archives
+	      _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'
+	    fi
+	    _LT_TAGVAR(archive_cmds_need_lc, $1)=yes
+	    # This is similar to how AIX traditionally builds its shared
+	    # libraries.
+	    _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+          fi
+        fi
+        ;;
+
+      beos*)
+	if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+	  # Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+	  # support --undefined.  This deserves some investigation.  FIXME
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	else
+	  _LT_TAGVAR(ld_shlibs, $1)=no
+	fi
+	;;
+
+      chorus*)
+        case $cc_basename in
+          *)
+	  # FIXME: insert proper C++ library support
+	  _LT_TAGVAR(ld_shlibs, $1)=no
+	  ;;
+        esac
+        ;;
+
+      cygwin* | mingw* | pw32* | cegcc*)
+        # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,
+        # as there is no search path for DLLs.
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-all-symbols'
+        _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+        _LT_TAGVAR(always_export_symbols, $1)=no
+        _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
+
+        if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
+          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+          # If the export-symbols file already is a .def file (1st line
+          # is EXPORTS), use it as is; otherwise, prepend...
+          _LT_TAGVAR(archive_expsym_cmds, $1)='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	    cp $export_symbols $output_objdir/$soname.def;
+          else
+	    echo EXPORTS > $output_objdir/$soname.def;
+	    cat $export_symbols >> $output_objdir/$soname.def;
+          fi~
+          $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+        else
+          _LT_TAGVAR(ld_shlibs, $1)=no
+        fi
+        ;;
+      darwin* | rhapsody*)
+        _LT_DARWIN_LINKER_FEATURES($1)
+	;;
+
+      dgux*)
+        case $cc_basename in
+          ec++*)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          ghcx*)
+	    # Green Hills C++ Compiler
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          *)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+        esac
+        ;;
+
+      freebsd[[12]]*)
+        # C++ shared libraries reported to be fairly broken before
+	# switch to ELF
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+
+      freebsd-elf*)
+        _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+        ;;
+
+      freebsd* | dragonfly*)
+        # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF
+        # conventions
+        _LT_TAGVAR(ld_shlibs, $1)=yes
+        ;;
+
+      gnu*)
+        ;;
+
+      haiku*)
+        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+        _LT_TAGVAR(link_all_deplibs, $1)=yes
+        ;;
+
+      hpux9*)
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+        _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+        _LT_TAGVAR(hardcode_direct, $1)=yes
+        _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,
+				             # but as the default
+				             # location of the library.
+
+        case $cc_basename in
+          CC*)
+            # FIXME: insert proper C++ library support
+            _LT_TAGVAR(ld_shlibs, $1)=no
+            ;;
+          aCC*)
+            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -b ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+            # Commands to make compiler produce verbose output that lists
+            # what "hidden" libraries, object files and flags are used when
+            # linking a shared library.
+            #
+            # There doesn't appear to be a way to prevent this compiler from
+            # explicitly linking system object files so we need to strip them
+            # from the output so that they don't get included in the library
+            # dependencies.
+            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+            ;;
+          *)
+            if test "$GXX" = yes; then
+              _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -nostdlib -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+            else
+              # FIXME: insert proper C++ library support
+              _LT_TAGVAR(ld_shlibs, $1)=no
+            fi
+            ;;
+        esac
+        ;;
+
+      hpux10*|hpux11*)
+        if test $with_gnu_ld = no; then
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+	  _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+          case $host_cpu in
+            hppa*64*|ia64*)
+              ;;
+            *)
+	      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+              ;;
+          esac
+        fi
+        case $host_cpu in
+          hppa*64*|ia64*)
+            _LT_TAGVAR(hardcode_direct, $1)=no
+            _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+            ;;
+          *)
+            _LT_TAGVAR(hardcode_direct, $1)=yes
+            _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+            _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,
+					         # but as the default
+					         # location of the library.
+            ;;
+        esac
+
+        case $cc_basename in
+          CC*)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          aCC*)
+	    case $host_cpu in
+	      hppa*64*)
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        ;;
+	      ia64*)
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        ;;
+	      *)
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        ;;
+	    esac
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+	    ;;
+          *)
+	    if test "$GXX" = yes; then
+	      if test $with_gnu_ld = no; then
+	        case $host_cpu in
+	          hppa*64*)
+	            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            ;;
+	          ia64*)
+	            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            ;;
+	          *)
+	            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            ;;
+	        esac
+	      fi
+	    else
+	      # FIXME: insert proper C++ library support
+	      _LT_TAGVAR(ld_shlibs, $1)=no
+	    fi
+	    ;;
+        esac
+        ;;
+
+      interix[[3-9]]*)
+	_LT_TAGVAR(hardcode_direct, $1)=no
+	_LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
+	# Instead, shared libraries are loaded at an image base (0x10000000 by
+	# default) and relocated if they conflict, which is a slow very memory
+	# consuming and fragmenting process.  To avoid this, we pick a random,
+	# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
+	# time.  Moving up from 0x10000000 also allows more sbrk(2) space.
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+	;;
+      irix5* | irix6*)
+        case $cc_basename in
+          CC*)
+	    # SGI C++
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+
+	    # Archives containing C++ object files must be created using
+	    # "CC -ar", where "CC" is the IRIX C++ compiler.  This is
+	    # necessary to make sure instantiated templates are included
+	    # in the archive.
+	    _LT_TAGVAR(old_archive_cmds, $1)='$CC -ar -WR,-u -o $oldlib $oldobjs'
+	    ;;
+          *)
+	    if test "$GXX" = yes; then
+	      if test "$with_gnu_ld" = no; then
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	      else
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` -o $lib'
+	      fi
+	    fi
+	    _LT_TAGVAR(link_all_deplibs, $1)=yes
+	    ;;
+        esac
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+        _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+        _LT_TAGVAR(inherit_rpath, $1)=yes
+        ;;
+
+      linux* | k*bsd*-gnu | kopensolaris*-gnu)
+        case $cc_basename in
+          KCC*)
+	    # Kuck and Associates, Inc. (KAI) C++ Compiler
+
+	    # KCC will only create a shared library if the output file
+	    # ends with ".so" (or ".sl" for HP-UX), so rename the library
+	    # to its proper name (with version) after linking.
+	    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib ${wl}-retain-symbols-file,$export_symbols; mv \$templib $lib'
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP "ld"`; rm -f libconftest$shared_ext; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+
+	    # Archives containing C++ object files must be created using
+	    # "CC -Bstatic", where "CC" is the KAI C++ compiler.
+	    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs'
+	    ;;
+	  icpc* | ecpc* )
+	    # Intel C++
+	    with_gnu_ld=yes
+	    # version 8.0 and above of icpc choke on multiply defined symbols
+	    # if we add $predep_objects and $postdep_objects, however 7.1 and
+	    # earlier do not add the objects themselves.
+	    case `$CC -V 2>&1` in
+	      *"Version 7."*)
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+		_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+		;;
+	      *)  # Version 8.0 or newer
+	        tmp_idyn=
+	        case $host_cpu in
+		  ia64*) tmp_idyn=' -i_dynamic';;
+		esac
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+		_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+		;;
+	    esac
+	    _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	    ;;
+          pgCC* | pgcpp*)
+            # Portland Group C++ compiler
+	    case `$CC -V` in
+	    *pgCC\ [[1-5]].* | *pgcpp\ [[1-5]].*)
+	      _LT_TAGVAR(prelink_cmds, $1)='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~
+		compile_command="$compile_command `find $tpldir -name \*.o | sort | $NL2SP`"'
+	      _LT_TAGVAR(old_archive_cmds, $1)='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~
+		$AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \*.o | sort | $NL2SP`~
+		$RANLIB $oldlib'
+	      _LT_TAGVAR(archive_cmds, $1)='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
+		$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | sort | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
+	      _LT_TAGVAR(archive_expsym_cmds, $1)='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
+		$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | sort | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
+	      ;;
+	    *) # Version 6 and above use weak symbols
+	      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
+	      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
+	      ;;
+	    esac
+
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}--rpath ${wl}$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+            ;;
+	  cxx*)
+	    # Compaq C++
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname  -o $lib ${wl}-retain-symbols-file $wl$export_symbols'
+
+	    runpath_var=LD_RUN_PATH
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'
+	    _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld"`; templist=`func_echo_all "$templist" | $SED "s/\(^.*ld.*\)\( .*ld .*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "X$list" | $Xsed'
+	    ;;
+	  xl* | mpixl* | bgxl*)
+	    # IBM XL 8.0 on PPC, with GNU ld
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    if test "x$supports_anon_versioning" = xyes; then
+	      _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $output_objdir/$libname.ver~
+		cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+		echo "local: *; };" >> $output_objdir/$libname.ver~
+		$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+	    fi
+	    ;;
+	  *)
+	    case `$CC -V 2>&1 | sed 5q` in
+	    *Sun\ C*)
+	      # Sun C++ 5.9
+	      _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'
+	      _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file ${wl}$export_symbols'
+	      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+	      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	      _LT_TAGVAR(compiler_needs_object, $1)=yes
+
+	      # Not sure whether something based on
+	      # $CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1
+	      # would be better.
+	      output_verbose_link_cmd='func_echo_all'
+
+	      # Archives containing C++ object files must be created using
+	      # "CC -xar", where "CC" is the Sun C++ compiler.  This is
+	      # necessary to make sure instantiated templates are included
+	      # in the archive.
+	      _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'
+	      ;;
+	    esac
+	    ;;
+	esac
+	;;
+
+      lynxos*)
+        # FIXME: insert proper C++ library support
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	;;
+
+      m88k*)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+	;;
+
+      mvs*)
+        case $cc_basename in
+          cxx*)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+	  *)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+	esac
+	;;
+
+      netbsd*)
+        if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'
+	  wlarc=
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+	  _LT_TAGVAR(hardcode_direct, $1)=yes
+	  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	fi
+	# Workaround some broken pre-1.5 toolchains
+	output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP conftest.$objext | $SED -e "s:-lgcc -lc -lgcc::"'
+	;;
+
+      *nto* | *qnx*)
+        _LT_TAGVAR(ld_shlibs, $1)=yes
+	;;
+
+      openbsd2*)
+        # C++ shared libraries are fairly broken
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	;;
+
+      openbsd*)
+	if test -f /usr/libexec/ld.so; then
+	  _LT_TAGVAR(hardcode_direct, $1)=yes
+	  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	  if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file,$export_symbols -o $lib'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+	  fi
+	  output_verbose_link_cmd=func_echo_all
+	else
+	  _LT_TAGVAR(ld_shlibs, $1)=no
+	fi
+	;;
+
+      osf3* | osf4* | osf5*)
+        case $cc_basename in
+          KCC*)
+	    # Kuck and Associates, Inc. (KAI) C++ Compiler
+
+	    # KCC will only create a shared library if the output file
+	    # ends with ".so" (or ".sl" for HP-UX), so rename the library
+	    # to its proper name (with version) after linking.
+	    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo "$lib" | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
+
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	    _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	    # Archives containing C++ object files must be created using
+	    # the KAI C++ compiler.
+	    case $host in
+	      osf3*) _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs' ;;
+	      *) _LT_TAGVAR(old_archive_cmds, $1)='$CC -o $oldlib $oldobjs' ;;
+	    esac
+	    ;;
+          RCC*)
+	    # Rational C++ 2.4.1
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          cxx*)
+	    case $host in
+	      osf3*)
+	        _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $soname `test -n "$verstring" && func_echo_all "${wl}-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+		;;
+	      *)
+	        _LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \*'
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	        _LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done~
+	          echo "-hidden">> $lib.exp~
+	          $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname ${wl}-input ${wl}$lib.exp  `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib~
+	          $RM $lib.exp'
+	        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'
+		;;
+	    esac
+
+	    _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld" | $GREP -v "ld:"`; templist=`func_echo_all "$templist" | $SED "s/\(^.*ld.*\)\( .*ld.*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+	    ;;
+	  *)
+	    if test "$GXX" = yes && test "$with_gnu_ld" = no; then
+	      _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
+	      case $host in
+	        osf3*)
+	          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+		  ;;
+	        *)
+	          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+		  ;;
+	      esac
+
+	      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+	      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	      # Commands to make compiler produce verbose output that lists
+	      # what "hidden" libraries, object files and flags are used when
+	      # linking a shared library.
+	      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
+
+	    else
+	      # FIXME: insert proper C++ library support
+	      _LT_TAGVAR(ld_shlibs, $1)=no
+	    fi
+	    ;;
+        esac
+        ;;
+
+      psos*)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+
+      sunos4*)
+        case $cc_basename in
+          CC*)
+	    # Sun C++ 4.x
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          lcc*)
+	    # Lucid
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          *)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+        esac
+        ;;
+
+      solaris*)
+        case $cc_basename in
+          CC* | sunCC*)
+	    # Sun C++ 4.2, 5.x and Centerline C++
+            _LT_TAGVAR(archive_cmds_need_lc,$1)=yes
+	    _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag}  -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	      $CC -G${allow_undefined_flag} ${wl}-M ${wl}$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+	    _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	    case $host_os in
+	      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;
+	      *)
+		# The compiler driver will combine and reorder linker options,
+		# but understands `-z linker_flag'.
+	        # Supported since Solaris 2.6 (maybe 2.5.1?)
+		_LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'
+	        ;;
+	    esac
+	    _LT_TAGVAR(link_all_deplibs, $1)=yes
+
+	    output_verbose_link_cmd='func_echo_all'
+
+	    # Archives containing C++ object files must be created using
+	    # "CC -xar", where "CC" is the Sun C++ compiler.  This is
+	    # necessary to make sure instantiated templates are included
+	    # in the archive.
+	    _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'
+	    ;;
+          gcx*)
+	    # Green Hills C++ Compiler
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+
+	    # The C++ compiler must be used to create the archive.
+	    _LT_TAGVAR(old_archive_cmds, $1)='$CC $LDFLAGS -archive -o $oldlib $oldobjs'
+	    ;;
+          *)
+	    # GNU C++ compiler with Solaris linker
+	    if test "$GXX" = yes && test "$with_gnu_ld" = no; then
+	      _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-z ${wl}defs'
+	      if $CC --version | $GREP -v '^2\.7' > /dev/null; then
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+	        _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+		  $CC -shared -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+
+	        # Commands to make compiler produce verbose output that lists
+	        # what "hidden" libraries, object files and flags are used when
+	        # linking a shared library.
+	        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
+	      else
+	        # g++ 2.7 appears to require `-G' NOT `-shared' on this
+	        # platform.
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -G -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+	        _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+		  $CC -G -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+
+	        # Commands to make compiler produce verbose output that lists
+	        # what "hidden" libraries, object files and flags are used when
+	        # linking a shared library.
+	        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
+	      fi
+
+	      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $wl$libdir'
+	      case $host_os in
+		solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;
+		*)
+		  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
+		  ;;
+	      esac
+	    fi
+	    ;;
+        esac
+        ;;
+
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)
+      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
+      _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      runpath_var='LD_RUN_PATH'
+
+      case $cc_basename in
+        CC*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+      esac
+      ;;
+
+      sysv5* | sco3.2v5* | sco5v6*)
+	# Note: We can NOT use -z defs as we might desire, because we do not
+	# link with -lc, and that would cause any symbols used from libc to
+	# always be unresolved, which means just about no library would
+	# ever link correctly.  If we're not using GNU ld we use -z text
+	# though, which does catch some bad symbols but isn't as heavy-handed
+	# as -z defs.
+	_LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
+	_LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'
+	_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+	_LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'
+	_LT_TAGVAR(hardcode_libdir_separator, $1)=':'
+	_LT_TAGVAR(link_all_deplibs, $1)=yes
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'
+	runpath_var='LD_RUN_PATH'
+
+	case $cc_basename in
+          CC*)
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Tprelink_objects $oldobjs~
+	      '"$_LT_TAGVAR(old_archive_cmds, $1)"
+	    _LT_TAGVAR(reload_cmds, $1)='$CC -Tprelink_objects $reload_objs~
+	      '"$_LT_TAGVAR(reload_cmds, $1)"
+	    ;;
+	  *)
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    ;;
+	esac
+      ;;
+
+      tandem*)
+        case $cc_basename in
+          NCC*)
+	    # NonStop-UX NCC 3.20
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          *)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+        esac
+        ;;
+
+      vxworks*)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+
+      *)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+    esac
+
+    AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])
+    test "$_LT_TAGVAR(ld_shlibs, $1)" = no && can_build_shared=no
+
+    _LT_TAGVAR(GCC, $1)="$GXX"
+    _LT_TAGVAR(LD, $1)="$LD"
+
+    ## CAVEAT EMPTOR:
+    ## There is no encapsulation within the following macros, do not change
+    ## the running order or otherwise move them around unless you know exactly
+    ## what you are doing...
+    _LT_SYS_HIDDEN_LIBDEPS($1)
+    _LT_COMPILER_PIC($1)
+    _LT_COMPILER_C_O($1)
+    _LT_COMPILER_FILE_LOCKS($1)
+    _LT_LINKER_SHLIBS($1)
+    _LT_SYS_DYNAMIC_LINKER($1)
+    _LT_LINKER_HARDCODE_LIBPATH($1)
+
+    _LT_CONFIG($1)
+  fi # test -n "$compiler"
+
+  CC=$lt_save_CC
+  LDCXX=$LD
+  LD=$lt_save_LD
+  GCC=$lt_save_GCC
+  with_gnu_ld=$lt_save_with_gnu_ld
+  lt_cv_path_LDCXX=$lt_cv_path_LD
+  lt_cv_path_LD=$lt_save_path_LD
+  lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld
+  lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld
+fi # test "$_lt_caught_CXX_error" != yes
+
+AC_LANG_POP
+])# _LT_LANG_CXX_CONFIG
+
+
+# _LT_SYS_HIDDEN_LIBDEPS([TAGNAME])
+# ---------------------------------
+# Figure out "hidden" library dependencies from verbose
+# compiler output when linking a shared library.
+# Parse the compiler output and extract the necessary
+# objects, libraries and library flags.
+m4_defun([_LT_SYS_HIDDEN_LIBDEPS],
+[m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+# Dependencies to place before and after the object being linked:
+_LT_TAGVAR(predep_objects, $1)=
+_LT_TAGVAR(postdep_objects, $1)=
+_LT_TAGVAR(predeps, $1)=
+_LT_TAGVAR(postdeps, $1)=
+_LT_TAGVAR(compiler_lib_search_path, $1)=
+
+dnl we can't use the lt_simple_compile_test_code here,
+dnl because it contains code intended for an executable,
+dnl not a library.  It's possible we should let each
+dnl tag define a new lt_????_link_test_code variable,
+dnl but it's only used here...
+m4_if([$1], [], [cat > conftest.$ac_ext <<_LT_EOF
+int a;
+void foo (void) { a = 0; }
+_LT_EOF
+], [$1], [CXX], [cat > conftest.$ac_ext <<_LT_EOF
+class Foo
+{
+public:
+  Foo (void) { a = 0; }
+private:
+  int a;
+};
+_LT_EOF
+], [$1], [F77], [cat > conftest.$ac_ext <<_LT_EOF
+      subroutine foo
+      implicit none
+      integer*4 a
+      a=0
+      return
+      end
+_LT_EOF
+], [$1], [FC], [cat > conftest.$ac_ext <<_LT_EOF
+      subroutine foo
+      implicit none
+      integer a
+      a=0
+      return
+      end
+_LT_EOF
+], [$1], [GCJ], [cat > conftest.$ac_ext <<_LT_EOF
+public class foo {
+  private int a;
+  public void bar (void) {
+    a = 0;
+  }
+};
+_LT_EOF
+])
+dnl Parse the compiler output and extract the necessary
+dnl objects, libraries and library flags.
+if AC_TRY_EVAL(ac_compile); then
+  # Parse the compiler output and extract the necessary
+  # objects, libraries and library flags.
+
+  # Sentinel used to keep track of whether or not we are before
+  # the conftest object file.
+  pre_test_object_deps_done=no
+
+  for p in `eval "$output_verbose_link_cmd"`; do
+    case $p in
+
+    -L* | -R* | -l*)
+       # Some compilers place space between "-{L,R}" and the path.
+       # Remove the space.
+       if test $p = "-L" ||
+          test $p = "-R"; then
+	 prev=$p
+	 continue
+       else
+	 prev=
+       fi
+
+       if test "$pre_test_object_deps_done" = no; then
+	 case $p in
+	 -L* | -R*)
+	   # Internal compiler library paths should come after those
+	   # provided the user.  The postdeps already come after the
+	   # user supplied libs so there is no need to process them.
+	   if test -z "$_LT_TAGVAR(compiler_lib_search_path, $1)"; then
+	     _LT_TAGVAR(compiler_lib_search_path, $1)="${prev}${p}"
+	   else
+	     _LT_TAGVAR(compiler_lib_search_path, $1)="${_LT_TAGVAR(compiler_lib_search_path, $1)} ${prev}${p}"
+	   fi
+	   ;;
+	 # The "-l" case would never come before the object being
+	 # linked, so don't bother handling this case.
+	 esac
+       else
+	 if test -z "$_LT_TAGVAR(postdeps, $1)"; then
+	   _LT_TAGVAR(postdeps, $1)="${prev}${p}"
+	 else
+	   _LT_TAGVAR(postdeps, $1)="${_LT_TAGVAR(postdeps, $1)} ${prev}${p}"
+	 fi
+       fi
+       ;;
+
+    *.$objext)
+       # This assumes that the test object file only shows up
+       # once in the compiler output.
+       if test "$p" = "conftest.$objext"; then
+	 pre_test_object_deps_done=yes
+	 continue
+       fi
+
+       if test "$pre_test_object_deps_done" = no; then
+	 if test -z "$_LT_TAGVAR(predep_objects, $1)"; then
+	   _LT_TAGVAR(predep_objects, $1)="$p"
+	 else
+	   _LT_TAGVAR(predep_objects, $1)="$_LT_TAGVAR(predep_objects, $1) $p"
+	 fi
+       else
+	 if test -z "$_LT_TAGVAR(postdep_objects, $1)"; then
+	   _LT_TAGVAR(postdep_objects, $1)="$p"
+	 else
+	   _LT_TAGVAR(postdep_objects, $1)="$_LT_TAGVAR(postdep_objects, $1) $p"
+	 fi
+       fi
+       ;;
+
+    *) ;; # Ignore the rest.
+
+    esac
+  done
+
+  # Clean up.
+  rm -f a.out a.exe
+else
+  echo "libtool.m4: error: problem compiling $1 test program"
+fi
+
+$RM -f confest.$objext
+
+# PORTME: override above test on systems where it is broken
+m4_if([$1], [CXX],
+[case $host_os in
+interix[[3-9]]*)
+  # Interix 3.5 installs completely hosed .la files for C++, so rather than
+  # hack all around it, let's just trust "g++" to DTRT.
+  _LT_TAGVAR(predep_objects,$1)=
+  _LT_TAGVAR(postdep_objects,$1)=
+  _LT_TAGVAR(postdeps,$1)=
+  ;;
+
+linux*)
+  case `$CC -V 2>&1 | sed 5q` in
+  *Sun\ C*)
+    # Sun C++ 5.9
+
+    # The more standards-conforming stlport4 library is
+    # incompatible with the Cstd library. Avoid specifying
+    # it if it's in CXXFLAGS. Ignore libCrun as
+    # -library=stlport4 depends on it.
+    case " $CXX $CXXFLAGS " in
+    *" -library=stlport4 "*)
+      solaris_use_stlport4=yes
+      ;;
+    esac
+
+    if test "$solaris_use_stlport4" != yes; then
+      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'
+    fi
+    ;;
+  esac
+  ;;
+
+solaris*)
+  case $cc_basename in
+  CC* | sunCC*)
+    # The more standards-conforming stlport4 library is
+    # incompatible with the Cstd library. Avoid specifying
+    # it if it's in CXXFLAGS. Ignore libCrun as
+    # -library=stlport4 depends on it.
+    case " $CXX $CXXFLAGS " in
+    *" -library=stlport4 "*)
+      solaris_use_stlport4=yes
+      ;;
+    esac
+
+    # Adding this requires a known-good setup of shared libraries for
+    # Sun compiler versions before 5.6, else PIC objects from an old
+    # archive will be linked into the output, leading to subtle bugs.
+    if test "$solaris_use_stlport4" != yes; then
+      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'
+    fi
+    ;;
+  esac
+  ;;
+esac
+])
+
+case " $_LT_TAGVAR(postdeps, $1) " in
+*" -lc "*) _LT_TAGVAR(archive_cmds_need_lc, $1)=no ;;
+esac
+ _LT_TAGVAR(compiler_lib_search_dirs, $1)=
+if test -n "${_LT_TAGVAR(compiler_lib_search_path, $1)}"; then
+ _LT_TAGVAR(compiler_lib_search_dirs, $1)=`echo " ${_LT_TAGVAR(compiler_lib_search_path, $1)}" | ${SED} -e 's! -L! !g' -e 's!^ !!'`
+fi
+_LT_TAGDECL([], [compiler_lib_search_dirs], [1],
+    [The directories searched by this compiler when creating a shared library])
+_LT_TAGDECL([], [predep_objects], [1],
+    [Dependencies to place before and after the objects being linked to
+    create a shared library])
+_LT_TAGDECL([], [postdep_objects], [1])
+_LT_TAGDECL([], [predeps], [1])
+_LT_TAGDECL([], [postdeps], [1])
+_LT_TAGDECL([], [compiler_lib_search_path], [1],
+    [The library search path used internally by the compiler when linking
+    a shared library])
+])# _LT_SYS_HIDDEN_LIBDEPS
+
+
+# _LT_LANG_F77_CONFIG([TAG])
+# --------------------------
+# Ensure that the configuration variables for a Fortran 77 compiler are
+# suitably defined.  These variables are subsequently used by _LT_CONFIG
+# to write the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_F77_CONFIG],
+[AC_LANG_PUSH(Fortran 77)
+if test -z "$F77" || test "X$F77" = "Xno"; then
+  _lt_disable_F77=yes
+fi
+
+_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+_LT_TAGVAR(allow_undefined_flag, $1)=
+_LT_TAGVAR(always_export_symbols, $1)=no
+_LT_TAGVAR(archive_expsym_cmds, $1)=
+_LT_TAGVAR(export_dynamic_flag_spec, $1)=
+_LT_TAGVAR(hardcode_direct, $1)=no
+_LT_TAGVAR(hardcode_direct_absolute, $1)=no
+_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=
+_LT_TAGVAR(hardcode_libdir_separator, $1)=
+_LT_TAGVAR(hardcode_minus_L, $1)=no
+_LT_TAGVAR(hardcode_automatic, $1)=no
+_LT_TAGVAR(inherit_rpath, $1)=no
+_LT_TAGVAR(module_cmds, $1)=
+_LT_TAGVAR(module_expsym_cmds, $1)=
+_LT_TAGVAR(link_all_deplibs, $1)=unknown
+_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds
+_LT_TAGVAR(reload_flag, $1)=$reload_flag
+_LT_TAGVAR(reload_cmds, $1)=$reload_cmds
+_LT_TAGVAR(no_undefined_flag, $1)=
+_LT_TAGVAR(whole_archive_flag_spec, $1)=
+_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no
+
+# Source file extension for f77 test sources.
+ac_ext=f
+
+# Object file extension for compiled f77 test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# No sense in running all these tests if we already determined that
+# the F77 compiler isn't working.  Some variables (like enable_shared)
+# are currently assumed to apply to all compilers on this platform,
+# and will be corrupted by setting them based on a non-working compiler.
+if test "$_lt_disable_F77" != yes; then
+  # Code to be used in simple compile tests
+  lt_simple_compile_test_code="\
+      subroutine t
+      return
+      end
+"
+
+  # Code to be used in simple link tests
+  lt_simple_link_test_code="\
+      program t
+      end
+"
+
+  # ltmain only uses $CC for tagged configurations so make sure $CC is set.
+  _LT_TAG_COMPILER
+
+  # save warnings/boilerplate of simple test code
+  _LT_COMPILER_BOILERPLATE
+  _LT_LINKER_BOILERPLATE
+
+  # Allow CC to be a program name with arguments.
+  lt_save_CC="$CC"
+  lt_save_GCC=$GCC
+  CC=${F77-"f77"}
+  compiler=$CC
+  _LT_TAGVAR(compiler, $1)=$CC
+  _LT_CC_BASENAME([$compiler])
+  GCC=$G77
+  if test -n "$compiler"; then
+    AC_MSG_CHECKING([if libtool supports shared libraries])
+    AC_MSG_RESULT([$can_build_shared])
+
+    AC_MSG_CHECKING([whether to build shared libraries])
+    test "$can_build_shared" = "no" && enable_shared=no
+
+    # On AIX, shared libraries and static libraries use the same namespace, and
+    # are all built from PIC.
+    case $host_os in
+      aix3*)
+        test "$enable_shared" = yes && enable_static=no
+        if test -n "$RANLIB"; then
+          archive_cmds="$archive_cmds~\$RANLIB \$lib"
+          postinstall_cmds='$RANLIB $lib'
+        fi
+        ;;
+      aix[[4-9]]*)
+	if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+	  test "$enable_shared" = yes && enable_static=no
+	fi
+        ;;
+    esac
+    AC_MSG_RESULT([$enable_shared])
+
+    AC_MSG_CHECKING([whether to build static libraries])
+    # Make sure either enable_shared or enable_static is yes.
+    test "$enable_shared" = yes || enable_static=yes
+    AC_MSG_RESULT([$enable_static])
+
+    _LT_TAGVAR(GCC, $1)="$G77"
+    _LT_TAGVAR(LD, $1)="$LD"
+
+    ## CAVEAT EMPTOR:
+    ## There is no encapsulation within the following macros, do not change
+    ## the running order or otherwise move them around unless you know exactly
+    ## what you are doing...
+    _LT_COMPILER_PIC($1)
+    _LT_COMPILER_C_O($1)
+    _LT_COMPILER_FILE_LOCKS($1)
+    _LT_LINKER_SHLIBS($1)
+    _LT_SYS_DYNAMIC_LINKER($1)
+    _LT_LINKER_HARDCODE_LIBPATH($1)
+
+    _LT_CONFIG($1)
+  fi # test -n "$compiler"
+
+  GCC=$lt_save_GCC
+  CC="$lt_save_CC"
+fi # test "$_lt_disable_F77" != yes
+
+AC_LANG_POP
+])# _LT_LANG_F77_CONFIG
+
+
+# _LT_LANG_FC_CONFIG([TAG])
+# -------------------------
+# Ensure that the configuration variables for a Fortran compiler are
+# suitably defined.  These variables are subsequently used by _LT_CONFIG
+# to write the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_FC_CONFIG],
+[AC_LANG_PUSH(Fortran)
+
+if test -z "$FC" || test "X$FC" = "Xno"; then
+  _lt_disable_FC=yes
+fi
+
+_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+_LT_TAGVAR(allow_undefined_flag, $1)=
+_LT_TAGVAR(always_export_symbols, $1)=no
+_LT_TAGVAR(archive_expsym_cmds, $1)=
+_LT_TAGVAR(export_dynamic_flag_spec, $1)=
+_LT_TAGVAR(hardcode_direct, $1)=no
+_LT_TAGVAR(hardcode_direct_absolute, $1)=no
+_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=
+_LT_TAGVAR(hardcode_libdir_separator, $1)=
+_LT_TAGVAR(hardcode_minus_L, $1)=no
+_LT_TAGVAR(hardcode_automatic, $1)=no
+_LT_TAGVAR(inherit_rpath, $1)=no
+_LT_TAGVAR(module_cmds, $1)=
+_LT_TAGVAR(module_expsym_cmds, $1)=
+_LT_TAGVAR(link_all_deplibs, $1)=unknown
+_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds
+_LT_TAGVAR(reload_flag, $1)=$reload_flag
+_LT_TAGVAR(reload_cmds, $1)=$reload_cmds
+_LT_TAGVAR(no_undefined_flag, $1)=
+_LT_TAGVAR(whole_archive_flag_spec, $1)=
+_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no
+
+# Source file extension for fc test sources.
+ac_ext=${ac_fc_srcext-f}
+
+# Object file extension for compiled fc test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# No sense in running all these tests if we already determined that
+# the FC compiler isn't working.  Some variables (like enable_shared)
+# are currently assumed to apply to all compilers on this platform,
+# and will be corrupted by setting them based on a non-working compiler.
+if test "$_lt_disable_FC" != yes; then
+  # Code to be used in simple compile tests
+  lt_simple_compile_test_code="\
+      subroutine t
+      return
+      end
+"
+
+  # Code to be used in simple link tests
+  lt_simple_link_test_code="\
+      program t
+      end
+"
+
+  # ltmain only uses $CC for tagged configurations so make sure $CC is set.
+  _LT_TAG_COMPILER
+
+  # save warnings/boilerplate of simple test code
+  _LT_COMPILER_BOILERPLATE
+  _LT_LINKER_BOILERPLATE
+
+  # Allow CC to be a program name with arguments.
+  lt_save_CC="$CC"
+  lt_save_GCC=$GCC
+  CC=${FC-"f95"}
+  compiler=$CC
+  GCC=$ac_cv_fc_compiler_gnu
+
+  _LT_TAGVAR(compiler, $1)=$CC
+  _LT_CC_BASENAME([$compiler])
+
+  if test -n "$compiler"; then
+    AC_MSG_CHECKING([if libtool supports shared libraries])
+    AC_MSG_RESULT([$can_build_shared])
+
+    AC_MSG_CHECKING([whether to build shared libraries])
+    test "$can_build_shared" = "no" && enable_shared=no
+
+    # On AIX, shared libraries and static libraries use the same namespace, and
+    # are all built from PIC.
+    case $host_os in
+      aix3*)
+        test "$enable_shared" = yes && enable_static=no
+        if test -n "$RANLIB"; then
+          archive_cmds="$archive_cmds~\$RANLIB \$lib"
+          postinstall_cmds='$RANLIB $lib'
+        fi
+        ;;
+      aix[[4-9]]*)
+	if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+	  test "$enable_shared" = yes && enable_static=no
+	fi
+        ;;
+    esac
+    AC_MSG_RESULT([$enable_shared])
+
+    AC_MSG_CHECKING([whether to build static libraries])
+    # Make sure either enable_shared or enable_static is yes.
+    test "$enable_shared" = yes || enable_static=yes
+    AC_MSG_RESULT([$enable_static])
+
+    _LT_TAGVAR(GCC, $1)="$ac_cv_fc_compiler_gnu"
+    _LT_TAGVAR(LD, $1)="$LD"
+
+    ## CAVEAT EMPTOR:
+    ## There is no encapsulation within the following macros, do not change
+    ## the running order or otherwise move them around unless you know exactly
+    ## what you are doing...
+    _LT_SYS_HIDDEN_LIBDEPS($1)
+    _LT_COMPILER_PIC($1)
+    _LT_COMPILER_C_O($1)
+    _LT_COMPILER_FILE_LOCKS($1)
+    _LT_LINKER_SHLIBS($1)
+    _LT_SYS_DYNAMIC_LINKER($1)
+    _LT_LINKER_HARDCODE_LIBPATH($1)
+
+    _LT_CONFIG($1)
+  fi # test -n "$compiler"
+
+  GCC=$lt_save_GCC
+  CC="$lt_save_CC"
+fi # test "$_lt_disable_FC" != yes
+
+AC_LANG_POP
+])# _LT_LANG_FC_CONFIG
+
+
+# _LT_LANG_GCJ_CONFIG([TAG])
+# --------------------------
+# Ensure that the configuration variables for the GNU Java Compiler compiler
+# are suitably defined.  These variables are subsequently used by _LT_CONFIG
+# to write the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_GCJ_CONFIG],
+[AC_REQUIRE([LT_PROG_GCJ])dnl
+AC_LANG_SAVE
+
+# Source file extension for Java test sources.
+ac_ext=java
+
+# Object file extension for compiled Java test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# Code to be used in simple compile tests
+lt_simple_compile_test_code="class foo {}"
+
+# Code to be used in simple link tests
+lt_simple_link_test_code='public class conftest { public static void main(String[[]] argv) {}; }'
+
+# ltmain only uses $CC for tagged configurations so make sure $CC is set.
+_LT_TAG_COMPILER
+
+# save warnings/boilerplate of simple test code
+_LT_COMPILER_BOILERPLATE
+_LT_LINKER_BOILERPLATE
+
+# Allow CC to be a program name with arguments.
+lt_save_CC="$CC"
+lt_save_GCC=$GCC
+GCC=yes
+CC=${GCJ-"gcj"}
+compiler=$CC
+_LT_TAGVAR(compiler, $1)=$CC
+_LT_TAGVAR(LD, $1)="$LD"
+_LT_CC_BASENAME([$compiler])
+
+# GCJ did not exist at the time GCC didn't implicitly link libc in.
+_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+
+_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds
+_LT_TAGVAR(reload_flag, $1)=$reload_flag
+_LT_TAGVAR(reload_cmds, $1)=$reload_cmds
+
+if test -n "$compiler"; then
+  _LT_COMPILER_NO_RTTI($1)
+  _LT_COMPILER_PIC($1)
+  _LT_COMPILER_C_O($1)
+  _LT_COMPILER_FILE_LOCKS($1)
+  _LT_LINKER_SHLIBS($1)
+  _LT_LINKER_HARDCODE_LIBPATH($1)
+
+  _LT_CONFIG($1)
+fi
+
+AC_LANG_RESTORE
+
+GCC=$lt_save_GCC
+CC="$lt_save_CC"
+])# _LT_LANG_GCJ_CONFIG
+
+
+# _LT_LANG_RC_CONFIG([TAG])
+# -------------------------
+# Ensure that the configuration variables for the Windows resource compiler
+# are suitably defined.  These variables are subsequently used by _LT_CONFIG
+# to write the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_RC_CONFIG],
+[AC_REQUIRE([LT_PROG_RC])dnl
+AC_LANG_SAVE
+
+# Source file extension for RC test sources.
+ac_ext=rc
+
+# Object file extension for compiled RC test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# Code to be used in simple compile tests
+lt_simple_compile_test_code='sample MENU { MENUITEM "&Soup", 100, CHECKED }'
+
+# Code to be used in simple link tests
+lt_simple_link_test_code="$lt_simple_compile_test_code"
+
+# ltmain only uses $CC for tagged configurations so make sure $CC is set.
+_LT_TAG_COMPILER
+
+# save warnings/boilerplate of simple test code
+_LT_COMPILER_BOILERPLATE
+_LT_LINKER_BOILERPLATE
+
+# Allow CC to be a program name with arguments.
+lt_save_CC="$CC"
+lt_save_GCC=$GCC
+GCC=
+CC=${RC-"windres"}
+compiler=$CC
+_LT_TAGVAR(compiler, $1)=$CC
+_LT_CC_BASENAME([$compiler])
+_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes
+
+if test -n "$compiler"; then
+  :
+  _LT_CONFIG($1)
+fi
+
+GCC=$lt_save_GCC
+AC_LANG_RESTORE
+CC="$lt_save_CC"
+])# _LT_LANG_RC_CONFIG
+
+
+# LT_PROG_GCJ
+# -----------
+AC_DEFUN([LT_PROG_GCJ],
+[m4_ifdef([AC_PROG_GCJ], [AC_PROG_GCJ],
+  [m4_ifdef([A][M_PROG_GCJ], [A][M_PROG_GCJ],
+    [AC_CHECK_TOOL(GCJ, gcj,)
+      test "x${GCJFLAGS+set}" = xset || GCJFLAGS="-g -O2"
+      AC_SUBST(GCJFLAGS)])])[]dnl
+])
+
+# Old name:
+AU_ALIAS([LT_AC_PROG_GCJ], [LT_PROG_GCJ])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([LT_AC_PROG_GCJ], [])
+
+
+# LT_PROG_RC
+# ----------
+AC_DEFUN([LT_PROG_RC],
+[AC_CHECK_TOOL(RC, windres,)
+])
+
+# Old name:
+AU_ALIAS([LT_AC_PROG_RC], [LT_PROG_RC])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([LT_AC_PROG_RC], [])
+
+
+# _LT_DECL_EGREP
+# --------------
+# If we don't have a new enough Autoconf to choose the best grep
+# available, choose the one first in the user's PATH.
+m4_defun([_LT_DECL_EGREP],
+[AC_REQUIRE([AC_PROG_EGREP])dnl
+AC_REQUIRE([AC_PROG_FGREP])dnl
+test -z "$GREP" && GREP=grep
+_LT_DECL([], [GREP], [1], [A grep program that handles long lines])
+_LT_DECL([], [EGREP], [1], [An ERE matcher])
+_LT_DECL([], [FGREP], [1], [A literal string matcher])
+dnl Non-bleeding-edge autoconf doesn't subst GREP, so do it here too
+AC_SUBST([GREP])
+])
+
+
+# _LT_DECL_OBJDUMP
+# --------------
+# If we don't have a new enough Autoconf to choose the best objdump
+# available, choose the one first in the user's PATH.
+m4_defun([_LT_DECL_OBJDUMP],
+[AC_CHECK_TOOL(OBJDUMP, objdump, false)
+test -z "$OBJDUMP" && OBJDUMP=objdump
+_LT_DECL([], [OBJDUMP], [1], [An object symbol dumper])
+AC_SUBST([OBJDUMP])
+])
+
+
+# _LT_DECL_SED
+# ------------
+# Check for a fully-functional sed program, that truncates
+# as few characters as possible.  Prefer GNU sed if found.
+m4_defun([_LT_DECL_SED],
+[AC_PROG_SED
+test -z "$SED" && SED=sed
+Xsed="$SED -e 1s/^X//"
+_LT_DECL([], [SED], [1], [A sed program that does not truncate output])
+_LT_DECL([], [Xsed], ["\$SED -e 1s/^X//"],
+    [Sed that helps us avoid accidentally triggering echo(1) options like -n])
+])# _LT_DECL_SED
+
+m4_ifndef([AC_PROG_SED], [
+# NOTE: This macro has been submitted for inclusion into   #
+#  GNU Autoconf as AC_PROG_SED.  When it is available in   #
+#  a released version of Autoconf we should remove this    #
+#  macro and use it instead.                               #
+
+m4_defun([AC_PROG_SED],
+[AC_MSG_CHECKING([for a sed that does not truncate output])
+AC_CACHE_VAL(lt_cv_path_SED,
+[# Loop through the user's path and test for sed and gsed.
+# Then use that list of sed's as ones to test for truncation.
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for lt_ac_prog in sed gsed; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      if $as_executable_p "$as_dir/$lt_ac_prog$ac_exec_ext"; then
+        lt_ac_sed_list="$lt_ac_sed_list $as_dir/$lt_ac_prog$ac_exec_ext"
+      fi
+    done
+  done
+done
+IFS=$as_save_IFS
+lt_ac_max=0
+lt_ac_count=0
+# Add /usr/xpg4/bin/sed as it is typically found on Solaris
+# along with /bin/sed that truncates output.
+for lt_ac_sed in $lt_ac_sed_list /usr/xpg4/bin/sed; do
+  test ! -f $lt_ac_sed && continue
+  cat /dev/null > conftest.in
+  lt_ac_count=0
+  echo $ECHO_N "0123456789$ECHO_C" >conftest.in
+  # Check for GNU sed and select it if it is found.
+  if "$lt_ac_sed" --version 2>&1 < /dev/null | grep 'GNU' > /dev/null; then
+    lt_cv_path_SED=$lt_ac_sed
+    break
+  fi
+  while true; do
+    cat conftest.in conftest.in >conftest.tmp
+    mv conftest.tmp conftest.in
+    cp conftest.in conftest.nl
+    echo >>conftest.nl
+    $lt_ac_sed -e 's/a$//' < conftest.nl >conftest.out || break
+    cmp -s conftest.out conftest.nl || break
+    # 10000 chars as input seems more than enough
+    test $lt_ac_count -gt 10 && break
+    lt_ac_count=`expr $lt_ac_count + 1`
+    if test $lt_ac_count -gt $lt_ac_max; then
+      lt_ac_max=$lt_ac_count
+      lt_cv_path_SED=$lt_ac_sed
+    fi
+  done
+done
+])
+SED=$lt_cv_path_SED
+AC_SUBST([SED])
+AC_MSG_RESULT([$SED])
+])#AC_PROG_SED
+])#m4_ifndef
+
+# Old name:
+AU_ALIAS([LT_AC_PROG_SED], [AC_PROG_SED])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([LT_AC_PROG_SED], [])
+
+
+# _LT_CHECK_SHELL_FEATURES
+# ------------------------
+# Find out whether the shell is Bourne or XSI compatible,
+# or has some other useful features.
+m4_defun([_LT_CHECK_SHELL_FEATURES],
+[AC_MSG_CHECKING([whether the shell understands some XSI constructs])
+# Try some XSI features
+xsi_shell=no
+( _lt_dummy="a/b/c"
+  test "${_lt_dummy##*/},${_lt_dummy%/*},"${_lt_dummy%"$_lt_dummy"}, \
+      = c,a/b,, \
+    && eval 'test $(( 1 + 1 )) -eq 2 \
+    && test "${#_lt_dummy}" -eq 5' ) >/dev/null 2>&1 \
+  && xsi_shell=yes
+AC_MSG_RESULT([$xsi_shell])
+_LT_CONFIG_LIBTOOL_INIT([xsi_shell='$xsi_shell'])
+
+AC_MSG_CHECKING([whether the shell understands "+="])
+lt_shell_append=no
+( foo=bar; set foo baz; eval "$[1]+=\$[2]" && test "$foo" = barbaz ) \
+    >/dev/null 2>&1 \
+  && lt_shell_append=yes
+AC_MSG_RESULT([$lt_shell_append])
+_LT_CONFIG_LIBTOOL_INIT([lt_shell_append='$lt_shell_append'])
+
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  lt_unset=unset
+else
+  lt_unset=false
+fi
+_LT_DECL([], [lt_unset], [0], [whether the shell understands "unset"])dnl
+
+# test EBCDIC or ASCII
+case `echo X|tr X '\101'` in
+ A) # ASCII based system
+    # \n is not interpreted correctly by Solaris 8 /usr/ucb/tr
+  lt_SP2NL='tr \040 \012'
+  lt_NL2SP='tr \015\012 \040\040'
+  ;;
+ *) # EBCDIC based system
+  lt_SP2NL='tr \100 \n'
+  lt_NL2SP='tr \r\n \100\100'
+  ;;
+esac
+_LT_DECL([SP2NL], [lt_SP2NL], [1], [turn spaces into newlines])dnl
+_LT_DECL([NL2SP], [lt_NL2SP], [1], [turn newlines into spaces])dnl
+])# _LT_CHECK_SHELL_FEATURES
+
+
+# _LT_PROG_XSI_SHELLFNS
+# ---------------------
+# Bourne and XSI compatible variants of some useful shell functions.
+m4_defun([_LT_PROG_XSI_SHELLFNS],
+[case $xsi_shell in
+  yes)
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_dirname file append nondir_replacement
+# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
+# otherwise set result to NONDIR_REPLACEMENT.
+func_dirname ()
+{
+  case ${1} in
+    */*) func_dirname_result="${1%/*}${2}" ;;
+    *  ) func_dirname_result="${3}" ;;
+  esac
+}
+
+# func_basename file
+func_basename ()
+{
+  func_basename_result="${1##*/}"
+}
+
+# func_dirname_and_basename file append nondir_replacement
+# perform func_basename and func_dirname in a single function
+# call:
+#   dirname:  Compute the dirname of FILE.  If nonempty,
+#             add APPEND to the result, otherwise set result
+#             to NONDIR_REPLACEMENT.
+#             value returned in "$func_dirname_result"
+#   basename: Compute filename of FILE.
+#             value retuned in "$func_basename_result"
+# Implementation must be kept synchronized with func_dirname
+# and func_basename. For efficiency, we do not delegate to
+# those functions but instead duplicate the functionality here.
+func_dirname_and_basename ()
+{
+  case ${1} in
+    */*) func_dirname_result="${1%/*}${2}" ;;
+    *  ) func_dirname_result="${3}" ;;
+  esac
+  func_basename_result="${1##*/}"
+}
+
+# func_stripname prefix suffix name
+# strip PREFIX and SUFFIX off of NAME.
+# PREFIX and SUFFIX must not contain globbing or regex special
+# characters, hashes, percent signs, but SUFFIX may contain a leading
+# dot (in which case that matches only a dot).
+func_stripname ()
+{
+  # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are
+  # positional parameters, so assign one to ordinary parameter first.
+  func_stripname_result=${3}
+  func_stripname_result=${func_stripname_result#"${1}"}
+  func_stripname_result=${func_stripname_result%"${2}"}
+}
+
+# func_opt_split
+func_opt_split ()
+{
+  func_opt_split_opt=${1%%=*}
+  func_opt_split_arg=${1#*=}
+}
+
+# func_lo2o object
+func_lo2o ()
+{
+  case ${1} in
+    *.lo) func_lo2o_result=${1%.lo}.${objext} ;;
+    *)    func_lo2o_result=${1} ;;
+  esac
+}
+
+# func_xform libobj-or-source
+func_xform ()
+{
+  func_xform_result=${1%.*}.lo
+}
+
+# func_arith arithmetic-term...
+func_arith ()
+{
+  func_arith_result=$(( $[*] ))
+}
+
+# func_len string
+# STRING may not start with a hyphen.
+func_len ()
+{
+  func_len_result=${#1}
+}
+
+_LT_EOF
+    ;;
+  *) # Bourne compatible functions.
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_dirname file append nondir_replacement
+# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
+# otherwise set result to NONDIR_REPLACEMENT.
+func_dirname ()
+{
+  # Extract subdirectory from the argument.
+  func_dirname_result=`$ECHO "${1}" | $SED "$dirname"`
+  if test "X$func_dirname_result" = "X${1}"; then
+    func_dirname_result="${3}"
+  else
+    func_dirname_result="$func_dirname_result${2}"
+  fi
+}
+
+# func_basename file
+func_basename ()
+{
+  func_basename_result=`$ECHO "${1}" | $SED "$basename"`
+}
+
+dnl func_dirname_and_basename
+dnl A portable version of this function is already defined in general.m4sh
+dnl so there is no need for it here.
+
+# func_stripname prefix suffix name
+# strip PREFIX and SUFFIX off of NAME.
+# PREFIX and SUFFIX must not contain globbing or regex special
+# characters, hashes, percent signs, but SUFFIX may contain a leading
+# dot (in which case that matches only a dot).
+# func_strip_suffix prefix name
+func_stripname ()
+{
+  case ${2} in
+    .*) func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%\\\\${2}\$%%"`;;
+    *)  func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%${2}\$%%"`;;
+  esac
+}
+
+# sed scripts:
+my_sed_long_opt='1s/^\(-[[^=]]*\)=.*/\1/;q'
+my_sed_long_arg='1s/^-[[^=]]*=//'
+
+# func_opt_split
+func_opt_split ()
+{
+  func_opt_split_opt=`$ECHO "${1}" | $SED "$my_sed_long_opt"`
+  func_opt_split_arg=`$ECHO "${1}" | $SED "$my_sed_long_arg"`
+}
+
+# func_lo2o object
+func_lo2o ()
+{
+  func_lo2o_result=`$ECHO "${1}" | $SED "$lo2o"`
+}
+
+# func_xform libobj-or-source
+func_xform ()
+{
+  func_xform_result=`$ECHO "${1}" | $SED 's/\.[[^.]]*$/.lo/'`
+}
+
+# func_arith arithmetic-term...
+func_arith ()
+{
+  func_arith_result=`expr "$[@]"`
+}
+
+# func_len string
+# STRING may not start with a hyphen.
+func_len ()
+{
+  func_len_result=`expr "$[1]" : ".*" 2>/dev/null || echo $max_cmd_len`
+}
+
+_LT_EOF
+esac
+
+case $lt_shell_append in
+  yes)
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_append var value
+# Append VALUE to the end of shell variable VAR.
+func_append ()
+{
+  eval "$[1]+=\$[2]"
+}
+_LT_EOF
+    ;;
+  *)
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_append var value
+# Append VALUE to the end of shell variable VAR.
+func_append ()
+{
+  eval "$[1]=\$$[1]\$[2]"
+}
+
+_LT_EOF
+    ;;
+  esac
+])
+
+# Helper functions for option handling.                    -*- Autoconf -*-
+#
+#   Copyright (C) 2004, 2005, 2007, 2008, 2009 Free Software Foundation,
+#   Inc.
+#   Written by Gary V. Vaughan, 2004
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# serial 6 ltoptions.m4
+
+# This is to help aclocal find these macros, as it can't see m4_define.
+AC_DEFUN([LTOPTIONS_VERSION], [m4_if([1])])
+
+
+# _LT_MANGLE_OPTION(MACRO-NAME, OPTION-NAME)
+# ------------------------------------------
+m4_define([_LT_MANGLE_OPTION],
+[[_LT_OPTION_]m4_bpatsubst($1__$2, [[^a-zA-Z0-9_]], [_])])
+
+
+# _LT_SET_OPTION(MACRO-NAME, OPTION-NAME)
+# ---------------------------------------
+# Set option OPTION-NAME for macro MACRO-NAME, and if there is a
+# matching handler defined, dispatch to it.  Other OPTION-NAMEs are
+# saved as a flag.
+m4_define([_LT_SET_OPTION],
+[m4_define(_LT_MANGLE_OPTION([$1], [$2]))dnl
+m4_ifdef(_LT_MANGLE_DEFUN([$1], [$2]),
+        _LT_MANGLE_DEFUN([$1], [$2]),
+    [m4_warning([Unknown $1 option `$2'])])[]dnl
+])
+
+
+# _LT_IF_OPTION(MACRO-NAME, OPTION-NAME, IF-SET, [IF-NOT-SET])
+# ------------------------------------------------------------
+# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.
+m4_define([_LT_IF_OPTION],
+[m4_ifdef(_LT_MANGLE_OPTION([$1], [$2]), [$3], [$4])])
+
+
+# _LT_UNLESS_OPTIONS(MACRO-NAME, OPTION-LIST, IF-NOT-SET)
+# -------------------------------------------------------
+# Execute IF-NOT-SET unless all options in OPTION-LIST for MACRO-NAME
+# are set.
+m4_define([_LT_UNLESS_OPTIONS],
+[m4_foreach([_LT_Option], m4_split(m4_normalize([$2])),
+	    [m4_ifdef(_LT_MANGLE_OPTION([$1], _LT_Option),
+		      [m4_define([$0_found])])])[]dnl
+m4_ifdef([$0_found], [m4_undefine([$0_found])], [$3
+])[]dnl
+])
+
+
+# _LT_SET_OPTIONS(MACRO-NAME, OPTION-LIST)
+# ----------------------------------------
+# OPTION-LIST is a space-separated list of Libtool options associated
+# with MACRO-NAME.  If any OPTION has a matching handler declared with
+# LT_OPTION_DEFINE, dispatch to that macro; otherwise complain about
+# the unknown option and exit.
+m4_defun([_LT_SET_OPTIONS],
+[# Set options
+m4_foreach([_LT_Option], m4_split(m4_normalize([$2])),
+    [_LT_SET_OPTION([$1], _LT_Option)])
+
+m4_if([$1],[LT_INIT],[
+  dnl
+  dnl Simply set some default values (i.e off) if boolean options were not
+  dnl specified:
+  _LT_UNLESS_OPTIONS([LT_INIT], [dlopen], [enable_dlopen=no
+  ])
+  _LT_UNLESS_OPTIONS([LT_INIT], [win32-dll], [enable_win32_dll=no
+  ])
+  dnl
+  dnl If no reference was made to various pairs of opposing options, then
+  dnl we run the default mode handler for the pair.  For example, if neither
+  dnl `shared' nor `disable-shared' was passed, we enable building of shared
+  dnl archives by default:
+  _LT_UNLESS_OPTIONS([LT_INIT], [shared disable-shared], [_LT_ENABLE_SHARED])
+  _LT_UNLESS_OPTIONS([LT_INIT], [static disable-static], [_LT_ENABLE_STATIC])
+  _LT_UNLESS_OPTIONS([LT_INIT], [pic-only no-pic], [_LT_WITH_PIC])
+  _LT_UNLESS_OPTIONS([LT_INIT], [fast-install disable-fast-install],
+  		   [_LT_ENABLE_FAST_INSTALL])
+  ])
+])# _LT_SET_OPTIONS
+
+
+
+# _LT_MANGLE_DEFUN(MACRO-NAME, OPTION-NAME)
+# -----------------------------------------
+m4_define([_LT_MANGLE_DEFUN],
+[[_LT_OPTION_DEFUN_]m4_bpatsubst(m4_toupper([$1__$2]), [[^A-Z0-9_]], [_])])
+
+
+# LT_OPTION_DEFINE(MACRO-NAME, OPTION-NAME, CODE)
+# -----------------------------------------------
+m4_define([LT_OPTION_DEFINE],
+[m4_define(_LT_MANGLE_DEFUN([$1], [$2]), [$3])[]dnl
+])# LT_OPTION_DEFINE
+
+
+# dlopen
+# ------
+LT_OPTION_DEFINE([LT_INIT], [dlopen], [enable_dlopen=yes
+])
+
+AU_DEFUN([AC_LIBTOOL_DLOPEN],
+[_LT_SET_OPTION([LT_INIT], [dlopen])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you
+put the `dlopen' option into LT_INIT's first parameter.])
+])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_DLOPEN], [])
+
+
+# win32-dll
+# ---------
+# Declare package support for building win32 dll's.
+LT_OPTION_DEFINE([LT_INIT], [win32-dll],
+[enable_win32_dll=yes
+
+case $host in
+*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-cegcc*)
+  AC_CHECK_TOOL(AS, as, false)
+  AC_CHECK_TOOL(DLLTOOL, dlltool, false)
+  AC_CHECK_TOOL(OBJDUMP, objdump, false)
+  ;;
+esac
+
+test -z "$AS" && AS=as
+_LT_DECL([], [AS],      [1], [Assembler program])dnl
+
+test -z "$DLLTOOL" && DLLTOOL=dlltool
+_LT_DECL([], [DLLTOOL], [1], [DLL creation program])dnl
+
+test -z "$OBJDUMP" && OBJDUMP=objdump
+_LT_DECL([], [OBJDUMP], [1], [Object dumper program])dnl
+])# win32-dll
+
+AU_DEFUN([AC_LIBTOOL_WIN32_DLL],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+_LT_SET_OPTION([LT_INIT], [win32-dll])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you
+put the `win32-dll' option into LT_INIT's first parameter.])
+])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_WIN32_DLL], [])
+
+
+# _LT_ENABLE_SHARED([DEFAULT])
+# ----------------------------
+# implement the --enable-shared flag, and supports the `shared' and
+# `disable-shared' LT_INIT options.
+# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.
+m4_define([_LT_ENABLE_SHARED],
+[m4_define([_LT_ENABLE_SHARED_DEFAULT], [m4_if($1, no, no, yes)])dnl
+AC_ARG_ENABLE([shared],
+    [AS_HELP_STRING([--enable-shared@<:@=PKGS@:>@],
+	[build shared libraries @<:@default=]_LT_ENABLE_SHARED_DEFAULT[@:>@])],
+    [p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_shared=yes ;;
+    no) enable_shared=no ;;
+    *)
+      enable_shared=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_shared=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac],
+    [enable_shared=]_LT_ENABLE_SHARED_DEFAULT)
+
+    _LT_DECL([build_libtool_libs], [enable_shared], [0],
+	[Whether or not to build shared libraries])
+])# _LT_ENABLE_SHARED
+
+LT_OPTION_DEFINE([LT_INIT], [shared], [_LT_ENABLE_SHARED([yes])])
+LT_OPTION_DEFINE([LT_INIT], [disable-shared], [_LT_ENABLE_SHARED([no])])
+
+# Old names:
+AC_DEFUN([AC_ENABLE_SHARED],
+[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[shared])
+])
+
+AC_DEFUN([AC_DISABLE_SHARED],
+[_LT_SET_OPTION([LT_INIT], [disable-shared])
+])
+
+AU_DEFUN([AM_ENABLE_SHARED], [AC_ENABLE_SHARED($@)])
+AU_DEFUN([AM_DISABLE_SHARED], [AC_DISABLE_SHARED($@)])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AM_ENABLE_SHARED], [])
+dnl AC_DEFUN([AM_DISABLE_SHARED], [])
+
+
+
+# _LT_ENABLE_STATIC([DEFAULT])
+# ----------------------------
+# implement the --enable-static flag, and support the `static' and
+# `disable-static' LT_INIT options.
+# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.
+m4_define([_LT_ENABLE_STATIC],
+[m4_define([_LT_ENABLE_STATIC_DEFAULT], [m4_if($1, no, no, yes)])dnl
+AC_ARG_ENABLE([static],
+    [AS_HELP_STRING([--enable-static@<:@=PKGS@:>@],
+	[build static libraries @<:@default=]_LT_ENABLE_STATIC_DEFAULT[@:>@])],
+    [p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_static=yes ;;
+    no) enable_static=no ;;
+    *)
+     enable_static=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_static=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac],
+    [enable_static=]_LT_ENABLE_STATIC_DEFAULT)
+
+    _LT_DECL([build_old_libs], [enable_static], [0],
+	[Whether or not to build static libraries])
+])# _LT_ENABLE_STATIC
+
+LT_OPTION_DEFINE([LT_INIT], [static], [_LT_ENABLE_STATIC([yes])])
+LT_OPTION_DEFINE([LT_INIT], [disable-static], [_LT_ENABLE_STATIC([no])])
+
+# Old names:
+AC_DEFUN([AC_ENABLE_STATIC],
+[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[static])
+])
+
+AC_DEFUN([AC_DISABLE_STATIC],
+[_LT_SET_OPTION([LT_INIT], [disable-static])
+])
+
+AU_DEFUN([AM_ENABLE_STATIC], [AC_ENABLE_STATIC($@)])
+AU_DEFUN([AM_DISABLE_STATIC], [AC_DISABLE_STATIC($@)])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AM_ENABLE_STATIC], [])
+dnl AC_DEFUN([AM_DISABLE_STATIC], [])
+
+
+
+# _LT_ENABLE_FAST_INSTALL([DEFAULT])
+# ----------------------------------
+# implement the --enable-fast-install flag, and support the `fast-install'
+# and `disable-fast-install' LT_INIT options.
+# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.
+m4_define([_LT_ENABLE_FAST_INSTALL],
+[m4_define([_LT_ENABLE_FAST_INSTALL_DEFAULT], [m4_if($1, no, no, yes)])dnl
+AC_ARG_ENABLE([fast-install],
+    [AS_HELP_STRING([--enable-fast-install@<:@=PKGS@:>@],
+    [optimize for fast installation @<:@default=]_LT_ENABLE_FAST_INSTALL_DEFAULT[@:>@])],
+    [p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_fast_install=yes ;;
+    no) enable_fast_install=no ;;
+    *)
+      enable_fast_install=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_fast_install=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac],
+    [enable_fast_install=]_LT_ENABLE_FAST_INSTALL_DEFAULT)
+
+_LT_DECL([fast_install], [enable_fast_install], [0],
+	 [Whether or not to optimize for fast installation])dnl
+])# _LT_ENABLE_FAST_INSTALL
+
+LT_OPTION_DEFINE([LT_INIT], [fast-install], [_LT_ENABLE_FAST_INSTALL([yes])])
+LT_OPTION_DEFINE([LT_INIT], [disable-fast-install], [_LT_ENABLE_FAST_INSTALL([no])])
+
+# Old names:
+AU_DEFUN([AC_ENABLE_FAST_INSTALL],
+[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[fast-install])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you put
+the `fast-install' option into LT_INIT's first parameter.])
+])
+
+AU_DEFUN([AC_DISABLE_FAST_INSTALL],
+[_LT_SET_OPTION([LT_INIT], [disable-fast-install])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you put
+the `disable-fast-install' option into LT_INIT's first parameter.])
+])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_ENABLE_FAST_INSTALL], [])
+dnl AC_DEFUN([AM_DISABLE_FAST_INSTALL], [])
+
+
+# _LT_WITH_PIC([MODE])
+# --------------------
+# implement the --with-pic flag, and support the `pic-only' and `no-pic'
+# LT_INIT options.
+# MODE is either `yes' or `no'.  If omitted, it defaults to `both'.
+m4_define([_LT_WITH_PIC],
+[AC_ARG_WITH([pic],
+    [AS_HELP_STRING([--with-pic],
+	[try to use only PIC/non-PIC objects @<:@default=use both@:>@])],
+    [pic_mode="$withval"],
+    [pic_mode=default])
+
+test -z "$pic_mode" && pic_mode=m4_default([$1], [default])
+
+_LT_DECL([], [pic_mode], [0], [What type of objects to build])dnl
+])# _LT_WITH_PIC
+
+LT_OPTION_DEFINE([LT_INIT], [pic-only], [_LT_WITH_PIC([yes])])
+LT_OPTION_DEFINE([LT_INIT], [no-pic], [_LT_WITH_PIC([no])])
+
+# Old name:
+AU_DEFUN([AC_LIBTOOL_PICMODE],
+[_LT_SET_OPTION([LT_INIT], [pic-only])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you
+put the `pic-only' option into LT_INIT's first parameter.])
+])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_PICMODE], [])
+
+
+m4_define([_LTDL_MODE], [])
+LT_OPTION_DEFINE([LTDL_INIT], [nonrecursive],
+		 [m4_define([_LTDL_MODE], [nonrecursive])])
+LT_OPTION_DEFINE([LTDL_INIT], [recursive],
+		 [m4_define([_LTDL_MODE], [recursive])])
+LT_OPTION_DEFINE([LTDL_INIT], [subproject],
+		 [m4_define([_LTDL_MODE], [subproject])])
+
+m4_define([_LTDL_TYPE], [])
+LT_OPTION_DEFINE([LTDL_INIT], [installable],
+		 [m4_define([_LTDL_TYPE], [installable])])
+LT_OPTION_DEFINE([LTDL_INIT], [convenience],
+		 [m4_define([_LTDL_TYPE], [convenience])])
+
+# ltsugar.m4 -- libtool m4 base layer.                         -*-Autoconf-*-
+#
+# Copyright (C) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
+# Written by Gary V. Vaughan, 2004
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# serial 6 ltsugar.m4
+
+# This is to help aclocal find these macros, as it can't see m4_define.
+AC_DEFUN([LTSUGAR_VERSION], [m4_if([0.1])])
+
+
+# lt_join(SEP, ARG1, [ARG2...])
+# -----------------------------
+# Produce ARG1SEPARG2...SEPARGn, omitting [] arguments and their
+# associated separator.
+# Needed until we can rely on m4_join from Autoconf 2.62, since all earlier
+# versions in m4sugar had bugs.
+m4_define([lt_join],
+[m4_if([$#], [1], [],
+       [$#], [2], [[$2]],
+       [m4_if([$2], [], [], [[$2]_])$0([$1], m4_shift(m4_shift($@)))])])
+m4_define([_lt_join],
+[m4_if([$#$2], [2], [],
+       [m4_if([$2], [], [], [[$1$2]])$0([$1], m4_shift(m4_shift($@)))])])
+
+
+# lt_car(LIST)
+# lt_cdr(LIST)
+# ------------
+# Manipulate m4 lists.
+# These macros are necessary as long as will still need to support
+# Autoconf-2.59 which quotes differently.
+m4_define([lt_car], [[$1]])
+m4_define([lt_cdr],
+[m4_if([$#], 0, [m4_fatal([$0: cannot be called without arguments])],
+       [$#], 1, [],
+       [m4_dquote(m4_shift($@))])])
+m4_define([lt_unquote], $1)
+
+
+# lt_append(MACRO-NAME, STRING, [SEPARATOR])
+# ------------------------------------------
+# Redefine MACRO-NAME to hold its former content plus `SEPARATOR'`STRING'.
+# Note that neither SEPARATOR nor STRING are expanded; they are appended
+# to MACRO-NAME as is (leaving the expansion for when MACRO-NAME is invoked).
+# No SEPARATOR is output if MACRO-NAME was previously undefined (different
+# than defined and empty).
+#
+# This macro is needed until we can rely on Autoconf 2.62, since earlier
+# versions of m4sugar mistakenly expanded SEPARATOR but not STRING.
+m4_define([lt_append],
+[m4_define([$1],
+	   m4_ifdef([$1], [m4_defn([$1])[$3]])[$2])])
+
+
+
+# lt_combine(SEP, PREFIX-LIST, INFIX, SUFFIX1, [SUFFIX2...])
+# ----------------------------------------------------------
+# Produce a SEP delimited list of all paired combinations of elements of
+# PREFIX-LIST with SUFFIX1 through SUFFIXn.  Each element of the list
+# has the form PREFIXmINFIXSUFFIXn.
+# Needed until we can rely on m4_combine added in Autoconf 2.62.
+m4_define([lt_combine],
+[m4_if(m4_eval([$# > 3]), [1],
+       [m4_pushdef([_Lt_sep], [m4_define([_Lt_sep], m4_defn([lt_car]))])]]dnl
+[[m4_foreach([_Lt_prefix], [$2],
+	     [m4_foreach([_Lt_suffix],
+		]m4_dquote(m4_dquote(m4_shift(m4_shift(m4_shift($@)))))[,
+	[_Lt_sep([$1])[]m4_defn([_Lt_prefix])[$3]m4_defn([_Lt_suffix])])])])])
+
+
+# lt_if_append_uniq(MACRO-NAME, VARNAME, [SEPARATOR], [UNIQ], [NOT-UNIQ])
+# -----------------------------------------------------------------------
+# Iff MACRO-NAME does not yet contain VARNAME, then append it (delimited
+# by SEPARATOR if supplied) and expand UNIQ, else NOT-UNIQ.
+m4_define([lt_if_append_uniq],
+[m4_ifdef([$1],
+	  [m4_if(m4_index([$3]m4_defn([$1])[$3], [$3$2$3]), [-1],
+		 [lt_append([$1], [$2], [$3])$4],
+		 [$5])],
+	  [lt_append([$1], [$2], [$3])$4])])
+
+
+# lt_dict_add(DICT, KEY, VALUE)
+# -----------------------------
+m4_define([lt_dict_add],
+[m4_define([$1($2)], [$3])])
+
+
+# lt_dict_add_subkey(DICT, KEY, SUBKEY, VALUE)
+# --------------------------------------------
+m4_define([lt_dict_add_subkey],
+[m4_define([$1($2:$3)], [$4])])
+
+
+# lt_dict_fetch(DICT, KEY, [SUBKEY])
+# ----------------------------------
+m4_define([lt_dict_fetch],
+[m4_ifval([$3],
+	m4_ifdef([$1($2:$3)], [m4_defn([$1($2:$3)])]),
+    m4_ifdef([$1($2)], [m4_defn([$1($2)])]))])
+
+
+# lt_if_dict_fetch(DICT, KEY, [SUBKEY], VALUE, IF-TRUE, [IF-FALSE])
+# -----------------------------------------------------------------
+m4_define([lt_if_dict_fetch],
+[m4_if(lt_dict_fetch([$1], [$2], [$3]), [$4],
+	[$5],
+    [$6])])
+
+
+# lt_dict_filter(DICT, [SUBKEY], VALUE, [SEPARATOR], KEY, [...])
+# --------------------------------------------------------------
+m4_define([lt_dict_filter],
+[m4_if([$5], [], [],
+  [lt_join(m4_quote(m4_default([$4], [[, ]])),
+           lt_unquote(m4_split(m4_normalize(m4_foreach(_Lt_key, lt_car([m4_shiftn(4, $@)]),
+		      [lt_if_dict_fetch([$1], _Lt_key, [$2], [$3], [_Lt_key ])])))))])[]dnl
+])
+
+# ltversion.m4 -- version numbers			-*- Autoconf -*-
+#
+#   Copyright (C) 2004 Free Software Foundation, Inc.
+#   Written by Scott James Remnant, 2004
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# Generated from ltversion.in.
+
+# serial 3165 ltversion.m4
+# This file is part of GNU Libtool
+
+m4_define([LT_PACKAGE_VERSION], [2.2.7a])
+m4_define([LT_PACKAGE_REVISION], [1.3134])
+
+AC_DEFUN([LTVERSION_VERSION],
+[macro_version='2.2.7a'
+macro_revision='1.3134'
+_LT_DECL(, macro_version, 0, [Which release of libtool.m4 was used?])
+_LT_DECL(, macro_revision, 0)
+])
+
+# lt~obsolete.m4 -- aclocal satisfying obsolete definitions.    -*-Autoconf-*-
+#
+#   Copyright (C) 2004, 2005, 2007, 2009 Free Software Foundation, Inc.
+#   Written by Scott James Remnant, 2004.
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# serial 4 lt~obsolete.m4
+
+# These exist entirely to fool aclocal when bootstrapping libtool.
+#
+# In the past libtool.m4 has provided macros via AC_DEFUN (or AU_DEFUN)
+# which have later been changed to m4_define as they aren't part of the
+# exported API, or moved to Autoconf or Automake where they belong.
+#
+# The trouble is, aclocal is a bit thick.  It'll see the old AC_DEFUN
+# in /usr/share/aclocal/libtool.m4 and remember it, then when it sees us
+# using a macro with the same name in our local m4/libtool.m4 it'll
+# pull the old libtool.m4 in (it doesn't see our shiny new m4_define
+# and doesn't know about Autoconf macros at all.)
+#
+# So we provide this file, which has a silly filename so it's always
+# included after everything else.  This provides aclocal with the
+# AC_DEFUNs it wants, but when m4 processes it, it doesn't do anything
+# because those macros already exist, or will be overwritten later.
+# We use AC_DEFUN over AU_DEFUN for compatibility with aclocal-1.6. 
+#
+# Anytime we withdraw an AC_DEFUN or AU_DEFUN, remember to add it here.
+# Yes, that means every name once taken will need to remain here until
+# we give up compatibility with versions before 1.7, at which point
+# we need to keep only those names which we still refer to.
+
+# This is to help aclocal find these macros, as it can't see m4_define.
+AC_DEFUN([LTOBSOLETE_VERSION], [m4_if([1])])
+
+m4_ifndef([AC_LIBTOOL_LINKER_OPTION],	[AC_DEFUN([AC_LIBTOOL_LINKER_OPTION])])
+m4_ifndef([AC_PROG_EGREP],		[AC_DEFUN([AC_PROG_EGREP])])
+m4_ifndef([_LT_AC_PROG_ECHO_BACKSLASH],	[AC_DEFUN([_LT_AC_PROG_ECHO_BACKSLASH])])
+m4_ifndef([_LT_AC_SHELL_INIT],		[AC_DEFUN([_LT_AC_SHELL_INIT])])
+m4_ifndef([_LT_AC_SYS_LIBPATH_AIX],	[AC_DEFUN([_LT_AC_SYS_LIBPATH_AIX])])
+m4_ifndef([_LT_PROG_LTMAIN],		[AC_DEFUN([_LT_PROG_LTMAIN])])
+m4_ifndef([_LT_AC_TAGVAR],		[AC_DEFUN([_LT_AC_TAGVAR])])
+m4_ifndef([AC_LTDL_ENABLE_INSTALL],	[AC_DEFUN([AC_LTDL_ENABLE_INSTALL])])
+m4_ifndef([AC_LTDL_PREOPEN],		[AC_DEFUN([AC_LTDL_PREOPEN])])
+m4_ifndef([_LT_AC_SYS_COMPILER],	[AC_DEFUN([_LT_AC_SYS_COMPILER])])
+m4_ifndef([_LT_AC_LOCK],		[AC_DEFUN([_LT_AC_LOCK])])
+m4_ifndef([AC_LIBTOOL_SYS_OLD_ARCHIVE],	[AC_DEFUN([AC_LIBTOOL_SYS_OLD_ARCHIVE])])
+m4_ifndef([_LT_AC_TRY_DLOPEN_SELF],	[AC_DEFUN([_LT_AC_TRY_DLOPEN_SELF])])
+m4_ifndef([AC_LIBTOOL_PROG_CC_C_O],	[AC_DEFUN([AC_LIBTOOL_PROG_CC_C_O])])
+m4_ifndef([AC_LIBTOOL_SYS_HARD_LINK_LOCKS], [AC_DEFUN([AC_LIBTOOL_SYS_HARD_LINK_LOCKS])])
+m4_ifndef([AC_LIBTOOL_OBJDIR],		[AC_DEFUN([AC_LIBTOOL_OBJDIR])])
+m4_ifndef([AC_LTDL_OBJDIR],		[AC_DEFUN([AC_LTDL_OBJDIR])])
+m4_ifndef([AC_LIBTOOL_PROG_LD_HARDCODE_LIBPATH], [AC_DEFUN([AC_LIBTOOL_PROG_LD_HARDCODE_LIBPATH])])
+m4_ifndef([AC_LIBTOOL_SYS_LIB_STRIP],	[AC_DEFUN([AC_LIBTOOL_SYS_LIB_STRIP])])
+m4_ifndef([AC_PATH_MAGIC],		[AC_DEFUN([AC_PATH_MAGIC])])
+m4_ifndef([AC_PROG_LD_GNU],		[AC_DEFUN([AC_PROG_LD_GNU])])
+m4_ifndef([AC_PROG_LD_RELOAD_FLAG],	[AC_DEFUN([AC_PROG_LD_RELOAD_FLAG])])
+m4_ifndef([AC_DEPLIBS_CHECK_METHOD],	[AC_DEFUN([AC_DEPLIBS_CHECK_METHOD])])
+m4_ifndef([AC_LIBTOOL_PROG_COMPILER_NO_RTTI], [AC_DEFUN([AC_LIBTOOL_PROG_COMPILER_NO_RTTI])])
+m4_ifndef([AC_LIBTOOL_SYS_GLOBAL_SYMBOL_PIPE], [AC_DEFUN([AC_LIBTOOL_SYS_GLOBAL_SYMBOL_PIPE])])
+m4_ifndef([AC_LIBTOOL_PROG_COMPILER_PIC], [AC_DEFUN([AC_LIBTOOL_PROG_COMPILER_PIC])])
+m4_ifndef([AC_LIBTOOL_PROG_LD_SHLIBS],	[AC_DEFUN([AC_LIBTOOL_PROG_LD_SHLIBS])])
+m4_ifndef([AC_LIBTOOL_POSTDEP_PREDEP],	[AC_DEFUN([AC_LIBTOOL_POSTDEP_PREDEP])])
+m4_ifndef([LT_AC_PROG_EGREP],		[AC_DEFUN([LT_AC_PROG_EGREP])])
+m4_ifndef([LT_AC_PROG_SED],		[AC_DEFUN([LT_AC_PROG_SED])])
+m4_ifndef([_LT_CC_BASENAME],		[AC_DEFUN([_LT_CC_BASENAME])])
+m4_ifndef([_LT_COMPILER_BOILERPLATE],	[AC_DEFUN([_LT_COMPILER_BOILERPLATE])])
+m4_ifndef([_LT_LINKER_BOILERPLATE],	[AC_DEFUN([_LT_LINKER_BOILERPLATE])])
+m4_ifndef([_AC_PROG_LIBTOOL],		[AC_DEFUN([_AC_PROG_LIBTOOL])])
+m4_ifndef([AC_LIBTOOL_SETUP],		[AC_DEFUN([AC_LIBTOOL_SETUP])])
+m4_ifndef([_LT_AC_CHECK_DLFCN],		[AC_DEFUN([_LT_AC_CHECK_DLFCN])])
+m4_ifndef([AC_LIBTOOL_SYS_DYNAMIC_LINKER],	[AC_DEFUN([AC_LIBTOOL_SYS_DYNAMIC_LINKER])])
+m4_ifndef([_LT_AC_TAGCONFIG],		[AC_DEFUN([_LT_AC_TAGCONFIG])])
+m4_ifndef([AC_DISABLE_FAST_INSTALL],	[AC_DEFUN([AC_DISABLE_FAST_INSTALL])])
+m4_ifndef([_LT_AC_LANG_CXX],		[AC_DEFUN([_LT_AC_LANG_CXX])])
+m4_ifndef([_LT_AC_LANG_F77],		[AC_DEFUN([_LT_AC_LANG_F77])])
+m4_ifndef([_LT_AC_LANG_GCJ],		[AC_DEFUN([_LT_AC_LANG_GCJ])])
+m4_ifndef([AC_LIBTOOL_LANG_C_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_C_CONFIG])])
+m4_ifndef([_LT_AC_LANG_C_CONFIG],	[AC_DEFUN([_LT_AC_LANG_C_CONFIG])])
+m4_ifndef([AC_LIBTOOL_LANG_CXX_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_CXX_CONFIG])])
+m4_ifndef([_LT_AC_LANG_CXX_CONFIG],	[AC_DEFUN([_LT_AC_LANG_CXX_CONFIG])])
+m4_ifndef([AC_LIBTOOL_LANG_F77_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_F77_CONFIG])])
+m4_ifndef([_LT_AC_LANG_F77_CONFIG],	[AC_DEFUN([_LT_AC_LANG_F77_CONFIG])])
+m4_ifndef([AC_LIBTOOL_LANG_GCJ_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_GCJ_CONFIG])])
+m4_ifndef([_LT_AC_LANG_GCJ_CONFIG],	[AC_DEFUN([_LT_AC_LANG_GCJ_CONFIG])])
+m4_ifndef([AC_LIBTOOL_LANG_RC_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_RC_CONFIG])])
+m4_ifndef([_LT_AC_LANG_RC_CONFIG],	[AC_DEFUN([_LT_AC_LANG_RC_CONFIG])])
+m4_ifndef([AC_LIBTOOL_CONFIG],		[AC_DEFUN([AC_LIBTOOL_CONFIG])])
+m4_ifndef([_LT_AC_FILE_LTDLL_C],	[AC_DEFUN([_LT_AC_FILE_LTDLL_C])])
+m4_ifndef([_LT_REQUIRED_DARWIN_CHECKS],	[AC_DEFUN([_LT_REQUIRED_DARWIN_CHECKS])])
+m4_ifndef([_LT_AC_PROG_CXXCPP],		[AC_DEFUN([_LT_AC_PROG_CXXCPP])])
+m4_ifndef([_LT_PREPARE_SED_QUOTE_VARS],	[AC_DEFUN([_LT_PREPARE_SED_QUOTE_VARS])])
+m4_ifndef([_LT_PROG_ECHO_BACKSLASH],	[AC_DEFUN([_LT_PROG_ECHO_BACKSLASH])])
+m4_ifndef([_LT_PROG_F77],		[AC_DEFUN([_LT_PROG_F77])])
+m4_ifndef([_LT_PROG_FC],		[AC_DEFUN([_LT_PROG_FC])])
+m4_ifndef([_LT_PROG_CXX],		[AC_DEFUN([_LT_PROG_CXX])])
+
+# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_AUTOMAKE_VERSION(VERSION)
+# ----------------------------
+# Automake X.Y traces this macro to ensure aclocal.m4 has been
+# generated from the m4 files accompanying Automake X.Y.
+# (This private macro should not be called outside this file.)
+AC_DEFUN([AM_AUTOMAKE_VERSION],
+[am__api_version='1.11'
+dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
+dnl require some minimum version.  Point them to the right macro.
+m4_if([$1], [1.11], [],
+      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
+])
+
+# _AM_AUTOCONF_VERSION(VERSION)
+# -----------------------------
+# aclocal traces this macro to find the Autoconf version.
+# This is a private macro too.  Using m4_define simplifies
+# the logic in aclocal, which can simply ignore this definition.
+m4_define([_AM_AUTOCONF_VERSION], [])
+
+# AM_SET_CURRENT_AUTOMAKE_VERSION
+# -------------------------------
+# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
+# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.
+AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
+[AM_AUTOMAKE_VERSION([1.11])dnl
+m4_ifndef([AC_AUTOCONF_VERSION],
+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
+_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])
+
+# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
+
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
+# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to
+# `$srcdir', `$srcdir/..', or `$srcdir/../..'.
+#
+# Of course, Automake must honor this variable whenever it calls a
+# tool from the auxiliary directory.  The problem is that $srcdir (and
+# therefore $ac_aux_dir as well) can be either absolute or relative,
+# depending on how configure is run.  This is pretty annoying, since
+# it makes $ac_aux_dir quite unusable in subdirectories: in the top
+# source directory, any form will work fine, but in subdirectories a
+# relative path needs to be adjusted first.
+#
+# $ac_aux_dir/missing
+#    fails when called from a subdirectory if $ac_aux_dir is relative
+# $top_srcdir/$ac_aux_dir/missing
+#    fails if $ac_aux_dir is absolute,
+#    fails when called from a subdirectory in a VPATH build with
+#          a relative $ac_aux_dir
+#
+# The reason of the latter failure is that $top_srcdir and $ac_aux_dir
+# are both prefixed by $srcdir.  In an in-source build this is usually
+# harmless because $srcdir is `.', but things will broke when you
+# start a VPATH build or use an absolute $srcdir.
+#
+# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,
+# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:
+#   am_aux_dir='\$(top_srcdir)/'`expr "$ac_aux_dir" : "$srcdir//*\(.*\)"`
+# and then we would define $MISSING as
+#   MISSING="\${SHELL} $am_aux_dir/missing"
+# This will work as long as MISSING is not called from configure, because
+# unfortunately $(top_srcdir) has no meaning in configure.
+# However there are other variables, like CC, which are often used in
+# configure, and could therefore not use this "fixed" $ac_aux_dir.
+#
+# Another solution, used here, is to always expand $ac_aux_dir to an
+# absolute PATH.  The drawback is that using absolute paths prevent a
+# configured tree to be moved without reconfiguration.
+
+AC_DEFUN([AM_AUX_DIR_EXPAND],
+[dnl Rely on autoconf to set up CDPATH properly.
+AC_PREREQ([2.50])dnl
+# expand $ac_aux_dir to an absolute path
+am_aux_dir=`cd $ac_aux_dir && pwd`
+])
+
+# AM_CONDITIONAL                                            -*- Autoconf -*-
+
+# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 9
+
+# AM_CONDITIONAL(NAME, SHELL-CONDITION)
+# -------------------------------------
+# Define a conditional.
+AC_DEFUN([AM_CONDITIONAL],
+[AC_PREREQ(2.52)dnl
+ ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
+	[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
+AC_SUBST([$1_TRUE])dnl
+AC_SUBST([$1_FALSE])dnl
+_AM_SUBST_NOTMAKE([$1_TRUE])dnl
+_AM_SUBST_NOTMAKE([$1_FALSE])dnl
+m4_define([_AM_COND_VALUE_$1], [$2])dnl
+if $2; then
+  $1_TRUE=
+  $1_FALSE='#'
+else
+  $1_TRUE='#'
+  $1_FALSE=
+fi
+AC_CONFIG_COMMANDS_PRE(
+[if test -z "${$1_TRUE}" && test -z "${$1_FALSE}"; then
+  AC_MSG_ERROR([[conditional "$1" was never defined.
+Usually this means the macro was only invoked conditionally.]])
+fi])])
+
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 10
+
+# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be
+# written in clear, in which case automake, when reading aclocal.m4,
+# will think it sees a *use*, and therefore will trigger all it's
+# C support machinery.  Also note that it means that autoscan, seeing
+# CC etc. in the Makefile, will ask for an AC_PROG_CC use...
+
+
+# _AM_DEPENDENCIES(NAME)
+# ----------------------
+# See how the compiler implements dependency checking.
+# NAME is "CC", "CXX", "GCJ", or "OBJC".
+# We try a few techniques and use that to set a single cache variable.
+#
+# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was
+# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular
+# dependency, and given that the user is not expected to run this macro,
+# just rely on AC_PROG_CC.
+AC_DEFUN([_AM_DEPENDENCIES],
+[AC_REQUIRE([AM_SET_DEPDIR])dnl
+AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl
+AC_REQUIRE([AM_MAKE_INCLUDE])dnl
+AC_REQUIRE([AM_DEP_TRACK])dnl
+
+ifelse([$1], CC,   [depcc="$CC"   am_compiler_list=],
+       [$1], CXX,  [depcc="$CXX"  am_compiler_list=],
+       [$1], OBJC, [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
+       [$1], UPC,  [depcc="$UPC"  am_compiler_list=],
+       [$1], GCJ,  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
+                   [depcc="$$1"   am_compiler_list=])
+
+AC_CACHE_CHECK([dependency style of $depcc],
+               [am_cv_$1_dependencies_compiler_type],
+[if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
+  # We make a subdir and do the tests there.  Otherwise we can end up
+  # making bogus files that we don't know about and never remove.  For
+  # instance it was reported that on HP-UX the gcc test will end up
+  # making a dummy file named `D' -- because `-MD' means `put the output
+  # in D'.
+  mkdir conftest.dir
+  # Copy depcomp to subdir because otherwise we won't find it if we're
+  # using a relative directory.
+  cp "$am_depcomp" conftest.dir
+  cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
+
+  am_cv_$1_dependencies_compiler_type=none
+  if test "$am_compiler_list" = ""; then
+     am_compiler_list=`sed -n ['s/^#*\([a-zA-Z0-9]*\))$/\1/p'] < ./depcomp`
+  fi
+  am__universal=false
+  m4_case([$1], [CC],
+    [case " $depcc " in #(
+     *\ -arch\ *\ -arch\ *) am__universal=true ;;
+     esac],
+    [CXX],
+    [case " $depcc " in #(
+     *\ -arch\ *\ -arch\ *) am__universal=true ;;
+     esac])
+
+  for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
+    # We need to recreate these files for each test, as the compiler may
+    # overwrite some of them when testing with obscure command lines.
+    # This happens at least with the AIX C compiler.
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
+      # Solaris 8's {/usr,}/bin/sh.
+      touch sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+
+    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle `-M -o', and we need to detect this.  Also, some Intel
+    # versions had trouble with output in subdirs
+    am__obj=sub/conftest.${OBJEXT-o}
+    am__minus_obj="-o $am__obj"
+    case $depmode in
+    gcc)
+      # This depmode causes a compiler race in universal mode.
+      test "$am__universal" = false || continue
+      ;;
+    nosideeffect)
+      # after this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested
+      if test "x$enable_dependency_tracking" = xyes; then
+	continue
+      else
+	break
+      fi
+      ;;
+    msvisualcpp | msvcmsys)
+      # This compiler won't grok `-c -o', but also, the minuso test has
+      # not run yet.  These depmodes are late enough in the game, and
+      # so weak that their functioning should not be impacted.
+      am__obj=conftest.${OBJEXT-o}
+      am__minus_obj=
+      ;;
+    none) break ;;
+    esac
+    if depmode=$depmode \
+       source=sub/conftest.c object=$am__obj \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \
+         >/dev/null 2>conftest.err &&
+       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&
+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
+      # icc doesn't choke on unknown options, it will just issue warnings
+      # or remarks (even with -Werror).  So we grep stderr for any message
+      # that says an option was ignored or not supported.
+      # When given -MP, icc 7.0 and 7.1 complain thusly:
+      #   icc: Command line warning: ignoring option '-M'; no argument required
+      # The diagnosis changed in icc 8.0:
+      #   icc: Command line remark: option '-MP' not supported
+      if (grep 'ignoring option' conftest.err ||
+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
+        am_cv_$1_dependencies_compiler_type=$depmode
+        break
+      fi
+    fi
+  done
+
+  cd ..
+  rm -rf conftest.dir
+else
+  am_cv_$1_dependencies_compiler_type=none
+fi
+])
+AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])
+AM_CONDITIONAL([am__fastdep$1], [
+  test "x$enable_dependency_tracking" != xno \
+  && test "$am_cv_$1_dependencies_compiler_type" = gcc3])
+])
+
+
+# AM_SET_DEPDIR
+# -------------
+# Choose a directory name for dependency files.
+# This macro is AC_REQUIREd in _AM_DEPENDENCIES
+AC_DEFUN([AM_SET_DEPDIR],
+[AC_REQUIRE([AM_SET_LEADING_DOT])dnl
+AC_SUBST([DEPDIR], ["${am__leading_dot}deps"])dnl
+])
+
+
+# AM_DEP_TRACK
+# ------------
+AC_DEFUN([AM_DEP_TRACK],
+[AC_ARG_ENABLE(dependency-tracking,
+[  --disable-dependency-tracking  speeds up one-time build
+  --enable-dependency-tracking   do not reject slow dependency extractors])
+if test "x$enable_dependency_tracking" != xno; then
+  am_depcomp="$ac_aux_dir/depcomp"
+  AMDEPBACKSLASH='\'
+fi
+AM_CONDITIONAL([AMDEP], [test "x$enable_dependency_tracking" != xno])
+AC_SUBST([AMDEPBACKSLASH])dnl
+_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl
+])
+
+# Generate code to set up dependency tracking.              -*- Autoconf -*-
+
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+#serial 5
+
+# _AM_OUTPUT_DEPENDENCY_COMMANDS
+# ------------------------------
+AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],
+[{
+  # Autoconf 2.62 quotes --file arguments for eval, but not when files
+  # are listed without --file.  Let's play safe and only enable the eval
+  # if we detect the quoting.
+  case $CONFIG_FILES in
+  *\'*) eval set x "$CONFIG_FILES" ;;
+  *)   set x $CONFIG_FILES ;;
+  esac
+  shift
+  for mf
+  do
+    # Strip MF so we end up with the name of the file.
+    mf=`echo "$mf" | sed -e 's/:.*$//'`
+    # Check whether this is an Automake generated Makefile or not.
+    # We used to match only the files named `Makefile.in', but
+    # some people rename them; so instead we look at the file content.
+    # Grep'ing the first line is not enough: some people post-process
+    # each Makefile.in and add a new line on top of each file to say so.
+    # Grep'ing the whole file is not good either: AIX grep has a line
+    # limit of 2048, but all sed's we know have understand at least 4000.
+    if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
+      dirpart=`AS_DIRNAME("$mf")`
+    else
+      continue
+    fi
+    # Extract the definition of DEPDIR, am__include, and am__quote
+    # from the Makefile without running `make'.
+    DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
+    test -z "$DEPDIR" && continue
+    am__include=`sed -n 's/^am__include = //p' < "$mf"`
+    test -z "am__include" && continue
+    am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
+    # When using ansi2knr, U may be empty or an underscore; expand it
+    U=`sed -n 's/^U = //p' < "$mf"`
+    # Find all dependency output files, they are included files with
+    # $(DEPDIR) in their names.  We invoke sed twice because it is the
+    # simplest approach to changing $(DEPDIR) to its actual value in the
+    # expansion.
+    for file in `sed -n "
+      s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
+	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+      # Make sure the directory exists.
+      test -f "$dirpart/$file" && continue
+      fdir=`AS_DIRNAME(["$file"])`
+      AS_MKDIR_P([$dirpart/$fdir])
+      # echo "creating $dirpart/$file"
+      echo '# dummy' > "$dirpart/$file"
+    done
+  done
+}
+])# _AM_OUTPUT_DEPENDENCY_COMMANDS
+
+
+# AM_OUTPUT_DEPENDENCY_COMMANDS
+# -----------------------------
+# This macro should only be invoked once -- use via AC_REQUIRE.
+#
+# This code is only required when automatic dependency tracking
+# is enabled.  FIXME.  This creates each `.P' file that we will
+# need in order to bootstrap the dependency handling code.
+AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
+[AC_CONFIG_COMMANDS([depfiles],
+     [test x"$AMDEP_TRUE" != x"" || _AM_OUTPUT_DEPENDENCY_COMMANDS],
+     [AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"])
+])
+
+# Do all the work for Automake.                             -*- Autoconf -*-
+
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
+# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 16
+
+# This macro actually does too much.  Some checks are only needed if
+# your package does certain things.  But this isn't really a big deal.
+
+# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])
+# AM_INIT_AUTOMAKE([OPTIONS])
+# -----------------------------------------------
+# The call with PACKAGE and VERSION arguments is the old style
+# call (pre autoconf-2.50), which is being phased out.  PACKAGE
+# and VERSION should now be passed to AC_INIT and removed from
+# the call to AM_INIT_AUTOMAKE.
+# We support both call styles for the transition.  After
+# the next Automake release, Autoconf can make the AC_INIT
+# arguments mandatory, and then we can depend on a new Autoconf
+# release and drop the old call support.
+AC_DEFUN([AM_INIT_AUTOMAKE],
+[AC_PREREQ([2.62])dnl
+dnl Autoconf wants to disallow AM_ names.  We explicitly allow
+dnl the ones we care about.
+m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl
+AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl
+AC_REQUIRE([AC_PROG_INSTALL])dnl
+if test "`cd $srcdir && pwd`" != "`pwd`"; then
+  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
+  # is not polluted with repeated "-I."
+  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl
+  # test to see if srcdir already configured
+  if test -f $srcdir/config.status; then
+    AC_MSG_ERROR([source directory already configured; run "make distclean" there first])
+  fi
+fi
+
+# test whether we have cygpath
+if test -z "$CYGPATH_W"; then
+  if (cygpath --version) >/dev/null 2>/dev/null; then
+    CYGPATH_W='cygpath -w'
+  else
+    CYGPATH_W=echo
+  fi
+fi
+AC_SUBST([CYGPATH_W])
+
+# Define the identity of the package.
+dnl Distinguish between old-style and new-style calls.
+m4_ifval([$2],
+[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl
+ AC_SUBST([PACKAGE], [$1])dnl
+ AC_SUBST([VERSION], [$2])],
+[_AM_SET_OPTIONS([$1])dnl
+dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.
+m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,
+  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl
+ AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl
+ AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl
+
+_AM_IF_OPTION([no-define],,
+[AC_DEFINE_UNQUOTED(PACKAGE, "$PACKAGE", [Name of package])
+ AC_DEFINE_UNQUOTED(VERSION, "$VERSION", [Version number of package])])dnl
+
+# Some tools Automake needs.
+AC_REQUIRE([AM_SANITY_CHECK])dnl
+AC_REQUIRE([AC_ARG_PROGRAM])dnl
+AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})
+AM_MISSING_PROG(AUTOCONF, autoconf)
+AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})
+AM_MISSING_PROG(AUTOHEADER, autoheader)
+AM_MISSING_PROG(MAKEINFO, makeinfo)
+AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
+AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl
+AC_REQUIRE([AM_PROG_MKDIR_P])dnl
+# We need awk for the "check" target.  The system "awk" is bad on
+# some platforms.
+AC_REQUIRE([AC_PROG_AWK])dnl
+AC_REQUIRE([AC_PROG_MAKE_SET])dnl
+AC_REQUIRE([AM_SET_LEADING_DOT])dnl
+_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],
+	      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],
+			     [_AM_PROG_TAR([v7])])])
+_AM_IF_OPTION([no-dependencies],,
+[AC_PROVIDE_IFELSE([AC_PROG_CC],
+		  [_AM_DEPENDENCIES(CC)],
+		  [define([AC_PROG_CC],
+			  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl
+AC_PROVIDE_IFELSE([AC_PROG_CXX],
+		  [_AM_DEPENDENCIES(CXX)],
+		  [define([AC_PROG_CXX],
+			  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl
+AC_PROVIDE_IFELSE([AC_PROG_OBJC],
+		  [_AM_DEPENDENCIES(OBJC)],
+		  [define([AC_PROG_OBJC],
+			  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl
+])
+_AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl
+dnl The `parallel-tests' driver may need to know about EXEEXT, so add the
+dnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro
+dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.
+AC_CONFIG_COMMANDS_PRE(dnl
+[m4_provide_if([_AM_COMPILER_EXEEXT],
+  [AM_CONDITIONAL([am__EXEEXT], [test -n "$EXEEXT"])])])dnl
+])
+
+dnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not
+dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further
+dnl mangled by Autoconf and run in a shell conditional statement.
+m4_define([_AC_COMPILER_EXEEXT],
+m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])
+
+
+# When config.status generates a header, we must update the stamp-h file.
+# This file resides in the same directory as the config header
+# that is generated.  The stamp files are numbered to have different names.
+
+# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the
+# loop where config.status creates the headers, so we can generate
+# our stamp files there.
+AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],
+[# Compute $1's index in $config_headers.
+_am_arg=$1
+_am_stamp_count=1
+for _am_header in $config_headers :; do
+  case $_am_header in
+    $_am_arg | $_am_arg:* )
+      break ;;
+    * )
+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
+  esac
+done
+echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_count])
+
+# Copyright (C) 2001, 2003, 2005, 2008  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_INSTALL_SH
+# ------------------
+# Define $install_sh.
+AC_DEFUN([AM_PROG_INSTALL_SH],
+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
+if test x"${install_sh}" != xset; then
+  case $am_aux_dir in
+  *\ * | *\	*)
+    install_sh="\${SHELL} '$am_aux_dir/install-sh'" ;;
+  *)
+    install_sh="\${SHELL} $am_aux_dir/install-sh"
+  esac
+fi
+AC_SUBST(install_sh)])
+
+# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-
+# From Jim Meyering
+
+# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 5
+
+# AM_MAINTAINER_MODE([DEFAULT-MODE])
+# ----------------------------------
+# Control maintainer-specific portions of Makefiles.
+# Default is to disable them, unless `enable' is passed literally.
+# For symmetry, `disable' may be passed as well.  Anyway, the user
+# can override the default with the --enable/--disable switch.
+AC_DEFUN([AM_MAINTAINER_MODE],
+[m4_case(m4_default([$1], [disable]),
+       [enable], [m4_define([am_maintainer_other], [disable])],
+       [disable], [m4_define([am_maintainer_other], [enable])],
+       [m4_define([am_maintainer_other], [enable])
+        m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])
+AC_MSG_CHECKING([whether to am_maintainer_other maintainer-specific portions of Makefiles])
+  dnl maintainer-mode's default is 'disable' unless 'enable' is passed
+  AC_ARG_ENABLE([maintainer-mode],
+[  --][am_maintainer_other][-maintainer-mode  am_maintainer_other make rules and dependencies not useful
+			  (and sometimes confusing) to the casual installer],
+      [USE_MAINTAINER_MODE=$enableval],
+      [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))
+  AC_MSG_RESULT([$USE_MAINTAINER_MODE])
+  AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])
+  MAINT=$MAINTAINER_MODE_TRUE
+  AC_SUBST([MAINT])dnl
+]
+)
+
+AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])
+
+# Check to see how 'make' treats includes.	            -*- Autoconf -*-
+
+# Copyright (C) 2001, 2002, 2003, 2005, 2009  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 4
+
+# AM_MAKE_INCLUDE()
+# -----------------
+# Check to see how make treats includes.
+AC_DEFUN([AM_MAKE_INCLUDE],
+[am_make=${MAKE-make}
+cat > confinc << 'END'
+am__doit:
+	@echo this is the am__doit target
+.PHONY: am__doit
+END
+# If we don't find an include directive, just comment out the code.
+AC_MSG_CHECKING([for style of include used by $am_make])
+am__include="#"
+am__quote=
+_am_result=none
+# First try GNU make style include.
+echo "include confinc" > confmf
+# Ignore all kinds of additional output from `make'.
+case `$am_make -s -f confmf 2> /dev/null` in #(
+*the\ am__doit\ target*)
+  am__include=include
+  am__quote=
+  _am_result=GNU
+  ;;
+esac
+# Now try BSD make style include.
+if test "$am__include" = "#"; then
+   echo '.include "confinc"' > confmf
+   case `$am_make -s -f confmf 2> /dev/null` in #(
+   *the\ am__doit\ target*)
+     am__include=.include
+     am__quote="\""
+     _am_result=BSD
+     ;;
+   esac
+fi
+AC_SUBST([am__include])
+AC_SUBST([am__quote])
+AC_MSG_RESULT([$_am_result])
+rm -f confinc confmf
+])
+
+# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
+
+# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 6
+
+# AM_MISSING_PROG(NAME, PROGRAM)
+# ------------------------------
+AC_DEFUN([AM_MISSING_PROG],
+[AC_REQUIRE([AM_MISSING_HAS_RUN])
+$1=${$1-"${am_missing_run}$2"}
+AC_SUBST($1)])
+
+
+# AM_MISSING_HAS_RUN
+# ------------------
+# Define MISSING if not defined so far and test if it supports --run.
+# If it does, set am_missing_run to use it, otherwise, to nothing.
+AC_DEFUN([AM_MISSING_HAS_RUN],
+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
+AC_REQUIRE_AUX_FILE([missing])dnl
+if test x"${MISSING+set}" != xset; then
+  case $am_aux_dir in
+  *\ * | *\	*)
+    MISSING="\${SHELL} \"$am_aux_dir/missing\"" ;;
+  *)
+    MISSING="\${SHELL} $am_aux_dir/missing" ;;
+  esac
+fi
+# Use eval to expand $SHELL
+if eval "$MISSING --run true"; then
+  am_missing_run="$MISSING --run "
+else
+  am_missing_run=
+  AC_MSG_WARN([`missing' script is too old or missing])
+fi
+])
+
+# Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_MKDIR_P
+# ---------------
+# Check for `mkdir -p'.
+AC_DEFUN([AM_PROG_MKDIR_P],
+[AC_PREREQ([2.60])dnl
+AC_REQUIRE([AC_PROG_MKDIR_P])dnl
+dnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,
+dnl while keeping a definition of mkdir_p for backward compatibility.
+dnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.
+dnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of
+dnl Makefile.ins that do not define MKDIR_P, so we do our own
+dnl adjustment using top_builddir (which is defined more often than
+dnl MKDIR_P).
+AC_SUBST([mkdir_p], ["$MKDIR_P"])dnl
+case $mkdir_p in
+  [[\\/$]]* | ?:[[\\/]]*) ;;
+  */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
+esac
+])
+
+# Helper functions for option handling.                     -*- Autoconf -*-
+
+# Copyright (C) 2001, 2002, 2003, 2005, 2008  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 4
+
+# _AM_MANGLE_OPTION(NAME)
+# -----------------------
+AC_DEFUN([_AM_MANGLE_OPTION],
+[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])
+
+# _AM_SET_OPTION(NAME)
+# ------------------------------
+# Set option NAME.  Presently that only means defining a flag for this option.
+AC_DEFUN([_AM_SET_OPTION],
+[m4_define(_AM_MANGLE_OPTION([$1]), 1)])
+
+# _AM_SET_OPTIONS(OPTIONS)
+# ----------------------------------
+# OPTIONS is a space-separated list of Automake options.
+AC_DEFUN([_AM_SET_OPTIONS],
+[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])
+
+# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])
+# -------------------------------------------
+# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.
+AC_DEFUN([_AM_IF_OPTION],
+[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])
+
+# Check to make sure that the build environment is sane.    -*- Autoconf -*-
+
+# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 5
+
+# AM_SANITY_CHECK
+# ---------------
+AC_DEFUN([AM_SANITY_CHECK],
+[AC_MSG_CHECKING([whether build environment is sane])
+# Just in case
+sleep 1
+echo timestamp > conftest.file
+# Reject unsafe characters in $srcdir or the absolute working directory
+# name.  Accept space and tab only in the latter.
+am_lf='
+'
+case `pwd` in
+  *[[\\\"\#\$\&\'\`$am_lf]]*)
+    AC_MSG_ERROR([unsafe absolute working directory name]);;
+esac
+case $srcdir in
+  *[[\\\"\#\$\&\'\`$am_lf\ \	]]*)
+    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;
+esac
+
+# Do `set' in a subshell so we don't clobber the current shell's
+# arguments.  Must try -L first in case configure is actually a
+# symlink; some systems play weird games with the mod time of symlinks
+# (eg FreeBSD returns the mod time of the symlink's containing
+# directory).
+if (
+   set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
+   if test "$[*]" = "X"; then
+      # -L didn't work.
+      set X `ls -t "$srcdir/configure" conftest.file`
+   fi
+   rm -f conftest.file
+   if test "$[*]" != "X $srcdir/configure conftest.file" \
+      && test "$[*]" != "X conftest.file $srcdir/configure"; then
+
+      # If neither matched, then we have a broken ls.  This can happen
+      # if, for instance, CONFIG_SHELL is bash and it inherits a
+      # broken ls alias from the environment.  This has actually
+      # happened.  Such a system could not be considered "sane".
+      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
+alias in your environment])
+   fi
+
+   test "$[2]" = conftest.file
+   )
+then
+   # Ok.
+   :
+else
+   AC_MSG_ERROR([newly created file is older than distributed files!
+Check your system clock])
+fi
+AC_MSG_RESULT(yes)])
+
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_INSTALL_STRIP
+# ---------------------
+# One issue with vendor `install' (even GNU) is that you can't
+# specify the program used to strip binaries.  This is especially
+# annoying in cross-compiling environments, where the build's strip
+# is unlikely to handle the host's binaries.
+# Fortunately install-sh will honor a STRIPPROG variable, so we
+# always use install-sh in `make install-strip', and initialize
+# STRIPPROG with the value of the STRIP variable (set by the user).
+AC_DEFUN([AM_PROG_INSTALL_STRIP],
+[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
+# Installed binaries are usually stripped using `strip' when the user
+# run `make install-strip'.  However `strip' might not be the right
+# tool to use in cross-compilation environments, therefore Automake
+# will honor the `STRIP' environment variable to overrule this program.
+dnl Don't test for $cross_compiling = yes, because it might be `maybe'.
+if test "$cross_compiling" != no; then
+  AC_CHECK_TOOL([STRIP], [strip], :)
+fi
+INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
+AC_SUBST([INSTALL_STRIP_PROGRAM])])
+
+# Copyright (C) 2006, 2008  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 2
+
+# _AM_SUBST_NOTMAKE(VARIABLE)
+# ---------------------------
+# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.
+# This macro is traced by Automake.
+AC_DEFUN([_AM_SUBST_NOTMAKE])
+
+# AM_SUBST_NOTMAKE(VARIABLE)
+# ---------------------------
+# Public sister of _AM_SUBST_NOTMAKE.
+AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])
+
+# Check how to create a tarball.                            -*- Autoconf -*-
+
+# Copyright (C) 2004, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 2
+
+# _AM_PROG_TAR(FORMAT)
+# --------------------
+# Check how to create a tarball in format FORMAT.
+# FORMAT should be one of `v7', `ustar', or `pax'.
+#
+# Substitute a variable $(am__tar) that is a command
+# writing to stdout a FORMAT-tarball containing the directory
+# $tardir.
+#     tardir=directory && $(am__tar) > result.tar
+#
+# Substitute a variable $(am__untar) that extract such
+# a tarball read from stdin.
+#     $(am__untar) < result.tar
+AC_DEFUN([_AM_PROG_TAR],
+[# Always define AMTAR for backward compatibility.
+AM_MISSING_PROG([AMTAR], [tar])
+m4_if([$1], [v7],
+     [am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'],
+     [m4_case([$1], [ustar],, [pax],,
+              [m4_fatal([Unknown tar format])])
+AC_MSG_CHECKING([how to create a $1 tar archive])
+# Loop over all known methods to create a tar archive until one works.
+_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'
+_am_tools=${am_cv_prog_tar_$1-$_am_tools}
+# Do not fold the above two line into one, because Tru64 sh and
+# Solaris sh will not grok spaces in the rhs of `-'.
+for _am_tool in $_am_tools
+do
+  case $_am_tool in
+  gnutar)
+    for _am_tar in tar gnutar gtar;
+    do
+      AM_RUN_LOG([$_am_tar --version]) && break
+    done
+    am__tar="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$$tardir"'
+    am__tar_="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$tardir"'
+    am__untar="$_am_tar -xf -"
+    ;;
+  plaintar)
+    # Must skip GNU tar: if it does not support --format= it doesn't create
+    # ustar tarball either.
+    (tar --version) >/dev/null 2>&1 && continue
+    am__tar='tar chf - "$$tardir"'
+    am__tar_='tar chf - "$tardir"'
+    am__untar='tar xf -'
+    ;;
+  pax)
+    am__tar='pax -L -x $1 -w "$$tardir"'
+    am__tar_='pax -L -x $1 -w "$tardir"'
+    am__untar='pax -r'
+    ;;
+  cpio)
+    am__tar='find "$$tardir" -print | cpio -o -H $1 -L'
+    am__tar_='find "$tardir" -print | cpio -o -H $1 -L'
+    am__untar='cpio -i -H $1 -d'
+    ;;
+  none)
+    am__tar=false
+    am__tar_=false
+    am__untar=false
+    ;;
+  esac
+
+  # If the value was cached, stop now.  We just wanted to have am__tar
+  # and am__untar set.
+  test -n "${am_cv_prog_tar_$1}" && break
+
+  # tar/untar a dummy directory, and stop if the command works
+  rm -rf conftest.dir
+  mkdir conftest.dir
+  echo GrepMe > conftest.dir/file
+  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])
+  rm -rf conftest.dir
+  if test -s conftest.tar; then
+    AM_RUN_LOG([$am__untar <conftest.tar])
+    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break
+  fi
+done
+rm -rf conftest.dir
+
+AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])
+AC_MSG_RESULT([$am_cv_prog_tar_$1])])
+AC_SUBST([am__tar])
+AC_SUBST([am__untar])
+]) # _AM_PROG_TAR
+
+m4_include([../config/acx.m4])
+m4_include([../config/depstand.m4])
+m4_include([../config/lead-dot.m4])
+m4_include([../config/lthostflags.m4])
+m4_include([../config/override.m4])
diff --git a/function_reordering_plugin/callgraph.c b/function_reordering_plugin/callgraph.c
new file mode 100644
index 0000000..00cbffc
--- /dev/null
+++ b/function_reordering_plugin/callgraph.c
@@ -0,0 +1,1060 @@
+/* Callgraph implementation.
+   Copyright (C) 2011 Free Software Foundation, Inc.
+   Contributed by Sriraman Tallam (tmsriram@google.com)
+   and Easwaran Raman (eraman@google.com).
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+This program is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#include "callgraph.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <string.h>
+#include <hashtab.h>
+
+/*****************************************************************************/
+/* section_map hashtable definition and helpers. */
+
+/* Maps section name to its corresponding object handle and section index.  */
+static htab_t section_map = NULL;
+
+/* Hashtable helper for section_map htab.  */
+static hashval_t
+section_map_htab_hash_descriptor (const void *p)
+{
+  const Section_id *s = (const Section_id *)p;
+  const char *name = s->name;
+  return htab_hash_string(name);
+}
+
+/* Hashtable helper for section_map htab.  */
+static int
+section_map_htab_eq_descriptor (const void *p1, const void *p2)
+{
+  const Section_id *s1 = (const Section_id *)p1;
+  const char *c1 = s1->name;
+  const char *c2 = (const char *)p2;
+
+  return (strcmp (c1, c2) == 0);
+}
+/*****************************************************************************/
+
+
+/*****************************************************************************/
+/* function_map hashtable definition and helpers.
+   Maps function name to a unique Node.  */
+static htab_t function_map = NULL;
+static unsigned int last_function_id = 0;
+
+/* Hashtable helper for function_map htab.  */
+static hashval_t
+function_map_htab_hash_descriptor (const void *p)
+{
+  const Node *s = (const Node *)p;
+  const char *name = s->name;
+  return htab_hash_string(name);
+}
+
+/* Hashtable helper for section_map htab.  */
+static int
+function_map_htab_eq_descriptor (const void *p1, const void *p2)
+{
+  const Node *s1 = (const Node *)p1;
+  const char *c1 = s1->name;
+  const char *c2 = (const char *)p2;
+
+  return (strcmp (c1, c2) == 0);
+}
+/*****************************************************************************/
+
+/*****************************************************************************/
+/* edge_map hashtable definition and helpers.
+   Maps two node ids to a unique edge.  */
+static htab_t edge_map = NULL;
+
+static inline hashval_t
+edge_hash_function (unsigned int id1, unsigned int id2)
+{
+  return (id1 << 16) | id2;
+}
+
+/* Hashtable helper for edge_map htab.  */
+static hashval_t
+edge_map_htab_hash_descriptor (const void *p)
+{
+  Edge *e = (Edge *) p;
+  return edge_hash_function (e->first_function->id, e->second_function->id);
+}
+
+/* Hashtable helper for edge_map htab.  */
+static int
+edge_map_htab_eq_descriptor (const void *p1, const void *p2)
+{
+  Edge *e1 = (Edge *) p1;
+  Raw_edge *r1 = (Raw_edge *) p2;
+  return ((e1->first_function->id == r1->n1->id)
+	  && (e1->second_function->id == r1->n2->id));
+}
+
+
+/*****************************************************************************/
+
+
+/* Keep track of all allocated memory.  */
+typedef struct
+{
+  void *ptr;
+  void *next;
+} mm_node;
+
+mm_node *mm_node_chain = NULL;
+
+void
+push_allocated_ptr (void *ptr)
+{
+  mm_node *node = XNEW (mm_node);
+  node->ptr = ptr;
+  node->next = mm_node_chain;
+  mm_node_chain = node;
+}
+
+/* Chain of all the created nodes.  */
+Node *node_chain = NULL;
+/* Number of nodes that correspond to functions which will be reordered.  */
+unsigned int num_real_nodes = 0;
+/* Chain of all edges in the merged callgraph.  */
+Edge *active_edges = NULL;
+/* Chain of all the merged edges.  */
+Edge *inactive_edges = NULL;
+
+/* Initial value of number of functions to allocate hash tables.  */
+const int NUM_FUNCTIONS = 100;
+
+/* Reads off the next string from the char stream CONTENTS and updates
+   READ_LENGTH to the length of the string read.  The value of CONTENTS
+   is updated to start at the next string.   UPDATE_CONTENTS tells if
+   CONTENTS must be moved past the read string to the next string.  To
+   peek at the string, UPDATE_CONTENTS can be set to false.  */
+
+static char *
+get_next_string (char **contents, unsigned int *read_length,
+		 int update_contents)
+{
+  char *s = *contents;
+  *read_length = strlen (*contents) + 1;
+  if (update_contents)
+    *contents += *read_length;
+  return s;
+}
+
+/* Add an EDGE to the list of edges in the call graph.  */
+
+static void
+add_edge_to_list (Edge *edge)
+{
+  assert (edge != NULL);
+  edge->next = active_edges;
+  if (active_edges != NULL)
+    active_edges->prev = edge;
+  active_edges = edge;
+}
+
+/* Remove the edge from the list of edges in the call graph. This is done
+   when the nodes corresponding to this edge are merged.  */
+
+static void
+remove_edge_from_list (Edge * curr_edge)
+{
+  assert (curr_edge != NULL);
+  if (curr_edge->prev != NULL)
+    curr_edge->prev->next = curr_edge->next;
+  if (curr_edge->next != NULL)
+    curr_edge->next->prev = curr_edge->prev;
+  if (active_edges == curr_edge)
+    active_edges = curr_edge->next;
+  curr_edge->next = NULL;
+  curr_edge->prev = NULL;
+
+  /* Add to inactive edges to be freed later.  */
+  curr_edge->next = inactive_edges;
+  inactive_edges = curr_edge;
+  return;
+}
+
+/* Adds the WEIGHT value to the edge count of CALLER and CALLEE.  */
+
+static void
+update_edge (Node *n1, Node *n2, unsigned long long weight)
+{
+  void **slot;
+  Raw_edge re, *r;
+  Edge *e;
+
+  if (n1->id == n2->id)
+    return;
+  if (weight == 0)
+    return;
+
+  if (edge_map == NULL)
+    {
+      edge_map = htab_create ((NUM_FUNCTIONS * 2),
+			      edge_map_htab_hash_descriptor,
+			      edge_map_htab_eq_descriptor , NULL);
+      assert (edge_map != NULL);
+    }
+
+  r = &re;
+  init_raw_edge (r, n1, n2);
+  slot = htab_find_slot_with_hash (edge_map, r,
+				   edge_hash_function (r->n1->id, r->n2->id),
+				   INSERT);
+  if (*slot == NULL)
+    {
+      e = make_edge (r->n1, r->n2, weight);
+      *slot = e;
+      add_edge_to_list (e);
+    }
+  else
+    {
+      e = *slot;
+      e->weight += weight;
+    }
+  /* Update the computed node weight for n2,  which is the sum of its incoming
+     edge weights.  */
+  n2->computed_weight += weight;
+}
+
+/* Create a unique node for a function.  */
+
+static Node *
+get_function_node (char *name)
+{
+  void **slot = NULL;
+  Node *node;
+
+  if (function_map == NULL)
+    {
+      function_map = htab_create (NUM_FUNCTIONS,
+				  function_map_htab_hash_descriptor,
+				  function_map_htab_eq_descriptor , NULL);
+      assert (function_map != NULL);
+    }
+
+  slot = htab_find_slot_with_hash (function_map, name, htab_hash_string (name),
+				   INSERT);
+
+  if (*slot == NULL)
+    {
+      node = make_node (last_function_id, name);
+      /* Chain the node to the node_chain.  */
+      node->next = node_chain;
+      node_chain = node;
+      *slot = node;
+      last_function_id++;
+    }
+  else
+    {
+      node = (Node *)*slot;
+    }
+  return node;
+}
+
+/* Dumper funcction to print the list of functions that will be considered for
+   re-ordering.  */
+
+void
+dump_functions ()
+{
+  Node *node = node_chain;
+  while (node)
+  {
+    if (node->is_real_node)
+      fprintf (stderr, "Dumping function %s\n", node->name);
+    node = node->next;
+  }
+}
+
+/* Dump all the edges existing in the callgraph.  */
+
+void dump_edges (FILE *fp)
+{
+  Edge *it;
+  for (it = active_edges;
+       it != NULL;
+       it = it->next)
+    {
+      fprintf (fp,"# %s (%llu, %llu) ---- (%llu)---- %s (%llu, %llu)\n",
+               it->first_function->name,
+	       it->first_function->weight,
+	       it->first_function->computed_weight,
+	       it->weight,
+               it->second_function->name,
+	       it->second_function->weight,
+	       it->second_function->computed_weight);
+    }
+}
+
+/* For file local functions, append a unique identifier corresponding to
+   the file, FILE_HANDLE, to the NAME to keep the name unique.  */
+
+static char *
+canonicalize_function_name (void *file_handle, char *name)
+{
+  /* Number of hexadecimal digits in file_handle, plus length of "0x".  */
+  const int FILE_HANDLE_LEN = sizeof (void *) * 2 + 2;
+  char *canonical_name;
+
+  /* File local functions have _ZL prefix in the mangled name.  */
+  /* XXX: Handle file local functions exhaustively, like functions in
+     anonymous name spaces.  */
+  if (!is_prefix_of ("_ZL", name))
+    return name;
+
+  XNEWVEC_ALLOC (canonical_name, char, (strlen(name) + FILE_HANDLE_LEN + 2));
+  sprintf (canonical_name, "%s.%p", name, file_handle);
+  return canonical_name;
+}
+
+/* Parse the section contents of ".gnu.callgraph.text"  sections and create
+   call graph edges with appropriate weights. The section contents have the
+   following format :
+   Function  <caller_name>
+   Weight <entry_count> <max_count> (optional line)
+   ColdWeight <max_count> (optional line)
+   <callee_1>
+   <edge count between caller and callee_1>
+   <callee_2>
+   <edge count between caller and callee_2>
+   ....  */
+void
+parse_callgraph_section_contents (void *file_handle,
+				  unsigned char *section_contents,
+				  unsigned int length)
+{
+  char *contents;
+  char *caller;
+  char *node_weight_s = NULL;
+  unsigned int read_length = 0, curr_length = 0;
+  Node *caller_node;
+
+  /* HEADER_LEN is the length of string 'Function '.  */
+  const int HEADER_LEN = 9;
+
+  /* Prefix of line containing node weights.  */
+  const char *NODE_WEIGHT_PREFIX = "Weight ";
+  /* Prefix of line containing max bb count of cold split part.  */
+  const char *SPLIT_FUNCTION_PREFIX = "ColdWeight ";
+
+  /* First string in contents is 'Function <function-name>'.  */
+  assert (length > 0);
+  contents = (char*) (section_contents);
+  caller = get_next_string (&contents, &read_length, 1);
+  assert (read_length > HEADER_LEN);
+  caller = canonicalize_function_name (file_handle, caller + HEADER_LEN);
+  curr_length = read_length;
+  caller_node = get_function_node (caller);
+
+  /* Check if next string is a node weight, which has the format
+     "Weight <entry_count> <max_count>".  We could have callgraph
+     sections with or without node weights.  */
+
+  /* Peek at the next string.  */
+  if (curr_length < length)
+    node_weight_s = get_next_string (&contents, &read_length, 0);
+  if (node_weight_s != NULL
+      && is_prefix_of (NODE_WEIGHT_PREFIX, node_weight_s))
+    {
+      char *max_count_s;
+      unsigned long long max_count;
+      unsigned long long node_weight
+	= atoll (node_weight_s + strlen (NODE_WEIGHT_PREFIX));
+      /* Functions like comdats only have one caller_node and can
+	 have multiple node weights from multiple modules.  */
+      caller_node->weight += node_weight;
+
+      /* Find the space and get the max_count.  */
+      max_count_s = strstr (node_weight_s + strlen (NODE_WEIGHT_PREFIX), " ");
+      if (max_count_s != NULL)
+	{
+	  max_count = atoll (max_count_s + 1);
+          /* Functions like comdats only have one caller_node and can
+	     have multiple node weights from multiple modules.  */
+	  caller_node->max_count += max_count;
+	}
+      /* Actually read the node weight here.  */
+      get_next_string (&contents, &read_length, 1);
+      curr_length += read_length;
+    }
+
+  /* If the function is split it could have the weight of the split cold
+     section here as "SplitWeight <max_count>".  */
+
+  /* Peek at the next string.  */
+  if (curr_length < length)
+    node_weight_s = get_next_string (&contents, &read_length, 0);
+  if (node_weight_s != NULL
+      && is_prefix_of (SPLIT_FUNCTION_PREFIX, node_weight_s))
+    {
+      unsigned long long split_weight
+	= atoll (node_weight_s + strlen (SPLIT_FUNCTION_PREFIX));
+      caller_node->split_weight = split_weight;
+      /* Actually read the node weight here.  */
+      get_next_string (&contents, &read_length, 1);
+      curr_length += read_length;
+    }
+
+  while (curr_length < length)
+    {
+      /* Read callee, weight tuples.  */
+      char *callee;
+      char *weight_str;
+      unsigned long long weight;
+      Node *callee_node;
+
+      callee = get_next_string (&contents, &read_length, 1);
+      curr_length += read_length;
+
+      /* We can have multiple header lines; such a situation arises when
+         we've linked objects into a shared library, and we use that
+         library as input to the linker for something else.  Deal
+         gracefully with such cases.  */
+      if (strncmp (callee, "Function ", HEADER_LEN) == 0)
+	continue;
+
+      callee = canonicalize_function_name (file_handle, callee);
+      callee_node = get_function_node (callee);
+
+      assert (curr_length < length);
+      weight_str = get_next_string (&contents, &read_length, 1);
+      weight = atoll (weight_str);
+      curr_length += read_length;
+      update_edge (caller_node, callee_node, weight);
+    }
+}
+
+/* Traverse the list of edges and find the edge with the maximum weight.  */
+
+static Edge *
+find_max_edge ()
+{
+  Edge *it, *max_edge;
+
+  if (active_edges == NULL)
+    return NULL;
+
+  max_edge = active_edges;
+  assert (!active_edges->is_merged);
+
+  it = active_edges->next;
+  for (;it != NULL; it = it->next)
+    {
+      assert (!it->is_merged);
+      if (edge_lower (max_edge , it))
+          max_edge = it;
+    }
+
+  return max_edge;
+}
+
+/* Change the EDGE from OLD_NODE to KEPT_NODE to be between NEW_NODE
+   and KEPT_NODE.  */
+
+static void
+merge_edge (Edge *edge, Node *new_node, Node *old_node,
+            Node *kept_node)
+{
+  void **slot;
+  Raw_edge re, *r;
+
+  r = &re;
+  init_raw_edge (r, new_node, kept_node);
+  slot = htab_find_slot_with_hash (edge_map, r,
+				   edge_hash_function (r->n1->id, r->n2->id),
+				   INSERT);
+
+  if (*slot == NULL)
+    {
+      reset_functions (edge, new_node, kept_node);
+      *slot = edge;
+      add_edge_to_node (new_node, edge);
+    }
+  else
+    {
+      Edge *new_edge = *slot;
+      new_edge->weight += edge->weight;
+      edge->is_merged = 1;
+      remove_edge_from_list (edge);
+    }
+}
+
+/* Merge the two nodes in this EDGE. The new node's edges are the union of
+   the edges of the original nodes.  */
+
+static void
+collapse_edge (Edge * edge)
+{
+  Edge_list *it;
+  Node *kept_node = edge->first_function;
+  Node *merged_node = edge->second_function;
+
+  /* Go through all merged_node edges and merge with kept_node.  */
+  for (it = merged_node->edge_list; it != NULL; it = it->next)
+    {
+      Node *other_node = NULL;
+      Edge *this_edge = it->edge;
+      if (this_edge->is_merged)
+        continue;
+      if (this_edge == edge)
+        continue;
+      assert (this_edge->first_function->id == merged_node->id
+              || this_edge->second_function->id == merged_node->id);
+      other_node = (this_edge->first_function->id
+		    == merged_node->id)
+		   ? this_edge->second_function
+                   : this_edge->first_function;
+      merge_edge (this_edge, kept_node, merged_node, other_node);
+    }
+
+  merge_node (kept_node, merged_node);
+  edge->is_merged = 1;
+  remove_edge_from_list (edge);
+}
+
+/* Make node N a real node if it can be reordered, that is, its .text
+   section is available.  */
+static void set_node_type (Node *n)
+{
+  void *slot;
+  char *name = n->name;
+  slot = htab_find_with_hash (section_map, name, htab_hash_string (name));
+  if (slot != NULL)
+    {
+      /* Update the section instance corresponding to the node instance.
+	 Assign the weights from the node instance to the section instance.  */
+      Section_id *s = (Section_id *)(slot);
+      Section_id *s_comdat;
+      assert (s->weight == 0 && s->computed_weight == 0 && s->max_count == 0);
+      s->weight = n->weight;
+      s->computed_weight = n->computed_weight; 
+      s->max_count = n->max_count;
+
+      /* If s is comdat, update all the comdat candidates for weight.  */
+      s_comdat = s->comdat_group;
+      while (s_comdat != NULL)
+        {
+          s_comdat->weight = s->weight;
+          s_comdat->computed_weight = s->computed_weight;
+          s_comdat->max_count = s->max_count; 
+          s_comdat = s_comdat->comdat_group;
+        }
+      set_as_real_node (n);
+      num_real_nodes++;
+    }
+}
+
+/* Return true if WEIGHT is more than the cutoff, specified either as
+   as percent, CUTOFF_P, of MAX or as an absolute value, CUTOFF_A.   */
+int 
+edge_over_cutoff (unsigned long long weight, unsigned long long max,
+		  unsigned int cutoff_p, unsigned long long cutoff_a)
+{
+  /* First check if weight if more than cutoff_p% of max.  */
+  if (((double)(max) * (cutoff_p/100.0)) >= (double) weight)
+    return 0;
+  if (cutoff_a >= weight)
+    return 0;
+  return 1;
+}
+
+/* Edge cutoff is used to discard callgraph edges that are not above a
+   certain threshold.  cutoff_p is to express this as a percent of the
+   maximum value and cutoff_a is used to express this as an absolute
+   value.  */
+extern unsigned int edge_cutoff_p;
+extern unsigned long long edge_cutoff_a;
+
+void
+find_pettis_hansen_function_layout (FILE *fp)
+{
+  Node *n_it;
+  Edge *it;
+  unsigned int max_edge_value = 0;
+
+  assert (node_chain != NULL);
+  assert (active_edges != NULL);
+  if (fp != NULL)
+    dump_edges (fp);
+
+  /* Go over all the nodes and set it as real node only if a corresponding
+     function section exists.  */
+  for (n_it = node_chain; n_it != NULL; n_it = n_it->next)
+    set_node_type (n_it);
+
+  /* Set edge types. A WEAK_EDGE has one of its nodes corresponding to a
+     function that cannot be re-ordered.  */
+  for (it = active_edges; it != NULL; it = it->next)
+    set_edge_type (it);
+
+  it = find_max_edge ();
+  if (it != NULL)
+    max_edge_value = it->weight;
+  while (it != NULL)
+    {
+      if (!edge_over_cutoff (it->weight, max_edge_value, edge_cutoff_p,
+			     edge_cutoff_a))
+	{
+	  if (fp !=NULL)
+	    fprintf (fp, "Not considering edge with weight %llu and below\n",
+		     it->weight);
+          break;
+	}
+      collapse_edge (it);
+      it = find_max_edge ();
+    }
+}
+
+/* The list of sections created, excluding comdat duplicates.  */
+Section_id *first_section = NULL;
+/* The number of sections.  */
+int num_sections = 0;
+
+const int NUM_SECTION_TYPES = 4;
+const char *section_types[] = {".text.hot.",
+			       ".text.unlikely.",
+			       ".text.startup.",
+			       ".text." };
+
+/* For sections that are not in the callgraph, the priority gives the
+   importance of each section type.  Sections are grouped according to
+   priority, higher priority (lower number).  */
+const int section_priority[] = {0, 3, 1, 2};
+
+/* Order in which the sections must be laid out is given by
+   section_position[section_type].  The order in which the section
+   types are laid out from address low to high are: .text.unlikely,
+   .text.startup, .text., .text.hot followed by the sections grouped
+   by the callgraph.  */
+const int section_position[] = {3, 0, 1, 2};
+
+/* The position of the sections grouped using the callgraph.  It comes after
+   all the sections not present in the callgraph are laid out.  */
+#define CALLGRAPH_POSITION NUM_SECTION_TYPES
+
+/* Maps the function name corresponding to section SECTION_NAME to the
+   object handle and the section index.  */
+
+void
+map_section_name_to_index (char *section_name, void *handle, int shndx)
+{
+  void **slot;
+  char *function_name = NULL;
+  int i, section_type = -1;
+
+  for (i = 0; i < ARRAY_SIZE (section_types); ++i)
+    {
+      if (is_prefix_of (section_types[i], section_name))
+        {
+          function_name = section_name + strlen (section_types[i]);
+  	  section_type = i;
+	  break;
+        }
+    }
+
+  assert (function_name != NULL && section_type >= 0);
+  function_name = canonicalize_function_name (handle, function_name);
+  num_sections++;
+
+  /* Allocate section_map.  */
+  if (section_map == NULL)
+    {
+      section_map = htab_create (NUM_FUNCTIONS,
+				 section_map_htab_hash_descriptor,
+				 section_map_htab_eq_descriptor , NULL);
+      assert (section_map != NULL);
+    }
+
+  slot = htab_find_slot_with_hash (section_map, function_name,
+				   htab_hash_string (function_name),
+				   INSERT);
+  if (*slot == NULL)
+    {
+      Section_id *section = make_section_id (function_name, section_name,
+					     section_type, handle, shndx);
+      /* Chain it to the list of sections.  */
+      section->next = first_section;
+      first_section = section;
+      *slot = section;
+    }
+  else
+    {
+      /* The function already exists, it must be a COMDAT.  Only one section
+	 in the comdat group will be kept, we don't know which.  Chain all the
+         comdat sections in the same comdat group to be emitted together later.
+         Keep one section as representative (kept) and update its section_type
+         to be equal to the type of the highest priority section in the
+         group.  */
+      Section_id *kept = (Section_id *)(*slot);
+      Section_id *section = make_section_id (function_name, section_name,
+                                             section_type, handle, shndx);
+
+      /* Two comdats in the same group can have different priorities.  This
+	 ensures that the "kept" comdat section has the priority of the higest
+  	 section in that comdat group.   This is necessary because the plugin
+	 does not know which section will be kept.  */
+      if (section_priority[kept->section_type]
+	  > section_priority[section_type])
+        kept->section_type = section_type;
+
+      section->comdat_group = kept->comdat_group;
+      kept->comdat_group = section;
+    }
+}
+
+/* Add section S to the chain SECTION_START ... SECTION_END.
+   If it is a comdat, get all the comdat sections in the group.
+   Chain these sections to SECTION_END.  Set SECTION_START if it
+   is NULL.  */
+
+static void
+write_out_node (Section_id *s, Section_id **section_start,
+	        Section_id **section_end)
+{
+  assert (s != NULL && s->processed == 0);
+  s->processed = 1;
+  if (*section_start == NULL)
+    {
+      *section_start = s;
+      *section_end = s;
+    }
+  else
+    {
+      (*section_end)->group = s;
+      *section_end = s;
+    }
+
+  /* Print all other sections in the same comdat group.  */
+  while (s->comdat_group)
+    {
+      s = s->comdat_group;
+      s->processed = 1;
+      (*section_end)->group = s;
+      *section_end = s;
+    }
+}
+
+/* Find the max of a, b and c.  */
+static unsigned long long
+get_max (unsigned long long a, unsigned long long b, unsigned long long c)
+{
+  unsigned long long max = a;
+  if (b > max)
+    max = b;
+  if (c > max)
+    max = c;
+  return max;
+}
+
+/* This is true if the max count of any bb in a function should be used as
+   the node weight rather than the count of the entry bb.  */
+extern int use_max_count;
+
+/* Comparison function for sorting two sections a and b by their
+   weight.  */
+static 
+int section_weight_compare (const void *a, const void *b)
+{
+  Section_id *s_a = *(Section_id **)a;
+  Section_id *s_b = *(Section_id **)b;
+  assert (use_max_count <= 1);
+  unsigned long long max_sa_weight = get_max (s_a->weight, s_a->computed_weight,
+					      s_a->max_count * use_max_count);
+  unsigned long long max_sb_weight = get_max (s_b->weight, s_b->computed_weight,
+					      s_b->max_count * use_max_count);
+
+  if (max_sa_weight < max_sb_weight)
+    return -1;
+  else if (max_sa_weight == max_sb_weight)
+    return 0;
+
+  return 1;
+}
+
+/* s is a pointer to a section and the group of sections is linked
+   via s->group.  The output is the list of sections sorted by their
+   node weights (which is the maximum of their profile count, computed
+   weights or the max bb count if use_max_count is true).  */
+static Section_id *
+sort_section_group (Section_id *s)
+{
+  Section_id **sort_array;
+  Section_id *s_tmp;
+  int num_elements = 0;
+  int i;
+
+  if (s == NULL)
+    return s;
+
+  s_tmp = s;
+  while (s_tmp != NULL)
+    {
+      num_elements++;
+      s_tmp = s_tmp->group;
+    }
+
+  if (num_elements == 1)
+    return s;
+
+  XNEWVEC_ALLOC (sort_array, Section_id *, num_elements);
+  s_tmp = s;
+  for (i = 0; i < num_elements; ++i)
+    {
+      sort_array[i] = s_tmp;
+      s_tmp = s_tmp->group;
+    }
+
+  for (i = 0; i < num_elements; ++i)
+    {
+      sort_array[i]->group = NULL;
+    }
+
+  qsort (sort_array, num_elements, sizeof (Section_id *),
+	 section_weight_compare);
+
+  s_tmp = sort_array[0];
+  for (i = 1; i < num_elements; ++i)
+    {
+      s_tmp->group = sort_array[i];
+      s_tmp = s_tmp->group;
+    }
+  s_tmp->group = NULL;
+  return sort_array[0];
+}
+
+/* If sort_name_prefix is true then the sections not touched by the callgraph
+   are grouped according to their name prefix.  When sort_name_prefix is zero,
+   all the sections are put together and sorted according to their node
+   weights.  The default value of sort_name_prefix is 0.  Even when sections
+   are grouped by their prefix, each group is sorted by the node weights.  */
+extern int sort_name_prefix;
+static int section_position_index (int section_type)
+{
+  assert (section_type >= 0  && section_type < NUM_SECTION_TYPES);
+  if (!sort_name_prefix)
+    return 0;
+  else
+    return section_position[section_type];
+}
+
+/* Track where the unlikely sections start and end.  This will be needed if
+   the unlikely sections need to be split into a separate segment.  */
+int unlikely_segment_start = -1;
+int unlikely_segment_end = -1;
+
+/* This value is used to determine the profile threshold below which the
+   section is considered unlikely.  The default is zero.  */
+extern unsigned long long unlikely_segment_profile_cutoff;
+
+/* Visit each node and print the chain of merged nodes to the file.  Update
+   HANDLES and SHNDX to contain the ordered list of sections.  */
+
+unsigned int
+get_layout (FILE *fp, void*** handles,
+            unsigned int** shndx)
+{
+  Node *n_it;
+  int  i = 0;
+  int position;
+  void *slot;
+  int unlikely_section_index;
+
+  /* Form NUM_SECTION_TYPES + 1 groups of sections.  Index 5 corresponds
+     to the list of sections that correspond to functions in the callgraph.
+     For other sections, they are grouped by section_type and stored in
+     index: section_position[section_type]).
+     SECTION_START points to the first section in each section group and
+     SECTION_END points to the last.  */
+  Section_id *section_start[NUM_SECTION_TYPES + 1];
+  Section_id *section_end[NUM_SECTION_TYPES + 1];
+  Section_id *s_it;
+
+  XNEWVEC_ALLOC (*handles, void *, num_sections);
+  XNEWVEC_ALLOC (*shndx, unsigned int, num_sections);
+
+  for (i = 0; i < NUM_SECTION_TYPES + 1; i++)
+    {
+      section_start[i] = NULL;
+      section_end[i] = NULL;
+    }
+
+  /* Dump edges to the final reordering file.  */
+  for (n_it = node_chain; n_it != NULL; n_it = n_it->next)
+    {
+      Section_id *s;
+      Node *node;
+      /* First, only consider nodes that are real and that have other
+	 nodes merged with it. */
+      if (n_it->is_merged || !n_it->is_real_node || !n_it->merge_next)
+        continue;
+
+      slot = htab_find_with_hash (section_map, n_it->name,
+				  htab_hash_string (n_it->name));
+      assert (slot != NULL);
+      s = (Section_id *)slot;
+      write_out_node (s, &section_start[CALLGRAPH_POSITION],
+		      &section_end[CALLGRAPH_POSITION]);
+
+      if (fp)
+	fprintf (fp, "# Callgraph group : %s", n_it->name);
+
+      node = n_it->merge_next;
+      while (node != NULL)
+        {
+          if (node->is_real_node)
+	    {
+	      slot = htab_find_with_hash (section_map, node->name,
+					  htab_hash_string (node->name));
+	      assert (slot != NULL);
+	      s = (Section_id *)slot;
+	      write_out_node (s, &section_start[CALLGRAPH_POSITION],
+			      &section_end[CALLGRAPH_POSITION]);
+	      if (fp)
+		fprintf (fp, " %s", node->name);
+	    }
+          node = node->merge_next;
+	}
+
+      if (fp)
+	fprintf (fp, "\n");
+    }
+
+  
+  /*  Now handle all the sections that were not processed above during
+      callgraph handling.  Go through all the sections and sort unprocessed
+      sections into different section_type groups.  */
+  s_it = first_section;
+  while (s_it)
+    {
+      if (!s_it->processed)
+	{
+	  int index = section_position_index(s_it->section_type);
+	  write_out_node (s_it, &section_start[index], &section_end[index]);
+	}
+      s_it = s_it->next;
+    } 
+     
+  /* Determine the unlikely section index  */
+  unlikely_section_index = -1;
+  for (i = 0; i < ARRAY_SIZE (section_types); ++i)
+    if (strcmp (".text.unlikely.", section_types[i]) == 0)
+      break;
+
+  assert (i < ARRAY_SIZE (section_types));
+  unlikely_section_index = section_position_index(i);
+
+  position = 0;
+  for (i = 0; i < NUM_SECTION_TYPES + 1; ++i)
+    {
+      s_it = section_start[i];
+
+      if (s_it == NULL)
+	continue;
+
+      /* Sort all section groups by weight except the callgraph group.  */
+      if (i != CALLGRAPH_POSITION)
+	s_it = sort_section_group (s_it);
+
+      /* Start the unlikely segment if necessary.  */
+      assert (use_max_count <= 1);
+      if (i == unlikely_section_index
+	  && (get_max (s_it->weight, s_it->computed_weight,
+		       s_it->max_count * use_max_count)
+		<= unlikely_segment_profile_cutoff))
+	{
+	  assert (unlikely_segment_start == -1);
+	  unlikely_segment_start = position;
+	  if (fp != NULL)
+	    fprintf (fp, "=== Unlikely sections start ===\n");
+	}
+
+      do
+        {
+	  assert (position < num_sections);
+          (*handles)[position] = s_it->handle;
+          (*shndx)[position] = s_it->shndx;
+
+	  /* Check if this section will end the unlikely segment.  */
+	  if (i == unlikely_section_index
+	      && unlikely_segment_start >= 0
+              && unlikely_segment_start != position
+	      && unlikely_segment_end == -1
+	      && (get_max (s_it->weight, s_it->computed_weight,
+		           s_it->max_count * use_max_count)
+		    > unlikely_segment_profile_cutoff))
+	    {
+	      unlikely_segment_end = position - 1;
+	      if (fp != NULL)
+		fprintf (fp, "=== Unlikely sections end ===\n");
+	    }
+
+          position++;
+	  if (fp != NULL)
+	    {
+	      fprintf (fp, "%s entry count = %llu computed = %llu "
+		       "max count = %llu\n", s_it->full_name, s_it->weight,
+		       s_it->computed_weight, s_it->max_count);
+	    }
+	  s_it = s_it->group;
+        }
+      while (s_it);
+
+      /* End the unlikely segment if it has not been done already.  */
+      if (i == unlikely_section_index
+	  && unlikely_segment_start != -1
+	  && unlikely_segment_end == -1)
+	{
+	  unlikely_segment_end = position - 1;
+	  if (fp != NULL)
+	    fprintf (fp, "=== Unlikely sections end ===\n");
+	}
+    }
+  return position;
+}
+
+void
+cleanup ()
+{
+  /* Go through heap allocated objects and free them.  */
+  while (mm_node_chain)
+    {
+      mm_node *node = mm_node_chain;
+      free (node->ptr);
+      mm_node_chain = node->next;
+      free (node);
+    }
+
+  /*  Delete all htabs. */
+  htab_delete (section_map);
+  htab_delete (function_map);
+  htab_delete (edge_map);
+}
+
+/* Check if the callgraph is empty.  */
+unsigned int
+is_callgraph_empty ()
+{
+  if (active_edges == NULL)
+    return 1;
+  return 0;
+}
diff --git a/function_reordering_plugin/callgraph.h b/function_reordering_plugin/callgraph.h
new file mode 100644
index 0000000..3e07ca6
--- /dev/null
+++ b/function_reordering_plugin/callgraph.h
@@ -0,0 +1,315 @@
+/* Callgraph implementation.
+   Copyright (C) 2011 Free Software Foundation, Inc.
+   Contributed by Sriraman Tallam (tmsriram@google.com)
+   and Easwaran Raman (eraman@google.com).
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+This program is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef CALLGRAPH_H
+#define CALLGRAPH_H
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <hashtab.h>
+#include <string.h>
+#include "libiberty.h"
+
+/* All heap allocations are tracked to be cleaned up later.  */
+#define XNEW_ALLOC(A, T)	A = XNEW (T); push_allocated_ptr (A);
+#define XNEWVEC_ALLOC(A, T, N)	A = XNEWVEC (T,N); push_allocated_ptr (A);
+
+/* Push a pointer that should be freed after the plugin is done.  */
+void push_allocated_ptr (void *ptr);
+
+struct edge_d;
+typedef struct edge_d Edge;
+
+/* Maintain a list of edges.  */
+typedef struct edge_list_d
+{
+  Edge *edge;
+  struct edge_list_d *next;
+  struct edge_list_d *prev;
+} Edge_list;
+
+inline static Edge_list *
+make_edge_list (Edge *e)
+{
+  Edge_list *list;
+  XNEW_ALLOC (list, Edge_list);
+  list->edge = e;
+  list->next = NULL;
+  list->prev = NULL;
+  return list;
+}
+
+/* Represents a node in the call graph. */
+typedef struct node_d
+{
+  unsigned int id;
+  char *name;
+  /* Node weight, execution count of entry bb.  */
+  unsigned long long weight;
+  /* Weight computed by adding weights of incoming edges to
+     this node.  */
+  unsigned long long computed_weight;
+  /* Max count of any bb executed.  */
+  unsigned long long max_count;
+  /* Stores the max count of any bb in the split cold section.  */
+  unsigned long long split_weight;
+  /* Chain all the Nodes created.  */
+  struct node_d *next;
+  /* Pointer to the next node in the chain of merged nodes.  */
+  struct node_d *merge_next;
+  /* List of all edges with this node.  */
+  Edge_list *edge_list;
+  /* Pointer to the last node in the chain of merged nodes.  */
+  struct node_d *last_merge_node;
+  unsigned int is_merged;
+  /* 1 if the function corresponding to this node can be re-ordered.  */
+  unsigned int is_real_node;
+} Node;
+
+inline static Node *
+make_node (unsigned int id, char *name)
+{
+  Node *node;
+  XNEW_ALLOC (node, Node);
+  node->id = id;
+  node->name = name;
+  node->weight = 0;
+  node->computed_weight = 0;
+  node->max_count = 0;
+  node->split_weight = 0;
+  node->is_real_node = 0;
+  node->next = NULL;
+  node->edge_list = NULL;
+  node->last_merge_node = node;
+  node->is_merged = 0;
+  node->merge_next = NULL;
+  return node;
+}
+
+/* Chain the nodes that are merged. Maintain a pointer to the last
+   node in the chain.  After merging at the end, the last node in the
+   current chain is the last node in the chain of the merged node.  */
+inline static void
+merge_node (Node *merger, Node *mergee)
+{
+  merger->last_merge_node->merge_next = mergee;
+  merger->last_merge_node = mergee->last_merge_node;
+  mergee->is_merged = 1;
+}
+
+inline static void
+add_edge_to_node (Node *n, Edge *e)
+{
+  Edge_list *list;
+  assert (n != NULL && e != NULL);
+  list = make_edge_list (e);
+  list->next = n->edge_list;
+  if (n->edge_list != NULL)
+    n->edge_list->prev = list;
+  n->edge_list = list;
+}
+
+/* A node is real only if the function can be reordered.  */
+inline static void
+set_as_real_node (Node *node)
+{
+  node->is_real_node = 1;
+}
+
+/* WEAK if one of the nodes is not real. STRONG if both
+   nodes are real.  */
+typedef enum edge_type_
+{
+  STRONG_EDGE = 0,
+  WEAK_EDGE
+} Edge_type;
+
+/*Represents an edge in the call graph.  */
+struct edge_d
+{
+  Node *first_function;
+  Node *second_function;
+  unsigned long long weight;
+  Edge_type type;
+  /* 1 if the nodes corresponding to this edge have been merged.  */
+  unsigned int is_merged;
+  /* Doubly linked chain of created edges.  */
+  struct edge_d *prev;
+  struct edge_d *next;
+};
+
+inline static Edge *
+make_edge (Node *first, Node *second, unsigned long long weight)
+{
+  Edge *edge;
+  XNEW_ALLOC (edge, Edge);
+  edge->first_function = first;
+  edge->second_function = second;
+  edge->weight = weight;
+  edge->type = WEAK_EDGE;
+  edge->is_merged = 0;
+  edge->prev = NULL;
+  edge->next = NULL;
+  add_edge_to_node (first, edge);
+  add_edge_to_node (second, edge);
+  return edge;
+}
+
+inline static void
+set_edge_type (Edge *edge)
+{
+  if (edge->first_function->is_real_node
+      && edge->second_function->is_real_node)
+    edge->type = STRONG_EDGE;
+  else
+    edge->type = WEAK_EDGE;
+}
+
+inline static unsigned int
+edge_lower (Edge *e1, Edge *e2)
+{
+  if (e1->type == e2->type)
+    return (e1->weight < e2->weight) ? 1 : 0;
+  if (e1->type == STRONG_EDGE)
+    return 0;
+  return 1;
+}
+
+inline static void
+reset_functions (Edge *e, Node *n1, Node *n2)
+{
+  /* No self edges.  */
+  assert (n1->id != n2->id);
+  if (n1->id < n2->id)
+    {
+      e->first_function = n1;
+      e->second_function = n2;
+    }
+  else
+    {
+      e->first_function = n2;
+      e->second_function = n1;
+    }
+}
+
+/* A Section is represented by its object handle and the section index. */
+typedef struct section_id_
+{
+  /* Name of the function.  */
+  char *name;
+  /* Full name of the section.  */
+  char *full_name;
+  void *handle;
+  int shndx;
+  /* Corresponds to node weight.  */
+  unsigned long long weight;
+  /* Corresponds to node's computed weight.  */
+  unsigned long long computed_weight;
+  /* Max count of bb executed in this function.  */
+  unsigned long long max_count;
+  /* Type of prefix in section name.  */
+  int section_type;
+  /* Pointer to the next section in the same comdat_group.  */
+  struct section_id_ *comdat_group;
+  /* Chain all the sections created.  */
+  struct section_id_ *next;
+  /* Used for grouping sections.  */
+  struct section_id_ *group;
+  /* Pointer to the cold split section if any.   If this function
+     is comdat hot and kept, pointer to the kept cold split
+     section.  */
+  struct section_id_ *split_section;
+  /* Check if this section has been considered for output.  */
+  char processed;
+} Section_id;
+
+inline static Section_id *
+make_section_id (char *name, char *full_name,
+		 int section_type,
+		 void *handle, int shndx)
+{
+  Section_id *s;
+  XNEW_ALLOC (s, Section_id);
+  s->name = name;
+  s->full_name = full_name;
+  s->section_type = section_type;
+  s->handle = handle;
+  s->shndx = shndx;
+  s->comdat_group = NULL;
+  s->next = NULL;
+  s->group = NULL;
+  s->processed = 0;
+  s->weight = 0;
+  s->computed_weight = 0;
+  s->max_count = 0;
+  s->split_section = NULL;
+
+  return s;
+}
+
+/* A pair of nodes make a raw edge.  Also, N1->id < N2->id.  */
+typedef struct
+{
+  Node *n1;
+  Node *n2;
+} Raw_edge;
+
+inline static void
+init_raw_edge (Raw_edge *r, Node *n1, Node *n2)
+{
+  assert (n1 ->id != n2->id);
+  if (n1->id < n2->id)
+    {
+      r->n1 = n1;
+      r->n2 = n2;
+    }
+  else
+    {
+      r->n1 = n2;
+      r->n2 = n1;
+    }
+}
+
+inline static int is_prefix_of (const char *prefix, const char *str)
+{
+  return strncmp (prefix, str, strlen (prefix)) == 0;
+}
+
+/* Maps the function corresponding to section name to its
+   corresponding object handle and the section index.  */
+void
+map_section_name_to_index (char *section_name, void *handle, int shndx);
+
+void
+parse_callgraph_section_contents (void *handle,
+				  unsigned char *section_contents,
+				  unsigned int length);
+
+void dump_functions ();
+void dump_edges ();
+void find_pettis_hansen_function_layout (FILE *fp);
+
+unsigned int get_layout (FILE *fp, void*** handles,
+			 unsigned int** shndx);
+
+void cleanup ();
+/* Returns 1 if callgraph is empty.  */
+unsigned int is_callgraph_empty ();
+#endif
diff --git a/function_reordering_plugin/config.h.in b/function_reordering_plugin/config.h.in
new file mode 100644
index 0000000..2c954a8
--- /dev/null
+++ b/function_reordering_plugin/config.h.in
@@ -0,0 +1,68 @@
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#undef LT_OBJDIR
+
+/* Name of package */
+#undef PACKAGE
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the home page for this package. */
+#undef PACKAGE_URL
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Version number of package */
+#undef VERSION
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+#undef _FILE_OFFSET_BITS
+
+/* Define for large files, on AIX-style hosts. */
+#undef _LARGE_FILES
diff --git a/function_reordering_plugin/configure b/function_reordering_plugin/configure
new file mode 100755
index 0000000..81a6185
--- /dev/null
+++ b/function_reordering_plugin/configure
@@ -0,0 +1,13086 @@
+#! /bin/sh
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.64 for REORDER plugin for ld 0.1.
+#
+# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
+# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software
+# Foundation, Inc.
+#
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## -------------------- ##
+## M4sh Initialization. ##
+## -------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+
+
+as_nl='
+'
+export as_nl
+# Printing a long string crashes Solaris 7 /usr/bin/printf.
+as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
+# Prefer a ksh shell builtin over an external printf program on Solaris,
+# but without wasting forks for bash or zsh.
+if test -z "$BASH_VERSION$ZSH_VERSION" \
+    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='print -r --'
+  as_echo_n='print -rn --'
+elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='printf %s\n'
+  as_echo_n='printf %s'
+else
+  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
+    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
+    as_echo_n='/usr/ucb/echo -n'
+  else
+    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
+    as_echo_n_body='eval
+      arg=$1;
+      case $arg in #(
+      *"$as_nl"*)
+	expr "X$arg" : "X\\(.*\\)$as_nl";
+	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
+      esac;
+      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
+    '
+    export as_echo_n_body
+    as_echo_n='sh -c $as_echo_n_body as_echo'
+  fi
+  export as_echo_body
+  as_echo='sh -c $as_echo_body as_echo'
+fi
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+case $0 in #((
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  exit 1
+fi
+
+# Unset variables that we do not need and which cause bugs (e.g. in
+# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
+# suppresses any "Segmentation fault" message there.  '((' could
+# trigger a bug in pdksh 5.2.14.
+for as_var in BASH_ENV ENV MAIL MAILPATH
+do eval test x\${$as_var+set} = xset \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# CDPATH.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+if test "x$CONFIG_SHELL" = x; then
+  as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '\${1+\"\$@\"}'='\"\$@\"'
+  setopt NO_GLOB_SUBST
+else
+  case \`(set -o) 2>/dev/null\` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+"
+  as_required="as_fn_return () { (exit \$1); }
+as_fn_success () { as_fn_return 0; }
+as_fn_failure () { as_fn_return 1; }
+as_fn_ret_success () { return 0; }
+as_fn_ret_failure () { return 1; }
+
+exitcode=0
+as_fn_success || { exitcode=1; echo as_fn_success failed.; }
+as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
+as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
+as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
+if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :
+
+else
+  exitcode=1; echo positional parameters were not saved.
+fi
+test x\$exitcode = x0 || exit 1"
+  as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
+  as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
+  eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
+  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1
+
+  test -n \"\${ZSH_VERSION+set}\${BASH_VERSION+set}\" || (
+    ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+    ECHO=\$ECHO\$ECHO\$ECHO\$ECHO\$ECHO
+    ECHO=\$ECHO\$ECHO\$ECHO\$ECHO\$ECHO\$ECHO
+    PATH=/empty FPATH=/empty; export PATH FPATH
+    test \"X\`printf %s \$ECHO\`\" = \"X\$ECHO\" \\
+      || test \"X\`print -r -- \$ECHO\`\" = \"X\$ECHO\" ) || exit 1
+test \$(( 1 + 1 )) = 2 || exit 1"
+  if (eval "$as_required") 2>/dev/null; then :
+  as_have_required=yes
+else
+  as_have_required=no
+fi
+  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null; then :
+
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+as_found=false
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  as_found=:
+  case $as_dir in #(
+	 /*)
+	   for as_base in sh bash ksh sh5; do
+	     # Try only shells that exist, to save several forks.
+	     as_shell=$as_dir/$as_base
+	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
+		    { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$as_shell"; } 2>/dev/null; then :
+  CONFIG_SHELL=$as_shell as_have_required=yes
+		   if { $as_echo "$as_bourne_compatible""$as_suggested" | as_run=a "$as_shell"; } 2>/dev/null; then :
+  break 2
+fi
+fi
+	   done;;
+       esac
+  as_found=false
+done
+$as_found || { if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
+	      { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$SHELL"; } 2>/dev/null; then :
+  CONFIG_SHELL=$SHELL as_have_required=yes
+fi; }
+IFS=$as_save_IFS
+
+
+      if test "x$CONFIG_SHELL" != x; then :
+  # We cannot yet assume a decent shell, so we have to provide a
+	# neutralization value for shells without unset; and this also
+	# works around shells that cannot unset nonexistent variables.
+	BASH_ENV=/dev/null
+	ENV=/dev/null
+	(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+	export CONFIG_SHELL
+	exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
+fi
+
+    if test x$as_have_required = xno; then :
+  $as_echo "$0: This script requires a shell more modern than all"
+  $as_echo "$0: the shells that I found on your system."
+  if test x${ZSH_VERSION+set} = xset ; then
+    $as_echo "$0: In particular, zsh $ZSH_VERSION has bugs and should"
+    $as_echo "$0: be upgraded to zsh 4.3.4 or later."
+  else
+    $as_echo "$0: Please tell bug-autoconf@gnu.org about your system,
+$0: including any error possibly output before this
+$0: message. Then install a modern shell, or manually run
+$0: the script under such a shell if you do have one."
+  fi
+  exit 1
+fi
+fi
+fi
+SHELL=${CONFIG_SHELL-/bin/sh}
+export SHELL
+# Unset more variables known to interfere with behavior of common tools.
+CLICOLOR_FORCE= GREP_OPTIONS=
+unset CLICOLOR_FORCE GREP_OPTIONS
+
+## --------------------- ##
+## M4sh Shell Functions. ##
+## --------------------- ##
+# as_fn_unset VAR
+# ---------------
+# Portably unset VAR.
+as_fn_unset ()
+{
+  { eval $1=; unset $1;}
+}
+as_unset=as_fn_unset
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+
+# as_fn_mkdir_p
+# -------------
+# Create "$as_dir" as a directory, including parents if necessary.
+as_fn_mkdir_p ()
+{
+
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || eval $as_mkdir_p || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
+
+
+} # as_fn_mkdir_p
+# as_fn_append VAR VALUE
+# ----------------------
+# Append the text in VALUE to the end of the definition contained in VAR. Take
+# advantage of any shell optimizations that allow amortized linear growth over
+# repeated appends, instead of the typical quadratic growth present in naive
+# implementations.
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+  eval 'as_fn_append ()
+  {
+    eval $1+=\$2
+  }'
+else
+  as_fn_append ()
+  {
+    eval $1=\$$1\$2
+  }
+fi # as_fn_append
+
+# as_fn_arith ARG...
+# ------------------
+# Perform arithmetic evaluation on the ARGs, and store the result in the
+# global $as_val. Take advantage of shells that can avoid forks. The arguments
+# must be portable across $(()) and expr.
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+  eval 'as_fn_arith ()
+  {
+    as_val=$(( $* ))
+  }'
+else
+  as_fn_arith ()
+  {
+    as_val=`expr "$@" || test $? -eq 1`
+  }
+fi # as_fn_arith
+
+
+# as_fn_error ERROR [LINENO LOG_FD]
+# ---------------------------------
+# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
+# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
+# script with status $?, using 1 if that was 0.
+as_fn_error ()
+{
+  as_status=$?; test $as_status -eq 0 && as_status=1
+  if test "$3"; then
+    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
+  fi
+  $as_echo "$as_me: error: $1" >&2
+  as_fn_exit $as_status
+} # as_fn_error
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+
+  as_lineno_1=$LINENO as_lineno_1a=$LINENO
+  as_lineno_2=$LINENO as_lineno_2a=$LINENO
+  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
+  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
+  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
+  sed -n '
+    p
+    /[$]LINENO/=
+  ' <$as_myself |
+    sed '
+      s/[$]LINENO.*/&-/
+      t lineno
+      b
+      :lineno
+      N
+      :loop
+      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      t loop
+      s/-\n.*//
+    ' >$as_me.lineno &&
+  chmod +x "$as_me.lineno" ||
+    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensitive to this).
+  . "./$as_me.lineno"
+  # Exit status is that of the last command.
+  exit
+}
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in #(((((
+-n*)
+  case `echo 'xy\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  xy)  ECHO_C='\c';;
+  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
+       ECHO_T='	';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
+fi
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+    # In both cases, we have to default to `cp -p'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -p'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -p'
+  fi
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p='mkdir -p "$as_dir"'
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+if test -x / >/dev/null 2>&1; then
+  as_test_x='test -x'
+else
+  if ls -dL / >/dev/null 2>&1; then
+    as_ls_L_option=L
+  else
+    as_ls_L_option=
+  fi
+  as_test_x='
+    eval sh -c '\''
+      if test -d "$1"; then
+	test -d "$1/.";
+      else
+	case $1 in #(
+	-*)set "./$1";;
+	esac;
+	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
+	???[sx]*):;;*)false;;esac;fi
+    '\'' sh
+  '
+fi
+as_executable_p=$as_test_x
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+
+exec 7<&0 </dev/null 6>&1
+
+# Name of the host.
+# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_clean_files=
+ac_config_libobj_dir=.
+LIBOBJS=
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+
+# Identity of this package.
+PACKAGE_NAME='REORDER plugin for ld'
+PACKAGE_TARNAME='function_reordering_plugin'
+PACKAGE_VERSION='0.1'
+PACKAGE_STRING='REORDER plugin for ld 0.1'
+PACKAGE_BUGREPORT=''
+PACKAGE_URL=''
+
+# Factoring default headers for most tests.
+ac_includes_default="\
+#include <stdio.h>
+#ifdef HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#ifdef STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# ifdef HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#ifdef HAVE_STRING_H
+# if !defined STDC_HEADERS && defined HAVE_MEMORY_H
+#  include <memory.h>
+# endif
+# include <string.h>
+#endif
+#ifdef HAVE_STRINGS_H
+# include <strings.h>
+#endif
+#ifdef HAVE_INTTYPES_H
+# include <inttypes.h>
+#endif
+#ifdef HAVE_STDINT_H
+# include <stdint.h>
+#endif
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif"
+
+ac_subst_vars='am__EXEEXT_FALSE
+am__EXEEXT_TRUE
+LTLIBOBJS
+LIBOBJS
+target_noncanonical
+lt_host_flags
+CPP
+OTOOL64
+OTOOL
+LIPO
+NMEDIT
+DSYMUTIL
+RANLIB
+AR
+OBJDUMP
+LN_S
+NM
+ac_ct_DUMPBIN
+DUMPBIN
+LD
+FGREP
+EGREP
+GREP
+SED
+LIBTOOL
+am__fastdepCC_FALSE
+am__fastdepCC_TRUE
+CCDEPMODE
+AMDEPBACKSLASH
+AMDEP_FALSE
+AMDEP_TRUE
+am__quote
+am__include
+DEPDIR
+OBJEXT
+EXEEXT
+ac_ct_CC
+CPPFLAGS
+LDFLAGS
+CFLAGS
+CC
+MAINT
+MAINTAINER_MODE_FALSE
+MAINTAINER_MODE_TRUE
+am__untar
+am__tar
+AMTAR
+am__leading_dot
+SET_MAKE
+AWK
+mkdir_p
+MKDIR_P
+INSTALL_STRIP_PROGRAM
+STRIP
+install_sh
+MAKEINFO
+AUTOHEADER
+AUTOMAKE
+AUTOCONF
+ACLOCAL
+VERSION
+PACKAGE
+CYGPATH_W
+am__isrc
+INSTALL_DATA
+INSTALL_SCRIPT
+INSTALL_PROGRAM
+target_subdir
+host_subdir
+build_subdir
+build_libsubdir
+target_os
+target_vendor
+target_cpu
+target
+host_os
+host_vendor
+host_cpu
+host
+build_os
+build_vendor
+build_cpu
+build
+target_alias
+host_alias
+build_alias
+LIBS
+ECHO_T
+ECHO_N
+ECHO_C
+DEFS
+mandir
+localedir
+libdir
+psdir
+pdfdir
+dvidir
+htmldir
+infodir
+docdir
+oldincludedir
+includedir
+localstatedir
+sharedstatedir
+sysconfdir
+datadir
+datarootdir
+libexecdir
+sbindir
+bindir
+program_transform_name
+prefix
+exec_prefix
+PACKAGE_URL
+PACKAGE_BUGREPORT
+PACKAGE_STRING
+PACKAGE_VERSION
+PACKAGE_TARNAME
+PACKAGE_NAME
+PATH_SEPARATOR
+SHELL'
+ac_subst_files=''
+ac_user_opts='
+enable_option_checking
+with_build_libsubdir
+enable_maintainer_mode
+enable_dependency_tracking
+enable_largefile
+enable_shared
+enable_static
+with_pic
+enable_fast_install
+with_gnu_ld
+enable_libtool_lock
+'
+      ac_precious_vars='build_alias
+host_alias
+target_alias
+CC
+CFLAGS
+LDFLAGS
+LIBS
+CPPFLAGS
+CPP'
+
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+ac_unrecognized_opts=
+ac_unrecognized_sep=
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+# (The list follows the same order as the GNU Coding Standards.)
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datarootdir='${prefix}/share'
+datadir='${datarootdir}'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
+infodir='${datarootdir}/info'
+htmldir='${docdir}'
+dvidir='${docdir}'
+pdfdir='${docdir}'
+psdir='${docdir}'
+libdir='${exec_prefix}/lib'
+localedir='${datarootdir}/locale'
+mandir='${datarootdir}/man'
+
+ac_prev=
+ac_dashdash=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval $ac_prev=\$ac_option
+    ac_prev=
+    continue
+  fi
+
+  case $ac_option in
+  *=*)	ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
+  *)	ac_optarg=yes ;;
+  esac
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_dashdash$ac_option in
+  --)
+    ac_dashdash=yes ;;
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=*)
+    datadir=$ac_optarg ;;
+
+  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \
+  | --dataroo | --dataro | --datar)
+    ac_prev=datarootdir ;;
+  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \
+  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)
+    datarootdir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error "invalid feature name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--disable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=no ;;
+
+  -docdir | --docdir | --docdi | --doc | --do)
+    ac_prev=docdir ;;
+  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)
+    docdir=$ac_optarg ;;
+
+  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)
+    ac_prev=dvidir ;;
+  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)
+    dvidir=$ac_optarg ;;
+
+  -enable-* | --enable-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error "invalid feature name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--enable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=\$ac_optarg ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)
+    ac_prev=htmldir ;;
+  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \
+  | --ht=*)
+    htmldir=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localedir | --localedir | --localedi | --localed | --locale)
+    ac_prev=localedir ;;
+  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)
+    localedir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst | --locals)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)
+    ac_prev=pdfdir ;;
+  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)
+    pdfdir=$ac_optarg ;;
+
+  -psdir | --psdir | --psdi | --psd | --ps)
+    ac_prev=psdir ;;
+  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)
+    psdir=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error "invalid package name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--with-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=\$ac_optarg ;;
+
+  -without-* | --without-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error "invalid package name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--without-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=no ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) as_fn_error "unrecognized option: \`$ac_option'
+Try \`$0 --help' for more information."
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    case $ac_envvar in #(
+      '' | [0-9]* | *[!_$as_cr_alnum]* )
+      as_fn_error "invalid variable name: \`$ac_envvar'" ;;
+    esac
+    eval $ac_envvar=\$ac_optarg
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  as_fn_error "missing argument to $ac_option"
+fi
+
+if test -n "$ac_unrecognized_opts"; then
+  case $enable_option_checking in
+    no) ;;
+    fatal) as_fn_error "unrecognized options: $ac_unrecognized_opts" ;;
+    *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
+  esac
+fi
+
+# Check all directory arguments for consistency.
+for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
+		datadir sysconfdir sharedstatedir localstatedir includedir \
+		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
+		libdir localedir mandir
+do
+  eval ac_val=\$$ac_var
+  # Remove trailing slashes.
+  case $ac_val in
+    */ )
+      ac_val=`expr "X$ac_val" : 'X\(.*[^/]\)' \| "X$ac_val" : 'X\(.*\)'`
+      eval $ac_var=\$ac_val;;
+  esac
+  # Be sure to have absolute directory names.
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* )  continue;;
+    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
+  esac
+  as_fn_error "expected an absolute directory name for --$ac_var: $ac_val"
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+    $as_echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used." >&2
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+ac_pwd=`pwd` && test -n "$ac_pwd" &&
+ac_ls_di=`ls -di .` &&
+ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
+  as_fn_error "working directory cannot be determined"
+test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
+  as_fn_error "pwd does not report name of working directory"
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then the parent directory.
+  ac_confdir=`$as_dirname -- "$as_myself" ||
+$as_expr X"$as_myself" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_myself" : 'X\(//\)[^/]' \| \
+	 X"$as_myself" : 'X\(//\)$' \| \
+	 X"$as_myself" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_myself" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r "$srcdir/$ac_unique_file"; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r "$srcdir/$ac_unique_file"; then
+  test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
+  as_fn_error "cannot find sources ($ac_unique_file) in $srcdir"
+fi
+ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
+ac_abs_confdir=`(
+	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error "$ac_msg"
+	pwd)`
+# When building in place, set srcdir=.
+if test "$ac_abs_confdir" = "$ac_pwd"; then
+  srcdir=.
+fi
+# Remove unnecessary trailing slashes from srcdir.
+# Double slashes in file names in object file debugging info
+# mess up M-x gdb in Emacs.
+case $srcdir in
+*/) srcdir=`expr "X$srcdir" : 'X\(.*[^/]\)' \| "X$srcdir" : 'X\(.*\)'`;;
+esac
+for ac_var in $ac_precious_vars; do
+  eval ac_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_env_${ac_var}_value=\$${ac_var}
+  eval ac_cv_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_cv_env_${ac_var}_value=\$${ac_var}
+done
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+\`configure' configures REORDER plugin for ld 0.1 to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+                          [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+                          [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR            user executables [EPREFIX/bin]
+  --sbindir=DIR           system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR        program executables [EPREFIX/libexec]
+  --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
+  --libdir=DIR            object code libraries [EPREFIX/lib]
+  --includedir=DIR        C header files [PREFIX/include]
+  --oldincludedir=DIR     C header files for non-gcc [/usr/include]
+  --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]
+  --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]
+  --infodir=DIR           info documentation [DATAROOTDIR/info]
+  --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]
+  --mandir=DIR            man documentation [DATAROOTDIR/man]
+  --docdir=DIR            documentation root
+                          [DATAROOTDIR/doc/function_reordering_plugin]
+  --htmldir=DIR           html documentation [DOCDIR]
+  --dvidir=DIR            dvi documentation [DOCDIR]
+  --pdfdir=DIR            pdf documentation [DOCDIR]
+  --psdir=DIR             ps documentation [DOCDIR]
+_ACEOF
+
+  cat <<\_ACEOF
+
+Program names:
+  --program-prefix=PREFIX            prepend PREFIX to installed program names
+  --program-suffix=SUFFIX            append SUFFIX to installed program names
+  --program-transform-name=PROGRAM   run sed PROGRAM on installed program names
+
+System types:
+  --build=BUILD     configure for building on BUILD [guessed]
+  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
+  --target=TARGET   configure for building compilers for TARGET [HOST]
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+  case $ac_init_help in
+     short | recursive ) echo "Configuration of REORDER plugin for ld 0.1:";;
+   esac
+  cat <<\_ACEOF
+
+Optional Features:
+  --disable-option-checking  ignore unrecognized --enable/--with options
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --enable-maintainer-mode  enable make rules and dependencies not useful
+			  (and sometimes confusing) to the casual installer
+  --disable-dependency-tracking  speeds up one-time build
+  --enable-dependency-tracking   do not reject slow dependency extractors
+  --disable-largefile     omit support for large files
+  --enable-shared[=PKGS]  build shared libraries [default=yes]
+  --enable-static[=PKGS]  build static libraries [default=yes]
+  --enable-fast-install[=PKGS]
+                          optimize for fast installation [default=yes]
+  --disable-libtool-lock  avoid locking (might break parallel builds)
+
+Optional Packages:
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --with-build-libsubdir=DIR  Directory where to find libraries for build system
+  --with-pic              try to use only PIC/non-PIC objects [default=use
+                          both]
+  --with-gnu-ld           assume the C compiler uses GNU ld [default=no]
+
+Some influential environment variables:
+  CC          C compiler command
+  CFLAGS      C compiler flags
+  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
+              nonstandard directory <lib dir>
+  LIBS        libraries to pass to the linker, e.g. -l<library>
+  CPPFLAGS    C/C++/Objective C preprocessor flags, e.g. -I<include dir> if
+              you have headers in a nonstandard directory <include dir>
+  CPP         C preprocessor
+
+Use these variables to override the choices made by `configure' or to help
+it to find libraries and programs with nonstandard names/locations.
+
+Report bugs to the package provider.
+_ACEOF
+ac_status=$?
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d "$ac_dir" ||
+      { cd "$srcdir" && ac_pwd=`pwd` && srcdir=. && test -d "$ac_dir"; } ||
+      continue
+    ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+    cd "$ac_dir" || { ac_status=$?; continue; }
+    # Check for guested configure.
+    if test -f "$ac_srcdir/configure.gnu"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure.gnu" --help=recursive
+    elif test -f "$ac_srcdir/configure"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure" --help=recursive
+    else
+      $as_echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi || ac_status=$?
+    cd "$ac_pwd" || { ac_status=$?; break; }
+  done
+fi
+
+test -n "$ac_init_help" && exit $ac_status
+if $ac_init_version; then
+  cat <<\_ACEOF
+REORDER plugin for ld configure 0.1
+generated by GNU Autoconf 2.64
+
+Copyright (C) 2009 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit
+fi
+
+## ------------------------ ##
+## Autoconf initialization. ##
+## ------------------------ ##
+
+# ac_fn_c_try_compile LINENO
+# --------------------------
+# Try to compile conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext
+  if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1
+fi
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  return $ac_retval
+
+} # ac_fn_c_try_compile
+
+# ac_fn_c_try_link LINENO
+# -----------------------
+# Try to link conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_link ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext conftest$ac_exeext
+  if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1
+fi
+  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information
+  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would
+  # interfere with the next link command; also delete a directory that is
+  # left behind by Apple's compiler.  We do this before executing the actions.
+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  return $ac_retval
+
+} # ac_fn_c_try_link
+
+# ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES
+# -------------------------------------------------------
+# Tests whether HEADER exists and can be compiled using the include files in
+# INCLUDES, setting the cache variable VAR accordingly.
+ac_fn_c_check_header_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+#include <$2>
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  eval "$3=yes"
+else
+  eval "$3=no"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+
+} # ac_fn_c_check_header_compile
+
+# ac_fn_c_try_cpp LINENO
+# ----------------------
+# Try to preprocess conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_cpp ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if { { ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } >/dev/null && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+    ac_retval=1
+fi
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  return $ac_retval
+
+} # ac_fn_c_try_cpp
+
+# ac_fn_c_try_run LINENO
+# ----------------------
+# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes
+# that executables *can* be run.
+ac_fn_c_try_run ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'
+  { { case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+       $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+       ac_retval=$ac_status
+fi
+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  return $ac_retval
+
+} # ac_fn_c_try_run
+
+# ac_fn_c_check_func LINENO FUNC VAR
+# ----------------------------------
+# Tests whether FUNC exists, setting the cache variable VAR accordingly
+ac_fn_c_check_func ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+/* Define $2 to an innocuous variant, in case <limits.h> declares $2.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $2 innocuous_$2
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $2 (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $2
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $2 ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$2 || defined __stub___$2
+choke me
+#endif
+
+int
+main ()
+{
+return $2 ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  eval "$3=yes"
+else
+  eval "$3=no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+
+} # ac_fn_c_check_func
+cat >config.log <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by REORDER plugin for ld $as_me 0.1, which was
+generated by GNU Autoconf 2.64.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+exec 5>>config.log
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    $as_echo "PATH: $as_dir"
+  done
+IFS=$as_save_IFS
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *\'*)
+      ac_arg=`$as_echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) as_fn_append ac_configure_args0 " '$ac_arg'" ;;
+    2)
+      as_fn_append ac_configure_args1 " '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      as_fn_append ac_configure_args " '$ac_arg'"
+      ;;
+    esac
+  done
+done
+{ ac_configure_args0=; unset ac_configure_args0;}
+{ ac_configure_args1=; unset ac_configure_args1;}
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Use '\'' to represent an apostrophe within the trap.
+# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    cat <<\_ASBOX
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+_ASBOX
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+(
+  for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) { eval $ac_var=; unset $ac_var;} ;;
+      esac ;;
+    esac
+  done
+  (set) 2>&1 |
+    case $as_nl`(ac_space='\'' '\''; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      sed -n \
+	"s/'\''/'\''\\\\'\'''\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\''\\2'\''/p"
+      ;; #(
+    *)
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+)
+    echo
+
+    cat <<\_ASBOX
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+_ASBOX
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=\$$ac_var
+      case $ac_val in
+      *\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+      esac
+      $as_echo "$ac_var='\''$ac_val'\''"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      cat <<\_ASBOX
+## ------------------- ##
+## File substitutions. ##
+## ------------------- ##
+_ASBOX
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=\$$ac_var
+	case $ac_val in
+	*\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+	esac
+	$as_echo "$ac_var='\''$ac_val'\''"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      cat <<\_ASBOX
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+_ASBOX
+      echo
+      cat confdefs.h
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      $as_echo "$as_me: caught signal $ac_signal"
+    $as_echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core *.core core.conftest.* &&
+    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; as_fn_exit 1' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -f -r conftest* confdefs.h
+
+$as_echo "/* confdefs.h */" > confdefs.h
+
+# Predefined preprocessor variables.
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_URL "$PACKAGE_URL"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer an explicitly selected file to automatically selected ones.
+ac_site_file1=NONE
+ac_site_file2=NONE
+if test -n "$CONFIG_SITE"; then
+  ac_site_file1=$CONFIG_SITE
+elif test "x$prefix" != xNONE; then
+  ac_site_file1=$prefix/share/config.site
+  ac_site_file2=$prefix/etc/config.site
+else
+  ac_site_file1=$ac_default_prefix/share/config.site
+  ac_site_file2=$ac_default_prefix/etc/config.site
+fi
+for ac_site_file in "$ac_site_file1" "$ac_site_file2"
+do
+  test "x$ac_site_file" = xNONE && continue
+  if test -r "$ac_site_file"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
+$as_echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special
+  # files actually), so we avoid doing that.
+  if test -f "$cache_file"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: loading cache $cache_file" >&5
+$as_echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . "$cache_file";;
+      *)                      . "./$cache_file";;
+    esac
+  fi
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: creating cache $cache_file" >&5
+$as_echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in $ac_precious_vars; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val=\$ac_cv_env_${ac_var}_value
+  eval ac_new_val=\$ac_env_${ac_var}_value
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was not set in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	# differences in whitespace do not lead to failure.
+	ac_old_val_w=`echo x $ac_old_val`
+	ac_new_val_w=`echo x $ac_new_val`
+	if test "$ac_old_val_w" != "$ac_new_val_w"; then
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' has changed since the previous run:" >&5
+$as_echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	  ac_cache_corrupted=:
+	else
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
+$as_echo "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
+	  eval $ac_var=\$ac_old_val
+	fi
+	{ $as_echo "$as_me:${as_lineno-$LINENO}:   former value:  \`$ac_old_val'" >&5
+$as_echo "$as_me:   former value:  \`$ac_old_val'" >&2;}
+	{ $as_echo "$as_me:${as_lineno-$LINENO}:   current value: \`$ac_new_val'" >&5
+$as_echo "$as_me:   current value: \`$ac_new_val'" >&2;}
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *\'*) ac_arg=$ac_var=`$as_echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) as_fn_append ac_configure_args " '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+  { $as_echo "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
+$as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  as_fn_error "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
+fi
+## -------------------- ##
+## Main body of script. ##
+## -------------------- ##
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+
+
+ac_aux_dir=
+for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
+  for ac_t in install-sh install.sh shtool; do
+    if test -f "$ac_dir/$ac_t"; then
+      ac_aux_dir=$ac_dir
+      ac_install_sh="$ac_aux_dir/$ac_t -c"
+      break 2
+    fi
+  done
+done
+if test -z "$ac_aux_dir"; then
+  as_fn_error "cannot find install-sh, install.sh, or shtool in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" "$LINENO" 5
+fi
+
+# These three variables are undocumented and unsupported,
+# and are intended to be withdrawn in a future Autoconf release.
+# They can cause serious problems if a builder's source tree is in a directory
+# whose full name contains unusual characters.
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
+ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
+
+
+# Make sure we can run config.sub.
+$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
+  as_fn_error "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
+$as_echo_n "checking build system type... " >&6; }
+if test "${ac_cv_build+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_build_alias=$build_alias
+test "x$ac_build_alias" = x &&
+  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
+test "x$ac_build_alias" = x &&
+  as_fn_error "cannot guess build type; you must specify one" "$LINENO" 5
+ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
+  as_fn_error "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_build" >&5
+$as_echo "$ac_cv_build" >&6; }
+case $ac_cv_build in
+*-*-*) ;;
+*) as_fn_error "invalid value of canonical build" "$LINENO" 5;;
+esac
+build=$ac_cv_build
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_build
+shift
+build_cpu=$1
+build_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+build_os=$*
+IFS=$ac_save_IFS
+case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking host system type" >&5
+$as_echo_n "checking host system type... " >&6; }
+if test "${ac_cv_host+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test "x$host_alias" = x; then
+  ac_cv_host=$ac_cv_build
+else
+  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
+    as_fn_error "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_host" >&5
+$as_echo "$ac_cv_host" >&6; }
+case $ac_cv_host in
+*-*-*) ;;
+*) as_fn_error "invalid value of canonical host" "$LINENO" 5;;
+esac
+host=$ac_cv_host
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_host
+shift
+host_cpu=$1
+host_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+host_os=$*
+IFS=$ac_save_IFS
+case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking target system type" >&5
+$as_echo_n "checking target system type... " >&6; }
+if test "${ac_cv_target+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test "x$target_alias" = x; then
+  ac_cv_target=$ac_cv_host
+else
+  ac_cv_target=`$SHELL "$ac_aux_dir/config.sub" $target_alias` ||
+    as_fn_error "$SHELL $ac_aux_dir/config.sub $target_alias failed" "$LINENO" 5
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_target" >&5
+$as_echo "$ac_cv_target" >&6; }
+case $ac_cv_target in
+*-*-*) ;;
+*) as_fn_error "invalid value of canonical target" "$LINENO" 5;;
+esac
+target=$ac_cv_target
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_target
+shift
+target_cpu=$1
+target_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+target_os=$*
+IFS=$ac_save_IFS
+case $target_os in *\ *) target_os=`echo "$target_os" | sed 's/ /-/g'`;; esac
+
+
+# The aliases save the names the user supplied, while $host etc.
+# will get canonicalized.
+test -n "$target_alias" &&
+  test "$program_prefix$program_suffix$program_transform_name" = \
+    NONENONEs,x,x, &&
+  program_prefix=${target_alias}-
+
+ case ${build_alias} in
+  "") build_noncanonical=${build} ;;
+  *) build_noncanonical=${build_alias} ;;
+esac
+
+ case ${host_alias} in
+  "") host_noncanonical=${build_noncanonical} ;;
+  *) host_noncanonical=${host_alias} ;;
+esac
+
+ case ${target_alias} in
+  "") target_noncanonical=${host_noncanonical} ;;
+  *) target_noncanonical=${target_alias} ;;
+esac
+
+
+# post-stage1 host modules use a different CC_FOR_BUILD so, in order to
+# have matching libraries, they should use host libraries: Makefile.tpl
+# arranges to pass --with-build-libsubdir=$(HOST_SUBDIR).
+# However, they still use the build modules, because the corresponding
+# host modules (e.g. bison) are only built for the host when bootstrap
+# finishes. So:
+# - build_subdir is where we find build modules, and never changes.
+# - build_libsubdir is where we find build libraries, and can be overridden.
+
+# Prefix 'build-' so this never conflicts with target_subdir.
+build_subdir="build-${build_noncanonical}"
+
+# Check whether --with-build-libsubdir was given.
+if test "${with_build_libsubdir+set}" = set; then :
+  withval=$with_build_libsubdir; build_libsubdir="$withval"
+else
+  build_libsubdir="$build_subdir"
+fi
+
+# --srcdir=. covers the toplevel, while "test -d" covers the subdirectories
+if ( test $srcdir = . && test -d gcc ) \
+   || test -d $srcdir/../host-${host_noncanonical}; then
+  host_subdir="host-${host_noncanonical}"
+else
+  host_subdir=.
+fi
+# No prefix.
+target_subdir=${target_noncanonical}
+
+am__api_version='1.11'
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+# Reject install programs that cannot install multiple files.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a BSD-compatible install" >&5
+$as_echo_n "checking for a BSD-compatible install... " >&6; }
+if test -z "$INSTALL"; then
+if test "${ac_cv_path_install+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in #((
+  ./ | .// | /[cC]/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:[\\/]os2[\\/]install[\\/]* | ?:[\\/]OS2[\\/]INSTALL[\\/]* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; }; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    rm -rf conftest.one conftest.two conftest.dir
+	    echo one > conftest.one
+	    echo two > conftest.two
+	    mkdir conftest.dir
+	    if "$as_dir/$ac_prog$ac_exec_ext" -c conftest.one conftest.two "`pwd`/conftest.dir" &&
+	      test -s conftest.one && test -s conftest.two &&
+	      test -s conftest.dir/conftest.one &&
+	      test -s conftest.dir/conftest.two
+	    then
+	      ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	      break 3
+	    fi
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+
+  done
+IFS=$as_save_IFS
+
+rm -rf conftest.one conftest.two conftest.dir
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  Don't cache a
+    # value for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the value is a relative name.
+    INSTALL=$ac_install_sh
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $INSTALL" >&5
+$as_echo "$INSTALL" >&6; }
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether build environment is sane" >&5
+$as_echo_n "checking whether build environment is sane... " >&6; }
+# Just in case
+sleep 1
+echo timestamp > conftest.file
+# Reject unsafe characters in $srcdir or the absolute working directory
+# name.  Accept space and tab only in the latter.
+am_lf='
+'
+case `pwd` in
+  *[\\\"\#\$\&\'\`$am_lf]*)
+    as_fn_error "unsafe absolute working directory name" "$LINENO" 5;;
+esac
+case $srcdir in
+  *[\\\"\#\$\&\'\`$am_lf\ \	]*)
+    as_fn_error "unsafe srcdir value: \`$srcdir'" "$LINENO" 5;;
+esac
+
+# Do `set' in a subshell so we don't clobber the current shell's
+# arguments.  Must try -L first in case configure is actually a
+# symlink; some systems play weird games with the mod time of symlinks
+# (eg FreeBSD returns the mod time of the symlink's containing
+# directory).
+if (
+   set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
+   if test "$*" = "X"; then
+      # -L didn't work.
+      set X `ls -t "$srcdir/configure" conftest.file`
+   fi
+   rm -f conftest.file
+   if test "$*" != "X $srcdir/configure conftest.file" \
+      && test "$*" != "X conftest.file $srcdir/configure"; then
+
+      # If neither matched, then we have a broken ls.  This can happen
+      # if, for instance, CONFIG_SHELL is bash and it inherits a
+      # broken ls alias from the environment.  This has actually
+      # happened.  Such a system could not be considered "sane".
+      as_fn_error "ls -t appears to fail.  Make sure there is not a broken
+alias in your environment" "$LINENO" 5
+   fi
+
+   test "$2" = conftest.file
+   )
+then
+   # Ok.
+   :
+else
+   as_fn_error "newly created file is older than distributed files!
+Check your system clock" "$LINENO" 5
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+test "$program_prefix" != NONE &&
+  program_transform_name="s&^&$program_prefix&;$program_transform_name"
+# Use a double $ so make ignores it.
+test "$program_suffix" != NONE &&
+  program_transform_name="s&\$&$program_suffix&;$program_transform_name"
+# Double any \ or $.
+# By default was `s,x,x', remove it if useless.
+ac_script='s/[\\$]/&&/g;s/;s,x,x,$//'
+program_transform_name=`$as_echo "$program_transform_name" | sed "$ac_script"`
+
+# expand $ac_aux_dir to an absolute path
+am_aux_dir=`cd $ac_aux_dir && pwd`
+
+if test x"${MISSING+set}" != xset; then
+  case $am_aux_dir in
+  *\ * | *\	*)
+    MISSING="\${SHELL} \"$am_aux_dir/missing\"" ;;
+  *)
+    MISSING="\${SHELL} $am_aux_dir/missing" ;;
+  esac
+fi
+# Use eval to expand $SHELL
+if eval "$MISSING --run true"; then
+  am_missing_run="$MISSING --run "
+else
+  am_missing_run=
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`missing' script is too old or missing" >&5
+$as_echo "$as_me: WARNING: \`missing' script is too old or missing" >&2;}
+fi
+
+if test x"${install_sh}" != xset; then
+  case $am_aux_dir in
+  *\ * | *\	*)
+    install_sh="\${SHELL} '$am_aux_dir/install-sh'" ;;
+  *)
+    install_sh="\${SHELL} $am_aux_dir/install-sh"
+  esac
+fi
+
+# Installed binaries are usually stripped using `strip' when the user
+# run `make install-strip'.  However `strip' might not be the right
+# tool to use in cross-compilation environments, therefore Automake
+# will honor the `STRIP' environment variable to overrule this program.
+if test "$cross_compiling" != no; then
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
+set dummy ${ac_tool_prefix}strip; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_STRIP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$STRIP"; then
+  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+STRIP=$ac_cv_prog_STRIP
+if test -n "$STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
+$as_echo "$STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_STRIP"; then
+  ac_ct_STRIP=$STRIP
+  # Extract the first word of "strip", so it can be a program name with args.
+set dummy strip; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_STRIP"; then
+  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_STRIP="strip"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
+if test -n "$ac_ct_STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
+$as_echo "$ac_ct_STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_STRIP" = x; then
+    STRIP=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    STRIP=$ac_ct_STRIP
+  fi
+else
+  STRIP="$ac_cv_prog_STRIP"
+fi
+
+fi
+INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a thread-safe mkdir -p" >&5
+$as_echo_n "checking for a thread-safe mkdir -p... " >&6; }
+if test -z "$MKDIR_P"; then
+  if test "${ac_cv_path_mkdir+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/opt/sfw/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in mkdir gmkdir; do
+	 for ac_exec_ext in '' $ac_executable_extensions; do
+	   { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; } || continue
+	   case `"$as_dir/$ac_prog$ac_exec_ext" --version 2>&1` in #(
+	     'mkdir (GNU coreutils) '* | \
+	     'mkdir (coreutils) '* | \
+	     'mkdir (fileutils) '4.1*)
+	       ac_cv_path_mkdir=$as_dir/$ac_prog$ac_exec_ext
+	       break 3;;
+	   esac
+	 done
+       done
+  done
+IFS=$as_save_IFS
+
+fi
+
+  if test "${ac_cv_path_mkdir+set}" = set; then
+    MKDIR_P="$ac_cv_path_mkdir -p"
+  else
+    # As a last resort, use the slow shell script.  Don't cache a
+    # value for MKDIR_P within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the value is a relative name.
+    test -d ./--version && rmdir ./--version
+    MKDIR_P="$ac_install_sh -d"
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $MKDIR_P" >&5
+$as_echo "$MKDIR_P" >&6; }
+
+mkdir_p="$MKDIR_P"
+case $mkdir_p in
+  [\\/$]* | ?:[\\/]*) ;;
+  */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
+esac
+
+for ac_prog in gawk mawk nawk awk
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_AWK+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$AWK"; then
+  ac_cv_prog_AWK="$AWK" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_AWK="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+AWK=$ac_cv_prog_AWK
+if test -n "$AWK"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AWK" >&5
+$as_echo "$AWK" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$AWK" && break
+done
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ${MAKE-make} sets \$(MAKE)" >&5
+$as_echo_n "checking whether ${MAKE-make} sets \$(MAKE)... " >&6; }
+set x ${MAKE-make}
+ac_make=`$as_echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
+if { as_var=ac_cv_prog_make_${ac_make}_set; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.make <<\_ACEOF
+SHELL = /bin/sh
+all:
+	@echo '@@@%%%=$(MAKE)=@@@%%%'
+_ACEOF
+# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+case `${MAKE-make} -f conftest.make 2>/dev/null` in
+  *@@@%%%=?*=@@@%%%*)
+    eval ac_cv_prog_make_${ac_make}_set=yes;;
+  *)
+    eval ac_cv_prog_make_${ac_make}_set=no;;
+esac
+rm -f conftest.make
+fi
+if eval test \$ac_cv_prog_make_${ac_make}_set = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+  SET_MAKE=
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+  SET_MAKE="MAKE=${MAKE-make}"
+fi
+
+rm -rf .tst 2>/dev/null
+mkdir .tst 2>/dev/null
+if test -d .tst; then
+  am__leading_dot=.
+else
+  am__leading_dot=_
+fi
+rmdir .tst 2>/dev/null
+
+if test "`cd $srcdir && pwd`" != "`pwd`"; then
+  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
+  # is not polluted with repeated "-I."
+  am__isrc=' -I$(srcdir)'
+  # test to see if srcdir already configured
+  if test -f $srcdir/config.status; then
+    as_fn_error "source directory already configured; run \"make distclean\" there first" "$LINENO" 5
+  fi
+fi
+
+# test whether we have cygpath
+if test -z "$CYGPATH_W"; then
+  if (cygpath --version) >/dev/null 2>/dev/null; then
+    CYGPATH_W='cygpath -w'
+  else
+    CYGPATH_W=echo
+  fi
+fi
+
+
+# Define the identity of the package.
+ PACKAGE='function_reordering_plugin'
+ VERSION='0.1'
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE "$PACKAGE"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define VERSION "$VERSION"
+_ACEOF
+
+# Some tools Automake needs.
+
+ACLOCAL=${ACLOCAL-"${am_missing_run}aclocal-${am__api_version}"}
+
+
+AUTOCONF=${AUTOCONF-"${am_missing_run}autoconf"}
+
+
+AUTOMAKE=${AUTOMAKE-"${am_missing_run}automake-${am__api_version}"}
+
+
+AUTOHEADER=${AUTOHEADER-"${am_missing_run}autoheader"}
+
+
+MAKEINFO=${MAKEINFO-"${am_missing_run}makeinfo"}
+
+# We need awk for the "check" target.  The system "awk" is bad on
+# some platforms.
+# Always define AMTAR for backward compatibility.
+
+AMTAR=${AMTAR-"${am_missing_run}tar"}
+
+am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to enable maintainer-specific portions of Makefiles" >&5
+$as_echo_n "checking whether to enable maintainer-specific portions of Makefiles... " >&6; }
+    # Check whether --enable-maintainer-mode was given.
+if test "${enable_maintainer_mode+set}" = set; then :
+  enableval=$enable_maintainer_mode; USE_MAINTAINER_MODE=$enableval
+else
+  USE_MAINTAINER_MODE=no
+fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $USE_MAINTAINER_MODE" >&5
+$as_echo "$USE_MAINTAINER_MODE" >&6; }
+   if test $USE_MAINTAINER_MODE = yes; then
+  MAINTAINER_MODE_TRUE=
+  MAINTAINER_MODE_FALSE='#'
+else
+  MAINTAINER_MODE_TRUE='#'
+  MAINTAINER_MODE_FALSE=
+fi
+
+  MAINT=$MAINTAINER_MODE_TRUE
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CC="gcc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+if test -z "$CC"; then
+          if test -n "$ac_tool_prefix"; then
+    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="${ac_tool_prefix}cc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  fi
+fi
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in cl.exe
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$CC" && break
+  done
+fi
+if test -z "$CC"; then
+  ac_ct_CC=$CC
+  for ac_prog in cl.exe
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CC="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_CC" && break
+done
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+fi
+
+fi
+
+
+test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error "no acceptable C compiler found in \$PATH
+See \`config.log' for more details." "$LINENO" 5; }
+
+# Provide some information about the compiler.
+$as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+for ac_option in --version -v -V -qversion; do
+  { { ac_try="$ac_compiler $ac_option >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    sed '10a\
+... rest of stderr output deleted ...
+         10q' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    rm -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+done
+
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out conftest.out"
+# Try to create an executable without -o first, disregard a.out.
+# It will help us diagnose broken compilers, and finding out an intuition
+# of exeext.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler default output file name" >&5
+$as_echo_n "checking for C compiler default output file name... " >&6; }
+ac_link_default=`$as_echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
+
+# The possible output files:
+ac_files="a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*"
+
+ac_rmfiles=
+for ac_file in $ac_files
+do
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
+    * ) ac_rmfiles="$ac_rmfiles $ac_file";;
+  esac
+done
+rm -f $ac_rmfiles
+
+if { { ac_try="$ac_link_default"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link_default") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
+  # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
+# So ignore a value of `no', otherwise this would lead to `EXEEXT = no'
+# in a Makefile.  We should not override ac_cv_exeext if it was cached,
+# so that the user can short-circuit this test for compilers unknown to
+# Autoconf.
+for ac_file in $ac_files ''
+do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )
+	;;
+    [ab].out )
+	# We found the default executable, but exeext='' is most
+	# certainly right.
+	break;;
+    *.* )
+	if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
+	then :; else
+	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	fi
+	# We set ac_cv_exeext here because the later test for it is not
+	# safe: cross compilers may not add the suffix if given an `-o'
+	# argument, so we may need to know it at that point already.
+	# Even if this section looks crufty: it has the advantage of
+	# actually working.
+	break;;
+    * )
+	break;;
+  esac
+done
+test "$ac_cv_exeext" = no && ac_cv_exeext=
+
+else
+  ac_file=''
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_file" >&5
+$as_echo "$ac_file" >&6; }
+if test -z "$ac_file"; then :
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ as_fn_set_status 77
+as_fn_error "C compiler cannot create executables
+See \`config.log' for more details." "$LINENO" 5; }; }
+fi
+ac_exeext=$ac_cv_exeext
+
+# Check that the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler works" >&5
+$as_echo_n "checking whether the C compiler works... " >&6; }
+# If not cross compiling, check that we can run a simple program.
+if test "$cross_compiling" != yes; then
+  if { ac_try='./$ac_file'
+  { { case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then
+    cross_compiling=no
+  else
+    if test "$cross_compiling" = maybe; then
+	cross_compiling=yes
+    else
+	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error "cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details." "$LINENO" 5; }
+    fi
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out conftest.out
+ac_clean_files=$ac_clean_files_save
+# Check that the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are cross compiling" >&5
+$as_echo_n "checking whether we are cross compiling... " >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $cross_compiling" >&5
+$as_echo "$cross_compiling" >&6; }
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of executables" >&5
+$as_echo_n "checking for suffix of executables... " >&6; }
+if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
+  # If both `conftest.exe' and `conftest' are `present' (well, observable)
+# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
+# work properly (i.e., refer to `conftest.exe'), while it won't with
+# `rm'.
+for ac_file in conftest.exe conftest conftest.*; do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
+    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	  break;;
+    * ) break;;
+  esac
+done
+else
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error "cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details." "$LINENO" 5; }
+fi
+rm -f conftest$ac_cv_exeext
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
+$as_echo "$ac_cv_exeext" >&6; }
+
+rm -f conftest.$ac_ext
+EXEEXT=$ac_cv_exeext
+ac_exeext=$EXEEXT
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of object files" >&5
+$as_echo_n "checking for suffix of object files... " >&6; }
+if test "${ac_cv_objext+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.o conftest.obj
+if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
+  for ac_file in conftest.o conftest.obj conftest.*; do
+  test -f "$ac_file" || continue;
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;
+    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
+       break;;
+  esac
+done
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error "cannot compute suffix of object files: cannot compile
+See \`config.log' for more details." "$LINENO" 5; }
+fi
+rm -f conftest.$ac_cv_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_objext" >&5
+$as_echo "$ac_cv_objext" >&6; }
+OBJEXT=$ac_cv_objext
+ac_objext=$OBJEXT
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
+$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
+if test "${ac_cv_c_compiler_gnu+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_compiler_gnu=yes
+else
+  ac_compiler_gnu=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
+$as_echo "$ac_cv_c_compiler_gnu" >&6; }
+if test $ac_compiler_gnu = yes; then
+  GCC=yes
+else
+  GCC=
+fi
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
+$as_echo_n "checking whether $CC accepts -g... " >&6; }
+if test "${ac_cv_prog_cc_g+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_save_c_werror_flag=$ac_c_werror_flag
+   ac_c_werror_flag=yes
+   ac_cv_prog_cc_g=no
+   CFLAGS="-g"
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+else
+  CFLAGS=""
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+
+else
+  ac_c_werror_flag=$ac_save_c_werror_flag
+	 CFLAGS="-g"
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_c_werror_flag=$ac_save_c_werror_flag
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
+$as_echo "$ac_cv_prog_cc_g" >&6; }
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
+$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
+if test "${ac_cv_prog_cc_c89+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_prog_cc_c89=no
+ac_save_CC=$CC
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdarg.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
+/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
+   inside strings and character constants.  */
+#define FOO(x) 'x'
+int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
+
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
+	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_c89=$ac_arg
+fi
+rm -f core conftest.err conftest.$ac_objext
+  test "x$ac_cv_prog_cc_c89" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CC=$ac_save_CC
+
+fi
+# AC_CACHE_VAL
+case "x$ac_cv_prog_cc_c89" in
+  x)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+$as_echo "none needed" >&6; } ;;
+  xno)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+$as_echo "unsupported" >&6; } ;;
+  *)
+    CC="$CC $ac_cv_prog_cc_c89"
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
+$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
+esac
+if test "x$ac_cv_prog_cc_c89" != xno; then :
+
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+DEPDIR="${am__leading_dot}deps"
+
+ac_config_commands="$ac_config_commands depfiles"
+
+
+am_make=${MAKE-make}
+cat > confinc << 'END'
+am__doit:
+	@echo this is the am__doit target
+.PHONY: am__doit
+END
+# If we don't find an include directive, just comment out the code.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for style of include used by $am_make" >&5
+$as_echo_n "checking for style of include used by $am_make... " >&6; }
+am__include="#"
+am__quote=
+_am_result=none
+# First try GNU make style include.
+echo "include confinc" > confmf
+# Ignore all kinds of additional output from `make'.
+case `$am_make -s -f confmf 2> /dev/null` in #(
+*the\ am__doit\ target*)
+  am__include=include
+  am__quote=
+  _am_result=GNU
+  ;;
+esac
+# Now try BSD make style include.
+if test "$am__include" = "#"; then
+   echo '.include "confinc"' > confmf
+   case `$am_make -s -f confmf 2> /dev/null` in #(
+   *the\ am__doit\ target*)
+     am__include=.include
+     am__quote="\""
+     _am_result=BSD
+     ;;
+   esac
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $_am_result" >&5
+$as_echo "$_am_result" >&6; }
+rm -f confinc confmf
+
+# Check whether --enable-dependency-tracking was given.
+if test "${enable_dependency_tracking+set}" = set; then :
+  enableval=$enable_dependency_tracking;
+fi
+
+if test "x$enable_dependency_tracking" != xno; then
+  am_depcomp="$ac_aux_dir/depcomp"
+  AMDEPBACKSLASH='\'
+fi
+ if test "x$enable_dependency_tracking" != xno; then
+  AMDEP_TRUE=
+  AMDEP_FALSE='#'
+else
+  AMDEP_TRUE='#'
+  AMDEP_FALSE=
+fi
+
+
+
+depcc="$CC"   am_compiler_list=
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking dependency style of $depcc" >&5
+$as_echo_n "checking dependency style of $depcc... " >&6; }
+if test "${am_cv_CC_dependencies_compiler_type+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
+  # We make a subdir and do the tests there.  Otherwise we can end up
+  # making bogus files that we don't know about and never remove.  For
+  # instance it was reported that on HP-UX the gcc test will end up
+  # making a dummy file named `D' -- because `-MD' means `put the output
+  # in D'.
+  mkdir conftest.dir
+  # Copy depcomp to subdir because otherwise we won't find it if we're
+  # using a relative directory.
+  cp "$am_depcomp" conftest.dir
+  cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
+
+  am_cv_CC_dependencies_compiler_type=none
+  if test "$am_compiler_list" = ""; then
+     am_compiler_list=`sed -n 's/^#*\([a-zA-Z0-9]*\))$/\1/p' < ./depcomp`
+  fi
+  am__universal=false
+  case " $depcc " in #(
+     *\ -arch\ *\ -arch\ *) am__universal=true ;;
+     esac
+
+  for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
+    # We need to recreate these files for each test, as the compiler may
+    # overwrite some of them when testing with obscure command lines.
+    # This happens at least with the AIX C compiler.
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
+      # Solaris 8's {/usr,}/bin/sh.
+      touch sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+
+    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle `-M -o', and we need to detect this.  Also, some Intel
+    # versions had trouble with output in subdirs
+    am__obj=sub/conftest.${OBJEXT-o}
+    am__minus_obj="-o $am__obj"
+    case $depmode in
+    gcc)
+      # This depmode causes a compiler race in universal mode.
+      test "$am__universal" = false || continue
+      ;;
+    nosideeffect)
+      # after this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested
+      if test "x$enable_dependency_tracking" = xyes; then
+	continue
+      else
+	break
+      fi
+      ;;
+    msvisualcpp | msvcmsys)
+      # This compiler won't grok `-c -o', but also, the minuso test has
+      # not run yet.  These depmodes are late enough in the game, and
+      # so weak that their functioning should not be impacted.
+      am__obj=conftest.${OBJEXT-o}
+      am__minus_obj=
+      ;;
+    none) break ;;
+    esac
+    if depmode=$depmode \
+       source=sub/conftest.c object=$am__obj \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \
+         >/dev/null 2>conftest.err &&
+       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&
+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
+      # icc doesn't choke on unknown options, it will just issue warnings
+      # or remarks (even with -Werror).  So we grep stderr for any message
+      # that says an option was ignored or not supported.
+      # When given -MP, icc 7.0 and 7.1 complain thusly:
+      #   icc: Command line warning: ignoring option '-M'; no argument required
+      # The diagnosis changed in icc 8.0:
+      #   icc: Command line remark: option '-MP' not supported
+      if (grep 'ignoring option' conftest.err ||
+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
+        am_cv_CC_dependencies_compiler_type=$depmode
+        break
+      fi
+    fi
+  done
+
+  cd ..
+  rm -rf conftest.dir
+else
+  am_cv_CC_dependencies_compiler_type=none
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_CC_dependencies_compiler_type" >&5
+$as_echo "$am_cv_CC_dependencies_compiler_type" >&6; }
+CCDEPMODE=depmode=$am_cv_CC_dependencies_compiler_type
+
+ if
+  test "x$enable_dependency_tracking" != xno \
+  && test "$am_cv_CC_dependencies_compiler_type" = gcc3; then
+  am__fastdepCC_TRUE=
+  am__fastdepCC_FALSE='#'
+else
+  am__fastdepCC_TRUE='#'
+  am__fastdepCC_FALSE=
+fi
+
+
+
+# Check whether --enable-largefile was given.
+if test "${enable_largefile+set}" = set; then :
+  enableval=$enable_largefile;
+fi
+
+if test "$enable_largefile" != no; then
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for special C compiler options needed for large files" >&5
+$as_echo_n "checking for special C compiler options needed for large files... " >&6; }
+if test "${ac_cv_sys_largefile_CC+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_sys_largefile_CC=no
+     if test "$GCC" != yes; then
+       ac_save_CC=$CC
+       while :; do
+	 # IRIX 6.2 and later do not support large files by default,
+	 # so use the C compiler's -n32 option if that helps.
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+ /* Check that off_t can represent 2**63 - 1 correctly.
+    We can't simply define LARGE_OFF_T to be 9223372036854775807,
+    since some C++ compilers masquerading as C compilers
+    incorrectly reject 9223372036854775807.  */
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
+		       && LARGE_OFF_T % 2147483647 == 1)
+		      ? 1 : -1];
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+	 if ac_fn_c_try_compile "$LINENO"; then :
+  break
+fi
+rm -f core conftest.err conftest.$ac_objext
+	 CC="$CC -n32"
+	 if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_sys_largefile_CC=' -n32'; break
+fi
+rm -f core conftest.err conftest.$ac_objext
+	 break
+       done
+       CC=$ac_save_CC
+       rm -f conftest.$ac_ext
+    fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_largefile_CC" >&5
+$as_echo "$ac_cv_sys_largefile_CC" >&6; }
+  if test "$ac_cv_sys_largefile_CC" != no; then
+    CC=$CC$ac_cv_sys_largefile_CC
+  fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for _FILE_OFFSET_BITS value needed for large files" >&5
+$as_echo_n "checking for _FILE_OFFSET_BITS value needed for large files... " >&6; }
+if test "${ac_cv_sys_file_offset_bits+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  while :; do
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+ /* Check that off_t can represent 2**63 - 1 correctly.
+    We can't simply define LARGE_OFF_T to be 9223372036854775807,
+    since some C++ compilers masquerading as C compilers
+    incorrectly reject 9223372036854775807.  */
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
+		       && LARGE_OFF_T % 2147483647 == 1)
+		      ? 1 : -1];
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_sys_file_offset_bits=no; break
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#define _FILE_OFFSET_BITS 64
+#include <sys/types.h>
+ /* Check that off_t can represent 2**63 - 1 correctly.
+    We can't simply define LARGE_OFF_T to be 9223372036854775807,
+    since some C++ compilers masquerading as C compilers
+    incorrectly reject 9223372036854775807.  */
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
+		       && LARGE_OFF_T % 2147483647 == 1)
+		      ? 1 : -1];
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_sys_file_offset_bits=64; break
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  ac_cv_sys_file_offset_bits=unknown
+  break
+done
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_file_offset_bits" >&5
+$as_echo "$ac_cv_sys_file_offset_bits" >&6; }
+case $ac_cv_sys_file_offset_bits in #(
+  no | unknown) ;;
+  *)
+cat >>confdefs.h <<_ACEOF
+#define _FILE_OFFSET_BITS $ac_cv_sys_file_offset_bits
+_ACEOF
+;;
+esac
+rm -rf conftest*
+  if test $ac_cv_sys_file_offset_bits = unknown; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for _LARGE_FILES value needed for large files" >&5
+$as_echo_n "checking for _LARGE_FILES value needed for large files... " >&6; }
+if test "${ac_cv_sys_large_files+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  while :; do
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+ /* Check that off_t can represent 2**63 - 1 correctly.
+    We can't simply define LARGE_OFF_T to be 9223372036854775807,
+    since some C++ compilers masquerading as C compilers
+    incorrectly reject 9223372036854775807.  */
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
+		       && LARGE_OFF_T % 2147483647 == 1)
+		      ? 1 : -1];
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_sys_large_files=no; break
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#define _LARGE_FILES 1
+#include <sys/types.h>
+ /* Check that off_t can represent 2**63 - 1 correctly.
+    We can't simply define LARGE_OFF_T to be 9223372036854775807,
+    since some C++ compilers masquerading as C compilers
+    incorrectly reject 9223372036854775807.  */
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
+  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
+		       && LARGE_OFF_T % 2147483647 == 1)
+		      ? 1 : -1];
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_sys_large_files=1; break
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  ac_cv_sys_large_files=unknown
+  break
+done
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_large_files" >&5
+$as_echo "$ac_cv_sys_large_files" >&6; }
+case $ac_cv_sys_large_files in #(
+  no | unknown) ;;
+  *)
+cat >>confdefs.h <<_ACEOF
+#define _LARGE_FILES $ac_cv_sys_large_files
+_ACEOF
+;;
+esac
+rm -rf conftest*
+  fi
+fi
+
+case `pwd` in
+  *\ * | *\	*)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&5
+$as_echo "$as_me: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&2;} ;;
+esac
+
+
+
+macro_version='2.2.7a'
+macro_revision='1.3134'
+
+
+
+
+
+
+
+
+
+
+
+
+
+ltmain="$ac_aux_dir/ltmain.sh"
+
+# Backslashify metacharacters that are still active within
+# double-quoted strings.
+sed_quote_subst='s/\(["`$\\]\)/\\\1/g'
+
+# Same as above, but do not quote variable references.
+double_quote_subst='s/\(["`\\]\)/\\\1/g'
+
+# Sed substitution to delay expansion of an escaped shell variable in a
+# double_quote_subst'ed string.
+delay_variable_subst='s/\\\\\\\\\\\$/\\\\\\$/g'
+
+# Sed substitution to delay expansion of an escaped single quote.
+delay_single_quote_subst='s/'\''/'\'\\\\\\\'\''/g'
+
+# Sed substitution to avoid accidental globbing in evaled expressions
+no_glob_subst='s/\*/\\\*/g'
+
+ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO
+ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to print strings" >&5
+$as_echo_n "checking how to print strings... " >&6; }
+# Test print first, because it will be a builtin if present.
+if test "X`print -r -- -n 2>/dev/null`" = X-n && \
+   test "X`print -r -- $ECHO 2>/dev/null`" = "X$ECHO"; then
+  ECHO='print -r --'
+elif test "X`printf %s $ECHO 2>/dev/null`" = "X$ECHO"; then
+  ECHO='printf %s\n'
+else
+  # Use this function as a fallback that always works.
+  func_fallback_echo ()
+  {
+    eval 'cat <<_LTECHO_EOF
+$1
+_LTECHO_EOF'
+  }
+  ECHO='func_fallback_echo'
+fi
+
+# func_echo_all arg...
+# Invoke $ECHO with all args, space-separated.
+func_echo_all ()
+{
+    $ECHO ""
+}
+
+case "$ECHO" in
+  printf*) { $as_echo "$as_me:${as_lineno-$LINENO}: result: printf" >&5
+$as_echo "printf" >&6; } ;;
+  print*) { $as_echo "$as_me:${as_lineno-$LINENO}: result: print -r" >&5
+$as_echo "print -r" >&6; } ;;
+  *) { $as_echo "$as_me:${as_lineno-$LINENO}: result: cat" >&5
+$as_echo "cat" >&6; } ;;
+esac
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a sed that does not truncate output" >&5
+$as_echo_n "checking for a sed that does not truncate output... " >&6; }
+if test "${ac_cv_path_SED+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+            ac_script=s/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/
+     for ac_i in 1 2 3 4 5 6 7; do
+       ac_script="$ac_script$as_nl$ac_script"
+     done
+     echo "$ac_script" 2>/dev/null | sed 99q >conftest.sed
+     { ac_script=; unset ac_script;}
+     if test -z "$SED"; then
+  ac_path_SED_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in sed gsed; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_SED="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_SED" && $as_test_x "$ac_path_SED"; } || continue
+# Check for GNU ac_path_SED and select it if it is found.
+  # Check for GNU $ac_path_SED
+case `"$ac_path_SED" --version 2>&1` in
+*GNU*)
+  ac_cv_path_SED="$ac_path_SED" ac_path_SED_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo '' >> "conftest.nl"
+    "$ac_path_SED" -f conftest.sed < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_SED_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_SED="$ac_path_SED"
+      ac_path_SED_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_SED_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_SED"; then
+    as_fn_error "no acceptable sed could be found in \$PATH" "$LINENO" 5
+  fi
+else
+  ac_cv_path_SED=$SED
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_SED" >&5
+$as_echo "$ac_cv_path_SED" >&6; }
+ SED="$ac_cv_path_SED"
+  rm -f conftest.sed
+
+test -z "$SED" && SED=sed
+Xsed="$SED -e 1s/^X//"
+
+
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
+$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
+if test "${ac_cv_path_GREP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$GREP"; then
+  ac_path_GREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in grep ggrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
+# Check for GNU ac_path_GREP and select it if it is found.
+  # Check for GNU $ac_path_GREP
+case `"$ac_path_GREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'GREP' >> "conftest.nl"
+    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_GREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_GREP="$ac_path_GREP"
+      ac_path_GREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_GREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_GREP"; then
+    as_fn_error "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
+else
+  ac_cv_path_GREP=$GREP
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP" >&5
+$as_echo "$ac_cv_path_GREP" >&6; }
+ GREP="$ac_cv_path_GREP"
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
+$as_echo_n "checking for egrep... " >&6; }
+if test "${ac_cv_path_EGREP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
+   then ac_cv_path_EGREP="$GREP -E"
+   else
+     if test -z "$EGREP"; then
+  ac_path_EGREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in egrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
+# Check for GNU ac_path_EGREP and select it if it is found.
+  # Check for GNU $ac_path_EGREP
+case `"$ac_path_EGREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'EGREP' >> "conftest.nl"
+    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_EGREP="$ac_path_EGREP"
+      ac_path_EGREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_EGREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_EGREP"; then
+    as_fn_error "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
+else
+  ac_cv_path_EGREP=$EGREP
+fi
+
+   fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP" >&5
+$as_echo "$ac_cv_path_EGREP" >&6; }
+ EGREP="$ac_cv_path_EGREP"
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for fgrep" >&5
+$as_echo_n "checking for fgrep... " >&6; }
+if test "${ac_cv_path_FGREP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if echo 'ab*c' | $GREP -F 'ab*c' >/dev/null 2>&1
+   then ac_cv_path_FGREP="$GREP -F"
+   else
+     if test -z "$FGREP"; then
+  ac_path_FGREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in fgrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_FGREP="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_FGREP" && $as_test_x "$ac_path_FGREP"; } || continue
+# Check for GNU ac_path_FGREP and select it if it is found.
+  # Check for GNU $ac_path_FGREP
+case `"$ac_path_FGREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_FGREP="$ac_path_FGREP" ac_path_FGREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'FGREP' >> "conftest.nl"
+    "$ac_path_FGREP" FGREP < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_FGREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_FGREP="$ac_path_FGREP"
+      ac_path_FGREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_FGREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_FGREP"; then
+    as_fn_error "no acceptable fgrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
+else
+  ac_cv_path_FGREP=$FGREP
+fi
+
+   fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_FGREP" >&5
+$as_echo "$ac_cv_path_FGREP" >&6; }
+ FGREP="$ac_cv_path_FGREP"
+
+
+test -z "$GREP" && GREP=grep
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# Check whether --with-gnu-ld was given.
+if test "${with_gnu_ld+set}" = set; then :
+  withval=$with_gnu_ld; test "$withval" = no || with_gnu_ld=yes
+else
+  with_gnu_ld=no
+fi
+
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
+$as_echo_n "checking for ld used by $CC... " >&6; }
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [\\/]* | ?:[\\/]*)
+      re_direlt='/[^/][^/]*/\.\./'
+      # Canonicalize the pathname of ld
+      ac_prog=`$ECHO "$ac_prog"| $SED 's%\\\\%/%g'`
+      while $ECHO "$ac_prog" | $GREP "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`$ECHO $ac_prog| $SED "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNU ld" >&5
+$as_echo_n "checking for GNU ld... " >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for non-GNU ld" >&5
+$as_echo_n "checking for non-GNU ld... " >&6; }
+fi
+if test "${lt_cv_path_LD+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$LD"; then
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  for ac_dir in $PATH; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      lt_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some variants of GNU ld only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      case `"$lt_cv_path_LD" -v 2>&1 </dev/null` in
+      *GNU* | *'with BFD'*)
+	test "$with_gnu_ld" != no && break
+	;;
+      *)
+	test "$with_gnu_ld" != yes && break
+	;;
+      esac
+    fi
+  done
+  IFS="$lt_save_ifs"
+else
+  lt_cv_path_LD="$LD" # Let the user override the test with a path.
+fi
+fi
+
+LD="$lt_cv_path_LD"
+if test -n "$LD"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LD" >&5
+$as_echo "$LD" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+test -z "$LD" && as_fn_error "no acceptable ld found in \$PATH" "$LINENO" 5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if the linker ($LD) is GNU ld" >&5
+$as_echo_n "checking if the linker ($LD) is GNU ld... " >&6; }
+if test "${lt_cv_prog_gnu_ld+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  # I'd rather use --version here, but apparently some GNU lds only accept -v.
+case `$LD -v 2>&1 </dev/null` in
+*GNU* | *'with BFD'*)
+  lt_cv_prog_gnu_ld=yes
+  ;;
+*)
+  lt_cv_prog_gnu_ld=no
+  ;;
+esac
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_gnu_ld" >&5
+$as_echo "$lt_cv_prog_gnu_ld" >&6; }
+with_gnu_ld=$lt_cv_prog_gnu_ld
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for BSD- or MS-compatible name lister (nm)" >&5
+$as_echo_n "checking for BSD- or MS-compatible name lister (nm)... " >&6; }
+if test "${lt_cv_path_NM+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$NM"; then
+  # Let the user override the test.
+  lt_cv_path_NM="$NM"
+else
+  lt_nm_to_check="${ac_tool_prefix}nm"
+  if test -n "$ac_tool_prefix" && test "$build" = "$host"; then
+    lt_nm_to_check="$lt_nm_to_check nm"
+  fi
+  for lt_tmp_nm in $lt_nm_to_check; do
+    lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do
+      IFS="$lt_save_ifs"
+      test -z "$ac_dir" && ac_dir=.
+      tmp_nm="$ac_dir/$lt_tmp_nm"
+      if test -f "$tmp_nm" || test -f "$tmp_nm$ac_exeext" ; then
+	# Check to see if the nm accepts a BSD-compat flag.
+	# Adding the `sed 1q' prevents false positives on HP-UX, which says:
+	#   nm: unknown option "B" ignored
+	# Tru64's nm complains that /dev/null is an invalid object file
+	case `"$tmp_nm" -B /dev/null 2>&1 | sed '1q'` in
+	*/dev/null* | *'Invalid file or object type'*)
+	  lt_cv_path_NM="$tmp_nm -B"
+	  break
+	  ;;
+	*)
+	  case `"$tmp_nm" -p /dev/null 2>&1 | sed '1q'` in
+	  */dev/null*)
+	    lt_cv_path_NM="$tmp_nm -p"
+	    break
+	    ;;
+	  *)
+	    lt_cv_path_NM=${lt_cv_path_NM="$tmp_nm"} # keep the first match, but
+	    continue # so that we can try to find one that supports BSD flags
+	    ;;
+	  esac
+	  ;;
+	esac
+      fi
+    done
+    IFS="$lt_save_ifs"
+  done
+  : ${lt_cv_path_NM=no}
+fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_path_NM" >&5
+$as_echo "$lt_cv_path_NM" >&6; }
+if test "$lt_cv_path_NM" != "no"; then
+  NM="$lt_cv_path_NM"
+else
+  # Didn't find any BSD compatible name lister, look for dumpbin.
+  if test -n "$DUMPBIN"; then :
+    # Let the user override the test.
+  else
+    if test -n "$ac_tool_prefix"; then
+  for ac_prog in dumpbin "link -dump"
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_DUMPBIN+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$DUMPBIN"; then
+  ac_cv_prog_DUMPBIN="$DUMPBIN" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_DUMPBIN="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+DUMPBIN=$ac_cv_prog_DUMPBIN
+if test -n "$DUMPBIN"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DUMPBIN" >&5
+$as_echo "$DUMPBIN" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$DUMPBIN" && break
+  done
+fi
+if test -z "$DUMPBIN"; then
+  ac_ct_DUMPBIN=$DUMPBIN
+  for ac_prog in dumpbin "link -dump"
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_DUMPBIN+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_DUMPBIN"; then
+  ac_cv_prog_ac_ct_DUMPBIN="$ac_ct_DUMPBIN" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_DUMPBIN="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_DUMPBIN=$ac_cv_prog_ac_ct_DUMPBIN
+if test -n "$ac_ct_DUMPBIN"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DUMPBIN" >&5
+$as_echo "$ac_ct_DUMPBIN" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_DUMPBIN" && break
+done
+
+  if test "x$ac_ct_DUMPBIN" = x; then
+    DUMPBIN=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    DUMPBIN=$ac_ct_DUMPBIN
+  fi
+fi
+
+    case `$DUMPBIN -symbols /dev/null 2>&1 | sed '1q'` in
+    *COFF*)
+      DUMPBIN="$DUMPBIN -symbols"
+      ;;
+    *)
+      DUMPBIN=:
+      ;;
+    esac
+  fi
+
+  if test "$DUMPBIN" != ":"; then
+    NM="$DUMPBIN"
+  fi
+fi
+test -z "$NM" && NM=nm
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the name lister ($NM) interface" >&5
+$as_echo_n "checking the name lister ($NM) interface... " >&6; }
+if test "${lt_cv_nm_interface+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_nm_interface="BSD nm"
+  echo "int some_variable = 0;" > conftest.$ac_ext
+  (eval echo "\"\$as_me:$LINENO: $ac_compile\"" >&5)
+  (eval "$ac_compile" 2>conftest.err)
+  cat conftest.err >&5
+  (eval echo "\"\$as_me:$LINENO: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
+  (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
+  cat conftest.err >&5
+  (eval echo "\"\$as_me:$LINENO: output\"" >&5)
+  cat conftest.out >&5
+  if $GREP 'External.*some_variable' conftest.out > /dev/null; then
+    lt_cv_nm_interface="MS dumpbin"
+  fi
+  rm -f conftest*
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_nm_interface" >&5
+$as_echo "$lt_cv_nm_interface" >&6; }
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ln -s works" >&5
+$as_echo_n "checking whether ln -s works... " >&6; }
+LN_S=$as_ln_s
+if test "$LN_S" = "ln -s"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no, using $LN_S" >&5
+$as_echo "no, using $LN_S" >&6; }
+fi
+
+# find the maximum length of command line arguments
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the maximum length of command line arguments" >&5
+$as_echo_n "checking the maximum length of command line arguments... " >&6; }
+if test "${lt_cv_sys_max_cmd_len+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+    i=0
+  teststring="ABCD"
+
+  case $build_os in
+  msdosdjgpp*)
+    # On DJGPP, this test can blow up pretty badly due to problems in libc
+    # (any single argument exceeding 2000 bytes causes a buffer overrun
+    # during glob expansion).  Even if it were fixed, the result of this
+    # check would be larger than it should be.
+    lt_cv_sys_max_cmd_len=12288;    # 12K is about right
+    ;;
+
+  gnu*)
+    # Under GNU Hurd, this test is not required because there is
+    # no limit to the length of command line arguments.
+    # Libtool will interpret -1 as no limit whatsoever
+    lt_cv_sys_max_cmd_len=-1;
+    ;;
+
+  cygwin* | mingw* | cegcc*)
+    # On Win9x/ME, this test blows up -- it succeeds, but takes
+    # about 5 minutes as the teststring grows exponentially.
+    # Worse, since 9x/ME are not pre-emptively multitasking,
+    # you end up with a "frozen" computer, even though with patience
+    # the test eventually succeeds (with a max line length of 256k).
+    # Instead, let's just punt: use the minimum linelength reported by
+    # all of the supported platforms: 8192 (on NT/2K/XP).
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  mint*)
+    # On MiNT this can take a long time and run out of memory.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  amigaos*)
+    # On AmigaOS with pdksh, this test takes hours, literally.
+    # So we just punt and use a minimum line length of 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
+    # This has been around since 386BSD, at least.  Likely further.
+    if test -x /sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`
+    elif test -x /usr/sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`
+    else
+      lt_cv_sys_max_cmd_len=65536	# usable default for all BSDs
+    fi
+    # And add a safety zone
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
+    ;;
+
+  interix*)
+    # We know the value 262144 and hardcode it with a safety zone (like BSD)
+    lt_cv_sys_max_cmd_len=196608
+    ;;
+
+  osf*)
+    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure
+    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not
+    # nice to cause kernel panics so lets avoid the loop below.
+    # First set a reasonable default.
+    lt_cv_sys_max_cmd_len=16384
+    #
+    if test -x /sbin/sysconfig; then
+      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in
+        *1*) lt_cv_sys_max_cmd_len=-1 ;;
+      esac
+    fi
+    ;;
+  sco3.2v5*)
+    lt_cv_sys_max_cmd_len=102400
+    ;;
+  sysv5* | sco5v6* | sysv4.2uw2*)
+    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`
+    if test -n "$kargmax"; then
+      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[	 ]//'`
+    else
+      lt_cv_sys_max_cmd_len=32768
+    fi
+    ;;
+  *)
+    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`
+    if test -n "$lt_cv_sys_max_cmd_len"; then
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
+    else
+      # Make teststring a little bigger before we do anything with it.
+      # a 1K string should be a reasonable start.
+      for i in 1 2 3 4 5 6 7 8 ; do
+        teststring=$teststring$teststring
+      done
+      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}
+      # If test is not a shell built-in, we'll probably end up computing a
+      # maximum length that is only half of the actual maximum length, but
+      # we can't tell.
+      while { test "X"`func_fallback_echo "$teststring$teststring" 2>/dev/null` \
+	         = "X$teststring$teststring"; } >/dev/null 2>&1 &&
+	      test $i != 17 # 1/2 MB should be enough
+      do
+        i=`expr $i + 1`
+        teststring=$teststring$teststring
+      done
+      # Only check the string length outside the loop.
+      lt_cv_sys_max_cmd_len=`expr "X$teststring" : ".*" 2>&1`
+      teststring=
+      # Add a significant safety factor because C++ compilers can tack on
+      # massive amounts of additional arguments before passing them to the
+      # linker.  It appears as though 1/2 is a usable value.
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 2`
+    fi
+    ;;
+  esac
+
+fi
+
+if test -n $lt_cv_sys_max_cmd_len ; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_sys_max_cmd_len" >&5
+$as_echo "$lt_cv_sys_max_cmd_len" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: none" >&5
+$as_echo "none" >&6; }
+fi
+max_cmd_len=$lt_cv_sys_max_cmd_len
+
+
+
+
+
+
+: ${CP="cp -f"}
+: ${MV="mv -f"}
+: ${RM="rm -f"}
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands some XSI constructs" >&5
+$as_echo_n "checking whether the shell understands some XSI constructs... " >&6; }
+# Try some XSI features
+xsi_shell=no
+( _lt_dummy="a/b/c"
+  test "${_lt_dummy##*/},${_lt_dummy%/*},"${_lt_dummy%"$_lt_dummy"}, \
+      = c,a/b,, \
+    && eval 'test $(( 1 + 1 )) -eq 2 \
+    && test "${#_lt_dummy}" -eq 5' ) >/dev/null 2>&1 \
+  && xsi_shell=yes
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $xsi_shell" >&5
+$as_echo "$xsi_shell" >&6; }
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands \"+=\"" >&5
+$as_echo_n "checking whether the shell understands \"+=\"... " >&6; }
+lt_shell_append=no
+( foo=bar; set foo baz; eval "$1+=\$2" && test "$foo" = barbaz ) \
+    >/dev/null 2>&1 \
+  && lt_shell_append=yes
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_shell_append" >&5
+$as_echo "$lt_shell_append" >&6; }
+
+
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  lt_unset=unset
+else
+  lt_unset=false
+fi
+
+
+
+
+
+# test EBCDIC or ASCII
+case `echo X|tr X '\101'` in
+ A) # ASCII based system
+    # \n is not interpreted correctly by Solaris 8 /usr/ucb/tr
+  lt_SP2NL='tr \040 \012'
+  lt_NL2SP='tr \015\012 \040\040'
+  ;;
+ *) # EBCDIC based system
+  lt_SP2NL='tr \100 \n'
+  lt_NL2SP='tr \r\n \100\100'
+  ;;
+esac
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $LD option to reload object files" >&5
+$as_echo_n "checking for $LD option to reload object files... " >&6; }
+if test "${lt_cv_ld_reload_flag+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_ld_reload_flag='-r'
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_reload_flag" >&5
+$as_echo "$lt_cv_ld_reload_flag" >&6; }
+reload_flag=$lt_cv_ld_reload_flag
+case $reload_flag in
+"" | " "*) ;;
+*) reload_flag=" $reload_flag" ;;
+esac
+reload_cmds='$LD$reload_flag -o $output$reload_objs'
+case $host_os in
+  darwin*)
+    if test "$GCC" = yes; then
+      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'
+    else
+      reload_cmds='$LD$reload_flag -o $output$reload_objs'
+    fi
+    ;;
+esac
+
+
+
+
+
+
+
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}objdump", so it can be a program name with args.
+set dummy ${ac_tool_prefix}objdump; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_OBJDUMP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$OBJDUMP"; then
+  ac_cv_prog_OBJDUMP="$OBJDUMP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_OBJDUMP="${ac_tool_prefix}objdump"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+OBJDUMP=$ac_cv_prog_OBJDUMP
+if test -n "$OBJDUMP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OBJDUMP" >&5
+$as_echo "$OBJDUMP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_OBJDUMP"; then
+  ac_ct_OBJDUMP=$OBJDUMP
+  # Extract the first word of "objdump", so it can be a program name with args.
+set dummy objdump; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_OBJDUMP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_OBJDUMP"; then
+  ac_cv_prog_ac_ct_OBJDUMP="$ac_ct_OBJDUMP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_OBJDUMP="objdump"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_OBJDUMP=$ac_cv_prog_ac_ct_OBJDUMP
+if test -n "$ac_ct_OBJDUMP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OBJDUMP" >&5
+$as_echo "$ac_ct_OBJDUMP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_OBJDUMP" = x; then
+    OBJDUMP="false"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    OBJDUMP=$ac_ct_OBJDUMP
+  fi
+else
+  OBJDUMP="$ac_cv_prog_OBJDUMP"
+fi
+
+test -z "$OBJDUMP" && OBJDUMP=objdump
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to recognize dependent libraries" >&5
+$as_echo_n "checking how to recognize dependent libraries... " >&6; }
+if test "${lt_cv_deplibs_check_method+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_file_magic_cmd='$MAGIC_CMD'
+lt_cv_file_magic_test_file=
+lt_cv_deplibs_check_method='unknown'
+# Need to set the preceding variable on all platforms that support
+# interlibrary dependencies.
+# 'none' -- dependencies not supported.
+# `unknown' -- same as none, but documents that we really don't know.
+# 'pass_all' -- all dependencies passed with no checks.
+# 'test_compile' -- check by making test program.
+# 'file_magic [[regex]]' -- check by looking for files in library path
+# which responds to the $file_magic_cmd with a given extended regex.
+# If you have `file' or equivalent on your system and you're not sure
+# whether `pass_all' will *always* work, you probably want this one.
+
+case $host_os in
+aix[4-9]*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+beos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+bsdi[45]*)
+  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib)'
+  lt_cv_file_magic_cmd='/usr/bin/file -L'
+  lt_cv_file_magic_test_file=/shlib/libc.so
+  ;;
+
+cygwin*)
+  # func_win32_libid is a shell function defined in ltmain.sh
+  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
+  lt_cv_file_magic_cmd='func_win32_libid'
+  ;;
+
+mingw* | pw32*)
+  # Base MSYS/MinGW do not provide the 'file' command needed by
+  # func_win32_libid shell function, so use a weaker test based on 'objdump',
+  # unless we find 'file', for example because we are cross-compiling.
+  # func_win32_libid assumes BSD nm, so disallow it if using MS dumpbin.
+  if ( test "$lt_cv_nm_interface" = "BSD nm" && file / ) >/dev/null 2>&1; then
+    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
+    lt_cv_file_magic_cmd='func_win32_libid'
+  else
+    # Keep this pattern in sync with the one in func_win32_libid.
+    lt_cv_deplibs_check_method='file_magic file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)'
+    lt_cv_file_magic_cmd='$OBJDUMP -f'
+  fi
+  ;;
+
+cegcc*)
+  # use the weaker test based on 'objdump'. See mingw*.
+  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'
+  lt_cv_file_magic_cmd='$OBJDUMP -f'
+  ;;
+
+darwin* | rhapsody*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+freebsd* | dragonfly*)
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+    case $host_cpu in
+    i*86 )
+      # Not sure whether the presence of OpenBSD here was a mistake.
+      # Let's accept both of them until this is cleared up.
+      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[3-9]86 (compact )?demand paged shared library'
+      lt_cv_file_magic_cmd=/usr/bin/file
+      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`
+      ;;
+    esac
+  else
+    lt_cv_deplibs_check_method=pass_all
+  fi
+  ;;
+
+gnu*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+haiku*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+hpux10.20* | hpux11*)
+  lt_cv_file_magic_cmd=/usr/bin/file
+  case $host_cpu in
+  ia64*)
+    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF-[0-9][0-9]) shared object file - IA64'
+    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so
+    ;;
+  hppa*64*)
+    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF[ -][0-9][0-9])(-bit)?( [LM]SB)? shared object( file)?[, -]* PA-RISC [0-9]\.[0-9]'
+    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl
+    ;;
+  *)
+    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|PA-RISC[0-9]\.[0-9]) shared library'
+    lt_cv_file_magic_test_file=/usr/lib/libc.sl
+    ;;
+  esac
+  ;;
+
+interix[3-9]*)
+  # PIC code is broken on Interix 3.x, that's why |\.a not |_pic\.a here
+  lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so|\.a)$'
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $LD in
+  *-32|*"-32 ") libmagic=32-bit;;
+  *-n32|*"-n32 ") libmagic=N32;;
+  *-64|*"-64 ") libmagic=64-bit;;
+  *) libmagic=never-match;;
+  esac
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+# This must be Linux ELF.
+linux* | k*bsd*-gnu | kopensolaris*-gnu)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+netbsd*)
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
+  else
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so|_pic\.a)$'
+  fi
+  ;;
+
+newos6*)
+  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (executable|dynamic lib)'
+  lt_cv_file_magic_cmd=/usr/bin/file
+  lt_cv_file_magic_test_file=/usr/lib/libnls.so
+  ;;
+
+*nto* | *qnx*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+openbsd*)
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|\.so|_pic\.a)$'
+  else
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
+  fi
+  ;;
+
+osf3* | osf4* | osf5*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+rdos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+solaris*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sysv4 | sysv4.3*)
+  case $host_vendor in
+  motorola)
+    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib) M[0-9][0-9]* Version [0-9]'
+    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`
+    ;;
+  ncr)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  sequent)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )'
+    ;;
+  sni)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method="file_magic ELF [0-9][0-9]*-bit [LM]SB dynamic lib"
+    lt_cv_file_magic_test_file=/lib/libc.so
+    ;;
+  siemens)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  pc)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  esac
+  ;;
+
+tpf*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+esac
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_deplibs_check_method" >&5
+$as_echo "$lt_cv_deplibs_check_method" >&6; }
+file_magic_cmd=$lt_cv_file_magic_cmd
+deplibs_check_method=$lt_cv_deplibs_check_method
+test -z "$deplibs_check_method" && deplibs_check_method=unknown
+
+
+
+
+
+
+
+
+
+
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ar", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ar; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_AR+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$AR"; then
+  ac_cv_prog_AR="$AR" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_AR="${ac_tool_prefix}ar"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+AR=$ac_cv_prog_AR
+if test -n "$AR"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AR" >&5
+$as_echo "$AR" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_AR"; then
+  ac_ct_AR=$AR
+  # Extract the first word of "ar", so it can be a program name with args.
+set dummy ar; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_AR+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_AR"; then
+  ac_cv_prog_ac_ct_AR="$ac_ct_AR" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_AR="ar"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_AR=$ac_cv_prog_ac_ct_AR
+if test -n "$ac_ct_AR"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_AR" >&5
+$as_echo "$ac_ct_AR" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_AR" = x; then
+    AR="false"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    AR=$ac_ct_AR
+  fi
+else
+  AR="$ac_cv_prog_AR"
+fi
+
+test -z "$AR" && AR=ar
+test -z "$AR_FLAGS" && AR_FLAGS=cru
+
+
+
+
+
+
+
+
+
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
+set dummy ${ac_tool_prefix}strip; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_STRIP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$STRIP"; then
+  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+STRIP=$ac_cv_prog_STRIP
+if test -n "$STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
+$as_echo "$STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_STRIP"; then
+  ac_ct_STRIP=$STRIP
+  # Extract the first word of "strip", so it can be a program name with args.
+set dummy strip; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_STRIP"; then
+  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_STRIP="strip"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
+if test -n "$ac_ct_STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
+$as_echo "$ac_ct_STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_STRIP" = x; then
+    STRIP=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    STRIP=$ac_ct_STRIP
+  fi
+else
+  STRIP="$ac_cv_prog_STRIP"
+fi
+
+test -z "$STRIP" && STRIP=:
+
+
+
+
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ranlib; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_RANLIB+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+RANLIB=$ac_cv_prog_RANLIB
+if test -n "$RANLIB"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RANLIB" >&5
+$as_echo "$RANLIB" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_RANLIB"; then
+  ac_ct_RANLIB=$RANLIB
+  # Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_RANLIB"; then
+  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_RANLIB="ranlib"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
+if test -n "$ac_ct_RANLIB"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_RANLIB" >&5
+$as_echo "$ac_ct_RANLIB" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_RANLIB" = x; then
+    RANLIB=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    RANLIB=$ac_ct_RANLIB
+  fi
+else
+  RANLIB="$ac_cv_prog_RANLIB"
+fi
+
+test -z "$RANLIB" && RANLIB=:
+
+
+
+
+
+
+# Determine commands to create old-style static archives.
+old_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'
+old_postinstall_cmds='chmod 644 $oldlib'
+old_postuninstall_cmds=
+
+if test -n "$RANLIB"; then
+  case $host_os in
+  openbsd*)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB -t \$oldlib"
+    ;;
+  *)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB \$oldlib"
+    ;;
+  esac
+  old_archive_cmds="$old_archive_cmds~\$RANLIB \$oldlib"
+fi
+
+case $host_os in
+  darwin*)
+    lock_old_archive_extraction=yes ;;
+  *)
+    lock_old_archive_extraction=no ;;
+esac
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
+
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
+
+# Allow CC to be a program name with arguments.
+compiler=$CC
+
+
+# Check for command to grab the raw symbol name followed by C symbol from nm.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking command to parse $NM output from $compiler object" >&5
+$as_echo_n "checking command to parse $NM output from $compiler object... " >&6; }
+if test "${lt_cv_sys_global_symbol_pipe+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+
+# These are sane defaults that work on at least a few old systems.
+# [They come from Ultrix.  What could be older than Ultrix?!! ;)]
+
+# Character class describing NM global symbol codes.
+symcode='[BCDEGRST]'
+
+# Regexp to match symbols that can be accessed directly from C.
+sympat='\([_A-Za-z][_A-Za-z0-9]*\)'
+
+# Define system-specific variables.
+case $host_os in
+aix*)
+  symcode='[BCDT]'
+  ;;
+cygwin* | mingw* | pw32* | cegcc*)
+  symcode='[ABCDGISTW]'
+  ;;
+hpux*)
+  if test "$host_cpu" = ia64; then
+    symcode='[ABCDEGRST]'
+  fi
+  ;;
+irix* | nonstopux*)
+  symcode='[BCDEGRST]'
+  ;;
+osf*)
+  symcode='[BCDEGQRST]'
+  ;;
+solaris*)
+  symcode='[BDRT]'
+  ;;
+sco3.2v5*)
+  symcode='[DT]'
+  ;;
+sysv4.2uw2*)
+  symcode='[DT]'
+  ;;
+sysv5* | sco5v6* | unixware* | OpenUNIX*)
+  symcode='[ABDT]'
+  ;;
+sysv4)
+  symcode='[DFNSTU]'
+  ;;
+esac
+
+# If we're using GNU nm, then use its standard symbol codes.
+case `$NM -V 2>&1` in
+*GNU* | *'with BFD'*)
+  symcode='[ABCDGIRSTW]' ;;
+esac
+
+# Transform an extracted symbol line into a proper C declaration.
+# Some systems (esp. on ia64) link data and code symbols differently,
+# so use this general approach.
+lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern int \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
+
+# Transform an extracted symbol line into symbol name and symbol address
+lt_cv_sys_global_symbol_to_c_name_address="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"\2\", (void *) \&\2},/p'"
+lt_cv_sys_global_symbol_to_c_name_address_lib_prefix="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \(lib[^ ]*\)$/  {\"\2\", (void *) \&\2},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"lib\2\", (void *) \&\2},/p'"
+
+# Handle CRLF in mingw tool chain
+opt_cr=
+case $build_os in
+mingw*)
+  opt_cr=`$ECHO 'x\{0,1\}' | tr x '\015'` # option cr in regexp
+  ;;
+esac
+
+# Try without a prefix underscore, then with it.
+for ac_symprfx in "" "_"; do
+
+  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.
+  symxfrm="\\1 $ac_symprfx\\2 \\2"
+
+  # Write the raw and C identifiers.
+  if test "$lt_cv_nm_interface" = "MS dumpbin"; then
+    # Fake it for dumpbin and say T for any non-static function
+    # and D for any global variable.
+    # Also find C++ and __fastcall symbols from MSVC++,
+    # which start with @ or ?.
+    lt_cv_sys_global_symbol_pipe="$AWK '"\
+"     {last_section=section; section=\$ 3};"\
+"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};"\
+"     \$ 0!~/External *\|/{next};"\
+"     / 0+ UNDEF /{next}; / UNDEF \([^|]\)*()/{next};"\
+"     {if(hide[section]) next};"\
+"     {f=0}; \$ 0~/\(\).*\|/{f=1}; {printf f ? \"T \" : \"D \"};"\
+"     {split(\$ 0, a, /\||\r/); split(a[2], s)};"\
+"     s[1]~/^[@?]/{print s[1], s[1]; next};"\
+"     s[1]~prfx {split(s[1],t,\"@\"); print t[1], substr(t[1],length(prfx))}"\
+"     ' prfx=^$ac_symprfx"
+  else
+    lt_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[	 ]\($symcode$symcode*\)[	 ][	 ]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'"
+  fi
+
+  # Check to see that the pipe works correctly.
+  pipe_works=no
+
+  rm -f conftest*
+  cat > conftest.$ac_ext <<_LT_EOF
+#ifdef __cplusplus
+extern "C" {
+#endif
+char nm_test_var;
+void nm_test_func(void);
+void nm_test_func(void){}
+#ifdef __cplusplus
+}
+#endif
+int main(){nm_test_var='a';nm_test_func();return(0);}
+_LT_EOF
+
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    # Now try to grab the symbols.
+    nlist=conftest.nm
+    if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$NM conftest.$ac_objext \| "$lt_cv_sys_global_symbol_pipe" \> $nlist\""; } >&5
+  (eval $NM conftest.$ac_objext \| "$lt_cv_sys_global_symbol_pipe" \> $nlist) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s "$nlist"; then
+      # Try sorting and uniquifying the output.
+      if sort "$nlist" | uniq > "$nlist"T; then
+	mv -f "$nlist"T "$nlist"
+      else
+	rm -f "$nlist"T
+      fi
+
+      # Make sure that we snagged all the symbols we need.
+      if $GREP ' nm_test_var$' "$nlist" >/dev/null; then
+	if $GREP ' nm_test_func$' "$nlist" >/dev/null; then
+	  cat <<_LT_EOF > conftest.$ac_ext
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+_LT_EOF
+	  # Now generate the symbol file.
+	  eval "$lt_cv_sys_global_symbol_to_cdecl"' < "$nlist" | $GREP -v main >> conftest.$ac_ext'
+
+	  cat <<_LT_EOF >> conftest.$ac_ext
+
+/* The mapping between symbol names and symbols.  */
+const struct {
+  const char *name;
+  void       *address;
+}
+lt__PROGRAM__LTX_preloaded_symbols[] =
+{
+  { "@PROGRAM@", (void *) 0 },
+_LT_EOF
+	  $SED "s/^$symcode$symcode* \(.*\) \(.*\)$/  {\"\2\", (void *) \&\2},/" < "$nlist" | $GREP -v main >> conftest.$ac_ext
+	  cat <<\_LT_EOF >> conftest.$ac_ext
+  {0, (void *) 0}
+};
+
+/* This works around a problem in FreeBSD linker */
+#ifdef FREEBSD_WORKAROUND
+static const void *lt_preloaded_setup() {
+  return lt__PROGRAM__LTX_preloaded_symbols;
+}
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+_LT_EOF
+	  # Now try linking the two files.
+	  mv conftest.$ac_objext conftstm.$ac_objext
+	  lt_save_LIBS="$LIBS"
+	  lt_save_CFLAGS="$CFLAGS"
+	  LIBS="conftstm.$ac_objext"
+	  CFLAGS="$CFLAGS$lt_prog_compiler_no_builtin_flag"
+	  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s conftest${ac_exeext}; then
+	    pipe_works=yes
+	  fi
+	  LIBS="$lt_save_LIBS"
+	  CFLAGS="$lt_save_CFLAGS"
+	else
+	  echo "cannot find nm_test_func in $nlist" >&5
+	fi
+      else
+	echo "cannot find nm_test_var in $nlist" >&5
+      fi
+    else
+      echo "cannot run $lt_cv_sys_global_symbol_pipe" >&5
+    fi
+  else
+    echo "$progname: failed program was:" >&5
+    cat conftest.$ac_ext >&5
+  fi
+  rm -rf conftest* conftst*
+
+  # Do not use the global_symbol_pipe unless it works.
+  if test "$pipe_works" = yes; then
+    break
+  else
+    lt_cv_sys_global_symbol_pipe=
+  fi
+done
+
+fi
+
+if test -z "$lt_cv_sys_global_symbol_pipe"; then
+  lt_cv_sys_global_symbol_to_cdecl=
+fi
+if test -z "$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: failed" >&5
+$as_echo "failed" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: ok" >&5
+$as_echo "ok" >&6; }
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# Check whether --enable-libtool-lock was given.
+if test "${enable_libtool_lock+set}" = set; then :
+  enableval=$enable_libtool_lock;
+fi
+
+test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
+
+# Some flags need to be propagated to the compiler or linker for good
+# libtool support.
+case $host in
+ia64-*-hpux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    case `/usr/bin/file conftest.$ac_objext` in
+      *ELF-32*)
+	HPUX_IA64_MODE="32"
+	;;
+      *ELF-64*)
+	HPUX_IA64_MODE="64"
+	;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+*-*-irix6*)
+  # Find out which ABI we are using.
+  echo '#line '$LINENO' "configure"' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    if test "$lt_cv_prog_gnu_ld" = yes; then
+      case `/usr/bin/file conftest.$ac_objext` in
+	*32-bit*)
+	  LD="${LD-ld} -melf32bsmip"
+	  ;;
+	*N32*)
+	  LD="${LD-ld} -melf32bmipn32"
+	  ;;
+	*64-bit*)
+	  LD="${LD-ld} -melf64bmip"
+	;;
+      esac
+    else
+      case `/usr/bin/file conftest.$ac_objext` in
+	*32-bit*)
+	  LD="${LD-ld} -32"
+	  ;;
+	*N32*)
+	  LD="${LD-ld} -n32"
+	  ;;
+	*64-bit*)
+	  LD="${LD-ld} -64"
+	  ;;
+      esac
+    fi
+  fi
+  rm -rf conftest*
+  ;;
+
+x86_64-*kfreebsd*-gnu|x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*| \
+s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    case `/usr/bin/file conftest.o` in
+      *32-bit*)
+	case $host in
+	  x86_64-*kfreebsd*-gnu)
+	    LD="${LD-ld} -m elf_i386_fbsd"
+	    ;;
+	  x86_64-*linux*)
+	    LD="${LD-ld} -m elf_i386"
+	    ;;
+	  ppc64-*linux*|powerpc64-*linux*)
+	    LD="${LD-ld} -m elf32ppclinux"
+	    ;;
+	  s390x-*linux*)
+	    LD="${LD-ld} -m elf_s390"
+	    ;;
+	  sparc64-*linux*)
+	    LD="${LD-ld} -m elf32_sparc"
+	    ;;
+	esac
+	;;
+      *64-bit*)
+	case $host in
+	  x86_64-*kfreebsd*-gnu)
+	    LD="${LD-ld} -m elf_x86_64_fbsd"
+	    ;;
+	  x86_64-*linux*)
+	    LD="${LD-ld} -m elf_x86_64"
+	    ;;
+	  ppc*-*linux*|powerpc*-*linux*)
+	    LD="${LD-ld} -m elf64ppc"
+	    ;;
+	  s390*-*linux*|s390*-*tpf*)
+	    LD="${LD-ld} -m elf64_s390"
+	    ;;
+	  sparc*-*linux*)
+	    LD="${LD-ld} -m elf64_sparc"
+	    ;;
+	esac
+	;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+
+*-*-sco3.2v5*)
+  # On SCO OpenServer 5, we need -belf to get full-featured binaries.
+  SAVE_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS -belf"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler needs -belf" >&5
+$as_echo_n "checking whether the C compiler needs -belf... " >&6; }
+if test "${lt_cv_cc_needs_belf+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  lt_cv_cc_needs_belf=yes
+else
+  lt_cv_cc_needs_belf=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+     ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_cc_needs_belf" >&5
+$as_echo "$lt_cv_cc_needs_belf" >&6; }
+  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
+    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
+    CFLAGS="$SAVE_CFLAGS"
+  fi
+  ;;
+sparc*-*solaris*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    case `/usr/bin/file conftest.o` in
+    *64-bit*)
+      case $lt_cv_prog_gnu_ld in
+      yes*) LD="${LD-ld} -m elf64_sparc" ;;
+      *)
+	if ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then
+	  LD="${LD-ld} -64"
+	fi
+	;;
+      esac
+      ;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+esac
+
+need_locks="$enable_libtool_lock"
+
+
+  case $host_os in
+    rhapsody* | darwin*)
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}dsymutil", so it can be a program name with args.
+set dummy ${ac_tool_prefix}dsymutil; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_DSYMUTIL+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$DSYMUTIL"; then
+  ac_cv_prog_DSYMUTIL="$DSYMUTIL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_DSYMUTIL="${ac_tool_prefix}dsymutil"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+DSYMUTIL=$ac_cv_prog_DSYMUTIL
+if test -n "$DSYMUTIL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DSYMUTIL" >&5
+$as_echo "$DSYMUTIL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_DSYMUTIL"; then
+  ac_ct_DSYMUTIL=$DSYMUTIL
+  # Extract the first word of "dsymutil", so it can be a program name with args.
+set dummy dsymutil; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_DSYMUTIL+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_DSYMUTIL"; then
+  ac_cv_prog_ac_ct_DSYMUTIL="$ac_ct_DSYMUTIL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_DSYMUTIL="dsymutil"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_DSYMUTIL=$ac_cv_prog_ac_ct_DSYMUTIL
+if test -n "$ac_ct_DSYMUTIL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DSYMUTIL" >&5
+$as_echo "$ac_ct_DSYMUTIL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_DSYMUTIL" = x; then
+    DSYMUTIL=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    DSYMUTIL=$ac_ct_DSYMUTIL
+  fi
+else
+  DSYMUTIL="$ac_cv_prog_DSYMUTIL"
+fi
+
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}nmedit", so it can be a program name with args.
+set dummy ${ac_tool_prefix}nmedit; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_NMEDIT+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$NMEDIT"; then
+  ac_cv_prog_NMEDIT="$NMEDIT" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_NMEDIT="${ac_tool_prefix}nmedit"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+NMEDIT=$ac_cv_prog_NMEDIT
+if test -n "$NMEDIT"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $NMEDIT" >&5
+$as_echo "$NMEDIT" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_NMEDIT"; then
+  ac_ct_NMEDIT=$NMEDIT
+  # Extract the first word of "nmedit", so it can be a program name with args.
+set dummy nmedit; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_NMEDIT+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_NMEDIT"; then
+  ac_cv_prog_ac_ct_NMEDIT="$ac_ct_NMEDIT" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_NMEDIT="nmedit"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_NMEDIT=$ac_cv_prog_ac_ct_NMEDIT
+if test -n "$ac_ct_NMEDIT"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_NMEDIT" >&5
+$as_echo "$ac_ct_NMEDIT" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_NMEDIT" = x; then
+    NMEDIT=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    NMEDIT=$ac_ct_NMEDIT
+  fi
+else
+  NMEDIT="$ac_cv_prog_NMEDIT"
+fi
+
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}lipo", so it can be a program name with args.
+set dummy ${ac_tool_prefix}lipo; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_LIPO+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$LIPO"; then
+  ac_cv_prog_LIPO="$LIPO" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_LIPO="${ac_tool_prefix}lipo"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+LIPO=$ac_cv_prog_LIPO
+if test -n "$LIPO"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LIPO" >&5
+$as_echo "$LIPO" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_LIPO"; then
+  ac_ct_LIPO=$LIPO
+  # Extract the first word of "lipo", so it can be a program name with args.
+set dummy lipo; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_LIPO+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_LIPO"; then
+  ac_cv_prog_ac_ct_LIPO="$ac_ct_LIPO" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_LIPO="lipo"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_LIPO=$ac_cv_prog_ac_ct_LIPO
+if test -n "$ac_ct_LIPO"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_LIPO" >&5
+$as_echo "$ac_ct_LIPO" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_LIPO" = x; then
+    LIPO=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    LIPO=$ac_ct_LIPO
+  fi
+else
+  LIPO="$ac_cv_prog_LIPO"
+fi
+
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}otool", so it can be a program name with args.
+set dummy ${ac_tool_prefix}otool; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_OTOOL+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$OTOOL"; then
+  ac_cv_prog_OTOOL="$OTOOL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_OTOOL="${ac_tool_prefix}otool"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+OTOOL=$ac_cv_prog_OTOOL
+if test -n "$OTOOL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OTOOL" >&5
+$as_echo "$OTOOL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_OTOOL"; then
+  ac_ct_OTOOL=$OTOOL
+  # Extract the first word of "otool", so it can be a program name with args.
+set dummy otool; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_OTOOL+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_OTOOL"; then
+  ac_cv_prog_ac_ct_OTOOL="$ac_ct_OTOOL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_OTOOL="otool"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_OTOOL=$ac_cv_prog_ac_ct_OTOOL
+if test -n "$ac_ct_OTOOL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL" >&5
+$as_echo "$ac_ct_OTOOL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_OTOOL" = x; then
+    OTOOL=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    OTOOL=$ac_ct_OTOOL
+  fi
+else
+  OTOOL="$ac_cv_prog_OTOOL"
+fi
+
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}otool64", so it can be a program name with args.
+set dummy ${ac_tool_prefix}otool64; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_OTOOL64+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$OTOOL64"; then
+  ac_cv_prog_OTOOL64="$OTOOL64" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_OTOOL64="${ac_tool_prefix}otool64"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+OTOOL64=$ac_cv_prog_OTOOL64
+if test -n "$OTOOL64"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OTOOL64" >&5
+$as_echo "$OTOOL64" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_OTOOL64"; then
+  ac_ct_OTOOL64=$OTOOL64
+  # Extract the first word of "otool64", so it can be a program name with args.
+set dummy otool64; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_OTOOL64+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_OTOOL64"; then
+  ac_cv_prog_ac_ct_OTOOL64="$ac_ct_OTOOL64" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_OTOOL64="otool64"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_OTOOL64=$ac_cv_prog_ac_ct_OTOOL64
+if test -n "$ac_ct_OTOOL64"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL64" >&5
+$as_echo "$ac_ct_OTOOL64" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_OTOOL64" = x; then
+    OTOOL64=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    OTOOL64=$ac_ct_OTOOL64
+  fi
+else
+  OTOOL64="$ac_cv_prog_OTOOL64"
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -single_module linker flag" >&5
+$as_echo_n "checking for -single_module linker flag... " >&6; }
+if test "${lt_cv_apple_cc_single_mod+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_apple_cc_single_mod=no
+      if test -z "${LT_MULTI_MODULE}"; then
+	# By default we will add the -single_module flag. You can override
+	# by either setting the environment variable LT_MULTI_MODULE
+	# non-empty at configure time, or by adding -multi_module to the
+	# link flags.
+	rm -rf libconftest.dylib*
+	echo "int foo(void){return 1;}" > conftest.c
+	echo "$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
+-dynamiclib -Wl,-single_module conftest.c" >&5
+	$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
+	  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err
+        _lt_result=$?
+	if test -f libconftest.dylib && test ! -s conftest.err && test $_lt_result = 0; then
+	  lt_cv_apple_cc_single_mod=yes
+	else
+	  cat conftest.err >&5
+	fi
+	rm -rf libconftest.dylib*
+	rm -f conftest.*
+      fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_apple_cc_single_mod" >&5
+$as_echo "$lt_cv_apple_cc_single_mod" >&6; }
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -exported_symbols_list linker flag" >&5
+$as_echo_n "checking for -exported_symbols_list linker flag... " >&6; }
+if test "${lt_cv_ld_exported_symbols_list+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_ld_exported_symbols_list=no
+      save_LDFLAGS=$LDFLAGS
+      echo "_main" > conftest.sym
+      LDFLAGS="$LDFLAGS -Wl,-exported_symbols_list,conftest.sym"
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  lt_cv_ld_exported_symbols_list=yes
+else
+  lt_cv_ld_exported_symbols_list=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+	LDFLAGS="$save_LDFLAGS"
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_exported_symbols_list" >&5
+$as_echo "$lt_cv_ld_exported_symbols_list" >&6; }
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -force_load linker flag" >&5
+$as_echo_n "checking for -force_load linker flag... " >&6; }
+if test "${lt_cv_ld_force_load+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_ld_force_load=no
+      cat > conftest.c << _LT_EOF
+int forced_loaded() { return 2;}
+_LT_EOF
+      echo "$LTCC $LTCFLAGS -c -o conftest.o conftest.c" >&5
+      $LTCC $LTCFLAGS -c -o conftest.o conftest.c 2>&5
+      echo "$AR cru libconftest.a conftest.o" >&5
+      $AR cru libconftest.a conftest.o 2>&5
+      echo "$RANLIB libconftest.a" >&5
+      $RANLIB libconftest.a 2>&5
+      cat > conftest.c << _LT_EOF
+int main() { return 0;}
+_LT_EOF
+      echo "$LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a" >&5
+      $LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a 2>conftest.err
+      _lt_result=$?
+      if test -f conftest && test ! -s conftest.err && test $_lt_result = 0 && $GREP forced_load conftest 2>&1 >/dev/null; then
+	lt_cv_ld_force_load=yes
+      else
+	cat conftest.err >&5
+      fi
+        rm -f conftest.err libconftest.a conftest conftest.c
+        rm -rf conftest.dSYM
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_force_load" >&5
+$as_echo "$lt_cv_ld_force_load" >&6; }
+    case $host_os in
+    rhapsody* | darwin1.[012])
+      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;
+    darwin1.*)
+      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+    darwin*) # darwin 5.x on
+      # if running on 10.5 or later, the deployment target defaults
+      # to the OS version, if on x86, and 10.4, the deployment
+      # target defaults to 10.4. Don't you love it?
+      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in
+	10.0,*86*-darwin8*|10.0,*-darwin[91]*)
+	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+	10.[012]*)
+	  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+	10.*)
+	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+      esac
+    ;;
+  esac
+    if test "$lt_cv_apple_cc_single_mod" = "yes"; then
+      _lt_dar_single_mod='$single_module'
+    fi
+    if test "$lt_cv_ld_exported_symbols_list" = "yes"; then
+      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
+    else
+      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'
+    fi
+    if test "$DSYMUTIL" != ":" && test "$lt_cv_ld_force_load" = "no"; then
+      _lt_dsymutil='~$DSYMUTIL $lib || :'
+    else
+      _lt_dsymutil=
+    fi
+    ;;
+  esac
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
+$as_echo_n "checking how to run the C preprocessor... " >&6; }
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+  if test "${ac_cv_prog_CPP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+      # Double quotes because CPP needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+
+else
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  # Broken: success on invalid input.
+continue
+else
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then :
+  break
+fi
+
+    done
+    ac_cv_prog_CPP=$CPP
+
+fi
+  CPP=$ac_cv_prog_CPP
+else
+  ac_cv_prog_CPP=$CPP
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
+$as_echo "$CPP" >&6; }
+ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+
+else
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  # Broken: success on invalid input.
+continue
+else
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then :
+
+else
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error "C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." "$LINENO" 5; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
+$as_echo_n "checking for ANSI C header files... " >&6; }
+if test "${ac_cv_header_stdc+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_header_stdc=yes
+else
+  ac_cv_header_stdc=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <string.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then :
+
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then :
+
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then :
+  :
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ctype.h>
+#include <stdlib.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+	|| toupper (i) != TOUPPER (i))
+      return 2;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+
+else
+  ac_cv_header_stdc=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc" >&5
+$as_echo "$ac_cv_header_stdc" >&6; }
+if test $ac_cv_header_stdc = yes; then
+
+$as_echo "#define STDC_HEADERS 1" >>confdefs.h
+
+fi
+
+# On IRIX 5.3, sys/types and inttypes.h are conflicting.
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+		  inttypes.h stdint.h unistd.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
+"
+eval as_val=\$$as_ac_Header
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+for ac_header in dlfcn.h
+do :
+  ac_fn_c_check_header_compile "$LINENO" "dlfcn.h" "ac_cv_header_dlfcn_h" "$ac_includes_default
+"
+if test "x$ac_cv_header_dlfcn_h" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_DLFCN_H 1
+_ACEOF
+
+fi
+
+done
+
+
+
+
+
+# Set options
+
+
+
+        enable_dlopen=no
+
+
+  enable_win32_dll=no
+
+
+            # Check whether --enable-shared was given.
+if test "${enable_shared+set}" = set; then :
+  enableval=$enable_shared; p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_shared=yes ;;
+    no) enable_shared=no ;;
+    *)
+      enable_shared=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_shared=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
+else
+  enable_shared=yes
+fi
+
+
+
+
+
+
+
+
+
+  # Check whether --enable-static was given.
+if test "${enable_static+set}" = set; then :
+  enableval=$enable_static; p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_static=yes ;;
+    no) enable_static=no ;;
+    *)
+     enable_static=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_static=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
+else
+  enable_static=yes
+fi
+
+
+
+
+
+
+
+
+
+
+# Check whether --with-pic was given.
+if test "${with_pic+set}" = set; then :
+  withval=$with_pic; pic_mode="$withval"
+else
+  pic_mode=default
+fi
+
+
+test -z "$pic_mode" && pic_mode=default
+
+
+
+
+
+
+
+  # Check whether --enable-fast-install was given.
+if test "${enable_fast_install+set}" = set; then :
+  enableval=$enable_fast_install; p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_fast_install=yes ;;
+    no) enable_fast_install=no ;;
+    *)
+      enable_fast_install=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_fast_install=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
+else
+  enable_fast_install=yes
+fi
+
+
+
+
+
+
+
+
+
+
+
+# This can be used to rebuild libtool when needed
+LIBTOOL_DEPS="$ltmain"
+
+# Always use our own libtool.
+LIBTOOL='$(SHELL) $(top_builddir)/libtool'
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+test -z "$LN_S" && LN_S="ln -s"
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+if test -n "${ZSH_VERSION+set}" ; then
+   setopt NO_GLOB_SUBST
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for objdir" >&5
+$as_echo_n "checking for objdir... " >&6; }
+if test "${lt_cv_objdir+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  rm -f .libs 2>/dev/null
+mkdir .libs 2>/dev/null
+if test -d .libs; then
+  lt_cv_objdir=.libs
+else
+  # MS-DOS does not allow filenames that begin with a dot.
+  lt_cv_objdir=_libs
+fi
+rmdir .libs 2>/dev/null
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_objdir" >&5
+$as_echo "$lt_cv_objdir" >&6; }
+objdir=$lt_cv_objdir
+
+
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define LT_OBJDIR "$lt_cv_objdir/"
+_ACEOF
+
+
+
+
+case $host_os in
+aix3*)
+  # AIX sometimes has problems with the GCC collect2 program.  For some
+  # reason, if we set the COLLECT_NAMES environment variable, the problems
+  # vanish in a puff of smoke.
+  if test "X${COLLECT_NAMES+set}" != Xset; then
+    COLLECT_NAMES=
+    export COLLECT_NAMES
+  fi
+  ;;
+esac
+
+# Global variables:
+ofile=libtool
+can_build_shared=yes
+
+# All known linkers require a `.a' archive for static linking (except MSVC,
+# which needs '.lib').
+libext=a
+
+with_gnu_ld="$lt_cv_prog_gnu_ld"
+
+old_CC="$CC"
+old_CFLAGS="$CFLAGS"
+
+# Set sane defaults for various variables
+test -z "$CC" && CC=cc
+test -z "$LTCC" && LTCC=$CC
+test -z "$LTCFLAGS" && LTCFLAGS=$CFLAGS
+test -z "$LD" && LD=ld
+test -z "$ac_objext" && ac_objext=o
+
+for cc_temp in $compiler""; do
+  case $cc_temp in
+    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
+    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
+done
+cc_basename=`$ECHO "$cc_temp" | $SED "s%.*/%%; s%^$host_alias-%%"`
+
+
+# Only perform the check for file, if the check method requires it
+test -z "$MAGIC_CMD" && MAGIC_CMD=file
+case $deplibs_check_method in
+file_magic*)
+  if test "$file_magic_cmd" = '$MAGIC_CMD'; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${ac_tool_prefix}file" >&5
+$as_echo_n "checking for ${ac_tool_prefix}file... " >&6; }
+if test "${lt_cv_path_MAGIC_CMD+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $MAGIC_CMD in
+[\\/*] |  ?:[\\/]*)
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  ;;
+*)
+  lt_save_MAGIC_CMD="$MAGIC_CMD"
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
+  for ac_dir in $ac_dummy; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/${ac_tool_prefix}file; then
+      lt_cv_path_MAGIC_CMD="$ac_dir/${ac_tool_prefix}file"
+      if test -n "$file_magic_test_file"; then
+	case $deplibs_check_method in
+	"file_magic "*)
+	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
+	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
+	    $EGREP "$file_magic_regex" > /dev/null; then
+	    :
+	  else
+	    cat <<_LT_EOF 1>&2
+
+*** Warning: the command libtool uses to detect shared libraries,
+*** $file_magic_cmd, produces output that libtool cannot recognize.
+*** The result is that libtool may fail to recognize shared libraries
+*** as such.  This will affect the creation of libtool libraries that
+*** depend on shared libraries, but programs linked with such libtool
+*** libraries will work regardless of this problem.  Nevertheless, you
+*** may want to report the problem to your system manager and/or to
+*** bug-libtool@gnu.org
+
+_LT_EOF
+	  fi ;;
+	esac
+      fi
+      break
+    fi
+  done
+  IFS="$lt_save_ifs"
+  MAGIC_CMD="$lt_save_MAGIC_CMD"
+  ;;
+esac
+fi
+
+MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+if test -n "$MAGIC_CMD"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
+$as_echo "$MAGIC_CMD" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+
+
+
+if test -z "$lt_cv_path_MAGIC_CMD"; then
+  if test -n "$ac_tool_prefix"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for file" >&5
+$as_echo_n "checking for file... " >&6; }
+if test "${lt_cv_path_MAGIC_CMD+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $MAGIC_CMD in
+[\\/*] |  ?:[\\/]*)
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  ;;
+*)
+  lt_save_MAGIC_CMD="$MAGIC_CMD"
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
+  for ac_dir in $ac_dummy; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/file; then
+      lt_cv_path_MAGIC_CMD="$ac_dir/file"
+      if test -n "$file_magic_test_file"; then
+	case $deplibs_check_method in
+	"file_magic "*)
+	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
+	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
+	    $EGREP "$file_magic_regex" > /dev/null; then
+	    :
+	  else
+	    cat <<_LT_EOF 1>&2
+
+*** Warning: the command libtool uses to detect shared libraries,
+*** $file_magic_cmd, produces output that libtool cannot recognize.
+*** The result is that libtool may fail to recognize shared libraries
+*** as such.  This will affect the creation of libtool libraries that
+*** depend on shared libraries, but programs linked with such libtool
+*** libraries will work regardless of this problem.  Nevertheless, you
+*** may want to report the problem to your system manager and/or to
+*** bug-libtool@gnu.org
+
+_LT_EOF
+	  fi ;;
+	esac
+      fi
+      break
+    fi
+  done
+  IFS="$lt_save_ifs"
+  MAGIC_CMD="$lt_save_MAGIC_CMD"
+  ;;
+esac
+fi
+
+MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+if test -n "$MAGIC_CMD"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
+$as_echo "$MAGIC_CMD" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  else
+    MAGIC_CMD=:
+  fi
+fi
+
+  fi
+  ;;
+esac
+
+# Use C for the default configuration in the libtool script
+
+lt_save_CC="$CC"
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+# Source file extension for C test sources.
+ac_ext=c
+
+# Object file extension for compiled C test sources.
+objext=o
+objext=$objext
+
+# Code to be used in simple compile tests
+lt_simple_compile_test_code="int some_variable = 0;"
+
+# Code to be used in simple link tests
+lt_simple_link_test_code='int main(){return(0);}'
+
+
+
+
+
+
+
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
+
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
+
+# Allow CC to be a program name with arguments.
+compiler=$CC
+
+# Save the default compiler, since it gets overwritten when the other
+# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.
+compiler_DEFAULT=$CC
+
+# save warnings/boilerplate of simple test code
+ac_outfile=conftest.$ac_objext
+echo "$lt_simple_compile_test_code" >conftest.$ac_ext
+eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_compiler_boilerplate=`cat conftest.err`
+$RM conftest*
+
+ac_outfile=conftest.$ac_objext
+echo "$lt_simple_link_test_code" >conftest.$ac_ext
+eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_linker_boilerplate=`cat conftest.err`
+$RM -r conftest*
+
+
+if test -n "$compiler"; then
+
+lt_prog_compiler_no_builtin_flag=
+
+if test "$GCC" = yes; then
+  case $cc_basename in
+  nvcc*)
+    lt_prog_compiler_no_builtin_flag=' -Xcompiler -fno-builtin' ;;
+  *)
+    lt_prog_compiler_no_builtin_flag=' -fno-builtin' ;;
+  esac
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -fno-rtti -fno-exceptions" >&5
+$as_echo_n "checking if $compiler supports -fno-rtti -fno-exceptions... " >&6; }
+if test "${lt_cv_prog_compiler_rtti_exceptions+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_rtti_exceptions=no
+   ac_outfile=conftest.$ac_objext
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="-fno-rtti -fno-exceptions"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&5
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_rtti_exceptions=yes
+     fi
+   fi
+   $RM conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_rtti_exceptions" >&5
+$as_echo "$lt_cv_prog_compiler_rtti_exceptions" >&6; }
+
+if test x"$lt_cv_prog_compiler_rtti_exceptions" = xyes; then
+    lt_prog_compiler_no_builtin_flag="$lt_prog_compiler_no_builtin_flag -fno-rtti -fno-exceptions"
+else
+    :
+fi
+
+fi
+
+
+
+
+
+
+  lt_prog_compiler_wl=
+lt_prog_compiler_pic=
+lt_prog_compiler_static=
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $compiler option to produce PIC" >&5
+$as_echo_n "checking for $compiler option to produce PIC... " >&6; }
+
+  if test "$GCC" = yes; then
+    lt_prog_compiler_wl='-Wl,'
+    lt_prog_compiler_static='-static'
+
+    case $host_os in
+      aix*)
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	lt_prog_compiler_static='-Bstatic'
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            lt_prog_compiler_pic='-fPIC'
+        ;;
+      m68k)
+            # FIXME: we need at least 68020 code to build shared libraries, but
+            # adding the `-m68020' flag to GCC prevents building anything better,
+            # like `-m68040'.
+            lt_prog_compiler_pic='-m68020 -resident32 -malways-restore-a4'
+        ;;
+      esac
+      ;;
+
+    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
+
+    mingw* | cygwin* | pw32* | os2* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      # Although the cygwin gcc ignores -fPIC, still need this for old-style
+      # (--disable-auto-import) libraries
+      lt_prog_compiler_pic='-DDLL_EXPORT'
+      ;;
+
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      lt_prog_compiler_pic='-fno-common'
+      ;;
+
+    haiku*)
+      # PIC is the default for Haiku.
+      # The "-static" flag exists, but is broken.
+      lt_prog_compiler_static=
+      ;;
+
+    hpux*)
+      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
+      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
+      # sets the default TLS model and affects inlining.
+      case $host_cpu in
+      hppa*64*)
+	# +Z the default
+	;;
+      *)
+	lt_prog_compiler_pic='-fPIC'
+	;;
+      esac
+      ;;
+
+    interix[3-9]*)
+      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
+      # Instead, we relocate shared libraries at runtime.
+      ;;
+
+    msdosdjgpp*)
+      # Just because we use GCC doesn't mean we suddenly get shared libraries
+      # on systems that don't support them.
+      lt_prog_compiler_can_build_shared=no
+      enable_shared=no
+      ;;
+
+    *nto* | *qnx*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      lt_prog_compiler_pic='-fPIC -shared'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	lt_prog_compiler_pic=-Kconform_pic
+      fi
+      ;;
+
+    *)
+      lt_prog_compiler_pic='-fPIC'
+      ;;
+    esac
+
+    case $cc_basename in
+    nvcc*) # Cuda Compiler Driver 2.2
+      lt_prog_compiler_wl='-Xlinker '
+      lt_prog_compiler_pic='-Xcompiler -fPIC'
+      ;;
+    esac
+  else
+    # PORTME Check for flag to pass linker flags through the system compiler.
+    case $host_os in
+    aix*)
+      lt_prog_compiler_wl='-Wl,'
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	lt_prog_compiler_static='-Bstatic'
+      else
+	lt_prog_compiler_static='-bnso -bI:/lib/syscalls.exp'
+      fi
+      ;;
+
+    mingw* | cygwin* | pw32* | os2* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      lt_prog_compiler_pic='-DDLL_EXPORT'
+      ;;
+
+    hpux9* | hpux10* | hpux11*)
+      lt_prog_compiler_wl='-Wl,'
+      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but
+      # not for PA HP-UX.
+      case $host_cpu in
+      hppa*64*|ia64*)
+	# +Z the default
+	;;
+      *)
+	lt_prog_compiler_pic='+Z'
+	;;
+      esac
+      # Is there a better lt_prog_compiler_static that works with the bundled CC?
+      lt_prog_compiler_static='${wl}-a ${wl}archive'
+      ;;
+
+    irix5* | irix6* | nonstopux*)
+      lt_prog_compiler_wl='-Wl,'
+      # PIC (with -KPIC) is the default.
+      lt_prog_compiler_static='-non_shared'
+      ;;
+
+    linux* | k*bsd*-gnu | kopensolaris*-gnu)
+      case $cc_basename in
+      # old Intel for x86_64 which still supported -KPIC.
+      ecc*)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-KPIC'
+	lt_prog_compiler_static='-static'
+        ;;
+      # icc used to be incompatible with GCC.
+      # ICC 10 doesn't accept -KPIC any more.
+      icc* | ifort*)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-fPIC'
+	lt_prog_compiler_static='-static'
+        ;;
+      # Lahey Fortran 8.1.
+      lf95*)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='--shared'
+	lt_prog_compiler_static='--static'
+	;;
+      pgcc* | pgf77* | pgf90* | pgf95* | pgfortran*)
+        # Portland Group compilers (*not* the Pentium gcc compiler,
+	# which looks to be a dead project)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-fpic'
+	lt_prog_compiler_static='-Bstatic'
+        ;;
+      ccc*)
+        lt_prog_compiler_wl='-Wl,'
+        # All Alpha code is PIC.
+        lt_prog_compiler_static='-non_shared'
+        ;;
+      xl* | bgxl* | bgf* | mpixl*)
+	# IBM XL C 8.0/Fortran 10.1, 11.1 on PPC and BlueGene
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-qpic'
+	lt_prog_compiler_static='-qstaticlink'
+	;;
+      *)
+	case `$CC -V 2>&1 | sed 5q` in
+	*Sun\ F* | *Sun*Fortran*)
+	  # Sun Fortran 8.3 passes all unrecognized flags to the linker
+	  lt_prog_compiler_pic='-KPIC'
+	  lt_prog_compiler_static='-Bstatic'
+	  lt_prog_compiler_wl=''
+	  ;;
+	*Sun\ C*)
+	  # Sun C 5.9
+	  lt_prog_compiler_pic='-KPIC'
+	  lt_prog_compiler_static='-Bstatic'
+	  lt_prog_compiler_wl='-Wl,'
+	  ;;
+	esac
+	;;
+      esac
+      ;;
+
+    newsos6)
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    *nto* | *qnx*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      lt_prog_compiler_pic='-fPIC -shared'
+      ;;
+
+    osf3* | osf4* | osf5*)
+      lt_prog_compiler_wl='-Wl,'
+      # All OSF/1 code is PIC.
+      lt_prog_compiler_static='-non_shared'
+      ;;
+
+    rdos*)
+      lt_prog_compiler_static='-non_shared'
+      ;;
+
+    solaris*)
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      case $cc_basename in
+      f77* | f90* | f95* | sunf77* | sunf90* | sunf95*)
+	lt_prog_compiler_wl='-Qoption ld ';;
+      *)
+	lt_prog_compiler_wl='-Wl,';;
+      esac
+      ;;
+
+    sunos4*)
+      lt_prog_compiler_wl='-Qoption ld '
+      lt_prog_compiler_pic='-PIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    sysv4 | sysv4.2uw2* | sysv4.3*)
+      lt_prog_compiler_wl='-Wl,'
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec ;then
+	lt_prog_compiler_pic='-Kconform_pic'
+	lt_prog_compiler_static='-Bstatic'
+      fi
+      ;;
+
+    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+      lt_prog_compiler_wl='-Wl,'
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    unicos*)
+      lt_prog_compiler_wl='-Wl,'
+      lt_prog_compiler_can_build_shared=no
+      ;;
+
+    uts4*)
+      lt_prog_compiler_pic='-pic'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    *)
+      lt_prog_compiler_can_build_shared=no
+      ;;
+    esac
+  fi
+
+case $host_os in
+  # For platforms which do not support PIC, -DPIC is meaningless:
+  *djgpp*)
+    lt_prog_compiler_pic=
+    ;;
+  *)
+    lt_prog_compiler_pic="$lt_prog_compiler_pic -DPIC"
+    ;;
+esac
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_prog_compiler_pic" >&5
+$as_echo "$lt_prog_compiler_pic" >&6; }
+
+
+
+
+
+
+#
+# Check to make sure the PIC flag actually works.
+#
+if test -n "$lt_prog_compiler_pic"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler PIC flag $lt_prog_compiler_pic works" >&5
+$as_echo_n "checking if $compiler PIC flag $lt_prog_compiler_pic works... " >&6; }
+if test "${lt_cv_prog_compiler_pic_works+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_pic_works=no
+   ac_outfile=conftest.$ac_objext
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="$lt_prog_compiler_pic -DPIC"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&5
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_pic_works=yes
+     fi
+   fi
+   $RM conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_pic_works" >&5
+$as_echo "$lt_cv_prog_compiler_pic_works" >&6; }
+
+if test x"$lt_cv_prog_compiler_pic_works" = xyes; then
+    case $lt_prog_compiler_pic in
+     "" | " "*) ;;
+     *) lt_prog_compiler_pic=" $lt_prog_compiler_pic" ;;
+     esac
+else
+    lt_prog_compiler_pic=
+     lt_prog_compiler_can_build_shared=no
+fi
+
+fi
+
+
+
+
+
+
+#
+# Check to make sure the static flag actually works.
+#
+wl=$lt_prog_compiler_wl eval lt_tmp_static_flag=\"$lt_prog_compiler_static\"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler static flag $lt_tmp_static_flag works" >&5
+$as_echo_n "checking if $compiler static flag $lt_tmp_static_flag works... " >&6; }
+if test "${lt_cv_prog_compiler_static_works+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_static_works=no
+   save_LDFLAGS="$LDFLAGS"
+   LDFLAGS="$LDFLAGS $lt_tmp_static_flag"
+   echo "$lt_simple_link_test_code" > conftest.$ac_ext
+   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
+     # The linker can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     if test -s conftest.err; then
+       # Append any errors to the config.log.
+       cat conftest.err 1>&5
+       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
+       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+       if diff conftest.exp conftest.er2 >/dev/null; then
+         lt_cv_prog_compiler_static_works=yes
+       fi
+     else
+       lt_cv_prog_compiler_static_works=yes
+     fi
+   fi
+   $RM -r conftest*
+   LDFLAGS="$save_LDFLAGS"
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_static_works" >&5
+$as_echo "$lt_cv_prog_compiler_static_works" >&6; }
+
+if test x"$lt_cv_prog_compiler_static_works" = xyes; then
+    :
+else
+    lt_prog_compiler_static=
+fi
+
+
+
+
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
+$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
+if test "${lt_cv_prog_compiler_c_o+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_c_o=no
+   $RM -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&5
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_c_o=yes
+     fi
+   fi
+   chmod u+w . 2>&5
+   $RM conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
+   $RM out/* && rmdir out
+   cd ..
+   $RM -r conftest
+   $RM conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o" >&5
+$as_echo "$lt_cv_prog_compiler_c_o" >&6; }
+
+
+
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
+$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
+if test "${lt_cv_prog_compiler_c_o+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_c_o=no
+   $RM -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&5
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_c_o=yes
+     fi
+   fi
+   chmod u+w . 2>&5
+   $RM conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
+   $RM out/* && rmdir out
+   cd ..
+   $RM -r conftest
+   $RM conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o" >&5
+$as_echo "$lt_cv_prog_compiler_c_o" >&6; }
+
+
+
+
+hard_links="nottested"
+if test "$lt_cv_prog_compiler_c_o" = no && test "$need_locks" != no; then
+  # do not overwrite the value of need_locks provided by the user
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if we can lock with hard links" >&5
+$as_echo_n "checking if we can lock with hard links... " >&6; }
+  hard_links=yes
+  $RM conftest*
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  touch conftest.a
+  ln conftest.a conftest.b 2>&5 || hard_links=no
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $hard_links" >&5
+$as_echo "$hard_links" >&6; }
+  if test "$hard_links" = no; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
+$as_echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
+    need_locks=warn
+  fi
+else
+  need_locks=no
+fi
+
+
+
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $compiler linker ($LD) supports shared libraries" >&5
+$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
+
+  runpath_var=
+  allow_undefined_flag=
+  always_export_symbols=no
+  archive_cmds=
+  archive_expsym_cmds=
+  compiler_needs_object=no
+  enable_shared_with_static_runtimes=no
+  export_dynamic_flag_spec=
+  export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  hardcode_automatic=no
+  hardcode_direct=no
+  hardcode_direct_absolute=no
+  hardcode_libdir_flag_spec=
+  hardcode_libdir_flag_spec_ld=
+  hardcode_libdir_separator=
+  hardcode_minus_L=no
+  hardcode_shlibpath_var=unsupported
+  inherit_rpath=no
+  link_all_deplibs=unknown
+  module_cmds=
+  module_expsym_cmds=
+  old_archive_from_new_cmds=
+  old_archive_from_expsyms_cmds=
+  thread_safe_flag_spec=
+  whole_archive_flag_spec=
+  # include_expsyms should be a list of space-separated symbols to be *always*
+  # included in the symbol list
+  include_expsyms=
+  # exclude_expsyms can be an extended regexp of symbols to exclude
+  # it will be wrapped by ` (' and `)$', so one must not match beginning or
+  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
+  # as well as any symbol that contains `d'.
+  exclude_expsyms='_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*'
+  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
+  # platforms (ab)use it in PIC code, but their linkers get confused if
+  # the symbol is explicitly referenced.  Since portable code cannot
+  # rely on this symbol name, it's probably fine to never include it in
+  # preloaded symbol tables.
+  # Exclude shared library initialization/finalization symbols.
+  extract_expsyms_cmds=
+
+  case $host_os in
+  cygwin* | mingw* | pw32* | cegcc*)
+    # FIXME: the MSVC++ port hasn't been tested in a loooong time
+    # When not using gcc, we currently assume that we are using
+    # Microsoft Visual C++.
+    if test "$GCC" != yes; then
+      with_gnu_ld=no
+    fi
+    ;;
+  interix*)
+    # we just hope/assume this is gcc and not c89 (= MSVC++)
+    with_gnu_ld=yes
+    ;;
+  openbsd*)
+    with_gnu_ld=no
+    ;;
+  esac
+
+  ld_shlibs=yes
+
+  # On some targets, GNU ld is compatible enough with the native linker
+  # that we're better off using the native interface for both.
+  lt_use_gnu_ld_interface=no
+  if test "$with_gnu_ld" = yes; then
+    case $host_os in
+      aix*)
+	# The AIX port of GNU ld has always aspired to compatibility
+	# with the native linker.  However, as the warning in the GNU ld
+	# block says, versions before 2.19.5* couldn't really create working
+	# shared libraries, regardless of the interface used.
+	case `$LD -v 2>&1` in
+	  *\ \(GNU\ Binutils\)\ 2.19.5*) ;;
+	  *\ \(GNU\ Binutils\)\ 2.[2-9]*) ;;
+	  *\ \(GNU\ Binutils\)\ [3-9]*) ;;
+	  *)
+	    lt_use_gnu_ld_interface=yes
+	    ;;
+	esac
+	;;
+      *)
+	lt_use_gnu_ld_interface=yes
+	;;
+    esac
+  fi
+
+  if test "$lt_use_gnu_ld_interface" = yes; then
+    # If archive_cmds runs LD, not CC, wlarc should be empty
+    wlarc='${wl}'
+
+    # Set some defaults for GNU ld with shared library support. These
+    # are reset later if shared libraries are not supported. Putting them
+    # here allows them to be overridden if necessary.
+    runpath_var=LD_RUN_PATH
+    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+    export_dynamic_flag_spec='${wl}--export-dynamic'
+    # ancient GNU ld didn't support --whole-archive et. al.
+    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then
+      whole_archive_flag_spec="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+    else
+      whole_archive_flag_spec=
+    fi
+    supports_anon_versioning=no
+    case `$LD -v 2>&1` in
+      *GNU\ gold*) supports_anon_versioning=yes ;;
+      *\ [01].* | *\ 2.[0-9].* | *\ 2.10.*) ;; # catch versions < 2.11
+      *\ 2.11.93.0.2\ *) supports_anon_versioning=yes ;; # RH7.3 ...
+      *\ 2.11.92.0.12\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...
+      *\ 2.11.*) ;; # other 2.11 versions
+      *) supports_anon_versioning=yes ;;
+    esac
+
+    # See if GNU ld supports shared libraries.
+    case $host_os in
+    aix[3-9]*)
+      # On AIX/PPC, the GNU linker is very broken
+      if test "$host_cpu" != ia64; then
+	ld_shlibs=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: the GNU linker, at least up to release 2.19, is reported
+*** to be unable to reliably create shared libraries on AIX.
+*** Therefore, libtool is disabling shared libraries support.  If you
+*** really care for shared libraries, you may want to install binutils
+*** 2.20 or above, or modify your PATH so that a non-GNU linker is found.
+*** You will then need to restart the configuration process.
+
+_LT_EOF
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            archive_expsym_cmds=''
+        ;;
+      m68k)
+            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+            hardcode_libdir_flag_spec='-L$libdir'
+            hardcode_minus_L=yes
+        ;;
+      esac
+      ;;
+
+    beos*)
+      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	allow_undefined_flag=unsupported
+	# Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+	# support --undefined.  This deserves some investigation.  FIXME
+	archive_cmds='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
+
+    cygwin* | mingw* | pw32* | cegcc*)
+      # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
+      # as there is no search path for DLLs.
+      hardcode_libdir_flag_spec='-L$libdir'
+      export_dynamic_flag_spec='${wl}--export-all-symbols'
+      allow_undefined_flag=unsupported
+      always_export_symbols=no
+      enable_shared_with_static_runtimes=yes
+      export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[BCDGRS][ ]/s/.*[ ]\([^ ]*\)/\1 DATA/'\'' | $SED -e '\''/^[AITW][ ]/s/.*[ ]//'\'' | sort | uniq > $export_symbols'
+
+      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
+        archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	# If the export-symbols file already is a .def file (1st line
+	# is EXPORTS), use it as is; otherwise, prepend...
+	archive_expsym_cmds='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	  cp $export_symbols $output_objdir/$soname.def;
+	else
+	  echo EXPORTS > $output_objdir/$soname.def;
+	  cat $export_symbols >> $output_objdir/$soname.def;
+	fi~
+	$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
+
+    haiku*)
+      archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      link_all_deplibs=yes
+      ;;
+
+    interix[3-9]*)
+      hardcode_direct=no
+      hardcode_shlibpath_var=no
+      hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+      export_dynamic_flag_spec='${wl}-E'
+      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
+      # Instead, shared libraries are loaded at an image base (0x10000000 by
+      # default) and relocated if they conflict, which is a slow very memory
+      # consuming and fragmenting process.  To avoid this, we pick a random,
+      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
+      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
+      archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      archive_expsym_cmds='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      ;;
+
+    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)
+      tmp_diet=no
+      if test "$host_os" = linux-dietlibc; then
+	case $cc_basename in
+	  diet\ *) tmp_diet=yes;;	# linux-dietlibc with static linking (!diet-dyn)
+	esac
+      fi
+      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \
+	 && test "$tmp_diet" = no
+      then
+	tmp_addflag=
+	tmp_sharedflag='-shared'
+	case $cc_basename,$host_cpu in
+        pgcc*)				# Portland Group C compiler
+	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag'
+	  ;;
+	pgf77* | pgf90* | pgf95* | pgfortran*)
+					# Portland Group f77 and f90 compilers
+	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag -Mnomain' ;;
+	ecc*,ia64* | icc*,ia64*)	# Intel C compiler on ia64
+	  tmp_addflag=' -i_dynamic' ;;
+	efc*,ia64* | ifort*,ia64*)	# Intel Fortran compiler on ia64
+	  tmp_addflag=' -i_dynamic -nofor_main' ;;
+	ifc* | ifort*)			# Intel Fortran compiler
+	  tmp_addflag=' -nofor_main' ;;
+	lf95*)				# Lahey Fortran 8.1
+	  whole_archive_flag_spec=
+	  tmp_sharedflag='--shared' ;;
+	xl[cC]* | bgxl[cC]* | mpixl[cC]*) # IBM XL C 8.0 on PPC (deal with xlf below)
+	  tmp_sharedflag='-qmkshrobj'
+	  tmp_addflag= ;;
+	nvcc*)	# Cuda Compiler Driver 2.2
+	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  compiler_needs_object=yes
+	  ;;
+	esac
+	case `$CC -V 2>&1 | sed 5q` in
+	*Sun\ C*)			# Sun C 5.9
+	  whole_archive_flag_spec='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  compiler_needs_object=yes
+	  tmp_sharedflag='-G' ;;
+	*Sun\ F*)			# Sun Fortran 8.3
+	  tmp_sharedflag='-G' ;;
+	esac
+	archive_cmds='$CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+
+        if test "x$supports_anon_versioning" = xyes; then
+          archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
+	    cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+	    echo "local: *; };" >> $output_objdir/$libname.ver~
+	    $CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+        fi
+
+	case $cc_basename in
+	xlf* | bgf* | bgxlf* | mpixlf*)
+	  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself
+	  whole_archive_flag_spec='--whole-archive$convenience --no-whole-archive'
+	  hardcode_libdir_flag_spec=
+	  hardcode_libdir_flag_spec_ld='-rpath $libdir'
+	  archive_cmds='$LD -shared $libobjs $deplibs $linker_flags -soname $soname -o $lib'
+	  if test "x$supports_anon_versioning" = xyes; then
+	    archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
+	      cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+	      echo "local: *; };" >> $output_objdir/$libname.ver~
+	      $LD -shared $libobjs $deplibs $linker_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'
+	  fi
+	  ;;
+	esac
+      else
+        ld_shlibs=no
+      fi
+      ;;
+
+    netbsd*)
+      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	archive_cmds='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
+	wlarc=
+      else
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      fi
+      ;;
+
+    solaris*)
+      if $LD -v 2>&1 | $GREP 'BFD 2\.8' > /dev/null; then
+	ld_shlibs=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: The releases 2.8.* of the GNU linker cannot reliably
+*** create shared libraries on Solaris systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.9.1 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+_LT_EOF
+      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
+
+    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
+      case `$LD -v 2>&1` in
+        *\ [01].* | *\ 2.[0-9].* | *\ 2.1[0-5].*)
+	ld_shlibs=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not
+*** reliably create shared libraries on SCO systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+_LT_EOF
+	;;
+	*)
+	  # For security reasons, it is highly recommended that you always
+	  # use absolute paths for naming shared libraries, and exclude the
+	  # DT_RUNPATH tag from executables and libraries.  But doing so
+	  # requires that you compile everything twice, which is a pain.
+	  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+	    archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	  else
+	    ld_shlibs=no
+	  fi
+	;;
+      esac
+      ;;
+
+    sunos4*)
+      archive_cmds='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      wlarc=
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    *)
+      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
+    esac
+
+    if test "$ld_shlibs" = no; then
+      runpath_var=
+      hardcode_libdir_flag_spec=
+      export_dynamic_flag_spec=
+      whole_archive_flag_spec=
+    fi
+  else
+    # PORTME fill in a description of your system's linker (not GNU ld)
+    case $host_os in
+    aix3*)
+      allow_undefined_flag=unsupported
+      always_export_symbols=yes
+      archive_expsym_cmds='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'
+      # Note: this linker hardcodes the directories in LIBPATH if there
+      # are no directories specified by -L.
+      hardcode_minus_L=yes
+      if test "$GCC" = yes && test -z "$lt_prog_compiler_static"; then
+	# Neither direct hardcoding nor static linking is supported with a
+	# broken collect2.
+	hardcode_direct=unsupported
+      fi
+      ;;
+
+    aix[4-9]*)
+      if test "$host_cpu" = ia64; then
+	# On IA64, the linker does run time linking by default, so we don't
+	# have to do anything special.
+	aix_use_runtimelinking=no
+	exp_sym_flag='-Bexport'
+	no_entry_flag=""
+      else
+	# If we're using GNU nm, then we don't want the "-C" option.
+	# -C means demangle to AIX nm, but means don't demangle with GNU nm
+	# Also, AIX nm treats weak defined symbols like other global
+	# defined symbols, whereas GNU nm marks them as "W".
+	if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
+	  export_symbols_cmds='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	else
+	  export_symbols_cmds='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	fi
+	aix_use_runtimelinking=no
+
+	# Test if we are trying to use run time linking or normal
+	# AIX style linking. If -brtl is somewhere in LDFLAGS, we
+	# need to do runtime linking.
+	case $host_os in aix4.[23]|aix4.[23].*|aix[5-9]*)
+	  for ld_flag in $LDFLAGS; do
+	  if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
+	    aix_use_runtimelinking=yes
+	    break
+	  fi
+	  done
+	  ;;
+	esac
+
+	exp_sym_flag='-bexport'
+	no_entry_flag='-bnoentry'
+      fi
+
+      # When large executables or shared objects are built, AIX ld can
+      # have problems creating the table of contents.  If linking a library
+      # or program results in "error TOC overflow" add -mminimal-toc to
+      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
+
+      archive_cmds=''
+      hardcode_direct=yes
+      hardcode_direct_absolute=yes
+      hardcode_libdir_separator=':'
+      link_all_deplibs=yes
+      file_list_spec='${wl}-f,'
+
+      if test "$GCC" = yes; then
+	case $host_os in aix4.[012]|aix4.[012].*)
+	# We only want to do this on AIX 4.2 and lower, the check
+	# below for broken collect2 doesn't work under 4.3+
+	  collect2name=`${CC} -print-prog-name=collect2`
+	  if test -f "$collect2name" &&
+	   strings "$collect2name" | $GREP resolve_lib_name >/dev/null
+	  then
+	  # We have reworked collect2
+	  :
+	  else
+	  # We have old collect2
+	  hardcode_direct=unsupported
+	  # It fails to find uninstalled libraries when the uninstalled
+	  # path is not listed in the libpath.  Setting hardcode_minus_L
+	  # to unsupported forces relinking
+	  hardcode_minus_L=yes
+	  hardcode_libdir_flag_spec='-L$libdir'
+	  hardcode_libdir_separator=
+	  fi
+	  ;;
+	esac
+	shared_flag='-shared'
+	if test "$aix_use_runtimelinking" = yes; then
+	  shared_flag="$shared_flag "'${wl}-G'
+	fi
+      else
+	# not using gcc
+	if test "$host_cpu" = ia64; then
+	# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
+	# chokes on -Wl,-G. The following line is correct:
+	  shared_flag='-G'
+	else
+	  if test "$aix_use_runtimelinking" = yes; then
+	    shared_flag='${wl}-G'
+	  else
+	    shared_flag='${wl}-bM:SRE'
+	  fi
+	fi
+      fi
+
+      export_dynamic_flag_spec='${wl}-bexpall'
+      # It seems that -bexpall does not export symbols beginning with
+      # underscore (_), so it is better to generate a list of symbols to export.
+      always_export_symbols=yes
+      if test "$aix_use_runtimelinking" = yes; then
+	# Warning - without using the other runtime loading flags (-brtl),
+	# -berok will link without error, but may produce a broken library.
+	allow_undefined_flag='-berok'
+        # Determine the default libpath from the value encoded in an
+        # empty executable.
+        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+
+lt_aix_libpath_sed='
+    /Import File Strings/,/^$/ {
+	/^0/ {
+	    s/^0  *\(.*\)$/\1/
+	    p
+	}
+    }'
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then
+  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
+
+        hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+        archive_expsym_cmds='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then func_echo_all "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+      else
+	if test "$host_cpu" = ia64; then
+	  hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
+	  allow_undefined_flag="-z nodefs"
+	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+	else
+	 # Determine the default libpath from the value encoded in an
+	 # empty executable.
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+
+lt_aix_libpath_sed='
+    /Import File Strings/,/^$/ {
+	/^0/ {
+	    s/^0  *\(.*\)$/\1/
+	    p
+	}
+    }'
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then
+  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
+
+	 hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+	  # Warning - without using the other run time loading flags,
+	  # -berok will link without error, but may produce a broken library.
+	  no_undefined_flag=' ${wl}-bernotok'
+	  allow_undefined_flag=' ${wl}-berok'
+	  if test "$with_gnu_ld" = yes; then
+	    # We only use this code for GNU lds that support --whole-archive.
+	    whole_archive_flag_spec='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	  else
+	    # Exported symbols can be pulled into shared objects from archives
+	    whole_archive_flag_spec='$convenience'
+	  fi
+	  archive_cmds_need_lc=yes
+	  # This is similar to how AIX traditionally builds its shared libraries.
+	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+	fi
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            archive_expsym_cmds=''
+        ;;
+      m68k)
+            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+            hardcode_libdir_flag_spec='-L$libdir'
+            hardcode_minus_L=yes
+        ;;
+      esac
+      ;;
+
+    bsdi[45]*)
+      export_dynamic_flag_spec=-rdynamic
+      ;;
+
+    cygwin* | mingw* | pw32* | cegcc*)
+      # When not using gcc, we currently assume that we are using
+      # Microsoft Visual C++.
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      hardcode_libdir_flag_spec=' '
+      allow_undefined_flag=unsupported
+      # Tell ltmain to make .lib files, not .a files.
+      libext=lib
+      # Tell ltmain to make .dll files, not .so files.
+      shrext_cmds=".dll"
+      # FIXME: Setting linknames here is a bad hack.
+      archive_cmds='$CC -o $lib $libobjs $compiler_flags `func_echo_all "$deplibs" | $SED '\''s/ -lc$//'\''` -link -dll~linknames='
+      # The linker will automatically build a .lib file if we build a DLL.
+      old_archive_from_new_cmds='true'
+      # FIXME: Should let the user specify the lib program.
+      old_archive_cmds='lib -OUT:$oldlib$oldobjs$old_deplibs'
+      fix_srcfile_path='`cygpath -w "$srcfile"`'
+      enable_shared_with_static_runtimes=yes
+      ;;
+
+    darwin* | rhapsody*)
+
+
+  archive_cmds_need_lc=no
+  hardcode_direct=no
+  hardcode_automatic=yes
+  hardcode_shlibpath_var=unsupported
+  if test "$lt_cv_ld_force_load" = "yes"; then
+    whole_archive_flag_spec='`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience ${wl}-force_load,$conv\"; done; func_echo_all \"$new_convenience\"`'
+  else
+    whole_archive_flag_spec=''
+  fi
+  link_all_deplibs=yes
+  allow_undefined_flag="$_lt_dar_allow_undefined"
+  case $cc_basename in
+     ifort*) _lt_dar_can_shared=yes ;;
+     *) _lt_dar_can_shared=$GCC ;;
+  esac
+  if test "$_lt_dar_can_shared" = "yes"; then
+    output_verbose_link_cmd=func_echo_all
+    archive_cmds="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
+    module_cmds="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
+    archive_expsym_cmds="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
+    module_expsym_cmds="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
+
+  else
+  ld_shlibs=no
+  fi
+
+      ;;
+
+    dgux*)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_shlibpath_var=no
+      ;;
+
+    freebsd1*)
+      ld_shlibs=no
+      ;;
+
+    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor
+    # support.  Future versions do this automatically, but an explicit c++rt0.o
+    # does not break anything, and helps significantly (at the cost of a little
+    # extra space).
+    freebsd2.2*)
+      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    # Unfortunately, older versions of FreeBSD 2 do not have this feature.
+    freebsd2*)
+      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
+    freebsd* | dragonfly*)
+      archive_cmds='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    hpux9*)
+      if test "$GCC" = yes; then
+	archive_cmds='$RM $output_objdir/$soname~$CC -shared -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      else
+	archive_cmds='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      fi
+      hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+      hardcode_libdir_separator=:
+      hardcode_direct=yes
+
+      # hardcode_minus_L: Not really in the search PATH,
+      # but as the default location of the library.
+      hardcode_minus_L=yes
+      export_dynamic_flag_spec='${wl}-E'
+      ;;
+
+    hpux10*)
+      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
+	archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      if test "$with_gnu_ld" = no; then
+	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+	hardcode_libdir_flag_spec_ld='+b $libdir'
+	hardcode_libdir_separator=:
+	hardcode_direct=yes
+	hardcode_direct_absolute=yes
+	export_dynamic_flag_spec='${wl}-E'
+	# hardcode_minus_L: Not really in the search PATH,
+	# but as the default location of the library.
+	hardcode_minus_L=yes
+      fi
+      ;;
+
+    hpux11*)
+      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
+	case $host_cpu in
+	hppa*64*)
+	  archive_cmds='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	esac
+      else
+	case $host_cpu in
+	hppa*64*)
+	  archive_cmds='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+
+	  # Older versions of the 11.00 compiler do not understand -b yet
+	  # (HP92453-01 A.11.01.20 doesn't, HP92453-01 B.11.X.35175-35176.GP does)
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $CC understands -b" >&5
+$as_echo_n "checking if $CC understands -b... " >&6; }
+if test "${lt_cv_prog_compiler__b+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler__b=no
+   save_LDFLAGS="$LDFLAGS"
+   LDFLAGS="$LDFLAGS -b"
+   echo "$lt_simple_link_test_code" > conftest.$ac_ext
+   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
+     # The linker can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     if test -s conftest.err; then
+       # Append any errors to the config.log.
+       cat conftest.err 1>&5
+       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
+       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+       if diff conftest.exp conftest.er2 >/dev/null; then
+         lt_cv_prog_compiler__b=yes
+       fi
+     else
+       lt_cv_prog_compiler__b=yes
+     fi
+   fi
+   $RM -r conftest*
+   LDFLAGS="$save_LDFLAGS"
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler__b" >&5
+$as_echo "$lt_cv_prog_compiler__b" >&6; }
+
+if test x"$lt_cv_prog_compiler__b" = xyes; then
+    archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+else
+    archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
+fi
+
+	  ;;
+	esac
+      fi
+      if test "$with_gnu_ld" = no; then
+	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+	hardcode_libdir_separator=:
+
+	case $host_cpu in
+	hppa*64*|ia64*)
+	  hardcode_direct=no
+	  hardcode_shlibpath_var=no
+	  ;;
+	*)
+	  hardcode_direct=yes
+	  hardcode_direct_absolute=yes
+	  export_dynamic_flag_spec='${wl}-E'
+
+	  # hardcode_minus_L: Not really in the search PATH,
+	  # but as the default location of the library.
+	  hardcode_minus_L=yes
+	  ;;
+	esac
+      fi
+      ;;
+
+    irix5* | irix6* | nonstopux*)
+      if test "$GCC" = yes; then
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	# Try to use the -exported_symbol ld option, if it does not
+	# work, assume that -exports_file does not work either and
+	# implicitly export all symbols.
+        save_LDFLAGS="$LDFLAGS"
+        LDFLAGS="$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null"
+        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int foo(void) {}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'
+
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+        LDFLAGS="$save_LDFLAGS"
+      else
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'
+      fi
+      archive_cmds_need_lc='no'
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      inherit_rpath=yes
+      link_all_deplibs=yes
+      ;;
+
+    netbsd*)
+      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
+      else
+	archive_cmds='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF
+      fi
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    newsos6)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_direct=yes
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      hardcode_shlibpath_var=no
+      ;;
+
+    *nto* | *qnx*)
+      ;;
+
+    openbsd*)
+      if test -f /usr/libexec/ld.so; then
+	hardcode_direct=yes
+	hardcode_shlibpath_var=no
+	hardcode_direct_absolute=yes
+	if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+	  archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_expsym_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'
+	  hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+	  export_dynamic_flag_spec='${wl}-E'
+	else
+	  case $host_os in
+	   openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
+	     archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+	     hardcode_libdir_flag_spec='-R$libdir'
+	     ;;
+	   *)
+	     archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	     hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+	     ;;
+	  esac
+	fi
+      else
+	ld_shlibs=no
+      fi
+      ;;
+
+    os2*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      allow_undefined_flag=unsupported
+      archive_cmds='$ECHO "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~echo DATA >> $output_objdir/$libname.def~echo " SINGLE NONSHARED" >> $output_objdir/$libname.def~echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
+      old_archive_from_new_cmds='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
+      ;;
+
+    osf3*)
+      if test "$GCC" = yes; then
+	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      else
+	allow_undefined_flag=' -expect_unresolved \*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+      fi
+      archive_cmds_need_lc='no'
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+
+    osf4* | osf5*)	# as osf3* with the addition of -msym flag
+      if test "$GCC" = yes; then
+	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      else
+	allow_undefined_flag=' -expect_unresolved \*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	archive_expsym_cmds='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done; printf "%s\\n" "-hidden">> $lib.exp~
+	$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'
+
+	# Both c and cxx compiler support -rpath directly
+	hardcode_libdir_flag_spec='-rpath $libdir'
+      fi
+      archive_cmds_need_lc='no'
+      hardcode_libdir_separator=:
+      ;;
+
+    solaris*)
+      no_undefined_flag=' -z defs'
+      if test "$GCC" = yes; then
+	wlarc='${wl}'
+	archive_cmds='$CC -shared ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $CC -shared ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+      else
+	case `$CC -V 2>&1` in
+	*"Compilers 5.0"*)
+	  wlarc=''
+	  archive_cmds='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'
+	  ;;
+	*)
+	  wlarc='${wl}'
+	  archive_cmds='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+	  ;;
+	esac
+      fi
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_shlibpath_var=no
+      case $host_os in
+      solaris2.[0-5] | solaris2.[0-5].*) ;;
+      *)
+	# The compiler driver will combine and reorder linker options,
+	# but understands `-z linker_flag'.  GCC discards it without `$wl',
+	# but is careful enough not to reorder.
+	# Supported since Solaris 2.6 (maybe 2.5.1?)
+	if test "$GCC" = yes; then
+	  whole_archive_flag_spec='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
+	else
+	  whole_archive_flag_spec='-z allextract$convenience -z defaultextract'
+	fi
+	;;
+      esac
+      link_all_deplibs=yes
+      ;;
+
+    sunos4*)
+      if test "x$host_vendor" = xsequent; then
+	# Use $CC to link under sequent, because it throws in some extra .o
+	# files that make .init and .fini sections work.
+	archive_cmds='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    sysv4)
+      case $host_vendor in
+	sni)
+	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  hardcode_direct=yes # is this really true???
+	;;
+	siemens)
+	  ## LD is ld it makes a PLAMLIB
+	  ## CC just makes a GrossModule.
+	  archive_cmds='$LD -G -o $lib $libobjs $deplibs $linker_flags'
+	  reload_cmds='$CC -r -o $output$reload_objs'
+	  hardcode_direct=no
+        ;;
+	motorola)
+	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  hardcode_direct=no #Motorola manual says yes, but my tests say they lie
+	;;
+      esac
+      runpath_var='LD_RUN_PATH'
+      hardcode_shlibpath_var=no
+      ;;
+
+    sysv4.3*)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_shlibpath_var=no
+      export_dynamic_flag_spec='-Bexport'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	hardcode_shlibpath_var=no
+	runpath_var=LD_RUN_PATH
+	hardcode_runpath_var=yes
+	ld_shlibs=yes
+      fi
+      ;;
+
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)
+      no_undefined_flag='${wl}-z,text'
+      archive_cmds_need_lc=no
+      hardcode_shlibpath_var=no
+      runpath_var='LD_RUN_PATH'
+
+      if test "$GCC" = yes; then
+	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
+
+    sysv5* | sco3.2v5* | sco5v6*)
+      # Note: We can NOT use -z defs as we might desire, because we do not
+      # link with -lc, and that would cause any symbols used from libc to
+      # always be unresolved, which means just about no library would
+      # ever link correctly.  If we're not using GNU ld we use -z text
+      # though, which does catch some bad symbols but isn't as heavy-handed
+      # as -z defs.
+      no_undefined_flag='${wl}-z,text'
+      allow_undefined_flag='${wl}-z,nodefs'
+      archive_cmds_need_lc=no
+      hardcode_shlibpath_var=no
+      hardcode_libdir_flag_spec='${wl}-R,$libdir'
+      hardcode_libdir_separator=':'
+      link_all_deplibs=yes
+      export_dynamic_flag_spec='${wl}-Bexport'
+      runpath_var='LD_RUN_PATH'
+
+      if test "$GCC" = yes; then
+	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
+
+    uts4*)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_shlibpath_var=no
+      ;;
+
+    *)
+      ld_shlibs=no
+      ;;
+    esac
+
+    if test x$host_vendor = xsni; then
+      case $host in
+      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
+	export_dynamic_flag_spec='${wl}-Blargedynsym'
+	;;
+      esac
+    fi
+  fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs" >&5
+$as_echo "$ld_shlibs" >&6; }
+test "$ld_shlibs" = no && can_build_shared=no
+
+with_gnu_ld=$with_gnu_ld
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#
+# Do we need to explicitly link libc?
+#
+case "x$archive_cmds_need_lc" in
+x|xyes)
+  # Assume -lc should be added
+  archive_cmds_need_lc=yes
+
+  if test "$enable_shared" = yes && test "$GCC" = yes; then
+    case $archive_cmds in
+    *'~'*)
+      # FIXME: we may have to deal with multi-command sequences.
+      ;;
+    '$CC '*)
+      # Test whether the compiler implicitly links with -lc since on some
+      # systems, -lgcc has to come before -lc. If gcc already passes -lc
+      # to ld, don't add -lc before -lgcc.
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -lc should be explicitly linked in" >&5
+$as_echo_n "checking whether -lc should be explicitly linked in... " >&6; }
+if test "${lt_cv_archive_cmds_need_lc+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  $RM conftest*
+	echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+	if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } 2>conftest.err; then
+	  soname=conftest
+	  lib=conftest
+	  libobjs=conftest.$ac_objext
+	  deplibs=
+	  wl=$lt_prog_compiler_wl
+	  pic_flag=$lt_prog_compiler_pic
+	  compiler_flags=-v
+	  linker_flags=-v
+	  verstring=
+	  output_objdir=.
+	  libname=conftest
+	  lt_save_allow_undefined_flag=$allow_undefined_flag
+	  allow_undefined_flag=
+	  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1\""; } >&5
+  (eval $archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+	  then
+	    lt_cv_archive_cmds_need_lc=no
+	  else
+	    lt_cv_archive_cmds_need_lc=yes
+	  fi
+	  allow_undefined_flag=$lt_save_allow_undefined_flag
+	else
+	  cat conftest.err 1>&5
+	fi
+	$RM conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_archive_cmds_need_lc" >&5
+$as_echo "$lt_cv_archive_cmds_need_lc" >&6; }
+      archive_cmds_need_lc=$lt_cv_archive_cmds_need_lc
+      ;;
+    esac
+  fi
+  ;;
+esac
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking dynamic linker characteristics" >&5
+$as_echo_n "checking dynamic linker characteristics... " >&6; }
+
+if test "$GCC" = yes; then
+  case $host_os in
+    darwin*) lt_awk_arg="/^libraries:/,/LR/" ;;
+    *) lt_awk_arg="/^libraries:/" ;;
+  esac
+  case $host_os in
+    mingw* | cegcc*) lt_sed_strip_eq="s,=\([A-Za-z]:\),\1,g" ;;
+    *) lt_sed_strip_eq="s,=/,/,g" ;;
+  esac
+  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e "s/^libraries://" -e $lt_sed_strip_eq`
+  case $lt_search_path_spec in
+  *\;*)
+    # if the path contains ";" then we assume it to be the separator
+    # otherwise default to the standard path separator (i.e. ":") - it is
+    # assumed that no part of a normal pathname contains ";" but that should
+    # okay in the real world where ";" in dirpaths is itself problematic.
+    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED 's/;/ /g'`
+    ;;
+  *)
+    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED "s/$PATH_SEPARATOR/ /g"`
+    ;;
+  esac
+  # Ok, now we have the path, separated by spaces, we can step through it
+  # and add multilib dir if necessary.
+  lt_tmp_lt_search_path_spec=
+  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`
+  for lt_sys_path in $lt_search_path_spec; do
+    if test -d "$lt_sys_path/$lt_multi_os_dir"; then
+      lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir"
+    else
+      test -d "$lt_sys_path" && \
+	lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path"
+    fi
+  done
+  lt_search_path_spec=`$ECHO "$lt_tmp_lt_search_path_spec" | awk '
+BEGIN {RS=" "; FS="/|\n";} {
+  lt_foo="";
+  lt_count=0;
+  for (lt_i = NF; lt_i > 0; lt_i--) {
+    if ($lt_i != "" && $lt_i != ".") {
+      if ($lt_i == "..") {
+        lt_count++;
+      } else {
+        if (lt_count == 0) {
+          lt_foo="/" $lt_i lt_foo;
+        } else {
+          lt_count--;
+        }
+      }
+    }
+  }
+  if (lt_foo != "") { lt_freq[lt_foo]++; }
+  if (lt_freq[lt_foo] == 1) { print lt_foo; }
+}'`
+  # AWK program above erroneously prepends '/' to C:/dos/paths
+  # for these hosts.
+  case $host_os in
+    mingw* | cegcc*) lt_search_path_spec=`$ECHO "$lt_search_path_spec" |\
+      $SED 's,/\([A-Za-z]:\),\1,g'` ;;
+  esac
+  sys_lib_search_path_spec=`$ECHO "$lt_search_path_spec" | $lt_NL2SP`
+else
+  sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
+fi
+library_names_spec=
+libname_spec='lib$name'
+soname_spec=
+shrext_cmds=".so"
+postinstall_cmds=
+postuninstall_cmds=
+finish_cmds=
+finish_eval=
+shlibpath_var=
+shlibpath_overrides_runpath=unknown
+version_type=none
+dynamic_linker="$host_os ld.so"
+sys_lib_dlsearch_path_spec="/lib /usr/lib"
+need_lib_prefix=unknown
+hardcode_into_libs=no
+
+# when you set need_version to no, make sure it does not cause -set_version
+# flags to be left without arguments
+need_version=unknown
+
+case $host_os in
+aix3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
+  shlibpath_var=LIBPATH
+
+  # AIX 3 has no versioning support, so we append a major version to the name.
+  soname_spec='${libname}${release}${shared_ext}$major'
+  ;;
+
+aix[4-9]*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  hardcode_into_libs=yes
+  if test "$host_cpu" = ia64; then
+    # AIX 5 supports IA64
+    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+    shlibpath_var=LD_LIBRARY_PATH
+  else
+    # With GCC up to 2.95.x, collect2 would create an import file
+    # for dependence libraries.  The import file would start with
+    # the line `#! .'.  This would cause the generated library to
+    # depend on `.', always an invalid library.  This was fixed in
+    # development snapshots of GCC prior to 3.0.
+    case $host_os in
+      aix4 | aix4.[01] | aix4.[01].*)
+      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
+	   echo ' yes '
+	   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then
+	:
+      else
+	can_build_shared=no
+      fi
+      ;;
+    esac
+    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
+    # soname into executable. Probably we can add versioning support to
+    # collect2, so additional links can be useful in future.
+    if test "$aix_use_runtimelinking" = yes; then
+      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
+      # instead of lib<name>.a to let people know that these are not
+      # typical AIX shared libraries.
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    else
+      # We preserve .a as extension for shared libraries through AIX4.2
+      # and later when we are not doing run time linking.
+      library_names_spec='${libname}${release}.a $libname.a'
+      soname_spec='${libname}${release}${shared_ext}$major'
+    fi
+    shlibpath_var=LIBPATH
+  fi
+  ;;
+
+amigaos*)
+  case $host_cpu in
+  powerpc)
+    # Since July 2007 AmigaOS4 officially supports .so libraries.
+    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    ;;
+  m68k)
+    library_names_spec='$libname.ixlibrary $libname.a'
+    # Create ${libname}_ixlibrary.a entries in /sys/libs.
+    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all "$lib" | $SED '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
+    ;;
+  esac
+  ;;
+
+beos*)
+  library_names_spec='${libname}${shared_ext}'
+  dynamic_linker="$host_os ld.so"
+  shlibpath_var=LIBRARY_PATH
+  ;;
+
+bsdi[45]*)
+  version_type=linux
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
+  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
+  # the default ld.so.conf also contains /usr/contrib/lib and
+  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
+  # libtool to hard-code these into programs
+  ;;
+
+cygwin* | mingw* | pw32* | cegcc*)
+  version_type=windows
+  shrext_cmds=".dll"
+  need_version=no
+  need_lib_prefix=no
+
+  case $GCC,$host_os in
+  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+    library_names_spec='$libname.dll.a'
+    # DLL is installed to $(libdir)/../bin by postinstall_cmds
+    postinstall_cmds='base_file=`basename \${file}`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
+      dldir=$destdir/`dirname \$dlpath`~
+      test -d \$dldir || mkdir -p \$dldir~
+      $install_prog $dir/$dlname \$dldir/$dlname~
+      chmod a+x \$dldir/$dlname~
+      if test -n '\''$stripme'\'' && test -n '\''$striplib'\''; then
+        eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
+      fi'
+    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
+      dlpath=$dir/\$dldll~
+       $RM \$dlpath'
+    shlibpath_overrides_runpath=yes
+
+    case $host_os in
+    cygwin*)
+      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
+      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+
+      sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
+      ;;
+    mingw* | cegcc*)
+      # MinGW DLLs use traditional 'lib' prefix
+      soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    pw32*)
+      # pw32 DLLs use 'pw' prefix rather than 'lib'
+      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    esac
+    ;;
+
+  *)
+    library_names_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext} $libname.lib'
+    ;;
+  esac
+  dynamic_linker='Win32 ld.exe'
+  # FIXME: first we should search . and the directory the executable is in
+  shlibpath_var=PATH
+  ;;
+
+darwin* | rhapsody*)
+  dynamic_linker="$host_os dyld"
+  version_type=darwin
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
+  soname_spec='${libname}${release}${major}$shared_ext'
+  shlibpath_overrides_runpath=yes
+  shlibpath_var=DYLD_LIBRARY_PATH
+  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
+
+  sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/local/lib"
+  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'
+  ;;
+
+dgux*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+freebsd1*)
+  dynamic_linker=no
+  ;;
+
+freebsd* | dragonfly*)
+  # DragonFly does not have aout.  When/if they implement a new
+  # versioning mechanism, adjust this.
+  if test -x /usr/bin/objformat; then
+    objformat=`/usr/bin/objformat`
+  else
+    case $host_os in
+    freebsd[123]*) objformat=aout ;;
+    *) objformat=elf ;;
+    esac
+  fi
+  version_type=freebsd-$objformat
+  case $version_type in
+    freebsd-elf*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+      need_version=no
+      need_lib_prefix=no
+      ;;
+    freebsd-*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
+      need_version=yes
+      ;;
+  esac
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_os in
+  freebsd2*)
+    shlibpath_overrides_runpath=yes
+    ;;
+  freebsd3.[01]* | freebsdelf3.[01]*)
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  freebsd3.[2-9]* | freebsdelf3.[2-9]* | \
+  freebsd4.[0-5] | freebsdelf4.[0-5] | freebsd4.1.1 | freebsdelf4.1.1)
+    shlibpath_overrides_runpath=no
+    hardcode_into_libs=yes
+    ;;
+  *) # from 4.6 on, and DragonFly
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  esac
+  ;;
+
+gnu*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  hardcode_into_libs=yes
+  ;;
+
+haiku*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  dynamic_linker="$host_os runtime_loader"
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/system/lib'
+  hardcode_into_libs=yes
+  ;;
+
+hpux9* | hpux10* | hpux11*)
+  # Give a soname corresponding to the major version so that dld.sl refuses to
+  # link against other versions.
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  case $host_cpu in
+  ia64*)
+    shrext_cmds='.so'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.so"
+    shlibpath_var=LD_LIBRARY_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    if test "X$HPUX_IA64_MODE" = X32; then
+      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
+    else
+      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
+    fi
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  hppa*64*)
+    shrext_cmds='.sl'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  *)
+    shrext_cmds='.sl'
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=SHLIB_PATH
+    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    ;;
+  esac
+  # HP-UX runs *really* slowly unless shared libraries are mode 555, ...
+  postinstall_cmds='chmod 555 $lib'
+  # or fails outright, so override atomically:
+  install_override_mode=555
+  ;;
+
+interix[3-9]*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $host_os in
+    nonstopux*) version_type=nonstopux ;;
+    *)
+	if test "$lt_cv_prog_gnu_ld" = yes; then
+		version_type=linux
+	else
+		version_type=irix
+	fi ;;
+  esac
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
+  case $host_os in
+  irix5* | nonstopux*)
+    libsuff= shlibsuff=
+    ;;
+  *)
+    case $LD in # libtool.m4 will add one of these switches to LD
+    *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ")
+      libsuff= shlibsuff= libmagic=32-bit;;
+    *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ")
+      libsuff=32 shlibsuff=N32 libmagic=N32;;
+    *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ")
+      libsuff=64 shlibsuff=64 libmagic=64-bit;;
+    *) libsuff= shlibsuff= libmagic=never-match;;
+    esac
+    ;;
+  esac
+  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
+  shlibpath_overrides_runpath=no
+  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
+  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
+  hardcode_into_libs=yes
+  ;;
+
+# No shared lib support for Linux oldld, aout, or coff.
+linux*oldld* | linux*aout* | linux*coff*)
+  dynamic_linker=no
+  ;;
+
+# This must be Linux ELF.
+linux* | k*bsd*-gnu | kopensolaris*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+
+  # Some binutils ld are patched to set DT_RUNPATH
+  if test "${lt_cv_shlibpath_overrides_runpath+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_shlibpath_overrides_runpath=no
+    save_LDFLAGS=$LDFLAGS
+    save_libdir=$libdir
+    eval "libdir=/foo; wl=\"$lt_prog_compiler_wl\"; \
+	 LDFLAGS=\"\$LDFLAGS $hardcode_libdir_flag_spec\""
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  if  ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null; then :
+  lt_cv_shlibpath_overrides_runpath=yes
+fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+    LDFLAGS=$save_LDFLAGS
+    libdir=$save_libdir
+
+fi
+
+  shlibpath_overrides_runpath=$lt_cv_shlibpath_overrides_runpath
+
+  # This implies no fast_install, which is unacceptable.
+  # Some rework will be needed to allow for fast_install
+  # before this can be enabled.
+  hardcode_into_libs=yes
+
+  # Append ld.so.conf contents to the search path
+  if test -f /etc/ld.so.conf; then
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/"//g;/^$/d' | tr '\n' ' '`
+    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
+  fi
+
+  # We used to test for /lib/ld.so.1 and disable shared libraries on
+  # powerpc, because MkLinux only supported shared libraries with the
+  # GNU dynamic linker.  Since this was broken with cross compilers,
+  # most powerpc-linux boxes support dynamic linking these days and
+  # people can always --disable-shared, the test was removed, and we
+  # assume the GNU/Linux dynamic linker is in use.
+  dynamic_linker='GNU/Linux ld.so'
+  ;;
+
+netbsd*)
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+    dynamic_linker='NetBSD (a.out) ld.so'
+  else
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    dynamic_linker='NetBSD ld.elf_so'
+  fi
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  ;;
+
+newsos6)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  ;;
+
+*nto* | *qnx*)
+  version_type=qnx
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='ldqnx.so'
+  ;;
+
+openbsd*)
+  version_type=sunos
+  sys_lib_dlsearch_path_spec="/usr/lib"
+  need_lib_prefix=no
+  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
+  case $host_os in
+    openbsd3.3 | openbsd3.3.*)	need_version=yes ;;
+    *)				need_version=no  ;;
+  esac
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    case $host_os in
+      openbsd2.[89] | openbsd2.[89].*)
+	shlibpath_overrides_runpath=no
+	;;
+      *)
+	shlibpath_overrides_runpath=yes
+	;;
+      esac
+  else
+    shlibpath_overrides_runpath=yes
+  fi
+  ;;
+
+os2*)
+  libname_spec='$name'
+  shrext_cmds=".dll"
+  need_lib_prefix=no
+  library_names_spec='$libname${shared_ext} $libname.a'
+  dynamic_linker='OS/2 ld.exe'
+  shlibpath_var=LIBPATH
+  ;;
+
+osf3* | osf4* | osf5*)
+  version_type=osf
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
+  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
+  ;;
+
+rdos*)
+  dynamic_linker=no
+  ;;
+
+solaris*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  # ldd complains unless libraries are executable
+  postinstall_cmds='chmod +x $lib'
+  ;;
+
+sunos4*)
+  version_type=sunos
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  if test "$with_gnu_ld" = yes; then
+    need_lib_prefix=no
+  fi
+  need_version=yes
+  ;;
+
+sysv4 | sysv4.3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_vendor in
+    sni)
+      shlibpath_overrides_runpath=no
+      need_lib_prefix=no
+      runpath_var=LD_RUN_PATH
+      ;;
+    siemens)
+      need_lib_prefix=no
+      ;;
+    motorola)
+      need_lib_prefix=no
+      need_version=no
+      shlibpath_overrides_runpath=no
+      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
+      ;;
+  esac
+  ;;
+
+sysv4*MP*)
+  if test -d /usr/nec ;then
+    version_type=linux
+    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
+    soname_spec='$libname${shared_ext}.$major'
+    shlibpath_var=LD_LIBRARY_PATH
+  fi
+  ;;
+
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  version_type=freebsd-elf
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  if test "$with_gnu_ld" = yes; then
+    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
+  else
+    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
+    case $host_os in
+      sco3.2v5*)
+        sys_lib_search_path_spec="$sys_lib_search_path_spec /lib"
+	;;
+    esac
+  fi
+  sys_lib_dlsearch_path_spec='/usr/lib'
+  ;;
+
+tpf*)
+  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+uts4*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+*)
+  dynamic_linker=no
+  ;;
+esac
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $dynamic_linker" >&5
+$as_echo "$dynamic_linker" >&6; }
+test "$dynamic_linker" = no && can_build_shared=no
+
+variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
+if test "$GCC" = yes; then
+  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
+fi
+
+if test "${lt_cv_sys_lib_search_path_spec+set}" = set; then
+  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
+fi
+if test "${lt_cv_sys_lib_dlsearch_path_spec+set}" = set; then
+  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking how to hardcode library paths into programs" >&5
+$as_echo_n "checking how to hardcode library paths into programs... " >&6; }
+hardcode_action=
+if test -n "$hardcode_libdir_flag_spec" ||
+   test -n "$runpath_var" ||
+   test "X$hardcode_automatic" = "Xyes" ; then
+
+  # We can hardcode non-existent directories.
+  if test "$hardcode_direct" != no &&
+     # If the only mechanism to avoid hardcoding is shlibpath_var, we
+     # have to relink, otherwise we might link with an installed library
+     # when we should be linking with a yet-to-be-installed one
+     ## test "$_LT_TAGVAR(hardcode_shlibpath_var, )" != no &&
+     test "$hardcode_minus_L" != no; then
+    # Linking always hardcodes the temporary library directory.
+    hardcode_action=relink
+  else
+    # We can link without hardcoding, and we can hardcode nonexisting dirs.
+    hardcode_action=immediate
+  fi
+else
+  # We cannot hardcode anything, or else we can only hardcode existing
+  # directories.
+  hardcode_action=unsupported
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $hardcode_action" >&5
+$as_echo "$hardcode_action" >&6; }
+
+if test "$hardcode_action" = relink ||
+   test "$inherit_rpath" = yes; then
+  # Fast installation is not supported
+  enable_fast_install=no
+elif test "$shlibpath_overrides_runpath" = yes ||
+     test "$enable_shared" = no; then
+  # Fast installation is not necessary
+  enable_fast_install=needless
+fi
+
+
+
+
+
+
+  if test "x$enable_dlopen" != xyes; then
+  enable_dlopen=unknown
+  enable_dlopen_self=unknown
+  enable_dlopen_self_static=unknown
+else
+  lt_cv_dlopen=no
+  lt_cv_dlopen_libs=
+
+  case $host_os in
+  beos*)
+    lt_cv_dlopen="load_add_on"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+    ;;
+
+  mingw* | pw32* | cegcc*)
+    lt_cv_dlopen="LoadLibrary"
+    lt_cv_dlopen_libs=
+    ;;
+
+  cygwin*)
+    lt_cv_dlopen="dlopen"
+    lt_cv_dlopen_libs=
+    ;;
+
+  darwin*)
+  # if libdl is installed we need to link against it
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
+$as_echo_n "checking for dlopen in -ldl... " >&6; }
+if test "${ac_cv_lib_dl_dlopen+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dl_dlopen=yes
+else
+  ac_cv_lib_dl_dlopen=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
+$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
+if test "x$ac_cv_lib_dl_dlopen" = x""yes; then :
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
+else
+
+    lt_cv_dlopen="dyld"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+
+fi
+
+    ;;
+
+  *)
+    ac_fn_c_check_func "$LINENO" "shl_load" "ac_cv_func_shl_load"
+if test "x$ac_cv_func_shl_load" = x""yes; then :
+  lt_cv_dlopen="shl_load"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for shl_load in -ldld" >&5
+$as_echo_n "checking for shl_load in -ldld... " >&6; }
+if test "${ac_cv_lib_dld_shl_load+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldld  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char shl_load ();
+int
+main ()
+{
+return shl_load ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dld_shl_load=yes
+else
+  ac_cv_lib_dld_shl_load=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_shl_load" >&5
+$as_echo "$ac_cv_lib_dld_shl_load" >&6; }
+if test "x$ac_cv_lib_dld_shl_load" = x""yes; then :
+  lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-ldld"
+else
+  ac_fn_c_check_func "$LINENO" "dlopen" "ac_cv_func_dlopen"
+if test "x$ac_cv_func_dlopen" = x""yes; then :
+  lt_cv_dlopen="dlopen"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
+$as_echo_n "checking for dlopen in -ldl... " >&6; }
+if test "${ac_cv_lib_dl_dlopen+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dl_dlopen=yes
+else
+  ac_cv_lib_dl_dlopen=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
+$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
+if test "x$ac_cv_lib_dl_dlopen" = x""yes; then :
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -lsvld" >&5
+$as_echo_n "checking for dlopen in -lsvld... " >&6; }
+if test "${ac_cv_lib_svld_dlopen+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsvld  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_svld_dlopen=yes
+else
+  ac_cv_lib_svld_dlopen=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_svld_dlopen" >&5
+$as_echo "$ac_cv_lib_svld_dlopen" >&6; }
+if test "x$ac_cv_lib_svld_dlopen" = x""yes; then :
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dld_link in -ldld" >&5
+$as_echo_n "checking for dld_link in -ldld... " >&6; }
+if test "${ac_cv_lib_dld_dld_link+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldld  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dld_link ();
+int
+main ()
+{
+return dld_link ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dld_dld_link=yes
+else
+  ac_cv_lib_dld_dld_link=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_dld_link" >&5
+$as_echo "$ac_cv_lib_dld_dld_link" >&6; }
+if test "x$ac_cv_lib_dld_dld_link" = x""yes; then :
+  lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-ldld"
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+    ;;
+  esac
+
+  if test "x$lt_cv_dlopen" != xno; then
+    enable_dlopen=yes
+  else
+    enable_dlopen=no
+  fi
+
+  case $lt_cv_dlopen in
+  dlopen)
+    save_CPPFLAGS="$CPPFLAGS"
+    test "x$ac_cv_header_dlfcn_h" = xyes && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
+
+    save_LDFLAGS="$LDFLAGS"
+    wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
+
+    save_LIBS="$LIBS"
+    LIBS="$lt_cv_dlopen_libs $LIBS"
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a program can dlopen itself" >&5
+$as_echo_n "checking whether a program can dlopen itself... " >&6; }
+if test "${lt_cv_dlopen_self+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  	  if test "$cross_compiling" = yes; then :
+  lt_cv_dlopen_self=cross
+else
+  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+  lt_status=$lt_dlunknown
+  cat > conftest.$ac_ext <<_LT_EOF
+#line $LINENO "configure"
+#include "confdefs.h"
+
+#if HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
+
+#include <stdio.h>
+
+#ifdef RTLD_GLOBAL
+#  define LT_DLGLOBAL		RTLD_GLOBAL
+#else
+#  ifdef DL_GLOBAL
+#    define LT_DLGLOBAL		DL_GLOBAL
+#  else
+#    define LT_DLGLOBAL		0
+#  endif
+#endif
+
+/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#ifndef LT_DLLAZY_OR_NOW
+#  ifdef RTLD_LAZY
+#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
+#  else
+#    ifdef DL_LAZY
+#      define LT_DLLAZY_OR_NOW		DL_LAZY
+#    else
+#      ifdef RTLD_NOW
+#        define LT_DLLAZY_OR_NOW	RTLD_NOW
+#      else
+#        ifdef DL_NOW
+#          define LT_DLLAZY_OR_NOW	DL_NOW
+#        else
+#          define LT_DLLAZY_OR_NOW	0
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+
+/* When -fvisbility=hidden is used, assume the code has been annotated
+   correspondingly for the symbols needed.  */
+#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
+void fnord () __attribute__((visibility("default")));
+#endif
+
+void fnord () { int i=42; }
+int main ()
+{
+  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
+  int status = $lt_dlunknown;
+
+  if (self)
+    {
+      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
+      else
+        {
+	  if (dlsym( self,"_fnord"))  status = $lt_dlneed_uscore;
+          else puts (dlerror ());
+	}
+      /* dlclose (self); */
+    }
+  else
+    puts (dlerror ());
+
+  return status;
+}
+_LT_EOF
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
+    (./conftest; exit; ) >&5 2>/dev/null
+    lt_status=$?
+    case x$lt_status in
+      x$lt_dlno_uscore) lt_cv_dlopen_self=yes ;;
+      x$lt_dlneed_uscore) lt_cv_dlopen_self=yes ;;
+      x$lt_dlunknown|x*) lt_cv_dlopen_self=no ;;
+    esac
+  else :
+    # compilation failed
+    lt_cv_dlopen_self=no
+  fi
+fi
+rm -fr conftest*
+
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self" >&5
+$as_echo "$lt_cv_dlopen_self" >&6; }
+
+    if test "x$lt_cv_dlopen_self" = xyes; then
+      wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $lt_prog_compiler_static\"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a statically linked program can dlopen itself" >&5
+$as_echo_n "checking whether a statically linked program can dlopen itself... " >&6; }
+if test "${lt_cv_dlopen_self_static+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  	  if test "$cross_compiling" = yes; then :
+  lt_cv_dlopen_self_static=cross
+else
+  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+  lt_status=$lt_dlunknown
+  cat > conftest.$ac_ext <<_LT_EOF
+#line $LINENO "configure"
+#include "confdefs.h"
+
+#if HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
+
+#include <stdio.h>
+
+#ifdef RTLD_GLOBAL
+#  define LT_DLGLOBAL		RTLD_GLOBAL
+#else
+#  ifdef DL_GLOBAL
+#    define LT_DLGLOBAL		DL_GLOBAL
+#  else
+#    define LT_DLGLOBAL		0
+#  endif
+#endif
+
+/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#ifndef LT_DLLAZY_OR_NOW
+#  ifdef RTLD_LAZY
+#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
+#  else
+#    ifdef DL_LAZY
+#      define LT_DLLAZY_OR_NOW		DL_LAZY
+#    else
+#      ifdef RTLD_NOW
+#        define LT_DLLAZY_OR_NOW	RTLD_NOW
+#      else
+#        ifdef DL_NOW
+#          define LT_DLLAZY_OR_NOW	DL_NOW
+#        else
+#          define LT_DLLAZY_OR_NOW	0
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+
+/* When -fvisbility=hidden is used, assume the code has been annotated
+   correspondingly for the symbols needed.  */
+#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
+void fnord () __attribute__((visibility("default")));
+#endif
+
+void fnord () { int i=42; }
+int main ()
+{
+  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
+  int status = $lt_dlunknown;
+
+  if (self)
+    {
+      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
+      else
+        {
+	  if (dlsym( self,"_fnord"))  status = $lt_dlneed_uscore;
+          else puts (dlerror ());
+	}
+      /* dlclose (self); */
+    }
+  else
+    puts (dlerror ());
+
+  return status;
+}
+_LT_EOF
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
+    (./conftest; exit; ) >&5 2>/dev/null
+    lt_status=$?
+    case x$lt_status in
+      x$lt_dlno_uscore) lt_cv_dlopen_self_static=yes ;;
+      x$lt_dlneed_uscore) lt_cv_dlopen_self_static=yes ;;
+      x$lt_dlunknown|x*) lt_cv_dlopen_self_static=no ;;
+    esac
+  else :
+    # compilation failed
+    lt_cv_dlopen_self_static=no
+  fi
+fi
+rm -fr conftest*
+
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self_static" >&5
+$as_echo "$lt_cv_dlopen_self_static" >&6; }
+    fi
+
+    CPPFLAGS="$save_CPPFLAGS"
+    LDFLAGS="$save_LDFLAGS"
+    LIBS="$save_LIBS"
+    ;;
+  esac
+
+  case $lt_cv_dlopen_self in
+  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;
+  *) enable_dlopen_self=unknown ;;
+  esac
+
+  case $lt_cv_dlopen_self_static in
+  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;
+  *) enable_dlopen_self_static=unknown ;;
+  esac
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+striplib=
+old_striplib=
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether stripping libraries is possible" >&5
+$as_echo_n "checking whether stripping libraries is possible... " >&6; }
+if test -n "$STRIP" && $STRIP -V 2>&1 | $GREP "GNU strip" >/dev/null; then
+  test -z "$old_striplib" && old_striplib="$STRIP --strip-debug"
+  test -z "$striplib" && striplib="$STRIP --strip-unneeded"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+# FIXME - insert some real tests, host_os isn't really good enough
+  case $host_os in
+  darwin*)
+    if test -n "$STRIP" ; then
+      striplib="$STRIP -x"
+      old_striplib="$STRIP -S"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+    fi
+    ;;
+  *)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+    ;;
+  esac
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+  # Report which library types will actually be built
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if libtool supports shared libraries" >&5
+$as_echo_n "checking if libtool supports shared libraries... " >&6; }
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $can_build_shared" >&5
+$as_echo "$can_build_shared" >&6; }
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build shared libraries" >&5
+$as_echo_n "checking whether to build shared libraries... " >&6; }
+  test "$can_build_shared" = "no" && enable_shared=no
+
+  # On AIX, shared libraries and static libraries use the same namespace, and
+  # are all built from PIC.
+  case $host_os in
+  aix3*)
+    test "$enable_shared" = yes && enable_static=no
+    if test -n "$RANLIB"; then
+      archive_cmds="$archive_cmds~\$RANLIB \$lib"
+      postinstall_cmds='$RANLIB $lib'
+    fi
+    ;;
+
+  aix[4-9]*)
+    if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+      test "$enable_shared" = yes && enable_static=no
+    fi
+    ;;
+  esac
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_shared" >&5
+$as_echo "$enable_shared" >&6; }
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build static libraries" >&5
+$as_echo_n "checking whether to build static libraries... " >&6; }
+  # Make sure either enable_shared or enable_static is yes.
+  test "$enable_shared" = yes || enable_static=yes
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_static" >&5
+$as_echo "$enable_static" >&6; }
+
+
+
+
+fi
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+CC="$lt_save_CC"
+
+
+
+
+
+
+
+
+
+
+
+
+
+        ac_config_commands="$ac_config_commands libtool"
+
+
+
+
+# Only expand once:
+
+
+
+
+
+case $host in
+  *-cygwin* | *-mingw*)
+    # 'host' will be top-level target in the case of a target lib,
+    # we must compare to with_cross_host to decide if this is a native
+    # or cross-compiler and select where to install dlls appropriately.
+    if test -n "$with_cross_host" &&
+	test x"$with_cross_host" != x"no"; then
+      lt_host_flags='-no-undefined -bindir "$(toolexeclibdir)"';
+    else
+      lt_host_flags='-no-undefined -bindir "$(bindir)"';
+    fi
+    ;;
+  *)
+    lt_host_flags=
+    ;;
+esac
+
+
+
+
+ac_config_files="$ac_config_files Makefile"
+
+ac_config_headers="$ac_config_headers config.h"
+
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, we kill variables containing newlines.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+(
+  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) { eval $ac_var=; unset $ac_var;} ;;
+      esac ;;
+    esac
+  done
+
+  (set) 2>&1 |
+    case $as_nl`(ac_space=' '; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      # `set' does not quote correctly, so add quotes: double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \.
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;; #(
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+) |
+  sed '
+     /^ac_cv_env_/b end
+     t clear
+     :clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     :end' >>confcache
+if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
+  if test -w "$cache_file"; then
+    test "x$cache_file" != "x/dev/null" &&
+      { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
+$as_echo "$as_me: updating cache $cache_file" >&6;}
+    cat confcache >$cache_file
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
+$as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+DEFS=-DHAVE_CONFIG_H
+
+ac_libobjs=
+ac_ltlibobjs=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
+  ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  as_fn_append ac_ltlibobjs " \${LIBOBJDIR}$ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+ if test -n "$EXEEXT"; then
+  am__EXEEXT_TRUE=
+  am__EXEEXT_FALSE='#'
+else
+  am__EXEEXT_TRUE='#'
+  am__EXEEXT_FALSE=
+fi
+
+if test -z "${MAINTAINER_MODE_TRUE}" && test -z "${MAINTAINER_MODE_FALSE}"; then
+  as_fn_error "conditional \"MAINTAINER_MODE\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
+  as_fn_error "conditional \"AMDEP\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
+  as_fn_error "conditional \"am__fastdepCC\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+
+: ${CONFIG_STATUS=./config.status}
+ac_write_fail=0
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
+$as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
+as_write_fail=0
+cat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+
+SHELL=\${CONFIG_SHELL-$SHELL}
+export SHELL
+_ASEOF
+cat >>$CONFIG_STATUS <<\_ASEOF || as_write_fail=1
+## -------------------- ##
+## M4sh Initialization. ##
+## -------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+
+
+as_nl='
+'
+export as_nl
+# Printing a long string crashes Solaris 7 /usr/bin/printf.
+as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
+# Prefer a ksh shell builtin over an external printf program on Solaris,
+# but without wasting forks for bash or zsh.
+if test -z "$BASH_VERSION$ZSH_VERSION" \
+    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='print -r --'
+  as_echo_n='print -rn --'
+elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='printf %s\n'
+  as_echo_n='printf %s'
+else
+  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
+    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
+    as_echo_n='/usr/ucb/echo -n'
+  else
+    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
+    as_echo_n_body='eval
+      arg=$1;
+      case $arg in #(
+      *"$as_nl"*)
+	expr "X$arg" : "X\\(.*\\)$as_nl";
+	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
+      esac;
+      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
+    '
+    export as_echo_n_body
+    as_echo_n='sh -c $as_echo_n_body as_echo'
+  fi
+  export as_echo_body
+  as_echo='sh -c $as_echo_body as_echo'
+fi
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+case $0 in #((
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  exit 1
+fi
+
+# Unset variables that we do not need and which cause bugs (e.g. in
+# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
+# suppresses any "Segmentation fault" message there.  '((' could
+# trigger a bug in pdksh 5.2.14.
+for as_var in BASH_ENV ENV MAIL MAILPATH
+do eval test x\${$as_var+set} = xset \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# CDPATH.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+
+# as_fn_error ERROR [LINENO LOG_FD]
+# ---------------------------------
+# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
+# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
+# script with status $?, using 1 if that was 0.
+as_fn_error ()
+{
+  as_status=$?; test $as_status -eq 0 && as_status=1
+  if test "$3"; then
+    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
+  fi
+  $as_echo "$as_me: error: $1" >&2
+  as_fn_exit $as_status
+} # as_fn_error
+
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+
+# as_fn_unset VAR
+# ---------------
+# Portably unset VAR.
+as_fn_unset ()
+{
+  { eval $1=; unset $1;}
+}
+as_unset=as_fn_unset
+# as_fn_append VAR VALUE
+# ----------------------
+# Append the text in VALUE to the end of the definition contained in VAR. Take
+# advantage of any shell optimizations that allow amortized linear growth over
+# repeated appends, instead of the typical quadratic growth present in naive
+# implementations.
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+  eval 'as_fn_append ()
+  {
+    eval $1+=\$2
+  }'
+else
+  as_fn_append ()
+  {
+    eval $1=\$$1\$2
+  }
+fi # as_fn_append
+
+# as_fn_arith ARG...
+# ------------------
+# Perform arithmetic evaluation on the ARGs, and store the result in the
+# global $as_val. Take advantage of shells that can avoid forks. The arguments
+# must be portable across $(()) and expr.
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+  eval 'as_fn_arith ()
+  {
+    as_val=$(( $* ))
+  }'
+else
+  as_fn_arith ()
+  {
+    as_val=`expr "$@" || test $? -eq 1`
+  }
+fi # as_fn_arith
+
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in #(((((
+-n*)
+  case `echo 'xy\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  xy)  ECHO_C='\c';;
+  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
+       ECHO_T='	';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
+fi
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+    # In both cases, we have to default to `cp -p'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -p'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -p'
+  fi
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+
+# as_fn_mkdir_p
+# -------------
+# Create "$as_dir" as a directory, including parents if necessary.
+as_fn_mkdir_p ()
+{
+
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || eval $as_mkdir_p || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
+
+
+} # as_fn_mkdir_p
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p='mkdir -p "$as_dir"'
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+if test -x / >/dev/null 2>&1; then
+  as_test_x='test -x'
+else
+  if ls -dL / >/dev/null 2>&1; then
+    as_ls_L_option=L
+  else
+    as_ls_L_option=
+  fi
+  as_test_x='
+    eval sh -c '\''
+      if test -d "$1"; then
+	test -d "$1/.";
+      else
+	case $1 in #(
+	-*)set "./$1";;
+	esac;
+	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
+	???[sx]*):;;*)false;;esac;fi
+    '\'' sh
+  '
+fi
+as_executable_p=$as_test_x
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+exec 6>&1
+## ----------------------------------- ##
+## Main body of $CONFIG_STATUS script. ##
+## ----------------------------------- ##
+_ASEOF
+test $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# Save the log message, to keep $0 and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.
+ac_log="
+This file was extended by REORDER plugin for ld $as_me 0.1, which was
+generated by GNU Autoconf 2.64.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+on `(hostname || uname -n) 2>/dev/null | sed 1q`
+"
+
+_ACEOF
+
+case $ac_config_files in *"
+"*) set x $ac_config_files; shift; ac_config_files=$*;;
+esac
+
+case $ac_config_headers in *"
+"*) set x $ac_config_headers; shift; ac_config_headers=$*;;
+esac
+
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+# Files that config.status was made for.
+config_files="$ac_config_files"
+config_headers="$ac_config_headers"
+config_commands="$ac_config_commands"
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+ac_cs_usage="\
+\`$as_me' instantiates files and other configuration actions
+from templates according to the current configuration.  Unless the files
+and actions are specified as TAGs, all are instantiated by default.
+
+Usage: $0 [OPTION]... [TAG]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number and configuration settings, then exit
+  -q, --quiet, --silent
+                   do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+      --file=FILE[:TEMPLATE]
+                   instantiate the configuration file FILE
+      --header=FILE[:TEMPLATE]
+                   instantiate the configuration header FILE
+
+Configuration files:
+$config_files
+
+Configuration headers:
+$config_headers
+
+Configuration commands:
+$config_commands
+
+Report bugs to the package provider."
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_cs_version="\\
+REORDER plugin for ld config.status 0.1
+configured by $0, generated by GNU Autoconf 2.64,
+  with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
+
+Copyright (C) 2009 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+
+ac_pwd='$ac_pwd'
+srcdir='$srcdir'
+INSTALL='$INSTALL'
+MKDIR_P='$MKDIR_P'
+AWK='$AWK'
+test -n "\$AWK" || AWK=awk
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# The default lists apply if the user does not specify any file.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  *)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
+    $as_echo "$ac_cs_version"; exit ;;
+  --debug | --debu | --deb | --de | --d | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    case $ac_optarg in
+    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    as_fn_append CONFIG_FILES " '$ac_optarg'"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    case $ac_optarg in
+    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    as_fn_append CONFIG_HEADERS " '$ac_optarg'"
+    ac_need_defaults=false;;
+  --he | --h)
+    # Conflict between --help and --header
+    as_fn_error "ambiguous option: \`$1'
+Try \`$0 --help' for more information.";;
+  --help | --hel | -h )
+    $as_echo "$ac_cs_usage"; exit ;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) as_fn_error "unrecognized option: \`$1'
+Try \`$0 --help' for more information." ;;
+
+  *) as_fn_append ac_config_targets " $1"
+     ac_need_defaults=false ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+if \$ac_cs_recheck; then
+  set X '$SHELL' '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+  shift
+  \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
+  CONFIG_SHELL='$SHELL'
+  export CONFIG_SHELL
+  exec "\$@"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+  $as_echo "$ac_log"
+} >&5
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+#
+# INIT-COMMANDS
+#
+AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
+
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+sed_quote_subst='$sed_quote_subst'
+double_quote_subst='$double_quote_subst'
+delay_variable_subst='$delay_variable_subst'
+macro_version='`$ECHO "$macro_version" | $SED "$delay_single_quote_subst"`'
+macro_revision='`$ECHO "$macro_revision" | $SED "$delay_single_quote_subst"`'
+enable_shared='`$ECHO "$enable_shared" | $SED "$delay_single_quote_subst"`'
+enable_static='`$ECHO "$enable_static" | $SED "$delay_single_quote_subst"`'
+pic_mode='`$ECHO "$pic_mode" | $SED "$delay_single_quote_subst"`'
+enable_fast_install='`$ECHO "$enable_fast_install" | $SED "$delay_single_quote_subst"`'
+SHELL='`$ECHO "$SHELL" | $SED "$delay_single_quote_subst"`'
+ECHO='`$ECHO "$ECHO" | $SED "$delay_single_quote_subst"`'
+host_alias='`$ECHO "$host_alias" | $SED "$delay_single_quote_subst"`'
+host='`$ECHO "$host" | $SED "$delay_single_quote_subst"`'
+host_os='`$ECHO "$host_os" | $SED "$delay_single_quote_subst"`'
+build_alias='`$ECHO "$build_alias" | $SED "$delay_single_quote_subst"`'
+build='`$ECHO "$build" | $SED "$delay_single_quote_subst"`'
+build_os='`$ECHO "$build_os" | $SED "$delay_single_quote_subst"`'
+SED='`$ECHO "$SED" | $SED "$delay_single_quote_subst"`'
+Xsed='`$ECHO "$Xsed" | $SED "$delay_single_quote_subst"`'
+GREP='`$ECHO "$GREP" | $SED "$delay_single_quote_subst"`'
+EGREP='`$ECHO "$EGREP" | $SED "$delay_single_quote_subst"`'
+FGREP='`$ECHO "$FGREP" | $SED "$delay_single_quote_subst"`'
+LD='`$ECHO "$LD" | $SED "$delay_single_quote_subst"`'
+NM='`$ECHO "$NM" | $SED "$delay_single_quote_subst"`'
+LN_S='`$ECHO "$LN_S" | $SED "$delay_single_quote_subst"`'
+max_cmd_len='`$ECHO "$max_cmd_len" | $SED "$delay_single_quote_subst"`'
+ac_objext='`$ECHO "$ac_objext" | $SED "$delay_single_quote_subst"`'
+exeext='`$ECHO "$exeext" | $SED "$delay_single_quote_subst"`'
+lt_unset='`$ECHO "$lt_unset" | $SED "$delay_single_quote_subst"`'
+lt_SP2NL='`$ECHO "$lt_SP2NL" | $SED "$delay_single_quote_subst"`'
+lt_NL2SP='`$ECHO "$lt_NL2SP" | $SED "$delay_single_quote_subst"`'
+reload_flag='`$ECHO "$reload_flag" | $SED "$delay_single_quote_subst"`'
+reload_cmds='`$ECHO "$reload_cmds" | $SED "$delay_single_quote_subst"`'
+OBJDUMP='`$ECHO "$OBJDUMP" | $SED "$delay_single_quote_subst"`'
+deplibs_check_method='`$ECHO "$deplibs_check_method" | $SED "$delay_single_quote_subst"`'
+file_magic_cmd='`$ECHO "$file_magic_cmd" | $SED "$delay_single_quote_subst"`'
+AR='`$ECHO "$AR" | $SED "$delay_single_quote_subst"`'
+AR_FLAGS='`$ECHO "$AR_FLAGS" | $SED "$delay_single_quote_subst"`'
+STRIP='`$ECHO "$STRIP" | $SED "$delay_single_quote_subst"`'
+RANLIB='`$ECHO "$RANLIB" | $SED "$delay_single_quote_subst"`'
+old_postinstall_cmds='`$ECHO "$old_postinstall_cmds" | $SED "$delay_single_quote_subst"`'
+old_postuninstall_cmds='`$ECHO "$old_postuninstall_cmds" | $SED "$delay_single_quote_subst"`'
+old_archive_cmds='`$ECHO "$old_archive_cmds" | $SED "$delay_single_quote_subst"`'
+lock_old_archive_extraction='`$ECHO "$lock_old_archive_extraction" | $SED "$delay_single_quote_subst"`'
+CC='`$ECHO "$CC" | $SED "$delay_single_quote_subst"`'
+CFLAGS='`$ECHO "$CFLAGS" | $SED "$delay_single_quote_subst"`'
+compiler='`$ECHO "$compiler" | $SED "$delay_single_quote_subst"`'
+GCC='`$ECHO "$GCC" | $SED "$delay_single_quote_subst"`'
+lt_cv_sys_global_symbol_pipe='`$ECHO "$lt_cv_sys_global_symbol_pipe" | $SED "$delay_single_quote_subst"`'
+lt_cv_sys_global_symbol_to_cdecl='`$ECHO "$lt_cv_sys_global_symbol_to_cdecl" | $SED "$delay_single_quote_subst"`'
+lt_cv_sys_global_symbol_to_c_name_address='`$ECHO "$lt_cv_sys_global_symbol_to_c_name_address" | $SED "$delay_single_quote_subst"`'
+lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='`$ECHO "$lt_cv_sys_global_symbol_to_c_name_address_lib_prefix" | $SED "$delay_single_quote_subst"`'
+objdir='`$ECHO "$objdir" | $SED "$delay_single_quote_subst"`'
+MAGIC_CMD='`$ECHO "$MAGIC_CMD" | $SED "$delay_single_quote_subst"`'
+lt_prog_compiler_no_builtin_flag='`$ECHO "$lt_prog_compiler_no_builtin_flag" | $SED "$delay_single_quote_subst"`'
+lt_prog_compiler_wl='`$ECHO "$lt_prog_compiler_wl" | $SED "$delay_single_quote_subst"`'
+lt_prog_compiler_pic='`$ECHO "$lt_prog_compiler_pic" | $SED "$delay_single_quote_subst"`'
+lt_prog_compiler_static='`$ECHO "$lt_prog_compiler_static" | $SED "$delay_single_quote_subst"`'
+lt_cv_prog_compiler_c_o='`$ECHO "$lt_cv_prog_compiler_c_o" | $SED "$delay_single_quote_subst"`'
+need_locks='`$ECHO "$need_locks" | $SED "$delay_single_quote_subst"`'
+DSYMUTIL='`$ECHO "$DSYMUTIL" | $SED "$delay_single_quote_subst"`'
+NMEDIT='`$ECHO "$NMEDIT" | $SED "$delay_single_quote_subst"`'
+LIPO='`$ECHO "$LIPO" | $SED "$delay_single_quote_subst"`'
+OTOOL='`$ECHO "$OTOOL" | $SED "$delay_single_quote_subst"`'
+OTOOL64='`$ECHO "$OTOOL64" | $SED "$delay_single_quote_subst"`'
+libext='`$ECHO "$libext" | $SED "$delay_single_quote_subst"`'
+shrext_cmds='`$ECHO "$shrext_cmds" | $SED "$delay_single_quote_subst"`'
+extract_expsyms_cmds='`$ECHO "$extract_expsyms_cmds" | $SED "$delay_single_quote_subst"`'
+archive_cmds_need_lc='`$ECHO "$archive_cmds_need_lc" | $SED "$delay_single_quote_subst"`'
+enable_shared_with_static_runtimes='`$ECHO "$enable_shared_with_static_runtimes" | $SED "$delay_single_quote_subst"`'
+export_dynamic_flag_spec='`$ECHO "$export_dynamic_flag_spec" | $SED "$delay_single_quote_subst"`'
+whole_archive_flag_spec='`$ECHO "$whole_archive_flag_spec" | $SED "$delay_single_quote_subst"`'
+compiler_needs_object='`$ECHO "$compiler_needs_object" | $SED "$delay_single_quote_subst"`'
+old_archive_from_new_cmds='`$ECHO "$old_archive_from_new_cmds" | $SED "$delay_single_quote_subst"`'
+old_archive_from_expsyms_cmds='`$ECHO "$old_archive_from_expsyms_cmds" | $SED "$delay_single_quote_subst"`'
+archive_cmds='`$ECHO "$archive_cmds" | $SED "$delay_single_quote_subst"`'
+archive_expsym_cmds='`$ECHO "$archive_expsym_cmds" | $SED "$delay_single_quote_subst"`'
+module_cmds='`$ECHO "$module_cmds" | $SED "$delay_single_quote_subst"`'
+module_expsym_cmds='`$ECHO "$module_expsym_cmds" | $SED "$delay_single_quote_subst"`'
+with_gnu_ld='`$ECHO "$with_gnu_ld" | $SED "$delay_single_quote_subst"`'
+allow_undefined_flag='`$ECHO "$allow_undefined_flag" | $SED "$delay_single_quote_subst"`'
+no_undefined_flag='`$ECHO "$no_undefined_flag" | $SED "$delay_single_quote_subst"`'
+hardcode_libdir_flag_spec='`$ECHO "$hardcode_libdir_flag_spec" | $SED "$delay_single_quote_subst"`'
+hardcode_libdir_flag_spec_ld='`$ECHO "$hardcode_libdir_flag_spec_ld" | $SED "$delay_single_quote_subst"`'
+hardcode_libdir_separator='`$ECHO "$hardcode_libdir_separator" | $SED "$delay_single_quote_subst"`'
+hardcode_direct='`$ECHO "$hardcode_direct" | $SED "$delay_single_quote_subst"`'
+hardcode_direct_absolute='`$ECHO "$hardcode_direct_absolute" | $SED "$delay_single_quote_subst"`'
+hardcode_minus_L='`$ECHO "$hardcode_minus_L" | $SED "$delay_single_quote_subst"`'
+hardcode_shlibpath_var='`$ECHO "$hardcode_shlibpath_var" | $SED "$delay_single_quote_subst"`'
+hardcode_automatic='`$ECHO "$hardcode_automatic" | $SED "$delay_single_quote_subst"`'
+inherit_rpath='`$ECHO "$inherit_rpath" | $SED "$delay_single_quote_subst"`'
+link_all_deplibs='`$ECHO "$link_all_deplibs" | $SED "$delay_single_quote_subst"`'
+fix_srcfile_path='`$ECHO "$fix_srcfile_path" | $SED "$delay_single_quote_subst"`'
+always_export_symbols='`$ECHO "$always_export_symbols" | $SED "$delay_single_quote_subst"`'
+export_symbols_cmds='`$ECHO "$export_symbols_cmds" | $SED "$delay_single_quote_subst"`'
+exclude_expsyms='`$ECHO "$exclude_expsyms" | $SED "$delay_single_quote_subst"`'
+include_expsyms='`$ECHO "$include_expsyms" | $SED "$delay_single_quote_subst"`'
+prelink_cmds='`$ECHO "$prelink_cmds" | $SED "$delay_single_quote_subst"`'
+file_list_spec='`$ECHO "$file_list_spec" | $SED "$delay_single_quote_subst"`'
+variables_saved_for_relink='`$ECHO "$variables_saved_for_relink" | $SED "$delay_single_quote_subst"`'
+need_lib_prefix='`$ECHO "$need_lib_prefix" | $SED "$delay_single_quote_subst"`'
+need_version='`$ECHO "$need_version" | $SED "$delay_single_quote_subst"`'
+version_type='`$ECHO "$version_type" | $SED "$delay_single_quote_subst"`'
+runpath_var='`$ECHO "$runpath_var" | $SED "$delay_single_quote_subst"`'
+shlibpath_var='`$ECHO "$shlibpath_var" | $SED "$delay_single_quote_subst"`'
+shlibpath_overrides_runpath='`$ECHO "$shlibpath_overrides_runpath" | $SED "$delay_single_quote_subst"`'
+libname_spec='`$ECHO "$libname_spec" | $SED "$delay_single_quote_subst"`'
+library_names_spec='`$ECHO "$library_names_spec" | $SED "$delay_single_quote_subst"`'
+soname_spec='`$ECHO "$soname_spec" | $SED "$delay_single_quote_subst"`'
+install_override_mode='`$ECHO "$install_override_mode" | $SED "$delay_single_quote_subst"`'
+postinstall_cmds='`$ECHO "$postinstall_cmds" | $SED "$delay_single_quote_subst"`'
+postuninstall_cmds='`$ECHO "$postuninstall_cmds" | $SED "$delay_single_quote_subst"`'
+finish_cmds='`$ECHO "$finish_cmds" | $SED "$delay_single_quote_subst"`'
+finish_eval='`$ECHO "$finish_eval" | $SED "$delay_single_quote_subst"`'
+hardcode_into_libs='`$ECHO "$hardcode_into_libs" | $SED "$delay_single_quote_subst"`'
+sys_lib_search_path_spec='`$ECHO "$sys_lib_search_path_spec" | $SED "$delay_single_quote_subst"`'
+sys_lib_dlsearch_path_spec='`$ECHO "$sys_lib_dlsearch_path_spec" | $SED "$delay_single_quote_subst"`'
+hardcode_action='`$ECHO "$hardcode_action" | $SED "$delay_single_quote_subst"`'
+enable_dlopen='`$ECHO "$enable_dlopen" | $SED "$delay_single_quote_subst"`'
+enable_dlopen_self='`$ECHO "$enable_dlopen_self" | $SED "$delay_single_quote_subst"`'
+enable_dlopen_self_static='`$ECHO "$enable_dlopen_self_static" | $SED "$delay_single_quote_subst"`'
+old_striplib='`$ECHO "$old_striplib" | $SED "$delay_single_quote_subst"`'
+striplib='`$ECHO "$striplib" | $SED "$delay_single_quote_subst"`'
+
+LTCC='$LTCC'
+LTCFLAGS='$LTCFLAGS'
+compiler='$compiler_DEFAULT'
+
+# A function that is used when there is no print builtin or printf.
+func_fallback_echo ()
+{
+  eval 'cat <<_LTECHO_EOF
+\$1
+_LTECHO_EOF'
+}
+
+# Quote evaled strings.
+for var in SHELL \
+ECHO \
+SED \
+GREP \
+EGREP \
+FGREP \
+LD \
+NM \
+LN_S \
+lt_SP2NL \
+lt_NL2SP \
+reload_flag \
+OBJDUMP \
+deplibs_check_method \
+file_magic_cmd \
+AR \
+AR_FLAGS \
+STRIP \
+RANLIB \
+CC \
+CFLAGS \
+compiler \
+lt_cv_sys_global_symbol_pipe \
+lt_cv_sys_global_symbol_to_cdecl \
+lt_cv_sys_global_symbol_to_c_name_address \
+lt_cv_sys_global_symbol_to_c_name_address_lib_prefix \
+lt_prog_compiler_no_builtin_flag \
+lt_prog_compiler_wl \
+lt_prog_compiler_pic \
+lt_prog_compiler_static \
+lt_cv_prog_compiler_c_o \
+need_locks \
+DSYMUTIL \
+NMEDIT \
+LIPO \
+OTOOL \
+OTOOL64 \
+shrext_cmds \
+export_dynamic_flag_spec \
+whole_archive_flag_spec \
+compiler_needs_object \
+with_gnu_ld \
+allow_undefined_flag \
+no_undefined_flag \
+hardcode_libdir_flag_spec \
+hardcode_libdir_flag_spec_ld \
+hardcode_libdir_separator \
+fix_srcfile_path \
+exclude_expsyms \
+include_expsyms \
+file_list_spec \
+variables_saved_for_relink \
+libname_spec \
+library_names_spec \
+soname_spec \
+install_override_mode \
+finish_eval \
+old_striplib \
+striplib; do
+    case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
+    *[\\\\\\\`\\"\\\$]*)
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED \\"\\\$sed_quote_subst\\"\\\`\\\\\\""
+      ;;
+    *)
+      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
+      ;;
+    esac
+done
+
+# Double-quote double-evaled strings.
+for var in reload_cmds \
+old_postinstall_cmds \
+old_postuninstall_cmds \
+old_archive_cmds \
+extract_expsyms_cmds \
+old_archive_from_new_cmds \
+old_archive_from_expsyms_cmds \
+archive_cmds \
+archive_expsym_cmds \
+module_cmds \
+module_expsym_cmds \
+export_symbols_cmds \
+prelink_cmds \
+postinstall_cmds \
+postuninstall_cmds \
+finish_cmds \
+sys_lib_search_path_spec \
+sys_lib_dlsearch_path_spec; do
+    case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
+    *[\\\\\\\`\\"\\\$]*)
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED -e \\"\\\$double_quote_subst\\" -e \\"\\\$sed_quote_subst\\" -e \\"\\\$delay_variable_subst\\"\\\`\\\\\\""
+      ;;
+    *)
+      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
+      ;;
+    esac
+done
+
+ac_aux_dir='$ac_aux_dir'
+xsi_shell='$xsi_shell'
+lt_shell_append='$lt_shell_append'
+
+# See if we are running on zsh, and set the options which allow our
+# commands through without removal of \ escapes INIT.
+if test -n "\${ZSH_VERSION+set}" ; then
+   setopt NO_GLOB_SUBST
+fi
+
+
+    PACKAGE='$PACKAGE'
+    VERSION='$VERSION'
+    TIMESTAMP='$TIMESTAMP'
+    RM='$RM'
+    ofile='$ofile'
+
+
+
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+
+# Handling of arguments.
+for ac_config_target in $ac_config_targets
+do
+  case $ac_config_target in
+    "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
+    "libtool") CONFIG_COMMANDS="$CONFIG_COMMANDS libtool" ;;
+    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+    "config.h") CONFIG_HEADERS="$CONFIG_HEADERS config.h" ;;
+
+  *) as_fn_error "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
+  esac
+done
+
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
+  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason against having it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Hook for its removal unless debugging.
+# Note that there is a small window in which the directory will not be cleaned:
+# after its creation but before its name has been assigned to `$tmp'.
+$debug ||
+{
+  tmp=
+  trap 'exit_status=$?
+  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
+' 0
+  trap 'as_fn_exit 1' 1 2 13 15
+}
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./conf$$-$RANDOM
+  (umask 077 && mkdir "$tmp")
+} || as_fn_error "cannot create a temporary directory in ." "$LINENO" 5
+
+# Set up the scripts for CONFIG_FILES section.
+# No need to generate them if there are no CONFIG_FILES.
+# This happens for instance with `./config.status config.h'.
+if test -n "$CONFIG_FILES"; then
+
+
+ac_cr=`echo X | tr X '\015'`
+# On cygwin, bash can eat \r inside `` if the user requested igncr.
+# But we know of no other shell where ac_cr would be empty at this
+# point, so we can use a bashism as a fallback.
+if test "x$ac_cr" = x; then
+  eval ac_cr=\$\'\\r\'
+fi
+ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
+if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
+  ac_cs_awk_cr='\r'
+else
+  ac_cs_awk_cr=$ac_cr
+fi
+
+echo 'BEGIN {' >"$tmp/subs1.awk" &&
+_ACEOF
+
+
+{
+  echo "cat >conf$$subs.awk <<_ACEOF" &&
+  echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
+  echo "_ACEOF"
+} >conf$$subs.sh ||
+  as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
+ac_delim_num=`echo "$ac_subst_vars" | grep -c '$'`
+ac_delim='%!_!# '
+for ac_last_try in false false false false false :; do
+  . ./conf$$subs.sh ||
+    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
+
+  ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
+  if test $ac_delim_n = $ac_delim_num; then
+    break
+  elif $ac_last_try; then
+    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+rm -f conf$$subs.sh
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+cat >>"\$tmp/subs1.awk" <<\\_ACAWK &&
+_ACEOF
+sed -n '
+h
+s/^/S["/; s/!.*/"]=/
+p
+g
+s/^[^!]*!//
+:repl
+t repl
+s/'"$ac_delim"'$//
+t delim
+:nl
+h
+s/\(.\{148\}\).*/\1/
+t more1
+s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
+p
+n
+b repl
+:more1
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t nl
+:delim
+h
+s/\(.\{148\}\).*/\1/
+t more2
+s/["\\]/\\&/g; s/^/"/; s/$/"/
+p
+b
+:more2
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t delim
+' <conf$$subs.awk | sed '
+/^[^""]/{
+  N
+  s/\n//
+}
+' >>$CONFIG_STATUS || ac_write_fail=1
+rm -f conf$$subs.awk
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+_ACAWK
+cat >>"\$tmp/subs1.awk" <<_ACAWK &&
+  for (key in S) S_is_set[key] = 1
+  FS = ""
+
+}
+{
+  line = $ 0
+  nfields = split(line, field, "@")
+  substed = 0
+  len = length(field[1])
+  for (i = 2; i < nfields; i++) {
+    key = field[i]
+    keylen = length(key)
+    if (S_is_set[key]) {
+      value = S[key]
+      line = substr(line, 1, len) "" value "" substr(line, len + keylen + 3)
+      len += length(value) + length(field[++i])
+      substed = 1
+    } else
+      len += 1 + keylen
+  }
+
+  print line
+}
+
+_ACAWK
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+if sed "s/$ac_cr//" < /dev/null > /dev/null 2>&1; then
+  sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
+else
+  cat
+fi < "$tmp/subs1.awk" > "$tmp/subs.awk" \
+  || as_fn_error "could not setup config files machinery" "$LINENO" 5
+_ACEOF
+
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/
+s/:*\${srcdir}:*/:/
+s/:*@srcdir@:*/:/
+s/^\([^=]*=[	 ]*\):*/\1/
+s/:*$//
+s/^[^=]*=[	 ]*$//
+}'
+fi
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+fi # test -n "$CONFIG_FILES"
+
+# Set up the scripts for CONFIG_HEADERS section.
+# No need to generate them if there are no CONFIG_HEADERS.
+# This happens for instance with `./config.status Makefile'.
+if test -n "$CONFIG_HEADERS"; then
+cat >"$tmp/defines.awk" <<\_ACAWK ||
+BEGIN {
+_ACEOF
+
+# Transform confdefs.h into an awk script `defines.awk', embedded as
+# here-document in config.status, that substitutes the proper values into
+# config.h.in to produce config.h.
+
+# Create a delimiter string that does not exist in confdefs.h, to ease
+# handling of long lines.
+ac_delim='%!_!# '
+for ac_last_try in false false :; do
+  ac_t=`sed -n "/$ac_delim/p" confdefs.h`
+  if test -z "$ac_t"; then
+    break
+  elif $ac_last_try; then
+    as_fn_error "could not make $CONFIG_HEADERS" "$LINENO" 5
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+
+# For the awk script, D is an array of macro values keyed by name,
+# likewise P contains macro parameters if any.  Preserve backslash
+# newline sequences.
+
+ac_word_re=[_$as_cr_Letters][_$as_cr_alnum]*
+sed -n '
+s/.\{148\}/&'"$ac_delim"'/g
+t rset
+:rset
+s/^[	 ]*#[	 ]*define[	 ][	 ]*/ /
+t def
+d
+:def
+s/\\$//
+t bsnl
+s/["\\]/\\&/g
+s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
+D["\1"]=" \3"/p
+s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2"/p
+d
+:bsnl
+s/["\\]/\\&/g
+s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
+D["\1"]=" \3\\\\\\n"\\/p
+t cont
+s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2\\\\\\n"\\/p
+t cont
+d
+:cont
+n
+s/.\{148\}/&'"$ac_delim"'/g
+t clear
+:clear
+s/\\$//
+t bsnlc
+s/["\\]/\\&/g; s/^/"/; s/$/"/p
+d
+:bsnlc
+s/["\\]/\\&/g; s/^/"/; s/$/\\\\\\n"\\/p
+b cont
+' <confdefs.h | sed '
+s/'"$ac_delim"'/"\\\
+"/g' >>$CONFIG_STATUS || ac_write_fail=1
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+  for (key in D) D_is_set[key] = 1
+  FS = ""
+}
+/^[\t ]*#[\t ]*(define|undef)[\t ]+$ac_word_re([\t (]|\$)/ {
+  line = \$ 0
+  split(line, arg, " ")
+  if (arg[1] == "#") {
+    defundef = arg[2]
+    mac1 = arg[3]
+  } else {
+    defundef = substr(arg[1], 2)
+    mac1 = arg[2]
+  }
+  split(mac1, mac2, "(") #)
+  macro = mac2[1]
+  prefix = substr(line, 1, index(line, defundef) - 1)
+  if (D_is_set[macro]) {
+    # Preserve the white space surrounding the "#".
+    print prefix "define", macro P[macro] D[macro]
+    next
+  } else {
+    # Replace #undef with comments.  This is necessary, for example,
+    # in the case of _POSIX_SOURCE, which is predefined and required
+    # on some systems where configure will not decide to define it.
+    if (defundef == "undef") {
+      print "/*", prefix defundef, macro, "*/"
+      next
+    }
+  }
+}
+{ print }
+_ACAWK
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+  as_fn_error "could not setup config headers machinery" "$LINENO" 5
+fi # test -n "$CONFIG_HEADERS"
+
+
+eval set X "  :F $CONFIG_FILES  :H $CONFIG_HEADERS    :C $CONFIG_COMMANDS"
+shift
+for ac_tag
+do
+  case $ac_tag in
+  :[FHLC]) ac_mode=$ac_tag; continue;;
+  esac
+  case $ac_mode$ac_tag in
+  :[FHL]*:*);;
+  :L* | :C*:*) as_fn_error "invalid tag \`$ac_tag'" "$LINENO" 5;;
+  :[FH]-) ac_tag=-:-;;
+  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
+  esac
+  ac_save_IFS=$IFS
+  IFS=:
+  set x $ac_tag
+  IFS=$ac_save_IFS
+  shift
+  ac_file=$1
+  shift
+
+  case $ac_mode in
+  :L) ac_source=$1;;
+  :[FH])
+    ac_file_inputs=
+    for ac_f
+    do
+      case $ac_f in
+      -) ac_f="$tmp/stdin";;
+      *) # Look for the file first in the build tree, then in the source tree
+	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
+	 # because $ac_f cannot contain `:'.
+	 test -f "$ac_f" ||
+	   case $ac_f in
+	   [\\/$]*) false;;
+	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
+	   esac ||
+	   as_fn_error "cannot find input file: \`$ac_f'" "$LINENO" 5;;
+      esac
+      case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
+      as_fn_append ac_file_inputs " '$ac_f'"
+    done
+
+    # Let's still pretend it is `configure' which instantiates (i.e., don't
+    # use $as_me), people would be surprised to read:
+    #    /* config.h.  Generated by config.status.  */
+    configure_input='Generated from '`
+	  $as_echo "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
+	`' by configure.'
+    if test x"$ac_file" != x-; then
+      configure_input="$ac_file.  $configure_input"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
+$as_echo "$as_me: creating $ac_file" >&6;}
+    fi
+    # Neutralize special characters interpreted by sed in replacement strings.
+    case $configure_input in #(
+    *\&* | *\|* | *\\* )
+       ac_sed_conf_input=`$as_echo "$configure_input" |
+       sed 's/[\\\\&|]/\\\\&/g'`;; #(
+    *) ac_sed_conf_input=$configure_input;;
+    esac
+
+    case $ac_tag in
+    *:-:* | *:-) cat >"$tmp/stdin" \
+      || as_fn_error "could not create $ac_file" "$LINENO" 5 ;;
+    esac
+    ;;
+  esac
+
+  ac_dir=`$as_dirname -- "$ac_file" ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  as_dir="$ac_dir"; as_fn_mkdir_p
+  ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+
+  case $ac_mode in
+  :F)
+  #
+  # CONFIG_FILE
+  #
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
+  esac
+  ac_MKDIR_P=$MKDIR_P
+  case $MKDIR_P in
+  [\\/$]* | ?:[\\/]* ) ;;
+  */*) ac_MKDIR_P=$ac_top_build_prefix$MKDIR_P ;;
+  esac
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# If the template does not know about datarootdir, expand it.
+# FIXME: This hack should be removed a few years after 2.60.
+ac_datarootdir_hack=; ac_datarootdir_seen=
+ac_sed_dataroot='
+/datarootdir/ {
+  p
+  q
+}
+/@datadir@/p
+/@docdir@/p
+/@infodir@/p
+/@localedir@/p
+/@mandir@/p'
+case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
+*datarootdir*) ac_datarootdir_seen=yes;;
+*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
+$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+  ac_datarootdir_hack='
+  s&@datadir@&$datadir&g
+  s&@docdir@&$docdir&g
+  s&@infodir@&$infodir&g
+  s&@localedir@&$localedir&g
+  s&@mandir@&$mandir&g
+  s&\\\${datarootdir}&$datarootdir&g' ;;
+esac
+_ACEOF
+
+# Neutralize VPATH when `$srcdir' = `.'.
+# Shell code in configure.ac might set extrasub.
+# FIXME: do we really want to maintain this feature?
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_sed_extra="$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s|@configure_input@|$ac_sed_conf_input|;t t
+s&@top_builddir@&$ac_top_builddir_sub&;t t
+s&@top_build_prefix@&$ac_top_build_prefix&;t t
+s&@srcdir@&$ac_srcdir&;t t
+s&@abs_srcdir@&$ac_abs_srcdir&;t t
+s&@top_srcdir@&$ac_top_srcdir&;t t
+s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
+s&@builddir@&$ac_builddir&;t t
+s&@abs_builddir@&$ac_abs_builddir&;t t
+s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
+s&@INSTALL@&$ac_INSTALL&;t t
+s&@MKDIR_P@&$ac_MKDIR_P&;t t
+$ac_datarootdir_hack
+"
+eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$tmp/subs.awk" >$tmp/out \
+  || as_fn_error "could not create $ac_file" "$LINENO" 5
+
+test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
+  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
+  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined." >&5
+$as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined." >&2;}
+
+  rm -f "$tmp/stdin"
+  case $ac_file in
+  -) cat "$tmp/out" && rm -f "$tmp/out";;
+  *) rm -f "$ac_file" && mv "$tmp/out" "$ac_file";;
+  esac \
+  || as_fn_error "could not create $ac_file" "$LINENO" 5
+ ;;
+  :H)
+  #
+  # CONFIG_HEADER
+  #
+  if test x"$ac_file" != x-; then
+    {
+      $as_echo "/* $configure_input  */" \
+      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs"
+    } >"$tmp/config.h" \
+      || as_fn_error "could not create $ac_file" "$LINENO" 5
+    if diff "$ac_file" "$tmp/config.h" >/dev/null 2>&1; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: $ac_file is unchanged" >&5
+$as_echo "$as_me: $ac_file is unchanged" >&6;}
+    else
+      rm -f "$ac_file"
+      mv "$tmp/config.h" "$ac_file" \
+	|| as_fn_error "could not create $ac_file" "$LINENO" 5
+    fi
+  else
+    $as_echo "/* $configure_input  */" \
+      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs" \
+      || as_fn_error "could not create -" "$LINENO" 5
+  fi
+# Compute "$ac_file"'s index in $config_headers.
+_am_arg="$ac_file"
+_am_stamp_count=1
+for _am_header in $config_headers :; do
+  case $_am_header in
+    $_am_arg | $_am_arg:* )
+      break ;;
+    * )
+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
+  esac
+done
+echo "timestamp for $_am_arg" >`$as_dirname -- "$_am_arg" ||
+$as_expr X"$_am_arg" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$_am_arg" : 'X\(//\)[^/]' \| \
+	 X"$_am_arg" : 'X\(//\)$' \| \
+	 X"$_am_arg" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$_am_arg" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`/stamp-h$_am_stamp_count
+ ;;
+
+  :C)  { $as_echo "$as_me:${as_lineno-$LINENO}: executing $ac_file commands" >&5
+$as_echo "$as_me: executing $ac_file commands" >&6;}
+ ;;
+  esac
+
+
+  case $ac_file$ac_mode in
+    "depfiles":C) test x"$AMDEP_TRUE" != x"" || {
+  # Autoconf 2.62 quotes --file arguments for eval, but not when files
+  # are listed without --file.  Let's play safe and only enable the eval
+  # if we detect the quoting.
+  case $CONFIG_FILES in
+  *\'*) eval set x "$CONFIG_FILES" ;;
+  *)   set x $CONFIG_FILES ;;
+  esac
+  shift
+  for mf
+  do
+    # Strip MF so we end up with the name of the file.
+    mf=`echo "$mf" | sed -e 's/:.*$//'`
+    # Check whether this is an Automake generated Makefile or not.
+    # We used to match only the files named `Makefile.in', but
+    # some people rename them; so instead we look at the file content.
+    # Grep'ing the first line is not enough: some people post-process
+    # each Makefile.in and add a new line on top of each file to say so.
+    # Grep'ing the whole file is not good either: AIX grep has a line
+    # limit of 2048, but all sed's we know have understand at least 4000.
+    if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
+      dirpart=`$as_dirname -- "$mf" ||
+$as_expr X"$mf" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$mf" : 'X\(//\)[^/]' \| \
+	 X"$mf" : 'X\(//\)$' \| \
+	 X"$mf" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$mf" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+    else
+      continue
+    fi
+    # Extract the definition of DEPDIR, am__include, and am__quote
+    # from the Makefile without running `make'.
+    DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
+    test -z "$DEPDIR" && continue
+    am__include=`sed -n 's/^am__include = //p' < "$mf"`
+    test -z "am__include" && continue
+    am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
+    # When using ansi2knr, U may be empty or an underscore; expand it
+    U=`sed -n 's/^U = //p' < "$mf"`
+    # Find all dependency output files, they are included files with
+    # $(DEPDIR) in their names.  We invoke sed twice because it is the
+    # simplest approach to changing $(DEPDIR) to its actual value in the
+    # expansion.
+    for file in `sed -n "
+      s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
+	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+      # Make sure the directory exists.
+      test -f "$dirpart/$file" && continue
+      fdir=`$as_dirname -- "$file" ||
+$as_expr X"$file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$file" : 'X\(//\)[^/]' \| \
+	 X"$file" : 'X\(//\)$' \| \
+	 X"$file" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      as_dir=$dirpart/$fdir; as_fn_mkdir_p
+      # echo "creating $dirpart/$file"
+      echo '# dummy' > "$dirpart/$file"
+    done
+  done
+}
+ ;;
+    "libtool":C)
+
+    # See if we are running on zsh, and set the options which allow our
+    # commands through without removal of \ escapes.
+    if test -n "${ZSH_VERSION+set}" ; then
+      setopt NO_GLOB_SUBST
+    fi
+
+    cfgfile="${ofile}T"
+    trap "$RM \"$cfgfile\"; exit 1" 1 2 15
+    $RM "$cfgfile"
+
+    cat <<_LT_EOF >> "$cfgfile"
+#! $SHELL
+
+# `$ECHO "$ofile" | sed 's%^.*/%%'` - Provide generalized library-building support services.
+# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION
+# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
+# NOTE: Changes made to this file will be lost: look at ltmain.sh.
+#
+#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
+#                 2006, 2007, 2008, 2009, 2010 Free Software Foundation,
+#                 Inc.
+#   Written by Gordon Matzigkeit, 1996
+#
+#   This file is part of GNU Libtool.
+#
+# GNU Libtool is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# As a special exception to the GNU General Public License,
+# if you distribute this file as part of a program or library that
+# is built using GNU Libtool, you may include this file under the
+# same distribution terms that you use for the rest of that program.
+#
+# GNU Libtool is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Libtool; see the file COPYING.  If not, a copy
+# can be downloaded from http://www.gnu.org/licenses/gpl.html, or
+# obtained by writing to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+
+# The names of the tagged configurations supported by this script.
+available_tags=""
+
+# ### BEGIN LIBTOOL CONFIG
+
+# Which release of libtool.m4 was used?
+macro_version=$macro_version
+macro_revision=$macro_revision
+
+# Whether or not to build shared libraries.
+build_libtool_libs=$enable_shared
+
+# Whether or not to build static libraries.
+build_old_libs=$enable_static
+
+# What type of objects to build.
+pic_mode=$pic_mode
+
+# Whether or not to optimize for fast installation.
+fast_install=$enable_fast_install
+
+# Shell to use when invoking shell scripts.
+SHELL=$lt_SHELL
+
+# An echo program that protects backslashes.
+ECHO=$lt_ECHO
+
+# The host system.
+host_alias=$host_alias
+host=$host
+host_os=$host_os
+
+# The build system.
+build_alias=$build_alias
+build=$build
+build_os=$build_os
+
+# A sed program that does not truncate output.
+SED=$lt_SED
+
+# Sed that helps us avoid accidentally triggering echo(1) options like -n.
+Xsed="\$SED -e 1s/^X//"
+
+# A grep program that handles long lines.
+GREP=$lt_GREP
+
+# An ERE matcher.
+EGREP=$lt_EGREP
+
+# A literal string matcher.
+FGREP=$lt_FGREP
+
+# A BSD- or MS-compatible name lister.
+NM=$lt_NM
+
+# Whether we need soft or hard links.
+LN_S=$lt_LN_S
+
+# What is the maximum length of a command?
+max_cmd_len=$max_cmd_len
+
+# Object file suffix (normally "o").
+objext=$ac_objext
+
+# Executable file suffix (normally "").
+exeext=$exeext
+
+# whether the shell understands "unset".
+lt_unset=$lt_unset
+
+# turn spaces into newlines.
+SP2NL=$lt_lt_SP2NL
+
+# turn newlines into spaces.
+NL2SP=$lt_lt_NL2SP
+
+# An object symbol dumper.
+OBJDUMP=$lt_OBJDUMP
+
+# Method to check whether dependent libraries are shared objects.
+deplibs_check_method=$lt_deplibs_check_method
+
+# Command to use when deplibs_check_method == "file_magic".
+file_magic_cmd=$lt_file_magic_cmd
+
+# The archiver.
+AR=$lt_AR
+AR_FLAGS=$lt_AR_FLAGS
+
+# A symbol stripping program.
+STRIP=$lt_STRIP
+
+# Commands used to install an old-style archive.
+RANLIB=$lt_RANLIB
+old_postinstall_cmds=$lt_old_postinstall_cmds
+old_postuninstall_cmds=$lt_old_postuninstall_cmds
+
+# Whether to use a lock for old archive extraction.
+lock_old_archive_extraction=$lock_old_archive_extraction
+
+# A C compiler.
+LTCC=$lt_CC
+
+# LTCC compiler flags.
+LTCFLAGS=$lt_CFLAGS
+
+# Take the output of nm and produce a listing of raw symbols and C names.
+global_symbol_pipe=$lt_lt_cv_sys_global_symbol_pipe
+
+# Transform the output of nm in a proper C declaration.
+global_symbol_to_cdecl=$lt_lt_cv_sys_global_symbol_to_cdecl
+
+# Transform the output of nm in a C name address pair.
+global_symbol_to_c_name_address=$lt_lt_cv_sys_global_symbol_to_c_name_address
+
+# Transform the output of nm in a C name address pair when lib prefix is needed.
+global_symbol_to_c_name_address_lib_prefix=$lt_lt_cv_sys_global_symbol_to_c_name_address_lib_prefix
+
+# The name of the directory that contains temporary libtool files.
+objdir=$objdir
+
+# Used to examine libraries when file_magic_cmd begins with "file".
+MAGIC_CMD=$MAGIC_CMD
+
+# Must we lock files when doing compilation?
+need_locks=$lt_need_locks
+
+# Tool to manipulate archived DWARF debug symbol files on Mac OS X.
+DSYMUTIL=$lt_DSYMUTIL
+
+# Tool to change global to local symbols on Mac OS X.
+NMEDIT=$lt_NMEDIT
+
+# Tool to manipulate fat objects and archives on Mac OS X.
+LIPO=$lt_LIPO
+
+# ldd/readelf like tool for Mach-O binaries on Mac OS X.
+OTOOL=$lt_OTOOL
+
+# ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4.
+OTOOL64=$lt_OTOOL64
+
+# Old archive suffix (normally "a").
+libext=$libext
+
+# Shared library suffix (normally ".so").
+shrext_cmds=$lt_shrext_cmds
+
+# The commands to extract the exported symbol list from a shared archive.
+extract_expsyms_cmds=$lt_extract_expsyms_cmds
+
+# Variables whose values should be saved in libtool wrapper scripts and
+# restored at link time.
+variables_saved_for_relink=$lt_variables_saved_for_relink
+
+# Do we need the "lib" prefix for modules?
+need_lib_prefix=$need_lib_prefix
+
+# Do we need a version for libraries?
+need_version=$need_version
+
+# Library versioning type.
+version_type=$version_type
+
+# Shared library runtime path variable.
+runpath_var=$runpath_var
+
+# Shared library path variable.
+shlibpath_var=$shlibpath_var
+
+# Is shlibpath searched before the hard-coded library search path?
+shlibpath_overrides_runpath=$shlibpath_overrides_runpath
+
+# Format of library name prefix.
+libname_spec=$lt_libname_spec
+
+# List of archive names.  First name is the real one, the rest are links.
+# The last name is the one that the linker finds with -lNAME
+library_names_spec=$lt_library_names_spec
+
+# The coded name of the library, if different from the real name.
+soname_spec=$lt_soname_spec
+
+# Permission mode override for installation of shared libraries.
+install_override_mode=$lt_install_override_mode
+
+# Command to use after installation of a shared archive.
+postinstall_cmds=$lt_postinstall_cmds
+
+# Command to use after uninstallation of a shared archive.
+postuninstall_cmds=$lt_postuninstall_cmds
+
+# Commands used to finish a libtool library installation in a directory.
+finish_cmds=$lt_finish_cmds
+
+# As "finish_cmds", except a single script fragment to be evaled but
+# not shown.
+finish_eval=$lt_finish_eval
+
+# Whether we should hardcode library paths into libraries.
+hardcode_into_libs=$hardcode_into_libs
+
+# Compile-time system search path for libraries.
+sys_lib_search_path_spec=$lt_sys_lib_search_path_spec
+
+# Run-time system search path for libraries.
+sys_lib_dlsearch_path_spec=$lt_sys_lib_dlsearch_path_spec
+
+# Whether dlopen is supported.
+dlopen_support=$enable_dlopen
+
+# Whether dlopen of programs is supported.
+dlopen_self=$enable_dlopen_self
+
+# Whether dlopen of statically linked programs is supported.
+dlopen_self_static=$enable_dlopen_self_static
+
+# Commands to strip libraries.
+old_striplib=$lt_old_striplib
+striplib=$lt_striplib
+
+
+# The linker used to build libraries.
+LD=$lt_LD
+
+# How to create reloadable object files.
+reload_flag=$lt_reload_flag
+reload_cmds=$lt_reload_cmds
+
+# Commands used to build an old-style archive.
+old_archive_cmds=$lt_old_archive_cmds
+
+# A language specific compiler.
+CC=$lt_compiler
+
+# Is the compiler the GNU compiler?
+with_gcc=$GCC
+
+# Compiler flag to turn off builtin functions.
+no_builtin_flag=$lt_lt_prog_compiler_no_builtin_flag
+
+# How to pass a linker flag through the compiler.
+wl=$lt_lt_prog_compiler_wl
+
+# Additional compiler flags for building library objects.
+pic_flag=$lt_lt_prog_compiler_pic
+
+# Compiler flag to prevent dynamic linking.
+link_static_flag=$lt_lt_prog_compiler_static
+
+# Does compiler simultaneously support -c and -o options?
+compiler_c_o=$lt_lt_cv_prog_compiler_c_o
+
+# Whether or not to add -lc for building shared libraries.
+build_libtool_need_lc=$archive_cmds_need_lc
+
+# Whether or not to disallow shared libs when runtime libs are static.
+allow_libtool_libs_with_static_runtimes=$enable_shared_with_static_runtimes
+
+# Compiler flag to allow reflexive dlopens.
+export_dynamic_flag_spec=$lt_export_dynamic_flag_spec
+
+# Compiler flag to generate shared objects directly from archives.
+whole_archive_flag_spec=$lt_whole_archive_flag_spec
+
+# Whether the compiler copes with passing no objects directly.
+compiler_needs_object=$lt_compiler_needs_object
+
+# Create an old-style archive from a shared archive.
+old_archive_from_new_cmds=$lt_old_archive_from_new_cmds
+
+# Create a temporary old-style archive to link instead of a shared archive.
+old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds
+
+# Commands used to build a shared archive.
+archive_cmds=$lt_archive_cmds
+archive_expsym_cmds=$lt_archive_expsym_cmds
+
+# Commands used to build a loadable module if different from building
+# a shared archive.
+module_cmds=$lt_module_cmds
+module_expsym_cmds=$lt_module_expsym_cmds
+
+# Whether we are building with GNU ld or not.
+with_gnu_ld=$lt_with_gnu_ld
+
+# Flag that allows shared libraries with undefined symbols to be built.
+allow_undefined_flag=$lt_allow_undefined_flag
+
+# Flag that enforces no undefined symbols.
+no_undefined_flag=$lt_no_undefined_flag
+
+# Flag to hardcode \$libdir into a binary during linking.
+# This must work even if \$libdir does not exist
+hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec
+
+# If ld is used when linking, flag to hardcode \$libdir into a binary
+# during linking.  This must work even if \$libdir does not exist.
+hardcode_libdir_flag_spec_ld=$lt_hardcode_libdir_flag_spec_ld
+
+# Whether we need a single "-rpath" flag with a separated argument.
+hardcode_libdir_separator=$lt_hardcode_libdir_separator
+
+# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
+# DIR into the resulting binary.
+hardcode_direct=$hardcode_direct
+
+# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
+# DIR into the resulting binary and the resulting library dependency is
+# "absolute",i.e impossible to change by setting \${shlibpath_var} if the
+# library is relocated.
+hardcode_direct_absolute=$hardcode_direct_absolute
+
+# Set to "yes" if using the -LDIR flag during linking hardcodes DIR
+# into the resulting binary.
+hardcode_minus_L=$hardcode_minus_L
+
+# Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
+# into the resulting binary.
+hardcode_shlibpath_var=$hardcode_shlibpath_var
+
+# Set to "yes" if building a shared library automatically hardcodes DIR
+# into the library and all subsequent libraries and executables linked
+# against it.
+hardcode_automatic=$hardcode_automatic
+
+# Set to yes if linker adds runtime paths of dependent libraries
+# to runtime path list.
+inherit_rpath=$inherit_rpath
+
+# Whether libtool must link a program against all its dependency libraries.
+link_all_deplibs=$link_all_deplibs
+
+# Fix the shell variable \$srcfile for the compiler.
+fix_srcfile_path=$lt_fix_srcfile_path
+
+# Set to "yes" if exported symbols are required.
+always_export_symbols=$always_export_symbols
+
+# The commands to list exported symbols.
+export_symbols_cmds=$lt_export_symbols_cmds
+
+# Symbols that should not be listed in the preloaded symbols.
+exclude_expsyms=$lt_exclude_expsyms
+
+# Symbols that must always be exported.
+include_expsyms=$lt_include_expsyms
+
+# Commands necessary for linking programs (against libraries) with templates.
+prelink_cmds=$lt_prelink_cmds
+
+# Specify filename containing input files.
+file_list_spec=$lt_file_list_spec
+
+# How to hardcode a shared library path into an executable.
+hardcode_action=$hardcode_action
+
+# ### END LIBTOOL CONFIG
+
+_LT_EOF
+
+  case $host_os in
+  aix3*)
+    cat <<\_LT_EOF >> "$cfgfile"
+# AIX sometimes has problems with the GCC collect2 program.  For some
+# reason, if we set the COLLECT_NAMES environment variable, the problems
+# vanish in a puff of smoke.
+if test "X${COLLECT_NAMES+set}" != Xset; then
+  COLLECT_NAMES=
+  export COLLECT_NAMES
+fi
+_LT_EOF
+    ;;
+  esac
+
+
+ltmain="$ac_aux_dir/ltmain.sh"
+
+
+  # We use sed instead of cat because bash on DJGPP gets confused if
+  # if finds mixed CR/LF and LF-only lines.  Since sed operates in
+  # text mode, it properly converts lines to CR/LF.  This bash problem
+  # is reportedly fixed, but why not run on old versions too?
+  sed '/^# Generated shell functions inserted here/q' "$ltmain" >> "$cfgfile" \
+    || (rm -f "$cfgfile"; exit 1)
+
+  case $xsi_shell in
+  yes)
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_dirname file append nondir_replacement
+# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
+# otherwise set result to NONDIR_REPLACEMENT.
+func_dirname ()
+{
+  case ${1} in
+    */*) func_dirname_result="${1%/*}${2}" ;;
+    *  ) func_dirname_result="${3}" ;;
+  esac
+}
+
+# func_basename file
+func_basename ()
+{
+  func_basename_result="${1##*/}"
+}
+
+# func_dirname_and_basename file append nondir_replacement
+# perform func_basename and func_dirname in a single function
+# call:
+#   dirname:  Compute the dirname of FILE.  If nonempty,
+#             add APPEND to the result, otherwise set result
+#             to NONDIR_REPLACEMENT.
+#             value returned in "$func_dirname_result"
+#   basename: Compute filename of FILE.
+#             value retuned in "$func_basename_result"
+# Implementation must be kept synchronized with func_dirname
+# and func_basename. For efficiency, we do not delegate to
+# those functions but instead duplicate the functionality here.
+func_dirname_and_basename ()
+{
+  case ${1} in
+    */*) func_dirname_result="${1%/*}${2}" ;;
+    *  ) func_dirname_result="${3}" ;;
+  esac
+  func_basename_result="${1##*/}"
+}
+
+# func_stripname prefix suffix name
+# strip PREFIX and SUFFIX off of NAME.
+# PREFIX and SUFFIX must not contain globbing or regex special
+# characters, hashes, percent signs, but SUFFIX may contain a leading
+# dot (in which case that matches only a dot).
+func_stripname ()
+{
+  # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are
+  # positional parameters, so assign one to ordinary parameter first.
+  func_stripname_result=${3}
+  func_stripname_result=${func_stripname_result#"${1}"}
+  func_stripname_result=${func_stripname_result%"${2}"}
+}
+
+# func_opt_split
+func_opt_split ()
+{
+  func_opt_split_opt=${1%%=*}
+  func_opt_split_arg=${1#*=}
+}
+
+# func_lo2o object
+func_lo2o ()
+{
+  case ${1} in
+    *.lo) func_lo2o_result=${1%.lo}.${objext} ;;
+    *)    func_lo2o_result=${1} ;;
+  esac
+}
+
+# func_xform libobj-or-source
+func_xform ()
+{
+  func_xform_result=${1%.*}.lo
+}
+
+# func_arith arithmetic-term...
+func_arith ()
+{
+  func_arith_result=$(( $* ))
+}
+
+# func_len string
+# STRING may not start with a hyphen.
+func_len ()
+{
+  func_len_result=${#1}
+}
+
+_LT_EOF
+    ;;
+  *) # Bourne compatible functions.
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_dirname file append nondir_replacement
+# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
+# otherwise set result to NONDIR_REPLACEMENT.
+func_dirname ()
+{
+  # Extract subdirectory from the argument.
+  func_dirname_result=`$ECHO "${1}" | $SED "$dirname"`
+  if test "X$func_dirname_result" = "X${1}"; then
+    func_dirname_result="${3}"
+  else
+    func_dirname_result="$func_dirname_result${2}"
+  fi
+}
+
+# func_basename file
+func_basename ()
+{
+  func_basename_result=`$ECHO "${1}" | $SED "$basename"`
+}
+
+
+# func_stripname prefix suffix name
+# strip PREFIX and SUFFIX off of NAME.
+# PREFIX and SUFFIX must not contain globbing or regex special
+# characters, hashes, percent signs, but SUFFIX may contain a leading
+# dot (in which case that matches only a dot).
+# func_strip_suffix prefix name
+func_stripname ()
+{
+  case ${2} in
+    .*) func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%\\\\${2}\$%%"`;;
+    *)  func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%${2}\$%%"`;;
+  esac
+}
+
+# sed scripts:
+my_sed_long_opt='1s/^\(-[^=]*\)=.*/\1/;q'
+my_sed_long_arg='1s/^-[^=]*=//'
+
+# func_opt_split
+func_opt_split ()
+{
+  func_opt_split_opt=`$ECHO "${1}" | $SED "$my_sed_long_opt"`
+  func_opt_split_arg=`$ECHO "${1}" | $SED "$my_sed_long_arg"`
+}
+
+# func_lo2o object
+func_lo2o ()
+{
+  func_lo2o_result=`$ECHO "${1}" | $SED "$lo2o"`
+}
+
+# func_xform libobj-or-source
+func_xform ()
+{
+  func_xform_result=`$ECHO "${1}" | $SED 's/\.[^.]*$/.lo/'`
+}
+
+# func_arith arithmetic-term...
+func_arith ()
+{
+  func_arith_result=`expr "$@"`
+}
+
+# func_len string
+# STRING may not start with a hyphen.
+func_len ()
+{
+  func_len_result=`expr "$1" : ".*" 2>/dev/null || echo $max_cmd_len`
+}
+
+_LT_EOF
+esac
+
+case $lt_shell_append in
+  yes)
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_append var value
+# Append VALUE to the end of shell variable VAR.
+func_append ()
+{
+  eval "$1+=\$2"
+}
+_LT_EOF
+    ;;
+  *)
+    cat << \_LT_EOF >> "$cfgfile"
+
+# func_append var value
+# Append VALUE to the end of shell variable VAR.
+func_append ()
+{
+  eval "$1=\$$1\$2"
+}
+
+_LT_EOF
+    ;;
+  esac
+
+
+  sed -n '/^# Generated shell functions inserted here/,$p' "$ltmain" >> "$cfgfile" \
+    || (rm -f "$cfgfile"; exit 1)
+
+  mv -f "$cfgfile" "$ofile" ||
+    (rm -f "$ofile" && cp "$cfgfile" "$ofile" && rm -f "$cfgfile")
+  chmod +x "$ofile"
+
+ ;;
+
+  esac
+done # for ac_tag
+
+
+as_fn_exit 0
+_ACEOF
+ac_clean_files=$ac_clean_files_save
+
+test $ac_write_fail = 0 ||
+  as_fn_error "write failure creating $CONFIG_STATUS" "$LINENO" 5
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || as_fn_exit $?
+fi
+if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
+$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
+fi
+
diff --git a/function_reordering_plugin/configure.ac b/function_reordering_plugin/configure.ac
new file mode 100644
index 0000000..9e3f4b5
--- /dev/null
+++ b/function_reordering_plugin/configure.ac
@@ -0,0 +1,14 @@
+AC_PREREQ(2.64)
+AC_INIT([REORDER plugin for ld], 0.1,,[function_reordering_plugin])
+AC_CANONICAL_SYSTEM
+GCC_TOPLEV_SUBDIRS
+AM_INIT_AUTOMAKE([foreign no-dist])
+AM_MAINTAINER_MODE
+AC_PROG_CC
+AC_SYS_LARGEFILE
+AM_PROG_LIBTOOL
+ACX_LT_HOST_FLAGS
+AC_SUBST(target_noncanonical)
+AC_CONFIG_FILES(Makefile)
+AC_CONFIG_HEADERS(config.h)
+AC_OUTPUT
diff --git a/function_reordering_plugin/function_reordering_plugin.c b/function_reordering_plugin/function_reordering_plugin.c
new file mode 100644
index 0000000..4f95cc6
--- /dev/null
+++ b/function_reordering_plugin/function_reordering_plugin.c
@@ -0,0 +1,501 @@
+/* Function re-ordering plugin for gold.
+   Copyright (C) 2011 Free Software Foundation, Inc.
+   Contributed by Sriraman Tallam (tmsriram@google.com)
+   and Easwaran Raman (eraman@google.com).
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+This program is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* This plugin should be invoked only when callgraph edge profile
+   information is available in the object files generated using the
+   compiler flag -fcallgraph-profiles-sections.  The callgraph edge
+   profiles are stored in special sections marked .gnu.callgraph.*
+
+   This plugin reads the callgraph sections and constructs an annotated
+   callgraph.  It then repeatedly groups sections that are connected by
+   hot edges and passes the new function layout to the linker.  The
+   layout is based on the procedure reordering algorithm described
+   in the paper :
+
+   "Profile guided code positioning", K. Pettis, R. Hansen
+   Proceedings of PLDI 1990.
+
+   This plugin dumps the final layout order of the functions in a file
+   called "final_layout.txt".  To change the output file, pass the new
+   file name with --plugin-opt,file=<name>.  To dump to stderr instead,
+   just pass stderr as the file name.
+
+   This plugin also allows placing all functions found cold in a separate
+   segment.  This can be enabled with the linker option:
+   --plugin-opt,split_segment=yes.  */
+
+#if HAVE_STDINT_H
+#include <stdint.h>
+#endif
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <string.h>
+#if  defined (__ELF__)
+  #include <elf.h>
+#endif
+#include "config.h"
+#include "plugin-api.h"
+#include "callgraph.h"
+
+/* #include <elf.h>   Not available on Darwin. 
+   Rather than dealing with cross-compilation includes, hard code the
+   values we need, as these will not change.  */
+#ifndef SHT_NULL
+ #define SHT_NULL 0
+#endif
+#ifndef SHT_PROGBITS
+ #define SHT_PROGBITS 1
+#endif
+
+enum ld_plugin_status claim_file_hook (const struct ld_plugin_input_file *file,
+                                       int *claimed);
+enum ld_plugin_status all_symbols_read_hook ();
+
+static ld_plugin_message message = NULL;
+static ld_plugin_register_claim_file register_claim_file_hook = NULL;
+static ld_plugin_register_all_symbols_read
+  register_all_symbols_read_hook = NULL;
+static ld_plugin_get_input_section_count get_input_section_count = NULL;
+static ld_plugin_get_input_section_type get_input_section_type = NULL;
+static ld_plugin_get_input_section_name get_input_section_name = NULL;
+static ld_plugin_get_input_section_contents get_input_section_contents = NULL;
+static ld_plugin_update_section_order update_section_order = NULL;
+static ld_plugin_allow_section_ordering allow_section_ordering = NULL;
+static ld_plugin_allow_unique_segment_for_sections 
+    allow_unique_segment_for_sections = NULL;
+static ld_plugin_unique_segment_for_sections unique_segment_for_sections = NULL;
+
+/* The file where the final function order will be stored.
+   It can be set by using the  plugin option  as --plugin-opt
+   "file=<name>".  To dump to stderr, say --plugin-opt "file=stderr".  */
+
+static char *out_file = NULL;
+
+/* The plugin does nothing when no-op is 1.  */
+static int no_op = 0;
+
+/* The plugin creates a new segment for unlikely code if split_segment
+   is set.  This can be set with the linker option:
+   "--plugin-opt,split_segment=yes".  */
+static int split_segment = 0;
+
+/* If SORT_NAME_PREFIX is true then the sections not touched by the callgraph
+   are grouped according to their name prefix.  When SORT_NAME_PREFIX is zero,
+   all the sections are put together and sorted according to their node
+   weights.  The default value of SORT_NAME_PREFIX is 0.  Even when sections
+   are grouped by their prefix, each group is sorted by the node weights.  */
+int sort_name_prefix = 0;
+
+/* Edge cutoff is used to discard callgraph edges that are not above a
+   certain threshold.  cutoff_p is to express this as a percent of the
+   maximum value and cutoff_a is used to express this as an absolute
+   value.  The default is to consider all edges.  */
+unsigned int edge_cutoff_p = 0;
+unsigned long long edge_cutoff_a = 0;
+
+/* This is true if the max count of any bb in a function should be used as
+   the node weight rather than the count of the entry bb.  */
+int use_max_count = 1;
+
+/* This is used to decide which sections are considered unlikely.  If the
+   section profile is greater than this value then it is not unlikely
+   executed.  */
+unsigned long long unlikely_segment_profile_cutoff = 0;
+
+/* Copies new output file name out_file  */
+void get_filename (const char *name)
+{
+  XNEWVEC_ALLOC (out_file, char, (strlen (name) + 1));
+  strcpy (out_file, name);
+}
+
+/* MSG_FATAL prints a format string and aborts.  Uses the plugin API if
+   available, otherwise falls back to using fprintf.  */
+
+#define MSG_FATAL(...) \
+  if (message) { \
+    message (LDPL_FATAL, __VA_ARGS__); } \
+  else { \
+    fprintf (stderr, "fatal: " __VA_ARGS__); abort (); }
+
+/* MSG_ERROR prints a format string. Uses the plugin API if
+   available, otherwise falls back to using fprintf.  */
+
+#define MSG_ERROR(...) \
+  if (message) { \
+    message (LDPL_ERROR, __VA_ARGS__); } \
+  else { \
+    fprintf (stderr, "error: " __VA_ARGS__); }
+
+/* Process options to plugin.  Options with prefix "group=" are special.
+   They specify the type of grouping. The option "group=none" makes the
+   plugin do nothing.   Options with prefix "file=" set the output file
+   where the final function order must be stored.  Option "segment=none"
+   does not place the cold code in a separate ELF segment.  */
+static int
+process_option (const char *name)
+{
+  const char *option_group = "group=";
+  const char *option_file = "file=";
+  const char *option_segment = "split_segment=";
+  const char *option_edge_cutoff = "edge_cutoff=";
+  const char *option_sort_name_prefix = "sort_name_prefix=";
+  const char *option_max_count = "use_maxcount=";
+  const char *option_unlikely_cutoff = "unlikely_cutoff=";
+
+  /* Check if option is "group="  */
+  if (strncmp (name, option_group, strlen (option_group)) == 0)
+    {
+      if (strcmp (name + strlen (option_group), "none") == 0)
+	no_op = 1;
+      else
+	no_op = 0;
+      return 0;
+    }
+  /* Check if option is "file=" */
+  else if (strncmp (name, option_file, strlen (option_file)) == 0)
+    {
+      get_filename (name + strlen (option_file));
+      return 0;
+    }
+  /* Check if options is "split_segment=[yes|no]"  */
+  else if (strncmp (name, option_segment, strlen (option_segment)) == 0)
+    {
+      const char *option_val = name + strlen (option_segment);
+      if (strcmp (option_val, "no") == 0)
+	{
+	  split_segment = 0;
+	  return 0;
+	}
+      else if (strcmp (option_val, "yes") == 0)
+	{
+	  split_segment = 1;
+	  return 0;
+	}
+    }
+  else if (strncmp (name, option_edge_cutoff,
+	   strlen (option_edge_cutoff)) == 0)
+    {
+      const char *a_or_p = name + strlen (option_edge_cutoff);
+      char *endptr = NULL;
+      if (a_or_p[0] == 'p')
+	{
+          edge_cutoff_p = strtol (a_or_p + 1, &endptr, 10);
+	  /* Sanity check value entered.  */
+	  if (*endptr == '\0' && edge_cutoff_p <= 100)
+	    return 0;
+	  if (edge_cutoff_p > 100)
+	    {
+	      MSG_ERROR ("Percent value > 100 in option %s\n", name);
+	      return 1;
+	    }
+	}
+      else if (a_or_p[0] == 'a')
+	{
+          edge_cutoff_a = strtoll (a_or_p + 1, &endptr, 10);
+	  /* Sanity check value entered.  */
+	  if (*endptr == '\0')
+	    return 0;
+	}
+      MSG_ERROR ("Wrong format/non-numeric value for edge_cutoff in %s, "
+   	        "use edge_cutoff=[p|a]<value>\n", name);
+      return 1;
+    }
+  else if (strncmp (name, option_sort_name_prefix,
+	   strlen (option_sort_name_prefix)) == 0)
+    {
+      const char *option_val = name + strlen (option_sort_name_prefix);
+      if (strcmp (option_val, "no") == 0)
+	{
+	  sort_name_prefix = 0;
+	  return 0;
+	}
+      else if (strcmp (option_val, "yes") == 0)
+	{
+	  sort_name_prefix = 1;
+	  return 0;
+	}
+    }
+  else if (strncmp (name, option_max_count,
+	   strlen (option_max_count)) == 0)
+    {
+      const char *option_val = name + strlen (option_max_count);
+      if (strcmp (option_val, "no") == 0)
+	{
+	  use_max_count = 0;
+	  return 0;
+	}
+      else if (strcmp (option_val, "yes") == 0)
+	{
+	  use_max_count = 1;
+	  return 0;
+	}
+    }
+  /* Check if option is unlikely_cutoff.  This decides what sections are
+     considered unlikely for segment splitting.  The default cutoff is 0.  */
+  else if (strncmp (name, option_unlikely_cutoff,
+	   strlen (option_unlikely_cutoff)) == 0)
+    {
+      const char *option_val = name + strlen (option_unlikely_cutoff);
+      char *endptr = NULL;
+      unlikely_segment_profile_cutoff = strtoll (option_val, &endptr, 10);
+      /* Sanity check value entered.  */
+      if (*endptr == '\0')
+	return 0;
+      MSG_ERROR ("Non-numeric value in option %s\n", name);
+      return 1;
+    }
+
+  /* Flag error on unknown plugin option.  */
+  MSG_ERROR ("Unknown option to function reordering plugin :%s\n", name);
+  return 1;
+}
+
+/* Plugin entry point.  */
+enum ld_plugin_status
+onload (struct ld_plugin_tv *tv)
+{
+  struct ld_plugin_tv *entry;
+  for (entry = tv; entry->tv_tag != LDPT_NULL; ++entry)
+    {
+      switch (entry->tv_tag)
+        {
+        case LDPT_API_VERSION:
+          break;
+        case LDPT_GOLD_VERSION:
+          break;
+        case LDPT_OPTION:
+	  if (process_option (entry->tv_u.tv_string) == 1)
+	    return LDPS_ERR;
+	  /* If no_op is set, do not do anything else.  */
+	  if (no_op) return LDPS_OK;
+	  break;
+	case LDPT_MESSAGE:
+	  message = *entry->tv_u.tv_message;
+	  break;
+        case LDPT_REGISTER_CLAIM_FILE_HOOK:
+	  register_claim_file_hook = *entry->tv_u.tv_register_claim_file;
+          break;
+	case LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK:
+	  register_all_symbols_read_hook
+	    = *entry->tv_u.tv_register_all_symbols_read;
+          break;
+        case LDPT_GET_INPUT_SECTION_COUNT:
+          get_input_section_count = *entry->tv_u.tv_get_input_section_count;
+          break;
+        case LDPT_GET_INPUT_SECTION_TYPE:
+          get_input_section_type = *entry->tv_u.tv_get_input_section_type;
+          break;
+        case LDPT_GET_INPUT_SECTION_NAME:
+          get_input_section_name = *entry->tv_u.tv_get_input_section_name;
+          break;
+        case LDPT_GET_INPUT_SECTION_CONTENTS:
+          get_input_section_contents = *entry->tv_u.tv_get_input_section_contents;
+          break;
+	case LDPT_UPDATE_SECTION_ORDER:
+	  update_section_order = *entry->tv_u.tv_update_section_order;
+	  break;
+	case LDPT_ALLOW_SECTION_ORDERING:
+	  allow_section_ordering = *entry->tv_u.tv_allow_section_ordering;
+	  break;
+	case LDPT_ALLOW_UNIQUE_SEGMENT_FOR_SECTIONS:
+	  allow_unique_segment_for_sections
+	      = *entry->tv_u.tv_allow_unique_segment_for_sections;
+	  break;
+	case LDPT_UNIQUE_SEGMENT_FOR_SECTIONS:
+	  unique_segment_for_sections = *entry->tv_u.tv_unique_segment_for_sections;
+	  break;
+        default:
+          break;
+        }
+    }
+
+  assert (!no_op);
+
+  /* If the API for code reordering is missing, abort!  */
+  if (register_all_symbols_read_hook == NULL
+      || register_claim_file_hook == NULL
+      || get_input_section_count == NULL
+      || get_input_section_type == NULL
+      || get_input_section_name == NULL
+      || get_input_section_contents == NULL
+      || update_section_order == NULL
+      || allow_section_ordering == NULL)
+    {
+      MSG_FATAL ("API for code reordering not available\n");
+    }
+
+  /* If segment splitting is desired and the API is missing, flag error.  */
+  if (split_segment == 1
+      && (allow_unique_segment_for_sections == NULL
+          || unique_segment_for_sections == NULL))
+    {
+      MSG_FATAL ("Segment splitting API not available for split_segment\n");
+    }
+
+  /* Register handlers.  */
+  assert ((*register_all_symbols_read_hook) (all_symbols_read_hook)
+	   == LDPS_OK);
+  assert ((*register_claim_file_hook) (claim_file_hook)
+	  == LDPS_OK);
+  return LDPS_OK;
+}
+
+static int is_ordering_specified = 0;
+
+/* This function is called by the linker for every new object it encounters.  */
+
+enum ld_plugin_status
+claim_file_hook (const struct ld_plugin_input_file *file, int *claimed)
+{
+  unsigned int count = 0;
+  struct ld_plugin_section section;
+  unsigned int shndx;
+
+  (void) claimed;
+
+  if (is_ordering_specified == 0)
+    {
+      /* Inform the linker to prepare for section reordering.  */
+      (*allow_section_ordering) ();
+      /* Inform the linker to allow certain sections to be placed in
+	 a separate segment.  */
+      if (split_segment == 1)
+        (*allow_unique_segment_for_sections) ();
+      is_ordering_specified = 1;
+    }
+
+  (*get_input_section_count) (file->handle, &count);
+
+  for (shndx = 0; shndx < count; ++shndx)
+    {
+      unsigned int type = SHT_NULL;
+      char *name = NULL;
+
+      section.handle = file->handle;
+      section.shndx = shndx;
+      (*get_input_section_type) (section, &type);
+
+      (*get_input_section_name) (section, &name);
+      push_allocated_ptr (name);
+      if (type == SHT_PROGBITS && is_prefix_of (".text.", name))
+        {
+          map_section_name_to_index (name, file->handle, shndx);
+        }
+      else if (is_prefix_of (".gnu.callgraph.text", name))
+        {
+	  /* Process callgraph sections.  */
+          unsigned char *section_contents_ptr = NULL;
+          size_t length;
+          (*get_input_section_contents) (section,
+	    (const unsigned char **)&section_contents_ptr,
+	    &length);
+	  unsigned char *section_contents;
+	  XNEWVEC_ALLOC (section_contents, unsigned char, length);
+	  memcpy (section_contents, section_contents_ptr, length);
+          parse_callgraph_section_contents (file->handle,
+					    section_contents,
+					    (unsigned int)length);
+        }
+    }
+
+  return LDPS_OK;
+}
+
+/* This function is called by the linker after all the symbols have been read.
+   At this stage, it is fine to tell the linker the desired function order.  */
+
+/* These globals are set to the start and end of the unlikely function sections
+   in the section list, which can then be mapped to a separate segment.  */
+extern int unlikely_segment_start;
+extern int unlikely_segment_end;
+
+enum ld_plugin_status
+all_symbols_read_hook (void)
+{
+  unsigned int num_entries;
+  unsigned int i;
+  struct ld_plugin_section *section_list;
+  void **handles;
+  unsigned int *shndx;
+  FILE *fp = NULL;
+
+  if (is_callgraph_empty ())
+    return LDPS_OK;
+
+  /* Open the file to write the final layout  */
+  if (out_file != NULL)
+    {
+      if (strcmp (out_file, "stderr") == 0)
+	fp = stderr;
+      else
+	fp = fopen (out_file, "w");
+
+      fprintf (fp, "# Remove lines starting with \'#\' to"
+		   " pass to --section-ordering-file\n");
+      fprintf (fp, "# Lines starting with \'#\' are the edge profiles\n");
+    }
+
+  find_pettis_hansen_function_layout (fp);
+  num_entries = get_layout (fp, &handles, &shndx);
+  XNEWVEC_ALLOC (section_list, struct ld_plugin_section, num_entries);
+
+  for (i = 0; i < num_entries; i++)
+    {
+      section_list[i].handle = handles[i];
+      section_list[i].shndx = shndx[i];
+    }
+
+  if (split_segment == 1
+      && unlikely_segment_start >= 0
+      && (unlikely_segment_end >= unlikely_segment_start))
+    {
+      /* Pass the new order of functions to the linker.  */
+      /* Fix the order of all sections upto the beginning of the
+	 unlikely section.  */
+      update_section_order (section_list, unlikely_segment_start);
+      assert (num_entries > unlikely_segment_end);
+      /* Fix the order of all sections after the end of the unlikely
+	 section.  */
+      update_section_order (section_list + unlikely_segment_end + 1,
+			    num_entries - unlikely_segment_end - 1);
+      /* Map all unlikely code into a new segment.  */
+      unique_segment_for_sections (
+	  ".text.unlikely_executed", 0, 0x1000,
+	  section_list + unlikely_segment_start,
+	  unlikely_segment_end - unlikely_segment_start + 1);
+      if (fp != NULL)
+	fprintf (fp, "Moving %u section(s) to new segment\n",
+		 unlikely_segment_end - unlikely_segment_start + 1);
+    }
+  else
+    {
+      /* Pass the new order of functions to the linker.  */
+      update_section_order (section_list, num_entries);
+    }
+
+  if (out_file != NULL
+      && strcmp (out_file, "stderr") != 0)
+    fclose (fp);
+
+  cleanup ();
+  return LDPS_OK;
+}
diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index 326ec63..c504cc7 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-4.8.2
+4.8.x-codefirex
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 03d681a..4b0a9df 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -86,6 +86,12 @@
 	* config/aarch64/arm_neon.h
 	(vld1<q>_<fpsu><8, 16, 32, 64>): Convert to RTL builtins.
 
+2013-07-15  Sterling Augustine  <saugustine@google.com>
+
+        * dwarf2out.c (output_pubnames): Rework assertion.  Move logic
+        checking DW_TAG_enumerator and die_parent ...
+        (include_pubname_in_output): ...to here.
+
 2013-07-11  Georg-Johann Lay  <avr@gjlay.de>
 
 	Backport from 2013-07-11 trunk r200901.
diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index 045de75..bc9d670 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -878,6 +878,7 @@ GIMPLE_H = gimple.h gimple.def gsstruct.def pointer-set.h $(VEC_H) \
 TRANS_MEM_H = trans-mem.h
 GCOV_IO_H = gcov-io.h gcov-iov.h auto-host.h
 COVERAGE_H = coverage.h $(GCOV_IO_H)
+AUTO_PROFILE_H = auto-profile.h
 DEMANGLE_H = $(srcdir)/../include/demangle.h
 RECOG_H = recog.h
 ALIAS_H = alias.h
@@ -1161,6 +1162,7 @@ OBJS = \
 	alias.o \
 	alloc-pool.o \
 	auto-inc-dec.o \
+	auto-profile.o \
 	bb-reorder.o \
 	bitmap.o \
 	bt-load.o \
@@ -1275,6 +1277,7 @@ OBJS = \
 	ira-emit.o \
 	ira-lives.o \
 	jump.o \
+	l-ipo.o \
 	langhooks.o \
 	lcm.o \
 	lists.o \
@@ -1463,7 +1466,7 @@ OBJS = \
 
 # Objects in libcommon.a, potentially used by all host binaries and with
 # no target dependencies.
-OBJS-libcommon = diagnostic.o diagnostic-color.o pretty-print.o intl.o input.o version.o
+OBJS-libcommon = diagnostic.o diagnostic-color.o pretty-print.o intl.o input.o version.o vec.o
 
 # Objects in libcommon-target.a, used by drivers and by the core
 # compiler and containing target-dependent code.
@@ -1917,9 +1920,10 @@ collect2-aix.o : collect2-aix.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
 tlink.o: tlink.c $(DEMANGLE_H) $(HASHTAB_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
     $(OBSTACK_H) collect2.h intl.h $(DIAGNOSTIC_CORE_H) $(VEC_H)
 
-lto-wrapper$(exeext): lto-wrapper.o ggc-none.o libcommon-target.a $(LIBDEPS)
+LTO_WRAPPER_OBJS = lto-wrapper.o vec.o ggc-none.o
+lto-wrapper$(exeext): $(LTO_WRAPPER_OBJS) libcommon-target.a $(LIBDEPS)
 	+$(LINKER) $(ALL_COMPILERFLAGS) $(LDFLAGS) -o T$@ \
-	    lto-wrapper.o ggc-none.o libcommon-target.a $(LIBS)
+	    $(LTO_WRAPPER_OBJS) libcommon-target.a $(LIBS)
 	mv -f T$@ $@
 
 lto-wrapper.o: lto-wrapper.c $(CONFIG_H) $(SYSTEM_H) coretypes.h intl.h \
@@ -1970,7 +1974,8 @@ CFLAGS-c-family/c-opts.o += @TARGET_SYSTEM_ROOT_DEFINE@
 c-family/c-opts.o : c-family/c-opts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
         $(TREE_H) $(C_PRAGMA_H) $(FLAGS_H) toplev.h langhooks.h \
         $(DIAGNOSTIC_H) intl.h debug.h $(C_COMMON_H) $(C_TARGET_H) \
-        $(OPTS_H) $(OPTIONS_H) $(MKDEPS_H) incpath.h cppdefault.h
+        $(OPTS_H) $(OPTIONS_H) $(MKDEPS_H) incpath.h cppdefault.h $(FUNCTION_H) \
+	$(PARAMS_H) l-ipo.h
 
 CFLAGS-c-family/c-pch.o += -DHOST_MACHINE=\"$(host)\" \
 	-DTARGET_MACHINE=\"$(target)\"
@@ -2034,6 +2039,7 @@ DRIVER_DEFINES = \
   -DDEFAULT_TARGET_MACHINE=\"$(target_noncanonical)\" \
   -DSTANDARD_BINDIR_PREFIX=\"$(bindir)/\" \
   -DTOOLDIR_BASE_PREFIX=\"$(libsubdir_to_prefix)$(prefix_to_exec_prefix)\" \
+  @RUNTIME_ROOT_PREFIX_DEFINE@ \
   @TARGET_SYSTEM_ROOT_DEFINE@ \
   $(VALGRIND_DRIVER_DEFINES) \
   `test "X$${SHLIB}" = "X" || test "@enable_shared@" != "yes" || echo "-DENABLE_SHARED_LIBGCC"` \
@@ -2218,7 +2224,7 @@ tree-inline.o : tree-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
    intl.h $(FUNCTION_H) $(GIMPLE_H) \
    debug.h $(DIAGNOSTIC_H) $(EXCEPT_H) $(TREE_FLOW_H) tree-iterator.h tree-mudflap.h \
    $(IPA_PROP_H) value-prof.h $(TREE_PASS_H) $(TARGET_H) \
-   $(TREE_PRETTY_PRINT_H)
+   $(TREE_PRETTY_PRINT_H) l-ipo.h
 print-tree.o : print-tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h \
    $(TM_H) $(TREE_H) $(GGC_H) langhooks.h tree-iterator.h \
    $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(GIMPLE_PRETTY_PRINT_H)
@@ -2263,7 +2269,7 @@ tree-ssa.o : tree-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
    langhooks.h $(TREE_PASS_H) $(BASIC_BLOCK_H) $(BITMAP_H) \
    $(FLAGS_H) $(GGC_H) $(HASHTAB_H) pointer-set.h \
    $(GIMPLE_H) $(TREE_INLINE_H) $(TARGET_H) \
-   $(GIMPLE_PRETTY_PRINT_H) $(CFGLOOP_H)
+   $(GIMPLE_PRETTY_PRINT_H) $(CFGLOOP_H) l-ipo.h
 tree-into-ssa.o : tree-into-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
    $(TREE_H) $(TM_P_H) $(DIAGNOSTIC_CORE_H) \
    $(FUNCTION_H) $(TM_H) coretypes.h \
@@ -2383,7 +2389,7 @@ tree-cfg.o : tree-cfg.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
    $(TREE_H) $(TM_P_H) $(GGC_H) $(FLAGS_H) $(TARGET_H) \
    $(DIAGNOSTIC_CORE_H) $(FUNCTION_H) $(TM_H) coretypes.h \
    $(TREE_DUMP_H) $(EXCEPT_H) $(CFGLOOP_H) $(TREE_PASS_H) \
-   $(BASIC_BLOCK_H) \
+   $(BASIC_BLOCK_H) l-ipo.h \
    value-prof.h tree-ssa-propagate.h $(TREE_INLINE_H) $(GIMPLE_PRETTY_PRINT_H)
 tree-cfgcleanup.o : tree-cfgcleanup.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
    $(TREE_H) $(TM_P_H) $(GGC_H) $(FLAGS_H) \
@@ -2649,7 +2655,7 @@ tree-nomudflap.o : $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TREE_INLINE_H) \
 tree-pretty-print.o : tree-pretty-print.c $(CONFIG_H) $(SYSTEM_H) \
    $(TREE_H) $(DIAGNOSTIC_H) $(HASHTAB_H) $(TREE_FLOW_H) \
    $(TM_H) coretypes.h dumpfile.h tree-iterator.h $(SCEV_H) langhooks.h \
-   value-prof.h output.h $(TREE_PRETTY_PRINT_H)
+   value-prof.h output.h $(TREE_PRETTY_PRINT_H) l-ipo.h
 tree-diagnostic.o : tree-diagnostic.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h \
    $(TREE_H) $(DIAGNOSTIC_H) tree-diagnostic.h langhooks.h $(LANGHOOKS_DEF_H) \
    $(VEC_H) $(TREE_PRETTY_PRINT_H)
@@ -2668,7 +2674,7 @@ opts.o : opts.c $(OPTS_H) $(OPTIONS_H) $(DIAGNOSTIC_CORE_H) $(CONFIG_H) $(SYSTEM
 opts-global.o : opts-global.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
    $(DIAGNOSTIC_H) $(OPTS_H) $(FLAGS_H) $(GGC_H) $(TREE_H) langhooks.h \
    $(TM_H) $(RTL_H) $(DBGCNT_H) debug.h $(LTO_STREAMER_H) output.h \
-   $(PLUGIN_H) toplev.h $(TREE_PASS_H)
+   $(PLUGIN_H) toplev.h $(TREE_PASS_H) $(PARAMS_H) l-ipo.h
 opts-common.o : opts-common.c $(OPTS_H) $(FLAGS_H) $(CONFIG_H) $(SYSTEM_H) \
    coretypes.h intl.h $(DIAGNOSTIC_H) $(TM_H)
 targhooks.o : targhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \
@@ -2701,7 +2707,7 @@ toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
    $(OPTS_H) params.def tree-mudflap.h $(TREE_PASS_H) $(GIMPLE_H) \
    tree-ssa-alias.h $(PLUGIN_H) realmpfr.h tree-diagnostic.h \
    $(TREE_PRETTY_PRINT_H) opts-diagnostic.h $(COMMON_TARGET_H) \
-   tsan.h diagnostic-color.h
+   tsan.h diagnostic-color.h $(AUTO_PROFILE_H)
 
 hwint.o : hwint.c $(CONFIG_H) $(SYSTEM_H) $(DIAGNOSTIC_CORE_H)
 
@@ -2715,7 +2721,7 @@ passes.o : passes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
    hosthooks.h $(CGRAPH_H) $(COVERAGE_H) $(TREE_PASS_H) $(TREE_DUMP_H) \
    $(GGC_H) $(OPTS_H) $(TREE_FLOW_H) $(TREE_INLINE_H) \
    gt-passes.h $(DF_H) $(PREDICT_H) $(LTO_STREAMER_H) \
-   $(PLUGIN_H) $(IPA_UTILS_H)
+   $(PLUGIN_H) $(IPA_UTILS_H) l-ipo.h
 
 plugin.o : plugin.c $(PLUGIN_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h \
    $(DIAGNOSTIC_CORE_H) $(TREE_H) $(TREE_PASS_H) intl.h $(PLUGIN_VERSION_H) $(GGC_H)
@@ -2746,14 +2752,14 @@ varasm.o : varasm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
    output.h $(DIAGNOSTIC_CORE_H) xcoffout.h debug.h $(GGC_H) $(TM_P_H) \
    $(HASHTAB_H) $(TARGET_H) langhooks.h gt-varasm.h $(BASIC_BLOCK_H) \
    $(CGRAPH_H) $(TARGET_DEF_H) tree-mudflap.h \
-   pointer-set.h $(COMMON_TARGET_H) asan.h
+   pointer-set.h $(COMMON_TARGET_H) asan.h l-ipo.h
 function.o : function.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_ERROR_H) \
    $(TREE_H) $(GIMPLE_H) $(FLAGS_H) $(FUNCTION_H) $(EXPR_H) \
    $(OPTABS_H) $(LIBFUNCS_H) $(REGS_H) hard-reg-set.h insn-config.h $(RECOG_H) \
    output.h  $(EXCEPT_H) $(HASHTAB_H) $(GGC_H) $(TM_P_H) langhooks.h \
    gt-function.h $(TARGET_H) $(BASIC_BLOCK_H) $(PREDICT_H) \
    $(TREE_PASS_H) $(DF_H) $(PARAMS_H) bb-reorder.h \
-   $(COMMON_TARGET_H)
+   l-ipo.h $(COMMON_TARGET_H)
 statistics.o : statistics.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
    $(TREE_PASS_H) $(TREE_DUMP_H) $(HASHTAB_H) statistics.h $(FUNCTION_H)
 stmt.o : stmt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h $(TM_H) $(RTL_H) \
@@ -2761,7 +2767,7 @@ stmt.o : stmt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h $(TM_H) $(RTL_H)
    $(LIBFUNCS_H) $(EXCEPT_H) $(RECOG_H) $(DIAGNOSTIC_CORE_H) \
    output.h $(GGC_H) $(TM_P_H) langhooks.h $(PREDICT_H) $(OPTABS_H) \
    $(TARGET_H) $(GIMPLE_H) $(MACHMODE_H) $(REGS_H) alloc-pool.h \
-   $(PRETTY_PRINT_H) $(BITMAP_H) $(PARAMS_H)
+   $(PRETTY_PRINT_H) $(BITMAP_H) $(PARAMS_H) $(COVERAGE_H)
 except.o : except.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
    $(TREE_H) $(FLAGS_H) $(EXCEPT_H) $(FUNCTION_H) $(EXPR_H) $(LIBFUNCS_H) \
    langhooks.h insn-config.h hard-reg-set.h $(BASIC_BLOCK_H) output.h \
@@ -2866,7 +2872,7 @@ cgraph.o : cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h \
    langhooks.h toplev.h $(DIAGNOSTIC_CORE_H) $(FLAGS_H) $(GGC_H) $(TARGET_H) $(CGRAPH_H) \
    gt-cgraph.h intl.h $(BASIC_BLOCK_H) debug.h $(HASHTAB_H) \
    $(TREE_INLINE_H) $(TREE_FLOW_H) cif-code.def \
-   value-prof.h $(EXCEPT_H) $(IPA_UTILS_H) $(DIAGNOSTIC_CORE_H) \
+   value-prof.h $(EXCEPT_H) $(IPA_UTILS_H) $(DIAGNOSTIC_CORE_H) l-ipo.h \
    $(IPA_INLINE_H) $(LTO_STREAMER_H) $(CFGLOOP_H) $(GIMPLE_PRETTY_PRINT_H)
 cgraphunit.o : cgraphunit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
    $(TREE_H) langhooks.h $(TREE_INLINE_H) toplev.h $(DIAGNOSTIC_CORE_H) $(FLAGS_H) $(GGC_H) \
@@ -2874,8 +2880,9 @@ cgraphunit.o : cgraphunit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
    $(TREE_FLOW_H) $(TREE_PASS_H) debug.h $(DIAGNOSTIC_H) \
    $(FIBHEAP_H) output.h $(PARAMS_H) $(RTL_H) $(IPA_PROP_H) \
    gt-cgraphunit.h tree-iterator.h $(COVERAGE_H) $(TREE_DUMP_H) \
-   $(GIMPLE_PRETTY_PRINT_H) $(IPA_INLINE_H) $(IPA_UTILS_H) \
-   $(LTO_STREAMER_H) output.h $(REGSET_H) $(EXCEPT_H) $(GCC_PLUGIN_H) plugin.h
+   $(GIMPLE_PRETTY_PRINT_H) $(IPA_INLINE_H) $(IPA_UTILS_H) l-ipo.h \
+   $(LTO_STREAMER_H) output.h $(REGSET_H) $(EXCEPT_H) $(GCC_PLUGIN_H) plugin.h \
+   $(AUTO_PROFILE_H)
 cgraphclones.o : cgraphclones.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
    $(TREE_H) langhooks.h $(TREE_INLINE_H) toplev.h $(DIAGNOSTIC_CORE_H) $(FLAGS_H) $(GGC_H) \
    $(TARGET_H) $(CGRAPH_H) intl.h pointer-set.h $(FUNCTION_H) $(GIMPLE_H) \
@@ -2883,31 +2890,31 @@ cgraphclones.o : cgraphclones.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
    $(PARAMS_H) $(RTL_H) $(IPA_PROP_H) \
    tree-iterator.h $(COVERAGE_H) \
    $(GIMPLE_PRETTY_PRINT_H) $(IPA_INLINE_H) $(IPA_UTILS_H) \
-   $(LTO_STREAMER_H) $(EXCEPT_H) $(GCC_PLUGIN_H) gt-cgraphclones.h
+   $(LTO_STREAMER_H) $(EXCEPT_H) $(GCC_PLUGIN_H) $(AUTO_PROFILE_H) gt-cgraphclones.h
 cgraphbuild.o : cgraphbuild.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
    $(TREE_H) langhooks.h $(CGRAPH_H) intl.h pointer-set.h $(GIMPLE_H) \
    $(TREE_FLOW_H) $(TREE_PASS_H) $(IPA_UTILS_H) $(EXCEPT_H) \
-   $(IPA_INLINE_H)
+   $(IPA_INLINE_H) l-ipo.h $(AUTO_PROFILE_H)
 varpool.o : varpool.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
    $(TREE_H) $(CGRAPH_H) langhooks.h $(DIAGNOSTIC_CORE_H) $(HASHTAB_H) \
    $(GGC_H) $(TIMEVAR_H) debug.h $(TARGET_H) output.h $(GIMPLE_H) \
-   $(TREE_FLOW_H) 
+   $(TREE_FLOW_H) l-ipo.h
 ipa.o : ipa.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(CGRAPH_H) \
    $(TREE_PASS_H) $(GIMPLE_H) $(TARGET_H) $(GGC_H) pointer-set.h \
-   $(IPA_UTILS_H)
+   $(IPA_UTILS_H) l-ipo.h
 ipa-prop.o : ipa-prop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
    langhooks.h $(GGC_H) $(TARGET_H) $(CGRAPH_H) $(IPA_PROP_H) $(DIAGNOSTIC_H) \
    $(TREE_FLOW_H) $(TM_H) $(TREE_PASS_H) $(FLAGS_H) $(TREE_H) \
    $(TREE_INLINE_H) $(GIMPLE_H) \
    $(GIMPLE_PRETTY_PRINT_H) $(LTO_STREAMER_H) \
-   $(DATA_STREAMER_H) $(TREE_STREAMER_H) $(PARAMS_H)
+   $(DATA_STREAMER_H) $(TREE_STREAMER_H) $(PARAMS_H) l-ipo.h
 ipa-ref.o : ipa-ref.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
    langhooks.h $(GGC_H) $(TARGET_H) $(CGRAPH_H)  $(TREE_H) $(TARGET_H) \
    $(TREE_FLOW_H) $(TM_H) $(TREE_PASS_H) $(FLAGS_H) $(TREE_H) $(GGC_H) 
 ipa-cp.o : ipa-cp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \
    $(TREE_H) $(TARGET_H) $(GIMPLE_H) $(CGRAPH_H) $(IPA_PROP_H) $(TREE_FLOW_H) \
    $(TREE_PASS_H) $(FLAGS_H) $(DIAGNOSTIC_H) \
-   $(TREE_INLINE_H) $(PARAMS_H) $(TREE_PRETTY_PRINT_H) $(IPA_INLINE_H)
+   $(TREE_INLINE_H) $(PARAMS_H) $(TREE_PRETTY_PRINT_H) $(IPA_INLINE_H) l-ipo.h
 ipa-split.o : ipa-split.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
    $(TREE_H) $(TARGET_H) $(CGRAPH_H) $(IPA_PROP_H) $(TREE_FLOW_H) \
    $(TREE_PASS_H) $(FLAGS_H) $(DIAGNOSTIC_H) $(TREE_DUMP_H) \
@@ -2917,7 +2924,7 @@ ipa-inline.o : ipa-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
    $(DIAGNOSTIC_H) $(FIBHEAP_H) $(PARAMS_H) $(TREE_PASS_H) \
    $(COVERAGE_H) $(GGC_H) $(TREE_FLOW_H) $(RTL_H) $(IPA_PROP_H) \
    $(EXCEPT_H) $(GIMPLE_PRETTY_PRINT_H) $(IPA_INLINE_H) $(TARGET_H) \
-   $(IPA_UTILS_H)
+   $(IPA_UTILS_H) l-ipo.h $(AUTO_PROFILE_H) sreal.h
 ipa-inline-analysis.o : ipa-inline-analysis.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
    $(TREE_H) langhooks.h $(TREE_INLINE_H) $(FLAGS_H) $(CGRAPH_H) intl.h \
    $(DIAGNOSTIC_H) $(PARAMS_H) $(TREE_PASS_H) $(CFGLOOP_H) \
@@ -2928,11 +2935,11 @@ ipa-inline-transform.o : ipa-inline-transform.c $(CONFIG_H) $(SYSTEM_H) coretype
    $(TREE_H) langhooks.h $(TREE_INLINE_H) $(FLAGS_H) $(CGRAPH_H) intl.h \
    $(TREE_PASS_H) \
    $(HASHTAB_H) $(COVERAGE_H) $(GGC_H) $(TREE_FLOW_H) $(IPA_PROP_H) \
-   $(TREE_PASS_H)
+   $(TREE_PASS_H) l-ipo.h
 ipa-utils.o : ipa-utils.c $(IPA_UTILS_H) $(CONFIG_H) $(SYSTEM_H) \
    coretypes.h dumpfile.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) \
    langhooks.h pointer-set.h $(GGC_H) $(GIMPLE_H) $(SPLAY_TREE_H) \
-   $(CGRAPH_H) $(FLAGS_H) $(DIAGNOSTIC_H)
+   $(CGRAPH_H) $(FLAGS_H) $(DIAGNOSTIC_H) l-ipo.h
 ipa-reference.o : ipa-reference.c $(CONFIG_H) $(SYSTEM_H) \
    coretypes.h $(TM_H) $(TREE_H) $(TREE_FLOW_H) $(TREE_INLINE_H) langhooks.h \
    pointer-set.h $(GGC_H) $(IPA_REFERENCE_H) $(IPA_UTILS_H) $(SPLAY_TREE_H) \
@@ -2949,7 +2956,12 @@ coverage.o : coverage.c $(GCOV_IO_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfil
    $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) \
    $(FUNCTION_H) $(BASIC_BLOCK_H) toplev.h $(DIAGNOSTIC_CORE_H) $(GGC_H) langhooks.h $(COVERAGE_H) \
    tree-iterator.h $(CGRAPH_H) gcov-io.c $(TM_P_H) \
-   $(DIAGNOSTIC_CORE_H) intl.h gt-coverage.h $(TARGET_H) $(HASH_TABLE_H)
+   $(DIAGNOSTIC_CORE_H) intl.h gt-coverage.h $(TARGET_H) $(HASH_TABLE_H) l-ipo.h \
+   $(AUTO_PROFILE_H)
+auto-profile.o : auto-profile.c $(CONFIG_H) $(SYSTEM_H) $(FLAGS_H) \
+   $(BASIC_BLOCK_H) $(DIAGNOSTIC_CORE_H) $(GCOV_IO_H) $(INPUT_H) profile.h \
+   $(LANGHOOKS_H) $(OPTS_H) $(TREE_PASS_H) $(CGRAPH_H) $(GIMPLE_H) value-prof.h \
+   $(COVERAGE_H) coretypes.h $(TREE_H) $(PARAMS_H) $(AUTO_PROFILE_H)
 cselib.o : cselib.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h $(TM_H) $(RTL_H) \
    $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h $(RECOG_H) \
    $(EMIT_RTL_H) $(DIAGNOSTIC_CORE_H) $(FUNCTION_H) \
@@ -3032,7 +3044,7 @@ tree-sra.o : tree-sra.c $(CONFIG_H) $(SYSTEM_H) coretypes.h alloc-pool.h \
    $(TM_H) $(TREE_H) $(GIMPLE_H) $(CGRAPH_H) $(TREE_FLOW_H) \
    $(IPA_PROP_H) $(DIAGNOSTIC_H) statistics.h \
    $(PARAMS_H) $(TARGET_H) $(FLAGS_H) \
-   $(DBGCNT_H) $(TREE_INLINE_H) $(GIMPLE_PRETTY_PRINT_H)
+   $(DBGCNT_H) $(TREE_INLINE_H) $(GIMPLE_PRETTY_PRINT_H) l-ipo.h
 tree-switch-conversion.o : tree-switch-conversion.c $(CONFIG_H) $(SYSTEM_H) \
     $(TREE_H) $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) $(TREE_INLINE_H) \
     $(TM_H) coretypes.h $(GIMPLE_H) \
@@ -3089,7 +3101,7 @@ value-prof.o : value-prof.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h $(TM_
    $(RECOG_H) insn-config.h $(OPTABS_H) $(REGS_H) $(GGC_H) $(DIAGNOSTIC_H) \
    $(TREE_H) $(COVERAGE_H) $(RTL_H) $(GCOV_IO_H) $(TREE_FLOW_H) \
    tree-flow-inline.h $(TIMEVAR_H) $(DIAGNOSTIC_CORE_H) pointer-set.h \
-   $(GIMPLE_PRETTY_PRINT_H)
+   $(GIMPLE_PRETTY_PRINT_H) l-ipo.h
 loop-doloop.o : loop-doloop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h $(TM_H) \
    $(RTL_H) $(FLAGS_H) $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) $(TM_P_H) \
    $(DIAGNOSTIC_CORE_H) $(CFGLOOP_H) $(PARAMS_H) $(TARGET_H)
@@ -3102,7 +3114,7 @@ cfg.o : cfg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h $(DIAGNOSTIC_CORE_H
    $(GGC_H) $(OBSTACK_H) alloc-pool.h $(HASH_TABLE_H) $(CFGLOOP_H) $(TREE_H) \
    $(BASIC_BLOCK_H)
 cfghooks.o: cfghooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
-   $(TREE_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(TIMEVAR_H) toplev.h $(DIAGNOSTIC_CORE_H) $(CFGLOOP_H)
+   $(TREE_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(TIMEVAR_H) toplev.h $(DIAGNOSTIC_CORE_H) $(CFGLOOP_H) $(PRETTY_PRINT_H)
 cfgexpand.o : cfgexpand.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \
    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(FUNCTION_H) $(TM_H) \
    coretypes.h $(EXCEPT_H) langhooks.h $(TREE_PASS_H) $(RTL_H) \
@@ -3315,7 +3327,7 @@ modulo-sched.o : modulo-sched.c $(DDG_H) $(CONFIG_H) $(CONFIG_H) $(SYSTEM_H) \
    $(FLAGS_H) insn-config.h $(INSN_ATTR_H) $(EXCEPT_H) $(RECOG_H) \
    $(SCHED_INT_H) $(CFGLOOP_H) $(EXPR_H) $(PARAMS_H) \
    $(GCOV_IO_H) hard-reg-set.h $(TM_H) $(TREE_PASS_H) \
-   $(DF_H) $(DBGCNT_H)
+   $(DF_H) $(DBGCNT_H) profile.h
 haifa-sched.o : haifa-sched.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h \
    $(TM_H) $(RTL_H) \
    $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h $(FUNCTION_H) \
@@ -3379,7 +3391,7 @@ predict.o: predict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
    hard-reg-set.h $(DIAGNOSTIC_CORE_H) $(RECOG_H) $(FUNCTION_H) $(EXCEPT_H) \
    $(TM_P_H) $(PREDICT_H) sreal.h $(PARAMS_H) $(TARGET_H) $(CFGLOOP_H) \
    $(COVERAGE_H) $(SCEV_H) $(GGC_H) predict.def \
-   $(TREE_FLOW_H) $(TREE_PASS_H) $(EXPR_H) pointer-set.h
+   $(TREE_FLOW_H) $(TREE_PASS_H) $(EXPR_H) pointer-set.h $(AUTO_PROFILE_H)
 lists.o: lists.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(DIAGNOSTIC_CORE_H) \
    $(RTL_H) $(GGC_H) gt-lists.h
 bb-reorder.o : bb-reorder.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
@@ -3406,6 +3418,9 @@ ifcvt.o : ifcvt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \
    $(TARGET_H) $(BASIC_BLOCK_H) $(EXPR_H) output.h $(EXCEPT_H) $(TM_P_H) \
    $(OPTABS_H) $(CFGLOOP_H) hard-reg-set.h pointer-set.h \
    $(TREE_PASS_H) $(DF_H) $(DBGCNT_H)
+l-ipo.o : l-ipo.c l-ipo.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \
+    toplev.h $(LANGHOOKS_DEF_H) $(DIAGNOSTIC_H) debug.h $(GIMPLE_H) \
+    $(CGRAPH_H) $(GGC_H)
 params.o : params.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(COMMON_TARGET_H) \
    $(PARAMS_H) $(DIAGNOSTIC_CORE_H)
 pointer-set.o: pointer-set.c pointer-set.h $(CONFIG_H) $(SYSTEM_H)
@@ -3723,7 +3738,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \
   $(srcdir)/dwarf2cfi.c \
   $(srcdir)/dwarf2out.c \
   $(srcdir)/tree-vect-generic.c \
-  $(srcdir)/dojump.c \
+  $(srcdir)/dojump.c $(srcdir)/l-ipo.c \
   $(srcdir)/emit-rtl.c $(srcdir)/except.h $(srcdir)/explow.c $(srcdir)/expr.c \
   $(srcdir)/expr.h \
   $(srcdir)/function.c $(srcdir)/except.c \
@@ -4050,10 +4065,10 @@ gcov.o: gcov.c gcov-io.c $(GCOV_IO_H) intl.h $(SYSTEM_H) coretypes.h $(TM_H) \
 gcov-dump.o: gcov-dump.c gcov-io.c $(GCOV_IO_H) $(SYSTEM_H) coretypes.h \
    $(TM_H) $(CONFIG_H) version.h intl.h $(DIAGNOSTIC_H)
 
-GCOV_OBJS = gcov.o
+GCOV_OBJS = gcov.o vec.o ggc-none.o
 gcov$(exeext): $(GCOV_OBJS) $(LIBDEPS)
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) $(GCOV_OBJS) $(LIBS) -o $@
-GCOV_DUMP_OBJS = gcov-dump.o
+GCOV_DUMP_OBJS = gcov-dump.o vec.o ggc-none.o
 gcov-dump$(exeext): $(GCOV_DUMP_OBJS) $(LIBDEPS)
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) $(GCOV_DUMP_OBJS) \
 		$(LIBS) -o $@
diff --git a/gcc/attribs.c b/gcc/attribs.c
index 08ebfe1..e311710 100644
--- a/gcc/attribs.c
+++ b/gcc/attribs.c
@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "hashtab.h"
 #include "plugin.h"
 
+
 /* Table of the tables of attributes (common, language, format, machine)
    searched.  */
 static const struct attribute_spec *attribute_tables[4];
diff --git a/gcc/auto-profile.c b/gcc/auto-profile.c
new file mode 100644
index 0000000..3509db5
--- /dev/null
+++ b/gcc/auto-profile.c
@@ -0,0 +1,1721 @@
+/* Calculate branch probabilities, and basic block execution counts.
+   Copyright (C) 2012. Free Software Foundation, Inc.
+   Contributed by Dehao Chen (dehao@google.com)
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Read and annotate call graph profile from the auto profile data
+   file.  */
+
+#include <string.h>
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tree.h"
+#include "flags.h"	      /* for auto_profile_file.  */
+#include "basic-block.h"      /* for gcov_type.	 */
+#include "diagnostic-core.h"  /* for inform ().  */
+#include "gcov-io.h"	      /* for gcov_read_unsigned ().  */
+#include "input.h"	      /* for expanded_location.	 */
+#include "profile.h"	      /* for profile_info.  */
+#include "langhooks.h"	      /* for langhooks.	 */
+#include "opts.h"	      /* for in_fnames.	 */
+#include "tree-pass.h"	      /* for ipa pass.  */
+#include "cfgloop.h"	      /* for loop_optimizer_init.  */
+#include "gimple.h"
+#include "cgraph.h"
+#include "tree-flow.h"
+#include "value-prof.h"
+#include "coverage.h"
+#include "params.h"
+#include "auto-profile.h"
+
+/* The following routines implements AutoFDO optimization.
+
+   This optimization uses sampling profiles to annotate basic block counts
+   and uses heuristics to estimate branch probabilities.
+
+   There are three phases in AutoFDO:
+
+   Phase 1: Read profile from the profile data file.
+     The following info is read from the profile datafile:
+	* Function names and file names.
+	* Source level profile, which is a mapping from inline stack to
+	  its sample counts. 
+	* Module profile: Module to aux-modules mapping
+     Phase 1 just reads in data without processing it. It is invoked
+     before tree parsing because LIPO needs module profile before tree
+     parsing. (read_aux_modules)
+
+   Phase 2: Process profile to build internal data structure (hashmap).
+     This is done after tree parsing, because the processing requires the map
+     from function name to its debug name (bfd_name). The following hashmaps
+     is used to store profile.
+	* function_htab: map from function_name to its entry_bb count
+	* stack_htab: map from inline stack to its sample count
+	* bfd_name_htab: map from function name to its debug name (bfd_name)
+	* module_htab: map from module name to its aux-module names
+
+   Phase 3: Annotate control flow graph.
+     AutoFDO invokes a separate pass over the control flow graph to:
+	* Annotate basic block count
+	* Estimate branch probability
+
+   After the above 3 phases, all profile is readily annotated on the GCC IR.
+   AutoFDO tries to reuse all FDO infrastructure as much as possible to make
+   use of the profile. E.g. it uses existing mechanism to calculate the basic
+   block/edge frequency, as well as the cgraph node/edge count.
+
+   However, AutoFDO still differs from FDO in the following aspects:
+
+   * Profile is not accurate, because AutoFDO uses sampling to collect
+     profile, and uses debug info to represent the profile. As a result,
+     some hot basic blocks may have zero sample count. Because of this,
+     some optimization needs to be adjusted (e.g. loop peeling/unrolling).
+   * Each cloned context has its own profile, but these contexts may
+     not even exist when doing annotation. This provides more context-
+     sensitive profiles, but at the same time, adds complexity to the
+     implementation. Because of this, additional profile annotation is
+     needed for each function after the inline pass, and count scaling
+     is tricky in the second annotation.
+*/
+
+#define DEFAULT_AUTO_PROFILE_FILE "fbdata.afdo"
+#define SP_HTAB_INIT_SIZE 2000
+
+/* GCOV data structures to represent profile stored in the .afdo file.  */
+
+struct gcov_callsite_pos
+{
+  const char *file;
+  const char *func;
+  gcov_unsigned_t line;
+  gcov_unsigned_t discr;
+};
+
+struct gcov_stack
+{
+  const char *func_name;
+  const char *callee_name;
+  struct gcov_callsite_pos *stack;
+  gcov_unsigned_t size;
+  struct gcov_hist *hist;
+  gcov_unsigned_t hist_size;
+  gcov_type num_inst;
+  gcov_type count;
+  gcov_type max_count;
+};
+
+struct gcov_function
+{
+  const char *name;
+  const char *file;
+  gcov_type total_count;
+  gcov_type entry_count;
+  gcov_type max_count;
+  /* Number of call stacks in the function.  */
+  gcov_unsigned_t stack_num;
+  /* All the call stacks in the function.  */
+  struct gcov_stack *stacks;
+};
+
+struct afdo_bfd_name
+{
+  const char *assembler_name;
+  /* bfd_name is the name that debugger used for function name matching.
+     Different assembler names could map to the same bfd_name.  */
+  const char *bfd_name;
+};
+
+struct afdo_module
+{
+  char *name;
+  int ident;
+  unsigned exported;
+  unsigned lang;
+  unsigned ggc_memory;
+  unsigned num_aux_modules;
+  unsigned num_quote_paths;
+  unsigned num_bracket_paths;
+  unsigned num_cpp_defines;
+  unsigned num_cpp_includes;
+  unsigned num_cl_args;
+  char **strings;
+};
+
+struct gcov_hist
+{
+  enum hist_type type;
+  union
+    {
+      const char *func_name;
+      unsigned long long value;
+    } value;
+  gcov_type count;
+};
+
+/* Store the file name strings read from the profile data file.	 */
+static const char **file_names;
+
+/* gcov_ctr_summary structure to store the profile_info.  */
+static struct gcov_ctr_summary *afdo_profile_info;
+
+/* Hash table to hold function information.  */
+static htab_t function_htab;
+
+/* Hash table to hold stack information.  */
+static htab_t stack_htab;
+
+/* Hash table to hold assembler name to bfd name mapping.  */
+static htab_t bfd_name_htab;
+
+/* Hash table to hold module informaition.  */
+static htab_t module_htab;
+
+/* Store the module hash table contents.  */
+static struct afdo_module *modules;
+
+/* File static variables, which is used to pass information between
+   init_auto_profile and process_auto_profile.  */
+static gcov_unsigned_t function_num;
+static gcov_unsigned_t total_module_num;
+static struct gcov_function *gcov_functions;
+
+/* Check if PATH_NAME is absolute path, if yes, strip the directory part
+   of the PATH_NAME, return the file name.  */
+
+static const char *
+afdo_get_filename (const char *path_name)
+{
+  const char* last;
+  return path_name;
+  if (path_name == NULL)
+    return NULL;
+  last = strrchr (path_name, '/');
+  return ((last == 0) ? path_name : last + 1);
+}
+
+/* Given an assembler function NAME, return its original name. strip the
+   suffix at the end of the function name, added by optimizations such as
+   constant propagation etc.  */
+
+static gcov_unsigned_t
+afdo_get_original_name_size (const char *name)
+{
+  const char *ret;
+  if (!name)
+    return 0;
+  ret = strchr (name, '.');
+  if (!ret)
+    return strlen (name);
+  else
+    return ret - name;
+}
+
+/* Given an asssembler function NAME, return its corresponding bfd name.
+   If the mapping cannot be found, it means that the assembler function
+   name is not used/emitted in the current module(s).  */
+
+static const char *
+afdo_get_bfd_name (const char *name)
+{
+  struct afdo_bfd_name bfd, *bfd_entry;
+  gcov_unsigned_t size = afdo_get_original_name_size (name);
+  /* If the function name is cloned, we want to find its original name.  */
+  char *buf = (char *) alloca (size + 1);
+  strncpy (buf, name, size);
+  buf[size] = 0;
+  bfd.assembler_name = buf;
+  bfd_entry = (struct afdo_bfd_name *) htab_find (bfd_name_htab, &bfd);
+  if (!bfd_entry)
+    return name;
+  return bfd_entry->bfd_name;
+}
+
+/* Traverse the cgraph, add each function's name to to bfd_name mapping.  */
+
+static void
+afdo_read_bfd_names (void)
+{
+  struct cgraph_node *node;
+
+  FOR_EACH_FUNCTION (node)
+    {
+      const char *bfd_name;
+      if (lang_hooks.dwarf_name (node->symbol.decl, 0) == NULL)
+	continue;
+      bfd_name = xstrdup (lang_hooks.dwarf_name (node->symbol.decl, 0));
+      afdo_add_bfd_name_mapping (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME
+	  (node->symbol.decl)), bfd_name);
+    }
+}
+
+/* Hash function for struct afdo_stack.  */
+
+static hashval_t
+afdo_stack_hash (const void *stack)
+{
+  gcov_unsigned_t i;
+  /* An arbitrary initial value borrowed from hashtab.c.  */
+  hashval_t h = 0x9e3779b9;
+  const struct gcov_stack *s = (const struct gcov_stack *) stack;
+  if (s->callee_name)
+    h = iterative_hash (afdo_get_bfd_name (s->callee_name),
+			strlen (afdo_get_bfd_name (s->callee_name)), h);
+  if (s->func_name)
+    h = iterative_hash (s->func_name,
+			afdo_get_original_name_size (s->func_name), h);
+  for (i = 0; i < s->size; i++) {
+    const struct gcov_callsite_pos *p = s->stack + i;
+    const char *file = afdo_get_filename (p->file);
+    const char *func = afdo_get_bfd_name (p->func);
+    h = iterative_hash (file, strlen (file), h);
+    if (func)
+      h = iterative_hash (func, strlen (func), h);
+    h = iterative_hash (&p->line, sizeof (p->line), h);
+    if (i == 0)
+      h = iterative_hash (&p->discr, sizeof (p->discr), h);
+  }
+  return h;
+}
+
+/* Check if two afdo_stack P and Q are identical.  */
+
+static int
+afdo_stack_eq (const void *p, const void *q)
+{
+  const struct gcov_stack *s1 = (const struct gcov_stack *) p;
+  const struct gcov_stack *s2 = (const struct gcov_stack *) q;
+
+  gcov_unsigned_t i;
+  if (s1->func_name == NULL || s2->func_name == NULL)
+    return 0;
+
+  if (s1->callee_name == NULL)
+    {
+      if (s2->callee_name != NULL)
+	return 0;
+    }
+  else if (s2->callee_name == NULL)
+    return 0;
+  else if (strcmp (afdo_get_bfd_name (s1->callee_name),
+		   afdo_get_bfd_name (s2->callee_name)))
+    return 0;
+
+  i = afdo_get_original_name_size (s1->func_name);
+  if (i != afdo_get_original_name_size (s2->func_name))
+    return 0;
+
+  if (strncmp (s1->func_name, s2->func_name, i))
+    return 0;
+
+  if (s1->size != s2->size)
+    return 0;
+  for (i = 0; i < s1->size; i++)
+    {
+      const struct gcov_callsite_pos *p1 = s1->stack + i;
+      const struct gcov_callsite_pos *p2 = s2->stack + i;
+      const char *func1 = afdo_get_bfd_name (p1->func);
+      const char *func2 = afdo_get_bfd_name (p2->func);
+
+      if (func1 != NULL && func2 != NULL)
+	{
+	  if (strcmp (func1, func2))
+	    return 0;
+	}
+      else if (func1 != func2)
+	return 0;
+
+      if (strcmp (afdo_get_filename (p1->file), afdo_get_filename (p2->file))
+	  || p1->line != p2->line || (i== 0 && p1->discr != p2->discr))
+	return 0;
+    }
+  return 1;
+}
+
+/* Hash function for struct afdo_function.  */
+
+static hashval_t
+afdo_function_hash (const void *func)
+{
+  /* An arbitrary initial value borrowed from hashtab.c.  */
+  hashval_t h = 0x9e3779b9;
+  const struct gcov_function *f = (const struct gcov_function *) func;
+
+  if (f->name)
+    h = iterative_hash (f->name, afdo_get_original_name_size (f->name), h);
+  return h;
+}
+
+/* Check if two afdo_function P and Q are identical.  */
+
+static int
+afdo_function_eq (const void *p, const void *q)
+{
+  const struct gcov_function *f1 = (const struct gcov_function *) p;
+  const struct gcov_function *f2 = (const struct gcov_function *) q;
+  gcov_unsigned_t i;
+
+  if (f1->name == NULL || f2->name == NULL)
+    return 0;
+
+  i = afdo_get_original_name_size (f1->name);
+  if (i != afdo_get_original_name_size (f2->name))
+    return 0;
+
+  return !strncmp (f1->name, f2->name, i);
+}
+
+/* Hash function for struct afdo_bfd_name.  */
+
+static hashval_t
+afdo_bfd_name_hash (const void *func)
+{
+  hashval_t h = 0x9e3779b9;
+  const struct afdo_bfd_name *f = (const struct afdo_bfd_name *) func;
+
+  if (f->assembler_name)
+    h = iterative_hash (f->assembler_name, strlen (f->assembler_name), h);
+  return h;
+}
+
+/* Check if two struct afdo_bfd_name P and Q are identical.  */
+
+static int
+afdo_bfd_name_eq (const void *p, const void *q)
+{
+  const struct afdo_bfd_name *b1 = (const struct afdo_bfd_name *) p;
+  const struct afdo_bfd_name *b2 = (const struct afdo_bfd_name *) q;
+
+  if (b1->assembler_name == NULL || b2->assembler_name == NULL)
+    return 0;
+
+  return !strcmp (b1->assembler_name, b2->assembler_name);
+}
+
+/* Free the hash table entry P.	 */
+
+static void
+afdo_bfd_name_del (void *p)
+{
+  free (p);
+}
+
+/* Hash Function for struct afdo_module.  */
+
+static hashval_t
+afdo_module_hash (const void *module)
+{
+  hashval_t h = 0x9e3779b9;
+  const struct afdo_module *m = (const struct afdo_module *)module;
+
+  if (m->name)
+    h = iterative_hash (m->name, strlen (m->name), h);
+
+  return h;
+}
+
+/* Check if two struct afdo_module P and Q are identical.	 */
+
+static int
+afdo_module_eq (const void *p, const void *q)
+{
+  const struct afdo_module *m1 = (const struct afdo_module *)p;
+  const struct afdo_module *m2 = (const struct afdo_module *)q;
+
+  if (m1->name == NULL || m2->name == NULL)
+    return 0;
+
+  return !strcmp (m1->name, m2->name);
+}
+
+/* Return the total number of emitted string for MODULE.  */
+
+static unsigned long long
+afdo_module_num_strings (const struct afdo_module *module)
+{
+  return module->num_quote_paths +
+    module->num_bracket_paths +
+    module->num_cpp_defines +
+    module->num_cpp_includes +
+    module->num_cl_args;
+}
+
+/* Add a module (specified in MODULE) into gcov_module_info format in
+   MODULE_INFO, which is used by LIPO to import auxiliary modules.
+   Set the is_primary flag if IS_PRIMARY is set.  */
+
+static void
+afdo_add_module (struct gcov_module_info **module_info,
+		 const struct afdo_module *module,
+		 gcov_unsigned_t is_primary)
+{
+  unsigned i;
+  size_t info_sz;
+
+  info_sz = sizeof (struct gcov_module_info) +
+    sizeof (void *) * afdo_module_num_strings (module);
+  *module_info = XCNEWVAR (struct gcov_module_info, info_sz);
+  (*module_info)->ident = module->ident;
+  (*module_info)->is_primary = is_primary;
+  (*module_info)->flags = is_primary ? module->exported : 1;
+  (*module_info)->lang = module->lang;
+  (*module_info)->ggc_memory = module->ggc_memory;
+  (*module_info)->source_filename = module->name;
+  (*module_info)->num_quote_paths = module->num_quote_paths;
+  (*module_info)->num_bracket_paths = module->num_bracket_paths;
+  (*module_info)->num_cpp_defines = module->num_cpp_defines;
+  (*module_info)->num_cpp_includes = module->num_cpp_includes;
+  (*module_info)->num_cl_args = module->num_cl_args;
+  for (i = 0; i < afdo_module_num_strings (module); i++)
+    (*module_info)->string_array[i] =
+	module->strings[module->num_aux_modules + i];
+}
+
+/* Read in the auxiliary modules for the current primary module.  */
+
+static void
+read_aux_modules (void)
+{
+  unsigned i, curr_module = 1, max_group = PARAM_VALUE (PARAM_MAX_LIPO_GROUP);
+  struct afdo_module module, *entry;
+
+  module.name = xstrdup (in_fnames[0]);
+  entry = (struct afdo_module *) htab_find (module_htab, &module);
+  if (!entry)
+    return;
+  module_infos = XCNEWVEC (struct gcov_module_info *,
+			   entry->num_aux_modules + 1);
+  afdo_add_module (module_infos, entry, true);
+  primary_module_id = entry->ident;
+  for (i = 0; i < entry->num_aux_modules; i++)
+    {
+      struct afdo_module *aux_entry;
+      module.name = entry->strings[i];
+      if (!strcmp (module.name, in_fnames[0]))
+	continue;
+      aux_entry = (struct afdo_module *) htab_find (module_htab, &module);
+      if (!aux_entry)
+	{
+	  inform (0, "aux module %s cannot be found.", module.name);
+	  continue;
+	}
+      if ((aux_entry->lang & GCOV_MODULE_LANG_MASK) !=
+	  (entry->lang & GCOV_MODULE_LANG_MASK))
+	{
+	  inform (0, "Not importing %s: source language"
+		  " different from primary module's source language",
+		  aux_entry->name);
+	  continue;
+	}
+      if ((aux_entry->lang & GCOV_MODULE_ASM_STMTS)
+	   && flag_ripa_disallow_asm_modules)
+	{
+	  if (flag_opt_info)
+	    inform (0, "Not importing %s: contains "
+		    "assembler statements", aux_entry->name);
+	  continue;
+	}
+      if (max_group != 0 && curr_module == max_group)
+	{
+	  if (flag_opt_info)
+	    inform (0, "Not importing %s: maximum group size reached",
+		    aux_entry->name);
+	}
+      afdo_add_module (&module_infos[curr_module], aux_entry, false);
+      if (incompatible_cl_args (module_infos[0], module_infos[curr_module]))
+	{
+	  if (flag_opt_info)
+	    inform (0, "Not importing %s: command-line"
+		    " arguments not compatible with primary module",
+		    aux_entry->name);
+	  free (module_infos[curr_module]);
+	  continue;
+	}
+      else
+	{
+	  curr_module ++;
+	  add_input_filename (module.name);
+	}
+    }
+}
+
+/* From AutoFDO profiles, find values inside STMT for that we want to measure
+   histograms for indirect-call optimization.  */
+
+static void
+afdo_indirect_call (gimple stmt, struct gcov_hist *values, int hist_size)
+{
+  tree callee;
+  int i, total = 0;
+  int actual_count = 0;
+  histogram_value hist;
+
+  if (gimple_code (stmt) != GIMPLE_CALL
+      || gimple_call_fndecl (stmt) != NULL_TREE)
+    return;
+
+  callee = gimple_call_fn (stmt);
+
+  for (i = 0; i < hist_size; i++)
+    if (values[i].type == HIST_TYPE_INDIR_CALL_TOPN)
+      break;
+
+  if (i == hist_size)
+    return;
+
+  hist = gimple_alloc_histogram_value (cfun, HIST_TYPE_INDIR_CALL_TOPN,
+				       stmt, callee);
+  hist->n_counters = (GCOV_ICALL_TOPN_VAL << 2) + 1;
+  hist->hvalue.counters =  XNEWVEC (gcov_type, hist->n_counters);
+  gimple_add_histogram_value (cfun, stmt, hist);
+
+  for (i = 0; i < hist_size; i++)
+    if (values[i].type == HIST_TYPE_INDIR_CALL_TOPN)
+      {
+	total += values[i].count;
+	/* Values are pre-sorted by the profile generator.  */
+	if (actual_count < 2)
+	  {
+	    hist->hvalue.counters[actual_count * 2 + 1] =
+		(unsigned long long) values[i].value.func_name;
+	    hist->hvalue.counters[actual_count * 2 + 2] = values[i].count;
+	    actual_count ++;
+	  }
+      }
+
+  hist->hvalue.counters[0] = total;
+
+  if (actual_count == 1)
+    {
+      hist->hvalue.counters[3] = 0;
+      hist->hvalue.counters[4] = 0;
+    }
+}
+
+/* From AutoFDO profiles, find values inside STMT for that we want to measure
+   histograms and adds them to list VALUES.  */
+
+static void
+afdo_vpt (gimple stmt, struct gcov_hist *v, int hist_size)
+{
+  afdo_indirect_call (stmt, v, hist_size);
+}
+
+/* Return the size of the inline stack of the STMT.  */
+
+static int
+get_inline_stack_size_by_stmt (gimple stmt)
+{
+  tree block;
+  int size = 1;
+
+  if (!stmt)
+    return 0;
+  if (LOCATION_LOCUS (gimple_location (stmt)) == UNKNOWN_LOCATION)
+    return 0;
+  block = gimple_block (stmt);
+  if (!block || TREE_CODE (block) != BLOCK || !gimple_location (stmt))
+    return 0;
+
+  for ( block = BLOCK_SUPERCONTEXT (block);
+	block && (TREE_CODE (block) == BLOCK);
+	block = BLOCK_SUPERCONTEXT (block)) {
+    /* Traverse the nesting blocks. If the block contains the source
+       location info, save the source location info to the inline stack.  */
+    if (LOCATION_LOCUS (BLOCK_SOURCE_LOCATION (block)) == UNKNOWN_LOCATION)
+      continue;
+    size ++;
+  }
+  return size;
+}
+
+/* Return the function decl of a given lexical BLOCK.  */
+
+static tree
+get_function_decl_from_block (tree block)
+{
+  tree decl;
+
+  if (LOCATION_LOCUS (BLOCK_SOURCE_LOCATION (block) == UNKNOWN_LOCATION))
+    return NULL_TREE;
+
+  for (decl = BLOCK_ABSTRACT_ORIGIN (block);
+       decl && (TREE_CODE (decl) == BLOCK);
+       decl = BLOCK_ABSTRACT_ORIGIN (decl))
+    if (TREE_CODE (decl) == FUNCTION_DECL)
+      break;
+  return decl;
+}
+
+/* Store the inline stack of STMT to POS_STACK, return the size of the
+   stack. Set the discriminator of the inline stack if DISCR is TRUE.  */
+
+static int
+get_inline_stack_by_stmt (gimple stmt, tree decl,
+			  struct gcov_callsite_pos *pos_stack, bool discr)
+{
+  tree block;
+  int idx = 0;
+  source_location loc;
+
+  if (!stmt)
+    return 0;
+  block = gimple_block (stmt);
+  if (!block || TREE_CODE (block) != BLOCK || !gimple_location (stmt))
+    return 0;
+
+  loc = gimple_location (stmt);
+  if (LOCATION_LOCUS (loc) == UNKNOWN_LOCATION)
+    return 0;
+  pos_stack[idx].file = expand_location (loc).file;
+  pos_stack[idx].line = expand_location (loc).line;
+  if (discr)
+    pos_stack[idx].discr = get_discriminator_from_locus (loc);
+  else
+    pos_stack[idx].discr = 0;
+  idx++;
+  for (block = BLOCK_SUPERCONTEXT (block);
+       block && (TREE_CODE (block) == BLOCK);
+       block = BLOCK_SUPERCONTEXT (block))
+    {
+      tree decl;
+      loc = BLOCK_SOURCE_LOCATION (block);
+
+      if (LOCATION_LOCUS (loc) == UNKNOWN_LOCATION)
+	continue;
+      decl = get_function_decl_from_block (block);
+      pos_stack[idx].file = expand_location (loc).file;
+      pos_stack[idx].line = expand_location (loc).line;
+      pos_stack[idx - 1].func =
+          decl ? IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)) : NULL;
+      pos_stack[idx - 1].line -= decl ? DECL_SOURCE_LINE (decl) : 0;
+      pos_stack[idx++].discr = 0;
+    }
+  if (decl)
+    {
+      pos_stack[idx - 1].func = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));
+      pos_stack[idx - 1].line -= DECL_SOURCE_LINE (decl);
+    }
+  return idx;
+}
+
+/* Read sample count info of the function with DECL, and save them
+   to ENTRY_COUNT and TOTAL_COUNT respectively.  */
+
+static void
+afdo_get_function_count (tree decl,
+			 gcov_type *entry_count)
+{
+  struct gcov_function func;
+  const struct gcov_function *func_entry;
+
+  *entry_count = 0;
+  func.name =
+    IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));
+  func.file = DECL_SOURCE_FILE (decl);
+  func_entry = (const struct gcov_function *)
+    htab_find (function_htab, &func);
+  if (func_entry)
+    {
+      /* We need to use the sum because in the profile collection binary,
+	 there are many cloned functions such as isra functions. We want
+	 to combine their profiles.  */
+      (*entry_count) = func_entry->entry_count;
+      return;
+    }
+  func.name = afdo_get_bfd_name (func.name);
+  func_entry = (const struct gcov_function *)
+    htab_find (function_htab, &func);
+  if (func_entry)
+    (*entry_count) = func_entry->entry_count;
+}
+
+/* Set the node count of the current function, and update the entry_bb
+   count.  */
+
+void
+afdo_set_current_function_count (void)
+{
+  gcov_type entry_count;
+  struct cgraph_node *node = cgraph_get_create_node (current_function_decl);
+
+  afdo_get_function_count (current_function_decl, &entry_count);
+  node->count = entry_count;
+  ENTRY_BLOCK_PTR->count = node->count;
+}
+
+/* Add the AS_NAME->BFD_NAME to the assembler_name to bfd_name mapping.  */
+
+void
+afdo_add_bfd_name_mapping (const char *as_name, const char *bfd_name)
+{
+  struct afdo_bfd_name **slot;
+  struct afdo_bfd_name *entry = (struct afdo_bfd_name *)
+    xmalloc (sizeof (struct afdo_bfd_name));
+
+  entry->assembler_name = as_name;
+  entry->bfd_name = bfd_name;
+  slot = (struct afdo_bfd_name **)
+    htab_find_slot (bfd_name_htab, entry, INSERT);
+  if (!*slot)
+    *slot = entry;
+  else
+    free (entry);
+}
+
+/* For a given POS_STACK with SIZE, get the COUNT, MAX_COUNT, NUM_INST,
+   HIST_SIZE and HIST for the inline stack. If CALLEE_NAME is non-null,
+   the COUNT/MAX_COUNT represents the total/max count in the inline stack.
+   Otherwise, the COUNT represents the count of an ordinary statement,
+   HIST stores the value histogram vectors with size of HIST_SIZE.
+   Return FALSE if profile is not found for the given POS_STACK.  */
+
+static bool
+get_stack_count (struct gcov_callsite_pos *pos_stack,
+		 const char *callee_name, int size,
+		 gcov_type *count, gcov_type *max_count, gcov_type *num_inst,
+		 gcov_unsigned_t *hist_size, struct gcov_hist **hist)
+{
+  struct gcov_stack stack, *entry;
+  stack.func_name = pos_stack[size - 1].func;
+  stack.callee_name = callee_name;
+  stack.stack = pos_stack;
+  stack.size = size;
+  entry = (struct gcov_stack *) htab_find (stack_htab, &stack);
+  if (entry)
+    {
+      *count = entry->count;
+      *num_inst = entry->num_inst;
+      if (max_count)
+	*max_count = entry->max_count;
+      if (hist_size)
+	{
+	  *hist_size = entry->hist_size;
+	  *hist = entry->hist;
+	}
+      return true;
+    }
+  *count = 0;
+  *num_inst = 0;
+  if (max_count)
+    *max_count = 0;
+  if (hist_size)
+    {
+      *hist_size = 0;
+      *hist = 0;
+    }
+  return false;
+}
+
+/* For a given STMT, get the COUNT and NUM_INST from its profile.
+   Return FALSE if profile is not found for STMT.  */
+
+static bool
+get_stmt_count (gimple stmt, gcov_type *count, gcov_type *num_inst,
+		gcov_unsigned_t *hist_size, struct gcov_hist **hist)
+{
+  struct gcov_callsite_pos *pos_stack;
+  int size;
+
+  if (!stmt)
+    return false;
+  size = get_inline_stack_size_by_stmt (stmt);
+  if (size == 0)
+    return false;
+  if (LOCATION_LOCUS (gimple_location (stmt)) == cfun->function_end_locus)
+    return false;
+
+  pos_stack = (struct gcov_callsite_pos *)
+      alloca (sizeof (struct gcov_callsite_pos) * size);
+
+  get_inline_stack_by_stmt (stmt, current_function_decl, pos_stack, true);
+
+  return get_stack_count (pos_stack, NULL, size, count, NULL, num_inst,
+			  hist_size, hist);
+}
+
+/* For a given EDGE, if IS_TOTAL is true, save EDGE->callee's total count
+   to COUNT, otherwise save EDGE's count to COUNT.  */
+
+static bool
+get_callsite_count (struct cgraph_edge *edge, gcov_type *count,
+		    gcov_type *max_count)
+{
+  struct gcov_callsite_pos *pos_stack;
+  gcov_type num_inst;
+  const char *callee_name =
+      IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (edge->callee->symbol.decl));
+  int size = get_inline_stack_size_by_stmt (edge->call_stmt);
+
+  if (size == 0)
+    return 0;
+  pos_stack = (struct gcov_callsite_pos *)
+      alloca (sizeof (struct gcov_callsite_pos) * size);
+
+  get_inline_stack_by_stmt (edge->call_stmt, edge->caller->symbol.decl,
+			    pos_stack, false);
+
+  return get_stack_count (pos_stack, callee_name,
+			  size, count, max_count, &num_inst, NULL, NULL);
+}
+
+/* For a given BB, return its execution count, and annotate value profile
+   on statements.  */
+
+static gcov_type
+afdo_get_bb_count (basic_block bb)
+{
+  gimple_stmt_iterator gsi;
+  gcov_type max_count = 0;
+  bool has_annotated = false;
+
+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+    {
+      gcov_type count, num_inst;
+      gcov_unsigned_t hist_size;
+      struct gcov_hist *hist;
+      gimple stmt = gsi_stmt (gsi);
+      if (get_stmt_count (stmt, &count, &num_inst, &hist_size, &hist))
+	{
+	  if (count > max_count)
+	    max_count = count;
+	  has_annotated = true;
+	  if (hist_size > 0)
+	    afdo_vpt (stmt, hist, hist_size);
+	}
+    }
+  if (has_annotated)
+    {
+      bb->flags |= BB_ANNOTATED;
+      return max_count;
+    }
+  else
+    return 0;
+}
+
+/* Annotate auto profile to the control flow graph.  */
+
+static void
+afdo_annotate_cfg (void)
+{
+  basic_block bb;
+  gcov_type max_count = ENTRY_BLOCK_PTR->count;
+
+  FOR_EACH_BB (bb)
+    {
+      bb->count = afdo_get_bb_count (bb);
+      if (bb->count > max_count)
+	max_count = bb->count;
+    }
+  if (ENTRY_BLOCK_PTR->count > ENTRY_BLOCK_PTR->next_bb->count)
+    {
+      ENTRY_BLOCK_PTR->next_bb->count = ENTRY_BLOCK_PTR->count;
+      ENTRY_BLOCK_PTR->next_bb->flags |= BB_ANNOTATED;
+    }
+  if (ENTRY_BLOCK_PTR->count > EXIT_BLOCK_PTR->prev_bb->count)
+    {
+      EXIT_BLOCK_PTR->prev_bb->count = ENTRY_BLOCK_PTR->count;
+      EXIT_BLOCK_PTR->prev_bb->flags |= BB_ANNOTATED;
+    }
+  if (max_count > 0)
+    {
+      afdo_calculate_branch_prob ();
+      counts_to_freqs ();
+      profile_status = PROFILE_READ;
+    }
+  if (flag_value_profile_transformations)
+    gimple_value_profile_transformations ();
+}
+
+extern gcov_working_set_t *gcov_working_sets;
+
+/* Read profile from profile data file. Write to the module hashmap.  */
+
+static void
+read_profile (void)
+{
+  gcov_unsigned_t i, j, k, file_name_num;
+  gcov_working_set_t set[128];
+
+  if (gcov_open (auto_profile_file, 1) == 0)
+    {
+      inform (0, "Cannot open profile file %s.", auto_profile_file);
+      flag_auto_profile = 0;
+      return;
+    }
+
+  if (gcov_read_unsigned () != GCOV_DATA_MAGIC)
+    {
+      inform (0, "Magic number does not mathch.");
+      flag_auto_profile = 0;
+      return;
+    }
+
+  /* GCOV_VERSION.  */
+  gcov_read_unsigned ();
+
+  /* Skip the empty integer.  */
+  gcov_read_unsigned ();
+  gcc_assert (gcov_read_unsigned () == GCOV_TAG_AFDO_FILE_NAMES);
+
+  /* Skip the length of the section.  */
+  gcov_read_unsigned ();
+
+  /* Read in the file name table.  */
+  file_name_num = gcov_read_unsigned ();
+  file_names = (const char **)
+    xmalloc (sizeof (const char *) * file_name_num);
+  for (i = 0; i < file_name_num; i++)
+    file_names[i] = xstrdup (gcov_read_string ());
+
+  if (gcov_read_unsigned () != GCOV_TAG_AFDO_FUNCTION)
+    {
+      inform (0, "Not expected TAG.");
+      return;
+    }
+
+  /* Skip the length of the section.  */
+  gcov_read_unsigned ();
+
+  /* Read in the function/callsite profile, and store it in local
+     data structure.  */
+  function_num = gcov_read_unsigned ();
+  gcov_functions = (struct gcov_function *)
+    xmalloc (function_num * sizeof (struct gcov_function));
+  for (i = 0; i < function_num; i++)
+    {
+      gcov_functions[i].name = file_names[gcov_read_unsigned ()];
+      gcov_functions[i].file = file_names[gcov_read_unsigned ()];
+      gcov_functions[i].total_count = gcov_read_counter ();
+      gcov_functions[i].entry_count = gcov_read_counter ();
+      gcov_functions[i].max_count = 0;
+      gcov_functions[i].stack_num = gcov_read_unsigned ();
+      gcov_functions[i].stacks = (struct gcov_stack *)
+	xmalloc (gcov_functions[i].stack_num * sizeof (struct gcov_stack));
+      for (j = 0; j < gcov_functions[i].stack_num; j++)
+	{
+	  gcov_functions[i].stacks[j].func_name = gcov_functions[i].name;
+	  gcov_functions[i].stacks[j].callee_name = NULL;
+	  gcov_functions[i].stacks[j].size = gcov_read_unsigned ();
+	  gcov_functions[i].stacks[j].stack = (struct gcov_callsite_pos *)
+	    xmalloc (gcov_functions[i].stacks[j].size
+		     * sizeof (struct gcov_callsite_pos));
+	  for (k = 0; k < gcov_functions[i].stacks[j].size; k++)
+	    {
+	      gcov_unsigned_t line, start_line;
+	      gcov_functions[i].stacks[j].stack[k].func =
+		file_names[gcov_read_unsigned ()];
+	      gcov_functions[i].stacks[j].stack[k].file =
+		file_names[gcov_read_unsigned ()];
+	      line = gcov_read_unsigned ();
+	      start_line = gcov_read_unsigned ();
+	      gcov_functions[i].stacks[j].stack[k].line =
+		line > start_line ? line - start_line : 0;
+	      gcov_functions[i].stacks[j].stack[k].discr =
+		gcov_read_unsigned ();
+	    }
+	  gcov_functions[i].stacks[j].count = gcov_read_counter ();
+	  gcov_functions[i].stacks[j].num_inst = gcov_read_counter ();
+	  gcov_functions[i].stacks[j].hist_size = gcov_read_unsigned ();
+	  if (gcov_functions[i].stacks[j].hist_size > 0)
+	    gcov_functions[i].stacks[j].hist = (struct gcov_hist *)
+	      xmalloc (gcov_functions[i].stacks[j].hist_size
+		       * sizeof (struct gcov_hist));
+	  else
+	    gcov_functions[i].stacks[j].hist = NULL;
+	  for (k = 0; k < gcov_functions[i].stacks[j].hist_size; k++)
+	    {
+	      gcov_functions[i].stacks[j].hist[k].type =
+		  (enum hist_type) gcov_read_unsigned ();
+	      if (gcov_functions[i].stacks[j].hist[k].type ==
+		  HIST_TYPE_INDIR_CALL_TOPN)
+		gcov_functions[i].stacks[j].hist[k].value.func_name =
+		    file_names[gcov_read_counter ()];
+	      else
+		gcov_functions[i].stacks[j].hist[k].value.value =
+		    gcov_read_counter ();
+	      gcov_functions[i].stacks[j].hist[k].count = gcov_read_counter ();
+	    }
+	}
+    }
+
+  /* Read in the module info.  */
+  if (gcov_read_unsigned () != GCOV_TAG_AFDO_MODULE_GROUPING)
+    {
+      inform (0, "Not expected TAG.");
+      return;
+    }
+  /* Skip the length of the section.  */
+  gcov_read_unsigned ();
+
+  /* Read in the file name table.  */
+  total_module_num = gcov_read_unsigned ();
+  modules = (struct afdo_module *)
+    xmalloc (total_module_num * sizeof (struct afdo_module));
+  for (i = 0; i < total_module_num; i++)
+    {
+      unsigned num_strings;
+      struct afdo_module **slot;
+      modules[i].name = xstrdup (gcov_read_string ());
+      modules[i].ident = i + 1;
+      /* exported flag.	 */
+      modules[i].exported = gcov_read_unsigned ();
+      modules[i].lang = gcov_read_unsigned ();
+      modules[i].ggc_memory = gcov_read_unsigned ();
+      /* aux_module and 5 options.  */
+      modules[i].num_aux_modules = gcov_read_unsigned ();
+      modules[i].num_quote_paths = gcov_read_unsigned ();
+      modules[i].num_bracket_paths = gcov_read_unsigned ();
+      modules[i].num_cpp_defines = gcov_read_unsigned ();
+      modules[i].num_cpp_includes = gcov_read_unsigned ();
+      modules[i].num_cl_args = gcov_read_unsigned ();
+      num_strings = modules[i].num_aux_modules
+	+ modules[i].num_quote_paths
+	+ modules[i].num_bracket_paths
+	+ modules[i].num_cpp_defines
+	+ modules[i].num_cpp_includes
+	+ modules[i].num_cl_args;
+      modules[i].strings = (char **)
+	xmalloc (num_strings * sizeof (char *));
+      for (j = 0; j < num_strings; j++)
+	modules[i].strings[j] = xstrdup (gcov_read_string ());
+      slot = (struct afdo_module **)
+	htab_find_slot (module_htab, &modules[i], INSERT);
+      if (!*slot)
+	*slot = &modules[i];
+      else
+	gcc_unreachable ();
+    }
+
+  /* Read in the working set.  */
+  if (gcov_read_unsigned () != GCOV_TAG_AFDO_WORKING_SET)
+    {
+      inform (0, "Not expected TAG.");
+      return;
+    }
+
+  /* Skip the length of the section.  */
+  gcov_read_unsigned ();
+  for (i = 0; i < 128; i++)
+    {
+      set[i].num_counters = gcov_read_unsigned ();
+      set[i].min_counter = gcov_read_counter ();
+    }
+  add_working_set (set);
+}
+
+/* Process the profile data and build the function/stack
+   hash maps.  */
+
+void
+process_auto_profile (void)
+{
+  unsigned i;
+
+  afdo_read_bfd_names ();
+  for (i = 0; i < function_num; i++)
+    {
+      struct gcov_function **func_slot = (struct gcov_function **)
+	  htab_find_slot (function_htab, gcov_functions + i, INSERT);
+      if (*func_slot)
+	{
+	  (*func_slot)->entry_count += gcov_functions[i].entry_count;
+	  (*func_slot)->total_count += gcov_functions[i].total_count;
+	  afdo_profile_info->sum_all += (*func_slot)->total_count;
+	}
+      else
+	*func_slot = gcov_functions + i;
+    }
+
+  for (i = 0; i < function_num; i++)
+    {
+      unsigned j;
+      struct gcov_function *func = gcov_functions + i;
+      for (j = 0; j < func->stack_num; j++)
+	{
+	  unsigned k;
+	  unsigned stack_size = func->stacks[j].size;
+	  gcov_type count = func->stacks[j].count;
+	  struct gcov_stack **stack_slot = (struct gcov_stack **)
+		  htab_find_slot (stack_htab, func->stacks + j, INSERT);
+	  if (func->stacks[j].num_inst && count > afdo_profile_info->sum_max)
+	    afdo_profile_info->sum_max = count / func->stacks[j].num_inst;
+	  if (*stack_slot)
+	    {
+	      (*stack_slot)->count += count;
+	      if ((*stack_slot)->num_inst < func->stacks[j].num_inst)
+		(*stack_slot)->num_inst = func->stacks[j].num_inst;
+	    }
+	  else
+	    *stack_slot = func->stacks + j;
+	  for (k = 1; k < stack_size; k++)
+	    {
+	      struct gcov_stack *new_stack = (struct gcov_stack *)
+		  xmalloc (sizeof (struct gcov_stack));
+	      new_stack->func_name = func->stacks[j].func_name;
+	      new_stack->callee_name =
+		  func->stacks[j].stack[stack_size - k - 1].func;
+	      new_stack->stack = func->stacks[j].stack + stack_size - k;
+	      new_stack->size = k;
+	      new_stack->num_inst = 0;
+	      new_stack->count = 0;
+	      new_stack->max_count = 0;
+	      new_stack->hist_size = 0;
+	      new_stack->hist = NULL;
+	      stack_slot = (struct gcov_stack **)
+		  htab_find_slot (stack_htab, new_stack, INSERT);
+	      if (!*stack_slot)
+		*stack_slot = new_stack;
+	      else
+		free (new_stack);
+	      (*stack_slot)->count += count;
+	      if ((*stack_slot)->max_count < count)
+		(*stack_slot)->max_count = count;
+	    }
+	}
+    }
+}
+
+/* Create the hash tables, and read the profile from the profile data
+   file.  */
+
+void
+init_auto_profile (void)
+{
+  if (auto_profile_file == NULL)
+    auto_profile_file = DEFAULT_AUTO_PROFILE_FILE;
+
+  /* Initialize the function hash table.  */
+  function_htab = htab_create_alloc ((size_t) SP_HTAB_INIT_SIZE,
+				     afdo_function_hash,
+				     afdo_function_eq,
+				     0,
+				     xcalloc,
+				     free);
+  /* Initialize the stack hash table.  */
+  stack_htab = htab_create_alloc ((size_t) SP_HTAB_INIT_SIZE,
+				  afdo_stack_hash,
+				  afdo_stack_eq,
+				  0,
+				  xcalloc,
+				  free);
+  /* Initialize the bfd name mapping table.  */
+  bfd_name_htab = htab_create_alloc ((size_t) SP_HTAB_INIT_SIZE,
+				     afdo_bfd_name_hash,
+				     afdo_bfd_name_eq,
+				     afdo_bfd_name_del,
+				     xcalloc,
+				     free);
+  /* Initialize the module hash table.  */
+  module_htab = htab_create_alloc ((size_t) SP_HTAB_INIT_SIZE,
+				   afdo_module_hash,
+				   afdo_module_eq,
+				   0,
+				   xcalloc,
+				   free);
+
+  afdo_profile_info = (struct gcov_ctr_summary *)
+    xcalloc (1, sizeof (struct gcov_ctr_summary));
+  afdo_profile_info->runs = 1;
+  afdo_profile_info->sum_max = 0;
+  afdo_profile_info->sum_all = 0;
+
+  /* Read the profile from the profile file.  */
+  read_profile ();
+
+  if (flag_dyn_ipa)
+    read_aux_modules ();
+}
+
+/* Free the resources.  */
+
+void
+end_auto_profile (void)
+{
+  unsigned i, j;
+
+  for (i = 0; i < function_num; i++)
+    {
+      for (j = 0; j < gcov_functions[i].stack_num; ++j)
+	{
+	  if (gcov_functions[i].stacks[j].hist_size > 0)
+	    free (gcov_functions[i].stacks[j].hist);
+	  free (gcov_functions[i].stacks[j].stack);
+	}
+      free (gcov_functions[i].stacks);
+    }
+  free (gcov_functions);
+
+  for (i = 0; i < total_module_num; i++)
+    free (modules[i].strings);
+  free (modules);
+  free (afdo_profile_info);
+  free (file_names);
+  htab_delete (function_htab);
+  htab_delete (stack_htab);
+  htab_delete (bfd_name_htab);
+  htab_delete (module_htab);
+  profile_info = NULL;
+}
+
+/* BB1 and BB2 are in an equivalent class iff:
+   1. BB1 dominates BB2.
+   2. BB2 post-dominates BB1.
+   3. BB1 and BB2 are in the same loop nest.
+   This function finds the equivalent class for each basic block, and
+   stores a pointer to the first BB in its equivalent class. Meanwhile,
+   set bb counts for the same equivalent class to be idenical.  */
+
+static void
+afdo_find_equiv_class (void)
+{
+  basic_block bb;
+
+  FOR_ALL_BB (bb)
+    bb->aux = NULL;
+
+  FOR_ALL_BB (bb)
+    {
+      vec<basic_block> dom_bbs;
+      basic_block bb1;
+      int i;
+
+      if (bb->aux != NULL)
+	continue;
+      bb->aux = bb;
+      dom_bbs = get_dominated_by (CDI_DOMINATORS, bb);
+      FOR_EACH_VEC_ELT (dom_bbs, i, bb1)
+	if (bb1->aux == NULL
+	    && dominated_by_p (CDI_POST_DOMINATORS, bb, bb1)
+	    && bb1->loop_father == bb->loop_father)
+	  {
+	    bb1->aux = bb;
+	    if (bb1->count > bb->count && (bb1->flags & BB_ANNOTATED) != 0)
+	      {
+		bb->count = MAX (bb->count, bb1->count);
+		bb->flags |= BB_ANNOTATED;
+	      }
+	  }
+      dom_bbs = get_dominated_by (CDI_POST_DOMINATORS, bb);
+      FOR_EACH_VEC_ELT (dom_bbs, i, bb1)
+	if (bb1->aux == NULL
+	    && dominated_by_p (CDI_DOMINATORS, bb, bb1)
+	    && bb1->loop_father == bb->loop_father)
+	  {
+	    bb1->aux = bb;
+	    if (bb1->count > bb->count && (bb1->flags & BB_ANNOTATED) != 0)
+	      {
+		bb->count = MAX (bb->count, bb1->count);
+		bb->flags |= BB_ANNOTATED;
+	      }
+	  }
+    }
+}
+
+/* If a baisk block only has one in/out edge, then the bb count and he
+   edge count should be the same.
+   IS_SUCC is true if the out edge of the basic block is examined.
+   Return TRUE if any basic block/edge count is changed.  */
+
+static bool
+afdo_propagate_single_edge (bool is_succ)
+{
+  basic_block bb;
+  bool changed = false;
+
+  FOR_EACH_BB (bb)
+    if (is_succ ? single_succ_p (bb) : single_pred_p (bb))
+      {
+	edge e = is_succ ? single_succ_edge (bb) : single_pred_edge (bb);
+	if (((e->flags & EDGE_ANNOTATED) == 0)
+	    && ((bb->flags & BB_ANNOTATED) != 0))
+	  {
+	    e->count = bb->count;
+	    e->flags |= EDGE_ANNOTATED;
+	    changed = true;
+	  }
+	else if (((e->flags & EDGE_ANNOTATED) != 0)
+	    && ((bb->flags & BB_ANNOTATED) == 0))
+	  {
+	    bb->count = e->count;
+	    bb->flags |= BB_ANNOTATED;
+	    changed = true;
+	  }
+	else if (bb->count != e->count)
+	  {
+	    e->count = bb->count = MAX (bb->count, e->count);
+	    changed = true;
+	  }
+      }
+  return changed;
+}
+
+/* If a basic block's count is known, and only one of its in/out edges' count
+   is unknown, its count can be calculated.
+   Meanwhile, if all of the in/out edges' counts are known, then the basic
+   block's unknown count can also be calculated.
+   IS_SUCC is true if out edges of a basic blocks are examined.
+   Return TRUE if any basic block/edge count is changed.  */
+
+static bool
+afdo_propagate_multi_edge (bool is_succ)
+{
+  basic_block bb;
+  bool changed = false;
+
+  FOR_EACH_BB (bb)
+    {
+      edge e, unknown_edge = NULL, zero_edge = NULL;
+      edge_iterator ei;
+      int num_unknown_edge = 0;
+      gcov_type total_known_count = 0;
+
+      if (is_succ)
+	{
+	  FOR_EACH_EDGE (e, ei, bb->succs)
+	    if ((e->flags & EDGE_ANNOTATED) == 0)
+	      num_unknown_edge ++, unknown_edge = e;
+	    else if (e->count == 0)
+	      zero_edge = e;
+	    else
+	      total_known_count += e->count;
+	}
+      else
+	{
+	  FOR_EACH_EDGE (e, ei, bb->preds)
+	    if ((e->flags & EDGE_ANNOTATED) == 0)
+	      num_unknown_edge ++, unknown_edge = e;
+	    else
+	      total_known_count += e->count;
+	}
+
+      if (num_unknown_edge == 0)
+	{
+	  if (total_known_count > bb->count)
+	    {
+	      bb->count = total_known_count;
+	      changed = true;
+	    }
+	  else if (zero_edge != NULL && total_known_count < bb->count
+		   && bb->loop_father && bb->loop_father->header == bb)
+	    {
+	      zero_edge->count = bb->count - total_known_count;
+	      changed = true;
+	    }
+	  if ((bb->flags & BB_ANNOTATED) == 0)
+	    {
+	      bb->flags |= BB_ANNOTATED;
+	      changed = true;
+	    }
+	}
+      else if (num_unknown_edge == 1
+	       && (bb->flags & BB_ANNOTATED) != 0)
+	{
+	  if (bb->count >= total_known_count)
+	    unknown_edge->count = bb->count - total_known_count;
+	  else
+	    unknown_edge->count = 0;
+	  unknown_edge->flags |= EDGE_ANNOTATED;
+	  changed = true;
+	}
+    }
+  return changed;
+}
+
+/* Special propagation for circuit expressions. Because GCC translates
+   control flow into data flow for circuit expressions. E.g.
+   BB1:
+   if (a && b)
+     BB2
+   else
+     BB3
+
+   will be translated into:
+
+   BB1:
+     if (a)
+       goto BB.t1
+     else
+       goto BB.t3
+   BB.t1:
+     if (b)
+       goto BB.t2
+     else
+       goto BB.t3
+   BB.t2:
+     goto BB.t3
+   BB.t3:
+     tmp = PHI (0 (BB1), 0 (BB.t1), 1 (BB.t2)
+     if (tmp)
+       goto BB2
+     else
+       goto BB3
+
+   In this case, we need to propagate through PHI to determine the edge
+   count of BB1->BB.t1, BB.t1->BB.t2.  */
+
+static void
+afdo_propagate_circuit (void)
+{
+  basic_block bb;
+  FOR_ALL_BB (bb)
+    {
+      gimple phi_stmt;
+      tree cmp_rhs, cmp_lhs;
+      gimple cmp_stmt = last_stmt (bb);
+      edge e;
+      edge_iterator ei;
+
+      if (!cmp_stmt || gimple_code (cmp_stmt) != GIMPLE_COND)
+	continue;
+      cmp_rhs = gimple_cond_rhs (cmp_stmt);
+      cmp_lhs = gimple_cond_lhs (cmp_stmt);
+      if (!TREE_CONSTANT (cmp_rhs)
+	  || !(integer_zerop (cmp_rhs) || integer_onep (cmp_rhs)))
+	continue;
+      if (TREE_CODE (cmp_lhs) != SSA_NAME)
+	continue;
+      if ((bb->flags & BB_ANNOTATED) == 0)
+	continue;
+      phi_stmt = SSA_NAME_DEF_STMT (cmp_lhs);
+      while (phi_stmt && gimple_code (phi_stmt) == GIMPLE_ASSIGN
+	     && gimple_assign_single_p (phi_stmt)
+	     && TREE_CODE (gimple_assign_rhs1 (phi_stmt)) == SSA_NAME)
+	phi_stmt = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (phi_stmt));
+      if (!phi_stmt || gimple_code (phi_stmt) != GIMPLE_PHI)
+	continue;
+      FOR_EACH_EDGE (e, ei, bb->succs)
+	{
+	  unsigned i, total = 0;
+	  edge only_one;
+	  bool check_value_one = (((integer_onep (cmp_rhs))
+		    ^ (gimple_cond_code (cmp_stmt) == EQ_EXPR))
+		    ^ ((e->flags & EDGE_TRUE_VALUE) != 0));
+	  if ((e->flags & EDGE_ANNOTATED) == 0)
+	    continue;
+	  for (i = 0; i < gimple_phi_num_args (phi_stmt); i++)
+	    {
+	      tree val = gimple_phi_arg_def (phi_stmt, i);
+	      edge ep = gimple_phi_arg_edge (phi_stmt, i);
+
+	      if (!TREE_CONSTANT (val) || !(integer_zerop (val)
+		  || integer_onep (val)))
+		continue;
+	      if (check_value_one ^ integer_onep (val))
+		continue;
+	      total++;
+	      only_one = ep;
+	      if (e->probability == 0 && (e->flags & EDGE_ANNOTATED) == 0)
+		{
+		  ep->probability = 0;
+		  ep->count = 0;
+		  ep->flags |= EDGE_ANNOTATED;
+		}
+	    }
+	  if (total == 1 && (only_one->flags & EDGE_ANNOTATED) == 0)
+	    {
+	      only_one->probability = e->probability;
+	      only_one->count = e->count;
+	      only_one->flags |= EDGE_ANNOTATED;
+	    }
+	}
+    }
+}
+
+/* Propagate the basic block count and edge count on the control flow
+   graph. We do the propagation iteratively until stablize.  */
+
+static void
+afdo_propagate (void)
+{
+  basic_block bb;
+  bool changed = true;
+
+  FOR_ALL_BB (bb)
+    {
+      bb->count = ((basic_block) bb->aux)->count;
+      if ((((basic_block) bb->aux)->flags & BB_ANNOTATED) != 0)
+	bb->flags |= BB_ANNOTATED;
+    }
+
+  while (changed)
+    {
+      changed = false;
+
+      if (afdo_propagate_single_edge (true))
+	changed = true;
+      if (afdo_propagate_single_edge (false))
+	changed = true;
+      if (afdo_propagate_multi_edge (true))
+	changed = true;
+      if (afdo_propagate_multi_edge (false))
+	changed = true;
+      afdo_propagate_circuit ();
+    }
+}
+
+/* Propagate counts on control flow graph and calculate branch
+   probabilities.  */
+
+void
+afdo_calculate_branch_prob (void)
+{
+  basic_block bb;
+  bool has_sample = false;
+
+  FOR_EACH_BB (bb)
+    if (bb->count > 0)
+      has_sample = true;
+
+  if (!has_sample)
+    return;
+
+  calculate_dominance_info (CDI_POST_DOMINATORS);
+  calculate_dominance_info (CDI_DOMINATORS);
+  loop_optimizer_init (0);
+
+  afdo_find_equiv_class ();
+  afdo_propagate ();
+
+  FOR_EACH_BB (bb)
+    {
+      edge e;
+      edge_iterator ei;
+      int num_unknown_succ = 0;
+      gcov_type total_count = 0;
+
+      FOR_EACH_EDGE (e, ei, bb->succs)
+	{
+	  if ((e->flags & EDGE_ANNOTATED) == 0)
+	    num_unknown_succ ++;
+	  else
+	    total_count += e->count;
+	}
+      if (num_unknown_succ == 0 && total_count > 0)
+	{
+	  FOR_EACH_EDGE (e, ei, bb->succs)
+	    e->probability =
+		(double) e->count * REG_BR_PROB_BASE / total_count;
+	}
+    }
+  FOR_ALL_BB (bb)
+    {
+      edge e;
+      edge_iterator ei;
+
+      FOR_EACH_EDGE (e, ei, bb->succs)
+	e->count =
+		(double) bb->count * e->probability / REG_BR_PROB_BASE;
+      bb->aux = NULL;
+    }
+
+  loop_optimizer_finalize ();
+  free_dominance_info (CDI_DOMINATORS);
+  free_dominance_info (CDI_POST_DOMINATORS);
+}
+
+/* Returns TRUE if EDGE is hot enough to be inlined early.  */
+
+bool
+afdo_callsite_hot_enough_for_early_inline (struct cgraph_edge *edge)
+{
+  gcov_type count, max_count;
+  if (get_callsite_count (edge, &count, &max_count))
+    {
+      bool is_hot;
+      const struct gcov_ctr_summary *saved_profile_info = profile_info;
+      /* At earling inline stage, profile_info is not set yet. We need to
+	 temporarily set it to afdo_profile_info to calculate hotness.  */
+      profile_info = afdo_profile_info;
+      is_hot = maybe_hot_count_p (NULL, count);
+      profile_info = saved_profile_info;
+      return is_hot;
+    }
+  else
+    return false;
+}
+
+/* Use AutoFDO profile to annoate the control flow graph.
+   Return the todo flag.  */
+
+static unsigned int
+auto_profile (void)
+{
+  struct cgraph_node *node;
+
+  if (cgraph_state == CGRAPH_STATE_FINISHED)
+    return 0;
+
+  init_node_map ();
+  profile_info = afdo_profile_info;
+
+  FOR_EACH_FUNCTION (node)
+    {
+      if (!gimple_has_body_p (node->symbol.decl))
+	continue;
+
+      /* Don't profile functions produced for builtin stuff.  */
+      if (DECL_SOURCE_LOCATION (node->symbol.decl) == BUILTINS_LOCATION)
+	continue;
+
+      push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));
+
+      afdo_annotate_cfg ();
+      compute_function_frequency ();
+      update_ssa (TODO_update_ssa);
+
+      current_function_decl = NULL;
+      pop_cfun ();
+    }
+
+  cgraph_pre_profiling_inlining_done = true;
+  cgraph_process_module_scope_statics ();
+  /* Now perform link to allow cross module inlining.  */
+  cgraph_do_link ();
+  varpool_do_link ();
+  cgraph_unify_type_alias_sets ();
+
+  return TODO_rebuild_cgraph_edges;
+}
+
+static bool
+gate_auto_profile_ipa (void)
+{
+  return flag_auto_profile;
+}
+
+struct simple_ipa_opt_pass pass_ipa_auto_profile =
+{
+ {
+  SIMPLE_IPA_PASS,
+  "afdo",                              /* name */
+  OPTGROUP_NONE,                       /* optinfo_flags */
+  gate_auto_profile_ipa,               /* gate */
+  auto_profile,                        /* execute */
+  NULL,                                /* sub */
+  NULL,                                /* next */
+  0,                                   /* static_pass_number */
+  TV_IPA_AUTOFDO,                      /* tv_id */
+  0,                                   /* properties_required */
+  0,                                   /* properties_provided */
+  0,                                   /* properties_destroyed */
+  0,                                   /* todo_flags_start */
+  0                                    /* todo_flags_finish */
+ }
+};
diff --git a/gcc/auto-profile.h b/gcc/auto-profile.h
new file mode 100644
index 0000000..e40697e
--- /dev/null
+++ b/gcc/auto-profile.h
@@ -0,0 +1,41 @@
+/* auto-profile.h - Defines data exported from auto-profile.c
+   Copyright (C) 2012. Free Software Foundation, Inc.
+   Contributed by Dehao Chen (dehao@google.com)
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef AUTO_PROFILE_H
+#define AUTO_PROFILE_H
+
+/* Read, process, finalize AutoFDO data structures.  */
+extern void init_auto_profile (void);
+extern void end_auto_profile (void);
+extern void process_auto_profile (void);
+
+/* Annotate function's count and total count.  */
+extern void afdo_set_current_function_count (void);
+
+/* Add the assembly_name to bfd_name mapping.  */
+extern void afdo_add_bfd_name_mapping (const char *, const char *);
+
+/* Calculate branch probability in both AutoFDO pass and after inlining.  */
+extern void afdo_calculate_branch_prob (void);
+
+/* Returns TRUE if EDGE is hot enough to be inlined early.  */
+extern bool afdo_callsite_hot_enough_for_early_inline (struct cgraph_edge *);
+
+#endif /* AUTO_PROFILE_H */
diff --git a/gcc/basic-block.h b/gcc/basic-block.h
index 90eb57b..41a5925 100644
--- a/gcc/basic-block.h
+++ b/gcc/basic-block.h
@@ -213,11 +213,6 @@ struct GTY((chain_next ("%h.next_bb"), chain_prev ("%h.prev_bb"))) basic_block_d
 
   /* Expected frequency.  Normalized to be in range 0 to BB_FREQ_MAX.  */
   int frequency;
-
-  /* The discriminator for this block.  The discriminator distinguishes
-     among several basic blocks that share a common locus, allowing for
-     more accurate sample-based profiling.  */
-  int discriminator;
 };
 
 /* This ensures that struct gimple_bb_info is smaller than
@@ -726,6 +721,7 @@ extern struct edge_list *pre_edge_rev_lcm (int, sbitmap *,
 extern void compute_available (sbitmap *, sbitmap *, sbitmap *, sbitmap *);
 
 /* In predict.c */
+extern bool maybe_hot_count_p (struct function *, gcov_type);
 extern bool maybe_hot_bb_p (struct function *, const_basic_block);
 extern bool maybe_hot_edge_p (edge);
 extern bool probably_never_executed_bb_p (struct function *, const_basic_block);
diff --git a/gcc/builtin-types.def b/gcc/builtin-types.def
index 3ef2d1b..e42ef63 100644
--- a/gcc/builtin-types.def
+++ b/gcc/builtin-types.def
@@ -554,6 +554,10 @@ DEF_POINTER_TYPE (BT_PTR_FN_VOID_VAR, BT_FN_VOID_VAR)
 DEF_FUNCTION_TYPE_3 (BT_FN_PTR_PTR_FN_VOID_VAR_PTR_SIZE,
 		     BT_PTR, BT_PTR_FN_VOID_VAR, BT_PTR, BT_SIZE)
 
+DEF_POINTER_TYPE (BT_PTR_FN_INT, BT_FN_INT)
+DEF_FUNCTION_TYPE_VAR_3 (BT_FN_INT_PTR_FN_INT_PTR_PTR_VAR,
+			 BT_INT, BT_PTR_FN_INT, BT_PTR, BT_PTR)
+
 
 DEF_FUNCTION_TYPE_1 (BT_FN_I1_VPTR, BT_I1, BT_VOLATILE_PTR)
 DEF_FUNCTION_TYPE_1 (BT_FN_I2_VPTR, BT_I2, BT_VOLATILE_PTR)
diff --git a/gcc/builtins.c b/gcc/builtins.c
index e3c32a9..2dc355b 100644
--- a/gcc/builtins.c
+++ b/gcc/builtins.c
@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "value-prof.h"
 #include "diagnostic-core.h"
 #include "builtins.h"
+#include "input.h"
 
 
 #ifndef PAD_VARARGS_DOWN
@@ -12107,13 +12108,16 @@ fold_builtin_next_arg (tree exp, bool va_start_p)
   tree fntype = TREE_TYPE (current_function_decl);
   int nargs = call_expr_nargs (exp);
   tree arg;
+  location_t loc = LOCATION_LOCUS (input_location);
+  if (has_discriminator (loc))
+    loc = map_discriminator_location (loc);
+
   /* There is good chance the current input_location points inside the
      definition of the va_start macro (perhaps on the token for
      builtin) in a system header, so warnings will not be emitted.
      Use the location in real source code.  */
   source_location current_location =
-    linemap_unwind_to_first_non_reserved_loc (line_table, input_location,
-					      NULL);
+    linemap_unwind_to_first_non_reserved_loc (line_table, loc, NULL);
 
   if (!stdarg_p (fntype))
     {
diff --git a/gcc/c-family/c-common.c b/gcc/c-family/c-common.c
index 0d91cc3..74c3b87 100644
--- a/gcc/c-family/c-common.c
+++ b/gcc/c-family/c-common.c
@@ -369,6 +369,13 @@ static tree ignore_attribute (tree *, tree, tree, int, bool *);
 static tree handle_no_split_stack_attribute (tree *, tree, tree, int, bool *);
 static tree handle_fnspec_attribute (tree *, tree, tree, int, bool *);
 
+static tree handle_always_patch_for_instrumentation_attribute (tree *, tree,
+                                                               tree, int,
+                                                               bool *);
+static tree handle_never_patch_for_instrumentation_attribute (tree *, tree,
+                                                              tree, int,
+                                                              bool *);
+
 static void check_function_nonnull (tree, int, tree *);
 static void check_nonnull_arg (void *, tree, unsigned HOST_WIDE_INT);
 static bool nonnull_check_p (tree, unsigned HOST_WIDE_INT);
@@ -738,6 +745,13 @@ const struct attribute_spec c_common_attribute_table[] =
      The name contains space to prevent its usage in source code.  */
   { "fn spec",	 	      1, 1, false, true, true,
 			      handle_fnspec_attribute, false },
+  { "always_patch_for_instrumentation", 0, 0, true,  false, false,
+                              handle_always_patch_for_instrumentation_attribute,
+                              false },
+  { "never_patch_for_instrumentation", 0, 0, true,  false, false,
+                              handle_never_patch_for_instrumentation_attribute,
+                              false },
+
   { NULL,                     0, 0, false, false, false, NULL, false }
 };
 
@@ -2651,12 +2665,22 @@ unsafe_conversion_p (tree type, tree expr, bool produce_warns)
 static void
 conversion_warning (tree type, tree expr)
 {
+  int warn_option;
   tree expr_type = TREE_TYPE (expr);
   location_t loc = EXPR_LOC_OR_HERE (expr);
 
-  if (!warn_conversion && !warn_sign_conversion)
+  if (!warn_conversion && !warn_sign_conversion && !warn_real_conversion)
     return;
 
+  /* When either type is a floating point type, warn with
+     -Wreal-conversion instead of -Wconversion (-Wreal-conversion is a
+     subset of -Wconversion that only warns for conversions of real
+     types to integral types).  */
+  warn_option = (warn_real_conversion
+		 && (FLOAT_TYPE_P (type) || FLOAT_TYPE_P (expr_type)))
+    ? OPT_Wreal_conversion
+    : OPT_Wconversion;
+
   switch (TREE_CODE (expr))
     {
     case EQ_EXPR:
@@ -2675,14 +2699,14 @@ conversion_warning (tree type, tree expr)
 	 can hold the values 0 and -1) doesn't lose information - but
 	 it does change the value.  */
       if (TYPE_PRECISION (type) == 1 && !TYPE_UNSIGNED (type))
-	warning_at (loc, OPT_Wconversion,
+	warning_at (loc, warn_option,
 		    "conversion to %qT from boolean expression", type);
       return;
 
     case REAL_CST:
     case INTEGER_CST:
       if (unsafe_conversion_p (type, expr, true))
-	warning_at (loc, OPT_Wconversion,
+	warning_at (loc, warn_option,
 		    "conversion to %qT alters %qT constant value",
 		    type, expr_type);
       return;
@@ -2701,7 +2725,7 @@ conversion_warning (tree type, tree expr)
 
     default: /* 'expr' is not a constant.  */
       if (unsafe_conversion_p (type, expr, true))
-	warning_at (loc, OPT_Wconversion,
+	warning_at (loc, warn_option,
 		    "conversion to %qT from %qT may alter its value",
 		    type, expr_type);
     }
@@ -6754,6 +6778,7 @@ handle_unused_attribute (tree *node, tree name, tree ARG_UNUSED (args),
 
       if (TREE_CODE (decl) == PARM_DECL
 	  || TREE_CODE (decl) == VAR_DECL
+	  || TREE_CODE (decl) == FIELD_DECL
 	  || TREE_CODE (decl) == FUNCTION_DECL
 	  || TREE_CODE (decl) == LABEL_DECL
 	  || TREE_CODE (decl) == TYPE_DECL)
@@ -8469,6 +8494,47 @@ handle_nonnull_attribute (tree *node, tree ARG_UNUSED (name),
   return NULL_TREE;
 }
 
+/* Handle a "always_patch_for_instrumentation" attribute; arguments as in
+   struct attribute_spec.handler.  */
+
+static tree
+handle_always_patch_for_instrumentation_attribute (tree *node, tree name,
+                                                   tree ARG_UNUSED (args),
+                                                   int ARG_UNUSED (flags),
+                                                   bool *no_add_attrs)
+{
+  if (TREE_CODE (*node) == FUNCTION_DECL)
+    {
+      /* Disable inlining if forced instrumentation.  */
+      DECL_UNINLINABLE (*node) = 1;
+    }
+  else
+    {
+      warning (OPT_Wattributes, "%qE attribute ignored", name);
+      *no_add_attrs = true;
+    }
+  return NULL_TREE;
+}
+
+
+/* Handle a "never_patch_for_instrumentation" attribute; arguments as in
+   struct attribute_spec.handler.  */
+
+static tree
+handle_never_patch_for_instrumentation_attribute (tree *node, tree name,
+                                                  tree ARG_UNUSED (args),
+                                                  int ARG_UNUSED (flags),
+                                                  bool *no_add_attrs)
+{
+  if (TREE_CODE (*node) != FUNCTION_DECL)
+    {
+      warning (OPT_Wattributes, "%qE attribute ignored", name);
+      *no_add_attrs = true;
+    }
+  return NULL_TREE;
+}
+
+
 /* Check the argument list of a function call for null in argument slots
    that are marked as requiring a non-null pointer argument.  The NARGS
    arguments are passed in the array ARGARRAY.
@@ -11422,6 +11488,31 @@ keyword_is_decl_specifier (enum rid keyword)
     }
 }
 
+/* Check for and warn about self-assignment or self-initialization.
+   LHS and RHS are the tree nodes for the left-hand side and right-hand side
+   of the assignment or initialization we are checking.
+   LOCATION is the source location for RHS.  */
+
+void
+check_for_self_assign (location_t location, tree lhs, tree rhs)
+{
+  if (lhs == NULL_TREE || rhs == NULL_TREE)
+    return;
+
+  /* Deal with TREE_LIST initializers (may be generated by class
+     member initialization in C++).  */
+  if (TREE_CODE (rhs) == TREE_LIST)
+    rhs = TREE_VALUE (rhs);
+
+  /* Only emit a warning if RHS is not a folded expression so that we don't
+     warn on something like x = x / 1.  */
+  if (!EXPR_FOLDED (rhs)
+      && operand_equal_p (lhs, rhs,
+                          OEP_PURE_SAME | OEP_ALLOW_NULL | OEP_ALLOW_NO_TYPE))
+    warning_at (location, OPT_Wself_assign, G_("%qE is assigned to itself"),
+                lhs);
+}
+
 /* Initialize language-specific-bits of tree_contains_struct.  */
 
 void
diff --git a/gcc/c-family/c-common.h b/gcc/c-family/c-common.h
index 4014651..2f469a7 100644
--- a/gcc/c-family/c-common.h
+++ b/gcc/c-family/c-common.h
@@ -996,6 +996,7 @@ extern void release_tree_vector (vec<tree, va_gc> *);
 extern vec<tree, va_gc> *make_tree_vector_single (tree);
 extern vec<tree, va_gc> *make_tree_vector_from_list (tree);
 extern vec<tree, va_gc> *make_tree_vector_copy (const vec<tree, va_gc> *);
+extern void check_for_self_assign (location_t, tree, tree);
 
 /* In c-gimplify.c  */
 extern void c_genericize (tree);
diff --git a/gcc/c-family/c-cppbuiltin.c b/gcc/c-family/c-cppbuiltin.c
index 3e210d9..4150604 100644
--- a/gcc/c-family/c-cppbuiltin.c
+++ b/gcc/c-family/c-cppbuiltin.c
@@ -871,6 +871,33 @@ c_cpp_builtins (cpp_reader *pfile)
   if (c_dialect_cxx () && TYPE_UNSIGNED (wchar_type_node))
     cpp_define (pfile, "__WCHAR_UNSIGNED__");
 
+  /* Tell source code if the compiler makes sync_compare_and_swap
+     builtins available.  */
+#ifdef HAVE_sync_compare_and_swapqi
+  if (HAVE_sync_compare_and_swapqi)
+    cpp_define (pfile, "__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1");
+#endif
+
+#ifdef HAVE_sync_compare_and_swaphi
+  if (HAVE_sync_compare_and_swaphi)
+    cpp_define (pfile, "__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2");
+#endif
+
+#ifdef HAVE_sync_compare_and_swapsi
+  if (HAVE_sync_compare_and_swapsi)
+    cpp_define (pfile, "__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4");
+#endif
+
+#ifdef HAVE_sync_compare_and_swapdi
+  if (HAVE_sync_compare_and_swapdi)
+    cpp_define (pfile, "__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8");
+#endif
+
+#ifdef HAVE_sync_compare_and_swapti
+  if (HAVE_sync_compare_and_swapti)
+    cpp_define (pfile, "__GCC_HAVE_SYNC_COMPARE_AND_SWAP_16");
+#endif
+
   cpp_atomic_builtins (pfile);
     
 #ifdef DWARF2_UNWIND_INFO
@@ -928,6 +955,8 @@ c_cpp_builtins (cpp_reader *pfile)
      format.  */
   if (ENABLE_DECIMAL_FLOAT && ENABLE_DECIMAL_BID_FORMAT)
     cpp_define (pfile, "__DECIMAL_BID_FORMAT__");
+  if (c_dialect_cxx () && flag_sized_delete)
+    cpp_define (pfile, "__GXX_DELETE_WITH_SIZE__");
 }
 
 /* Pass an object-like macro.  If it doesn't lie in the user's
diff --git a/gcc/c-family/c-opts.c b/gcc/c-family/c-opts.c
index 4b6990a..b5477dc 100644
--- a/gcc/c-family/c-opts.c
+++ b/gcc/c-family/c-opts.c
@@ -42,6 +42,10 @@ along with GCC; see the file COPYING3.  If not see
 				   TARGET_FLT_EVAL_METHOD_NON_DEFAULT and
 				   TARGET_OPTF.  */
 #include "tm_p.h"		/* For C_COMMON_OVERRIDE_OPTIONS.  */
+#include "function.h"
+#include "params.h"
+#include "l-ipo.h"
+#include "dumpfile.h"
 
 #ifndef DOLLARS_IN_IDENTIFIERS
 # define DOLLARS_IN_IDENTIFIERS true
@@ -101,6 +105,8 @@ static size_t deferred_count;
 /* Number of deferred options scanned for -include.  */
 static size_t include_cursor;
 
+static bool parsing_done_p = false;
+
 /* Whether any standard preincluded header has been preincluded.  */
 static bool done_preinclude;
 
@@ -834,6 +840,10 @@ c_common_post_options (const char **pfilename)
   else if (!flag_gnu89_inline && !flag_isoc99)
     error ("-fno-gnu89-inline is only supported in GNU99 or C99 mode");
 
+  if (flag_dyn_ipa && cpp_opts->preprocessed)
+    error ("-fpreprocessed/-save-temps are not supported with -fripa");
+
+
   /* Default to ObjC sjlj exception handling if NeXT runtime.  */
   if (flag_objc_sjlj_exceptions < 0)
     flag_objc_sjlj_exceptions = flag_next_runtime;
@@ -867,6 +877,12 @@ c_common_post_options (const char **pfilename)
   if (warn_packed_bitfield_compat == -1)
     warn_packed_bitfield_compat = 1;
 
+  /* Enable warning for converting real values to integral values
+     when -Wconversion is specified (unless disabled through
+     -Wno-real-conversion).  */
+  if (warn_real_conversion == -1)
+    warn_real_conversion = warn_conversion;
+
   /* Special format checking options don't work without -Wformat; warn if
      they are used.  */
   if (!warn_format)
@@ -1030,6 +1046,34 @@ c_common_init (void)
   return true;
 }
 
+/* Return TRUE if the lipo maximum memory consumption limit is reached, and
+   we should not import any further auxiliary modules. Check after parsing
+   each module, the Ith module being the just parsed module.  */
+static bool
+lipo_max_mem_reached (unsigned int i)
+{
+  if (L_IPO_COMP_MODE && PARAM_VALUE (PARAM_MAX_LIPO_MEMORY)
+      && i < (num_in_fnames - 1)
+      /* Scale up memory usage by 25% to account for memory consumption
+         by the optimizer.  */
+      && ((ggc_total_allocated () >> 10) * 1.25
+          > (size_t) PARAM_VALUE (PARAM_MAX_LIPO_MEMORY))) {
+    if (dump_enabled_p ())
+      {
+        i++;
+        do {
+          dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, input_location,
+                           "Not importing %s: maximum memory "
+                           "consumption reached", in_fnames[i]);
+          i++;
+        } while (i < num_in_fnames);
+      }
+    return true;
+  }
+  return false;
+}
+
+
 /* Initialize the integrated preprocessor after debug output has been
    initialized; loop over each input file.  */
 void
@@ -1042,8 +1086,22 @@ c_common_parse_file (void)
     {
       c_finish_options ();
       pch_init ();
+      set_lipo_c_parsing_context (parse_in, i, verbose);
       push_file_scope ();
+
       c_parse_file ();
+      if (i == 0 && flag_record_compilation_info_in_elf)
+        write_compilation_flags_to_asm ();
+
+      if (i == 0)
+	ggc_total_memory = (ggc_total_allocated () >> 10);
+
+      /* In lipo mode, processing too many auxiliary files will cause us
+	 to hit memory limits, and cause thrashing -- prevent this by not
+	 processing any further auxiliary modules if we reach a certain
+	 memory limit.  */
+      if (!include_all_aux && lipo_max_mem_reached (i))
+	num_in_fnames = i + 1;
       pop_file_scope ();
       /* And end the main input file, if the debug writer wants it  */
       if (debug_hooks->start_end_main_source_file)
@@ -1052,6 +1110,7 @@ c_common_parse_file (void)
 	break;
       cpp_undef_all (parse_in);
       cpp_clear_file_cache (parse_in);
+      deferred_count = 0;
       this_input_filename
 	= cpp_read_main_file (parse_in, in_fnames[i]);
       /* If an input file is missing, abandon further compilation.
@@ -1059,6 +1118,15 @@ c_common_parse_file (void)
       if (!this_input_filename)
 	break;
     }
+    parsing_done_p = true;
+}
+
+/* Returns true if parsing is done  */
+
+bool
+is_parsing_done_p (void)
+{
+  return parsing_done_p;
 }
 
 /* Common finish hook for the C, ObjC and C++ front ends.  */
@@ -1068,7 +1136,11 @@ c_common_finish (void)
   FILE *deps_stream = NULL;
 
   /* Don't write the deps file if there are errors.  */
-  if (cpp_opts->deps.style != DEPS_NONE && !seen_error ())
+  /* FIXME.  We are emitting the deps file even if there were errors.
+     This is a temporary workaround to avoid confusing Google's build
+     system.  It assumes that deps files are always emitted even
+     in the presence of errors.  */
+  if (cpp_opts->deps.style != DEPS_NONE /*&& !seen_error ()*/)
     {
       /* If -M or -MM was seen without -MF, default output to the
 	 output stream.  */
@@ -1290,9 +1362,15 @@ c_finish_options (void)
 	  struct deferred_opt *opt = &deferred_opts[i];
 
 	  if (opt->code == OPT_D)
-	    cpp_define (parse_in, opt->arg);
+	    {
+	      cpp_define (parse_in, opt->arg);
+	      coverage_note_define (opt->arg, true);
+	    }
 	  else if (opt->code == OPT_U)
-	    cpp_undef (parse_in, opt->arg);
+	    {
+	      cpp_undef (parse_in, opt->arg);
+	      coverage_note_define (opt->arg, false);
+	    }
 	  else if (opt->code == OPT_A)
 	    {
 	      if (opt->arg[0] == '-')
@@ -1315,6 +1393,7 @@ c_finish_options (void)
 	  if (opt->code == OPT_imacros
 	      && cpp_push_include (parse_in, opt->arg))
 	    {
+	      coverage_note_include (opt->arg);
 	      /* Disable push_command_line_include callback for now.  */
 	      include_cursor = deferred_count + 1;
 	      cpp_scan_nooutput (parse_in);
@@ -1359,7 +1438,10 @@ push_command_line_include (void)
 
       if (!cpp_opts->preprocessed && opt->code == OPT_include
 	  && cpp_push_include (parse_in, opt->arg))
-	return;
+	{
+	  coverage_note_include (opt->arg);
+	  return;
+	}
     }
 
   if (include_cursor == deferred_count)
diff --git a/gcc/c-family/c.opt b/gcc/c-family/c.opt
index 10ae84d..cfbd27f 100644
--- a/gcc/c-family/c.opt
+++ b/gcc/c-family/c.opt
@@ -327,6 +327,10 @@ Wconversion-null
 C++ ObjC++ Var(warn_conversion_null) Init(1) Warning
 Warn for converting NULL from/to a non-pointer type
 
+Wself-assign-non-pod
+C++ ObjC++ Var(warn_self_assign_non_pod) Init(0) Warning
+Warn when a variable of a non-POD type is assigned to itself
+
 Wctor-dtor-privacy
 C++ ObjC++ Var(warn_ctor_dtor_privacy) Warning
 Warn when all constructors and destructors are private
@@ -673,6 +677,10 @@ Wsign-compare
 C ObjC C++ ObjC++ EnabledBy(Wextra)
 ;
 
+Wreal-conversion
+C ObjC C++ ObjC++ Var(warn_real_conversion) Init(-1) Warning EnabledBy(Wconversion)
+Warn for implicit type conversions from real to integral values
+
 Wsign-conversion
 C ObjC C++ ObjC++ Var(warn_sign_conversion) LangEnabledBy(C ObjC,Wconversion)
 Warn for implicit type conversions between signed and unsigned integers
diff --git a/gcc/c/Make-lang.in b/gcc/c/Make-lang.in
index 8310e0a..33c047a 100644
--- a/gcc/c/Make-lang.in
+++ b/gcc/c/Make-lang.in
@@ -163,7 +163,7 @@ c/c-decl.o : c/c-decl.c c/c-lang.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
 	$(HASH_TABLE_H) $(LANGHOOKS_DEF_H) \
 	dumpfile.h $(C_COMMON_H) $(CPPLIB_H) $(DIAGNOSTIC_CORE_H) \
 	$(INPUT_H) langhooks.h pointer-set.h tree-iterator.h \
-	$(PLUGIN_H) c-family/c-ada-spec.h c-family/c-objc.h
+	$(PLUGIN_H) c-family/c-ada-spec.h c-family/c-objc.h l-ipo.h
 
 c/c-errors.o: c/c-errors.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
 	$(C_TREE_H) $(FLAGS_H) $(DIAGNOSTIC_H) $(TM_P_H)
@@ -190,5 +190,5 @@ c/c-parser.o : c/c-parser.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
 c/c-typeck.o : c/c-typeck.c c/c-lang.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
 	$(TREE_H) $(C_TREE_H) $(TARGET_H) $(FLAGS_H) intl.h \
 	langhooks.h tree-iterator.h $(BITMAP_H) $(GIMPLE_H) \
-	c-family/c-objc.h c-family/c-common.h
+	c-family/c-objc.h c-family/c-common.h l-ipo.h
 
diff --git a/gcc/c/c-decl.c b/gcc/c/c-decl.c
index d9bbf5c..26f4711 100644
--- a/gcc/c/c-decl.c
+++ b/gcc/c/c-decl.c
@@ -54,6 +54,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "hash-table.h"
 #include "langhooks-def.h"
 #include "pointer-set.h"
+#include "l-ipo.h"
 #include "plugin.h"
 #include "c-family/c-ada-spec.h"
 
@@ -527,6 +528,27 @@ static tree grokdeclarator (const struct c_declarator *,
 			    bool *, enum deprecated_states);
 static tree grokparms (struct c_arg_info *, bool);
 static void layout_array_type (tree);
+static void pop_ext_scope (void);
+
+/* LIPO support */
+/* The list of block nodes. A member node is  created
+   when an external scope is popped.  */
+static GTY (()) vec<tree, va_gc> *ext_blocks = NULL;
+static inline void
+apply_for_each_ext_block (void (*func) (tree))
+{
+  if (L_IPO_COMP_MODE)
+    {
+      size_t i;
+      tree eb;
+
+      for (i = 0;
+           ext_blocks->iterate (i, &eb);
+           ++i)
+        func (BLOCK_VARS (eb));
+    }
+}
+
 
 /* T is a statement.  Add it to the statement-tree.  This is the
    C/ObjC version--C++ has a slightly different version of this
@@ -676,6 +698,8 @@ bind (tree name, tree decl, struct c_scope *scope, bool invisible,
 
   b->shadowed = *here;
   *here = b;
+
+  add_decl_to_current_module_scope (decl, scope);
 }
 
 /* Clear the binding structure B, stick it on the binding_freelist,
@@ -1204,8 +1228,18 @@ pop_scope (void)
 	     binding in the home scope.  */
 	  if (!b->nested)
 	    {
-	      DECL_CHAIN (p) = BLOCK_VARS (block);
-	      BLOCK_VARS (block) = p;
+              /* In LIPO mode compilation, ext_scope is popped out
+                 at end of each module to block name lookup across
+                 modules. The ext_scope is used to keep the list of
+                 global variables in that module scope. Other decls
+                 are filtered out.  */
+              if (!L_IPO_COMP_MODE
+                  || scope != external_scope
+                  || TREE_CODE (p) == VAR_DECL)
+                {
+                  DECL_CHAIN (p) = BLOCK_VARS (block);
+                  BLOCK_VARS (block) = p;
+                }
 	    }
 	  else if (VAR_OR_FUNCTION_DECL_P (p) && scope != file_scope)
 	    {
@@ -1306,6 +1340,11 @@ push_file_scope (void)
   push_scope ();
   file_scope = current_scope;
 
+  /* LIPO support -- do this before file scope bindings
+     are created for visible_builtins -- only need to remember
+     external scope bindings.  */
+  push_module_scope ();
+
   start_fname_decls ();
 
   for (decl = visible_builtins; decl; decl = DECL_CHAIN (decl))
@@ -1340,7 +1379,18 @@ pop_file_scope (void)
   pop_scope ();
   file_scope = 0;
 
-  maybe_apply_pending_pragma_weaks ();
+  if (!L_IPO_COMP_MODE)
+    maybe_apply_pending_pragma_weaks ();
+  else
+    {
+      pop_ext_scope ();
+      gcc_assert (current_scope == 0 && external_scope == 0);
+      push_scope ();
+      external_scope = current_scope;
+      /* Prepare for parsing for the next module -- including
+         builtin re-binding.  */
+      pop_module_scope ();
+    }
 }
 
 /* Adjust the bindings for the start of a statement expression.  */
@@ -2527,7 +2577,9 @@ warn_if_shadowing (tree new_decl)
   struct c_binding *b;
 
   /* Shadow warnings wanted?  */
-  if (!warn_shadow
+  if (!(warn_shadow
+        || warn_shadow_local
+        || warn_shadow_compatible_local)
       /* No shadow warnings for internally generated vars.  */
       || DECL_IS_BUILTIN (new_decl)
       /* No shadow warnings for vars made for inlining.  */
@@ -2544,14 +2596,25 @@ warn_if_shadowing (tree new_decl)
 	tree old_decl = b->decl;
 
 	if (old_decl == error_mark_node)
-	  {
-	    warning (OPT_Wshadow, "declaration of %q+D shadows previous "
-		     "non-variable", new_decl);
-	    break;
-	  }
+	  warning (OPT_Wshadow, "declaration of %q+D shadows previous "
+		   "non-variable", new_decl);
 	else if (TREE_CODE (old_decl) == PARM_DECL)
-	  warning (OPT_Wshadow, "declaration of %q+D shadows a parameter",
-		   new_decl);
+          {
+            enum opt_code warning_code;
+
+            /* If '-Wshadow-compatible-local' is specified without other
+               -Wshadow flags, we will warn only when the types of the
+               shadowing variable (i.e. new_decl) and the shadowed variable
+               (old_decl) are compatible.  */
+            if (comptypes (TREE_TYPE (old_decl), TREE_TYPE (new_decl)))
+              warning_code = OPT_Wshadow_compatible_local;
+            else
+              warning_code = OPT_Wshadow_local;
+            warning (warning_code,
+                     "declaration of %q+D shadows a parameter", new_decl);
+            warning_at (DECL_SOURCE_LOCATION (old_decl), warning_code,
+			"shadowed declaration is here");
+          }
 	else if (DECL_FILE_SCOPE_P (old_decl))
 	  {
 	    /* Do not warn if a variable shadows a function, unless
@@ -2561,23 +2624,34 @@ warn_if_shadowing (tree new_decl)
 		&& !FUNCTION_POINTER_TYPE_P (TREE_TYPE (new_decl)))
 		continue;
 
-	    warning_at (DECL_SOURCE_LOCATION (new_decl), OPT_Wshadow, 
-			"declaration of %qD shadows a global declaration",
-			new_decl);
+            warning (OPT_Wshadow, "declaration of %q+D shadows a global "
+                     "declaration", new_decl);
+            warning_at (DECL_SOURCE_LOCATION (old_decl), OPT_Wshadow,
+		        "shadowed declaration is here");
 	  }
 	else if (TREE_CODE (old_decl) == FUNCTION_DECL
 		 && DECL_BUILT_IN (old_decl))
-	  {
 	    warning (OPT_Wshadow, "declaration of %q+D shadows "
 		     "a built-in function", new_decl);
-	    break;
-	  }
 	else
-	  warning (OPT_Wshadow, "declaration of %q+D shadows a previous local",
-		   new_decl);
-
-	warning_at (DECL_SOURCE_LOCATION (old_decl), OPT_Wshadow,
-		    "shadowed declaration is here");
+          {
+            enum opt_code warning_code;
+
+            /* If '-Wshadow-compatible-local' is specified without other
+               -Wshadow flags, we will warn only when the types of the
+               shadowing variable (i.e. new_decl) and the shadowed variable
+               (old_decl) are compatible.  */
+            if (comptypes (TREE_TYPE (old_decl), TREE_TYPE (new_decl)))
+              warning_code = OPT_Wshadow_compatible_local;
+            else
+              warning_code = OPT_Wshadow_local;
+            warning (warning_code,
+                     "declaration of %q+D shadows a previous local",
+                     new_decl);
+
+            warning_at (DECL_SOURCE_LOCATION (old_decl), warning_code,
+			"shadowed declaration is here");
+          }
 
 	break;
       }
@@ -10108,7 +10182,12 @@ c_write_global_declarations (void)
      through wrapup_global_declarations and check_global_declarations.  */
   FOR_EACH_VEC_ELT (*all_translation_units, i, t)
     c_write_global_declarations_1 (BLOCK_VARS (DECL_INITIAL (t)));
-  c_write_global_declarations_1 (BLOCK_VARS (ext_block));
+  if (ext_block)
+    c_write_global_declarations_1 (BLOCK_VARS (ext_block));
+  apply_for_each_ext_block (c_write_global_declarations_1);
+
+  if (L_IPO_COMP_MODE)
+    maybe_apply_pending_pragma_weaks ();
 
   timevar_stop (TV_PHASE_DEFERRED);
   timevar_start (TV_PHASE_OPT_GEN);
@@ -10127,7 +10206,9 @@ c_write_global_declarations (void)
       timevar_push (TV_SYMOUT);
       FOR_EACH_VEC_ELT (*all_translation_units, i, t)
 	c_write_global_declarations_2 (BLOCK_VARS (DECL_INITIAL (t)));
-      c_write_global_declarations_2 (BLOCK_VARS (ext_block));
+      if (ext_block)
+        c_write_global_declarations_2 (BLOCK_VARS (ext_block));
+      apply_for_each_ext_block (c_write_global_declarations_2);
       timevar_pop (TV_SYMOUT);
     }
 
@@ -10135,6 +10216,236 @@ c_write_global_declarations (void)
   timevar_stop (TV_PHASE_DBGINFO);
 }
 
+
+/* LIPO support */
+
+typedef struct GTY (()) c_sb
+{
+  tree decl;
+  tree id;
+  tree decl_copy_pre; /* copy at the start of file parsing.  */
+  tree decl_copy_post; /* copy at the end of module_scope.  */
+  int invisible;
+} c_saved_builtin;
+
+static GTY (()) vec<c_saved_builtin, va_gc> *saved_builtins = NULL;
+
+/* Return the needed size of lang_decl structure for tree T.  */
+
+int
+c_get_lang_decl_size (tree t)
+{
+  if (!DECL_LANG_SPECIFIC (t))
+    return 0;
+  return sizeof (struct lang_decl);
+}
+
+/* Return true if S is external or file scope.  */
+
+bool
+c_is_global_scope (tree decl ATTRIBUTE_UNUSED, void *s)
+{
+  struct c_scope *scope = (struct c_scope *)s;
+
+  if (scope == external_scope || scope == file_scope)
+    return true;
+
+  return false;
+}
+
+/* Add DECL to the list of builtins.  */
+
+void
+c_add_built_in_decl (tree decl)
+{
+  c_saved_builtin *sb;
+  struct c_binding *b = NULL;
+
+  if (!flag_dyn_ipa)
+    return;
+
+  if (at_eof)
+    return;
+
+  if (parser_parsing_start)
+    return;
+
+  sb = vec_safe_push (saved_builtins, c_saved_builtin ());
+  sb->decl = decl;
+  sb->decl_copy_pre = NULL;
+  sb->decl_copy_post = NULL;
+  sb->id = get_type_or_decl_name (decl);
+
+  switch (TREE_CODE (decl))
+    {
+    case TYPE_DECL:
+    case FUNCTION_DECL:
+    case CONST_DECL:
+      b = I_SYMBOL_BINDING (sb->id);
+      break;
+    case ENUMERAL_TYPE:
+    case UNION_TYPE:
+    case RECORD_TYPE:
+      b = I_TAG_BINDING (sb->id);
+      break;
+    default:
+      gcc_unreachable ();
+    }
+
+  gcc_assert (b && b->decl == decl
+              && b->id == sb->id && b->depth == 0);
+  sb->invisible = b->invisible;
+}
+
+/* Pop the external scope at the end of parsing of a file.  */
+
+static void
+pop_ext_scope (void)
+{
+  tree ext_b;
+  if (!L_IPO_COMP_MODE)
+    return;
+  ext_b = pop_scope ();
+  vec_safe_push (ext_blocks, ext_b);
+  gcc_assert (!current_scope);
+  external_scope = 0;
+
+  /* Now remove non var_decls from BLOCK_VARS --
+     this is needed to avoid tree-chain contamination
+     from other modules due to builtin (shared) decls.  */
+  {
+    tree *p = &BLOCK_VARS (ext_b);
+    tree decl = BLOCK_VARS (ext_b);
+    for (; decl; decl = TREE_CHAIN (decl))
+      {
+        if (TREE_CODE (decl) != VAR_DECL)
+          {
+            gcc_assert (0);
+            *p = TREE_CHAIN (decl);
+          }
+        else
+          p = &TREE_CHAIN (decl);
+      }
+  }
+}
+
+/* Save a copy of SB->decl before file parsing start.  */
+
+static void
+c_save_built_in_decl_pre_parsing_1 (c_saved_builtin *sb)
+{
+  tree decl = sb->decl;
+
+  sb->decl_copy_pre = lipo_save_decl (decl);
+  sb->decl_copy_post = NULL;
+  return;
+}
+
+/* Make copies of builtin decls before file parsing.  */
+
+void
+c_save_built_in_decl_pre_parsing (void)
+{
+  size_t i;
+  c_saved_builtin *bi;
+
+  for (i = 0;
+       saved_builtins->iterate (i, &bi);
+       ++i)
+    c_save_built_in_decl_pre_parsing_1 (bi);
+}
+
+/* Restore builtins to their values before file parsing (
+   the initial default value).  */
+
+void
+c_restore_built_in_decl_pre_parsing (void)
+{
+  size_t i;
+  c_saved_builtin *bi;
+
+  /* Now re-bind the builtins in the external scope.  */
+  gcc_assert (current_scope && current_scope == external_scope);
+  for (i = 0;
+       saved_builtins->iterate (i, &bi);
+      ++i)
+    {
+      tree id;
+      tree decl = bi->decl;
+      id = bi->id;
+
+      lipo_restore_decl (decl, bi->decl_copy_pre);
+      if (id)
+        bind (id, decl, external_scope, 
+              bi->invisible, false /*nested*/,
+              DECL_SOURCE_LOCATION (decl));
+    }
+}
+
+/* Save values of builtins after parsing of a file.  */
+
+void
+c_save_built_in_decl_post_parsing (void)
+{
+  size_t i;
+  c_saved_builtin *bi;
+
+  for (i = 0;
+       saved_builtins->iterate (i, &bi);
+       ++i)
+    {
+      /* Skip builtin decls in the predefined state.
+         The static flag for defined builtins are not set, so
+         do not check it.  */
+      if (DECL_ARTIFICIAL (bi->decl)
+          || TREE_CODE (bi->decl) != FUNCTION_DECL
+          || !DECL_STRUCT_FUNCTION (bi->decl))
+        continue;
+      /* Remember the defining module.  */
+      cgraph_link_node (cgraph_get_create_node (bi->decl));
+      if (!bi->decl_copy_post)
+        bi->decl_copy_post = lipo_save_decl (bi->decl);
+    }
+}
+
+/* Restore builtins to their values (non-default)
+   after parsing finishes.  */
+
+void
+c_restore_built_in_decl_post_parsing (void)
+{
+  c_saved_builtin *bi;
+  unsigned i;
+  for (i = 0;
+       saved_builtins->iterate (i, &bi);
+       ++i)
+    {
+      tree decl = bi->decl;
+      /* Now restore the decl's state  */
+      if (bi->decl_copy_post)
+        lipo_restore_decl (decl, bi->decl_copy_post);
+    }
+}
+
+/* Return true if type T is compiler generated.  */
+
+bool
+c_is_compiler_generated_type (tree t ATTRIBUTE_UNUSED)
+{
+  return false;
+}
+
+/* Return 1 if lang specific attribute of T1 and T2 are
+   equivalent.  */
+
+int
+c_cmp_lang_type (tree t1 ATTRIBUTE_UNUSED,
+                 tree t2 ATTRIBUTE_UNUSED)
+{
+  return 1;
+}
+
+
 /* Register reserved keyword WORD as qualifier for address space AS.  */
 
 void
diff --git a/gcc/c/c-lang.c b/gcc/c/c-lang.c
index 614c46d..c4b8e9c 100644
--- a/gcc/c/c-lang.c
+++ b/gcc/c/c-lang.c
@@ -44,6 +44,27 @@ enum c_language_kind c_language = clk_c;
 #undef LANG_HOOKS_INIT_TS
 #define LANG_HOOKS_INIT_TS c_common_init_ts
 
+/* LIPO support.  */
+#undef LANG_HOOKS_ADD_BUILT_IN_DECL
+#define LANG_HOOKS_ADD_BUILT_IN_DECL c_add_built_in_decl
+#undef LANG_HOOKS_SAVE_BUILT_IN_PRE
+#define LANG_HOOKS_SAVE_BUILT_IN_PRE c_save_built_in_decl_pre_parsing
+#undef LANG_HOOKS_RESTORE_BUILT_IN_PRE
+#define LANG_HOOKS_RESTORE_BUILT_IN_PRE c_restore_built_in_decl_pre_parsing
+#undef LANG_HOOKS_SAVE_BUILT_IN_POST
+#define LANG_HOOKS_SAVE_BUILT_IN_POST c_save_built_in_decl_post_parsing
+#undef LANG_HOOKS_RESTORE_BUILT_IN_POST
+#define LANG_HOOKS_RESTORE_BUILT_IN_POST c_restore_built_in_decl_post_parsing
+#undef LANG_HOOKS_HAS_GLOBAL_NAME
+#define LANG_HOOKS_HAS_GLOBAL_NAME c_is_global_scope
+#undef LANG_HOOKS_GET_LANG_DECL_SIZE
+#define LANG_HOOKS_GET_LANG_DECL_SIZE c_get_lang_decl_size
+#undef LANG_HOOKS_IS_GENERATED_TYPE
+#define LANG_HOOKS_IS_GENERATED_TYPE c_is_compiler_generated_type
+#undef LANG_HOOKS_CMP_LANG_TYPE
+#define LANG_HOOKS_CMP_LANG_TYPE c_cmp_lang_type
+
+
 /* Each front end provides its own lang hook initializer.  */
 struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;
 
diff --git a/gcc/c/c-tree.h b/gcc/c/c-tree.h
index d1a871d..83994a8 100644
--- a/gcc/c/c-tree.h
+++ b/gcc/c/c-tree.h
@@ -668,4 +668,19 @@ extern void c_write_global_declarations (void);
 extern void pedwarn_c90 (location_t, int opt, const char *, ...) ATTRIBUTE_GCC_DIAG(3,4);
 extern void pedwarn_c99 (location_t, int opt, const char *, ...) ATTRIBUTE_GCC_DIAG(3,4);
 
+/* LIPO support.  */
+
+extern int c_get_lang_decl_size (tree t);
+extern void c_lipo_dup_lang_type (tree src, tree dest);
+extern void c_lipo_copy_lang_type (tree src, tree dest);
+extern bool c_is_global_scope (tree decl, void *scope);
+extern void c_clear_name_bindings (tree id);
+extern void c_add_built_in_decl (tree decl);
+extern void c_save_built_in_decl_pre_parsing (void);
+extern void c_restore_built_in_decl_pre_parsing (void);
+extern void c_save_built_in_decl_post_parsing (void);
+extern void c_restore_built_in_decl_post_parsing (void);
+extern bool c_is_compiler_generated_type (tree t);
+extern int c_cmp_lang_type (tree t1, tree t2);
+
 #endif /* ! GCC_C_TREE_H */
diff --git a/gcc/cfg-flags.def b/gcc/cfg-flags.def
index de127d6..e778e35 100644
--- a/gcc/cfg-flags.def
+++ b/gcc/cfg-flags.def
@@ -93,6 +93,9 @@ DEF_BASIC_BLOCK_FLAG(VISITED, 13)
    demand, and is available after calling compute_transaction_bits().  */
 DEF_BASIC_BLOCK_FLAG(IN_TRANSACTION, 14)
 
+/* Set on blocks that has been annotated during AutoFDO profile
+   attribution.  */
+DEF_BASIC_BLOCK_FLAG(ANNOTATED, 15)
 #endif
 
 #ifdef DEF_EDGE_FLAG
@@ -177,6 +180,9 @@ DEF_EDGE_FLAG(TM_UNINSTRUMENTED, 15)
 /* Abort (over) edge out of a GIMPLE_TRANSACTION statement.  */
 DEF_EDGE_FLAG(TM_ABORT, 16)
 
+/* Annotated during AutoFDO profile attribution.  */
+DEF_EDGE_FLAG(ANNOTATED, 17)
+
 #endif
 
 /*
diff --git a/gcc/cfg.c b/gcc/cfg.c
index 9e4380c..e3af0ba 100644
--- a/gcc/cfg.c
+++ b/gcc/cfg.c
@@ -909,7 +909,7 @@ scale_bbs_frequencies_int (basic_block *bbs, int nbbs, int num, int den)
       if (num > 1000000)
 	return;
 
-      num = RDIV (1000 * num, den);
+      num = RDIV (1000.0 * num, den);
       den = 1000;
     }
   if (num > 100 * den)
@@ -922,9 +922,9 @@ scale_bbs_frequencies_int (basic_block *bbs, int nbbs, int num, int den)
       /* Make sure the frequencies do not grow over BB_FREQ_MAX.  */
       if (bbs[i]->frequency > BB_FREQ_MAX)
 	bbs[i]->frequency = BB_FREQ_MAX;
-      bbs[i]->count = RDIV (bbs[i]->count * num, den);
+      bbs[i]->count = RDIV ((double)bbs[i]->count * num, den);
       FOR_EACH_EDGE (e, ei, bbs[i]->succs)
-	e->count = RDIV (e->count * num, den);
+	e->count = RDIV ((double)e->count * num, den);
     }
 }
 
@@ -941,7 +941,7 @@ scale_bbs_frequencies_gcov_type (basic_block *bbs, int nbbs, gcov_type num,
 {
   int i;
   edge e;
-  gcov_type fraction = RDIV (num * 65536, den);
+  gcov_type fraction = RDIV (num * 65536.0, den);
 
   gcc_assert (fraction >= 0);
 
@@ -951,14 +951,14 @@ scale_bbs_frequencies_gcov_type (basic_block *bbs, int nbbs, gcov_type num,
 	edge_iterator ei;
 	bbs[i]->frequency = RDIV (bbs[i]->frequency * num, den);
 	if (bbs[i]->count <= MAX_SAFE_MULTIPLIER)
-	  bbs[i]->count = RDIV (bbs[i]->count * num, den);
+	  bbs[i]->count = RDIV ((double)bbs[i]->count * num, den);
 	else
-	  bbs[i]->count = RDIV (bbs[i]->count * fraction, 65536);
+	  bbs[i]->count = RDIV ((double)bbs[i]->count * fraction, 65536);
 	FOR_EACH_EDGE (e, ei, bbs[i]->succs)
 	  if (bbs[i]->count <= MAX_SAFE_MULTIPLIER)
-	    e->count = RDIV (e->count * num, den);
+	    e->count = RDIV ((double)e->count * num, den);
 	  else
-	    e->count = RDIV (e->count * fraction, 65536);
+	    e->count = RDIV ((double)e->count * fraction, 65536);
       }
    else
     for (i = 0; i < nbbs; i++)
@@ -968,9 +968,9 @@ scale_bbs_frequencies_gcov_type (basic_block *bbs, int nbbs, gcov_type num,
 	  bbs[i]->frequency = RDIV (bbs[i]->frequency * num, den);
 	else
 	  bbs[i]->frequency = RDIV (bbs[i]->frequency * fraction, 65536);
-	bbs[i]->count = RDIV (bbs[i]->count * fraction, 65536);
+	bbs[i]->count = RDIV ((double)bbs[i]->count * fraction, 65536);
 	FOR_EACH_EDGE (e, ei, bbs[i]->succs)
-	  e->count = RDIV (e->count * fraction, 65536);
+	  e->count = RDIV ((double)e->count * fraction, 65536);
       }
 }
 
diff --git a/gcc/cfgexpand.c b/gcc/cfgexpand.c
index 5acc42d..eed3b98 100644
--- a/gcc/cfgexpand.c
+++ b/gcc/cfgexpand.c
@@ -1514,6 +1514,28 @@ estimated_stack_frame_size (struct cgraph_node *node)
   return size;
 }
 
+/* Helper routine to check if a record or union contains an array field. */
+
+static int
+record_or_union_type_has_array_p (const_tree tree_type)
+{
+  tree fields = TYPE_FIELDS (tree_type);
+  tree f;
+
+  for (f = fields; f; f = DECL_CHAIN (f))
+    {
+      if (TREE_CODE (f) == FIELD_DECL)
+	{
+	  tree field_type = TREE_TYPE (f);
+	  if (RECORD_OR_UNION_TYPE_P (field_type))
+	    return record_or_union_type_has_array_p (field_type);
+	  if (TREE_CODE (field_type) == ARRAY_TYPE)
+	    return 1;
+	}
+    }
+  return 0;
+}
+
 /* Expand all variables used in the function.  */
 
 static rtx
@@ -1525,6 +1547,7 @@ expand_used_vars (void)
   struct pointer_map_t *ssa_name_decls;
   unsigned i;
   unsigned len;
+  int gen_stack_protect_signal = 0;
 
   /* Compute the phase of the stack frame for this function.  */
   {
@@ -1576,6 +1599,23 @@ expand_used_vars (void)
     }
   pointer_map_destroy (ssa_name_decls);
 
+  FOR_EACH_LOCAL_DECL (cfun, i, var)
+    if (!is_global_var (var))
+      {
+	tree var_type = TREE_TYPE (var);
+	/* Examine local referenced variables that have their addresses taken,
+	   contain an array, or are arrays.  */
+	if (TREE_CODE (var) == VAR_DECL
+	    && (TREE_CODE (var_type) == ARRAY_TYPE
+		|| TREE_ADDRESSABLE (var)
+		|| (RECORD_OR_UNION_TYPE_P (var_type)
+		    && record_or_union_type_has_array_p (var_type))))
+	  {
+	    ++gen_stack_protect_signal;
+	    break;
+	  }
+      }
+
   /* At this point all variables on the local_decls with TREE_USED
      set are not associated with any block scope.  Lay them out.  */
 
@@ -1662,11 +1702,18 @@ expand_used_vars (void)
 	dump_stack_var_partition ();
     }
 
-  /* There are several conditions under which we should create a
-     stack guard: protect-all, alloca used, protected decls present.  */
-  if (flag_stack_protect == 2
-      || (flag_stack_protect
-	  && (cfun->calls_alloca || has_protected_decls)))
+  /* Create stack guard, if
+     a) "-fstack-protector-all" - always;
+     b) "-fstack-protector-strong" - if there are arrays, memory
+     references to local variables, alloca used, or protected decls present;
+     c) "-fstack-protector" - if alloca used, or protected decls present  */
+  if (flag_stack_protect == 3  /* -fstack-protector-all  */
+      || (flag_stack_protect == 2  /* -fstack-protector-strong  */
+	  && (gen_stack_protect_signal || cfun->calls_alloca
+	      || has_protected_decls))
+      || (flag_stack_protect == 1  /* -fstack-protector  */
+	  && (cfun->calls_alloca
+	      || has_protected_decls)))
     create_stack_guard ();
 
   /* Assign rtl to each variable based on these partitions.  */
diff --git a/gcc/cfghooks.c b/gcc/cfghooks.c
index 5e3eeb5..e471a74 100644
--- a/gcc/cfghooks.c
+++ b/gcc/cfghooks.c
@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "timevar.h"
 #include "diagnostic-core.h"
 #include "cfgloop.h"
+#include "pretty-print.h"
 
 /* A pointer to one of the hooks containers.  */
 static struct cfg_hooks *cfg_hooks;
@@ -292,7 +293,12 @@ dump_bb_for_graph (pretty_printer *pp, basic_block bb)
   if (!cfg_hooks->dump_bb_for_graph)
     internal_error ("%s does not support dump_bb_for_graph",
 		    cfg_hooks->name);
-  cfg_hooks->dump_bb_for_graph (pp, bb);
+  if (bb->count)
+    pp_printf (pp, "COUNT:" HOST_WIDEST_INT_PRINT_DEC, bb->count);
+  pp_printf (pp, " FREQ:%i |", bb->frequency);
+  pp_write_text_to_stream (pp);
+  if (!(dump_flags & TDF_SLIM))
+    cfg_hooks->dump_bb_for_graph (pp, bb);
 }
 
 /* Dump the complete CFG to FILE.  FLAGS are the TDF_* flags in dumpfile.h.  */
@@ -477,7 +483,6 @@ split_block (basic_block bb, void *i)
 
   new_bb->count = bb->count;
   new_bb->frequency = bb->frequency;
-  new_bb->discriminator = bb->discriminator;
 
   if (dom_info_available_p (CDI_DOMINATORS))
     {
diff --git a/gcc/cfgloop.c b/gcc/cfgloop.c
index 751da5a..d129a92 100644
--- a/gcc/cfgloop.c
+++ b/gcc/cfgloop.c
@@ -1166,24 +1166,98 @@ get_loop_exit_edges (const struct loop *loop)
   return edges;
 }
 
-/* Counts the number of conditional branches inside LOOP.  */
+/* Determine if INSN is a floating point set.  */
 
-unsigned
-num_loop_branches (const struct loop *loop)
+static bool
+insn_has_fp_set(rtx insn)
 {
-  unsigned i, n;
-  basic_block * body;
+  int i;
+  rtx pat = PATTERN(insn);
+  if (GET_CODE (pat) == SET)
+    return (FLOAT_MODE_P (GET_MODE (SET_DEST (pat))));
+  else if (GET_CODE (pat) == PARALLEL)
+    {
+      for (i = 0; i < XVECLEN (pat, 0); i++)
+        {
+          rtx sub = XVECEXP (pat, 0, i);
+          if (GET_CODE (sub) == SET)
+            return (FLOAT_MODE_P (GET_MODE (SET_DEST (sub))));
+        }
+    }
+  return false;
+}
 
-  gcc_assert (loop->latch != EXIT_BLOCK_PTR);
+/* Analyzes the instructions inside LOOP, updating the DESC. Currently counts
+   the number of conditional branch instructions, calls and fp instructions,
+   as well as the average number of branches executed per iteration.  */
+
+void
+analyze_loop_insns (const struct loop *loop, struct niter_desc *desc)
+{
+  unsigned i, nbranch;
+  gcov_type weighted_nbranch;
+  bool has_call, has_fp;
+  basic_block * body, bb;
+  rtx insn;
+  gcov_type header_count = loop->header->count;
+
+  nbranch = weighted_nbranch = 0;
+  has_call = has_fp = false;
 
   body = get_loop_body (loop);
-  n = 0;
   for (i = 0; i < loop->num_nodes; i++)
-    if (EDGE_COUNT (body[i]->succs) >= 2)
-      n++;
+    {
+      bb = body[i];
+
+      if (EDGE_COUNT (bb->succs) >= 2)
+        {
+          nbranch++;
+
+          /* If this block is executed less frequently than the header (loop
+             entry), then it is weighted based on its execution count, which
+             will be turned into a ratio compared to the loop header below. */
+          if (bb->count < header_count)
+            weighted_nbranch += bb->count;
+
+          /* When it is executed more frequently than the header (i.e. it is
+             in a nested inner loop), simply weight the branch the same as the
+             header execution count, so that it will contribute 1 branch to
+             the ratio computed below. */
+          else
+            weighted_nbranch += header_count;
+        }
+
+      /* No need to iterate through the instructions below if
+         both flags have already been set.  */
+      if (has_call && has_fp)
+        continue;
+
+      FOR_BB_INSNS (bb, insn)
+        {
+          if (!INSN_P (insn))
+            continue;
+
+          if (!has_call)
+            has_call = CALL_P (insn);
+
+          if (!has_fp)
+            has_fp = insn_has_fp_set (insn);
+        }
+    }
   free (body);
 
-  return n;
+  desc->num_branches = nbranch;
+  /* Now divide the weights computed above by the loop header execution count,
+     to compute the average number of branches through the loop. By adding
+     header_count/2 to the numerator we round to nearest with integer
+     division.  */
+  if (header_count  != 0)
+    desc->av_num_branches
+        = (weighted_nbranch + header_count/2) / header_count;
+  else
+    desc->av_num_branches = 0;
+  desc->has_call = has_call;
+  desc->has_fp = has_fp;
 }
 
 /* Adds basic block BB to LOOP.  */
diff --git a/gcc/cfgloop.h b/gcc/cfgloop.h
index 01cef51..d82fbdd 100644
--- a/gcc/cfgloop.h
+++ b/gcc/cfgloop.h
@@ -257,7 +257,6 @@ extern basic_block *get_loop_body_in_custom_order (const struct loop *,
 extern vec<edge> get_loop_exit_edges (const struct loop *);
 extern edge single_exit (const struct loop *);
 extern edge single_likely_exit (struct loop *loop);
-extern unsigned num_loop_branches (const struct loop *);
 
 extern edge loop_preheader_edge (const struct loop *);
 extern edge loop_latch_edge (const struct loop *);
@@ -370,7 +369,8 @@ struct rtx_iv
 };
 
 /* The description of an exit from the loop and of the number of iterations
-   till we take the exit.  */
+   till we take the exit. Also includes other information used primarily
+   by the loop unroller.  */
 
 struct niter_desc
 {
@@ -408,6 +408,18 @@ struct niter_desc
 
   /* The number of iterations of the loop.  */
   rtx niter_expr;
+
+  /* The number of branches in the loop.  */
+  unsigned num_branches;
+
+  /* The number of executed branches per iteration.  */
+  unsigned av_num_branches;
+
+  /* Whether the loop contains a call instruction.  */
+  bool has_call;
+
+  /* Whether the loop contains fp instructions.  */
+  bool has_fp;
 };
 
 extern void iv_analysis_loop_init (struct loop *);
@@ -421,6 +433,7 @@ extern void iv_analysis_done (void);
 
 extern struct niter_desc *get_simple_loop_desc (struct loop *loop);
 extern void free_simple_loop_desc (struct loop *loop);
+void analyze_loop_insns (const struct loop *, struct niter_desc *desc);
 
 static inline struct niter_desc *
 simple_loop_desc (struct loop *loop)
diff --git a/gcc/cgraph.c b/gcc/cgraph.c
index 8c1efb4..22233ec 100644
--- a/gcc/cgraph.c
+++ b/gcc/cgraph.c
@@ -49,9 +49,11 @@ along with GCC; see the file COPYING3.  If not see
 #include "rtl.h"
 #include "ipa-utils.h"
 #include "lto-streamer.h"
+#include "l-ipo.h"
 #include "ipa-inline.h"
 #include "cfgloop.h"
 #include "gimple-pretty-print.h"
+#include "opts.h"
 
 /* FIXME: Only for PROP_loops, but cgraph shouldn't have to know about this.  */
 #include "tree-pass.h"
@@ -534,6 +536,7 @@ cgraph_create_node (tree decl)
       node->next_nested = node->origin->nested;
       node->origin->nested = node;
     }
+  pattern_match_function_attributes (decl);
   return node;
 }
 
@@ -720,7 +723,9 @@ cgraph_edge (struct cgraph_node *node, gimple call_stmt)
     {
       node->call_site_hash = htab_create_ggc (120, edge_hash, edge_eq, NULL);
       for (e2 = node->callees; e2; e2 = e2->next_callee)
-	cgraph_add_edge_to_call_site_hash (e2);
+	/* Skip fake edges.  */
+	if (e2->call_stmt)
+	  cgraph_add_edge_to_call_site_hash (e2);
       for (e2 = node->indirect_calls; e2; e2 = e2->next_callee)
 	cgraph_add_edge_to_call_site_hash (e2);
     }
@@ -750,6 +755,8 @@ cgraph_set_call_stmt (struct cgraph_edge *e, gimple new_stmt)
       /* Constant propagation (and possibly also inlining?) can turn an
 	 indirect call into a direct one.  */
       struct cgraph_node *new_callee = cgraph_get_node (decl);
+      if (L_IPO_COMP_MODE && cgraph_pre_profiling_inlining_done)
+        new_callee = cgraph_lipo_get_resolved_node (decl);
 
       gcc_checking_assert (new_callee);
       cgraph_make_edge_direct (e, new_callee);
@@ -815,7 +822,8 @@ cgraph_create_edge_1 (struct cgraph_node *caller, struct cgraph_node *callee,
   pop_cfun ();
   if (call_stmt
       && callee && callee->symbol.decl
-      && !gimple_check_call_matching_types (call_stmt, callee->symbol.decl))
+      && !gimple_check_call_matching_types (call_stmt, callee->symbol.decl,
+					    false))
     edge->call_stmt_cannot_inline_p = true;
   else
     edge->call_stmt_cannot_inline_p = false;
@@ -920,7 +928,7 @@ cgraph_edge_remove_caller (struct cgraph_edge *e)
       else
 	e->caller->callees = e->next_callee;
     }
-  if (e->caller->call_site_hash)
+  if (e->caller->call_site_hash && e->call_stmt)
     htab_remove_elt_with_hash (e->caller->call_site_hash,
 			       e->call_stmt,
 	  		       htab_hash_pointer (e->call_stmt));
@@ -959,6 +967,26 @@ cgraph_remove_edge (struct cgraph_edge *e)
   cgraph_free_edge (e);
 }
 
+/* Remove fake cgraph edges for indirect calls. NODE is the callee
+   of the edges.  */
+
+void
+cgraph_remove_fake_indirect_call_in_edges (struct cgraph_node *node)
+{
+  struct cgraph_edge *f, *e;
+
+  if (!L_IPO_COMP_MODE)
+    return;
+
+  for (e = node->callers; e; e = f)
+    {
+      f = e->next_caller;
+      if (!e->call_stmt)
+        cgraph_remove_edge (e);
+    }
+}
+
+
 /* Set callee of call graph edge E and add it to the corresponding set of
    callers. */
 
@@ -1015,7 +1043,8 @@ cgraph_make_edge_direct (struct cgraph_edge *edge, struct cgraph_node *callee)
 
   if (edge->call_stmt)
     edge->call_stmt_cannot_inline_p
-      = !gimple_check_call_matching_types (edge->call_stmt, callee->symbol.decl);
+      = !gimple_check_call_matching_types (edge->call_stmt, callee->symbol.decl,
+					   false);
 
   /* We need to re-determine the inlining status of the edge.  */
   initialize_inline_failed (edge);
@@ -1092,6 +1121,12 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)
       new_stmt = e->call_stmt;
       gimple_call_set_fndecl (new_stmt, e->callee->symbol.decl);
       update_stmt (new_stmt);
+      if (L_IPO_COMP_MODE)
+        {
+          int lp_nr = lookup_stmt_eh_lp (e->call_stmt);
+          if (lp_nr != 0 && !stmt_could_throw_p (e->call_stmt))
+            remove_stmt_from_eh_lp (e->call_stmt);
+        }
     }
 
   cgraph_set_call_stmt_including_clones (e->caller, e->call_stmt, new_stmt);
@@ -1266,6 +1301,8 @@ cgraph_node_remove_callers (struct cgraph_node *node)
 void
 cgraph_release_function_body (struct cgraph_node *node)
 {
+  if (cgraph_is_aux_decl_external (node))
+    DECL_EXTERNAL (node->symbol.decl) = 1;
   if (DECL_STRUCT_FUNCTION (node->symbol.decl))
     {
       push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));
@@ -1374,6 +1411,7 @@ cgraph_remove_node (struct cgraph_node *node)
      itself is kept in the cgraph even after it is compiled.  Check whether
      we are done with this body and reclaim it proactively if this is the case.
      */
+  bool kill_body = false;
   n = cgraph_get_node (node->symbol.decl);
   if (!n
       || (!n->clones && !n->clone_of && !n->global.inlined_to
@@ -1382,9 +1420,13 @@ cgraph_remove_node (struct cgraph_node *node)
 		  || DECL_EXTERNAL (n->symbol.decl)
 		  || !n->analyzed
 		  || n->symbol.in_other_partition))))
+	kill_body = true;
+
+  if (kill_body)
     cgraph_release_function_body (node);
 
-  node->symbol.decl = NULL;
+  cgraph_remove_link_node (node);
+
   if (node->call_site_hash)
     {
       htab_delete (node->call_site_hash);
@@ -1401,6 +1443,7 @@ cgraph_remove_node (struct cgraph_node *node)
   free_nodes = node;
 }
 
+
 /* Likewise indicate that a node is having address taken.  */
 
 void
@@ -1515,6 +1558,9 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)
   if (node->count)
     fprintf (f, " executed "HOST_WIDEST_INT_PRINT_DEC"x",
 	     (HOST_WIDEST_INT)node->count);
+  if (node->max_bb_count)
+    fprintf (f, " hottest bb executed "HOST_WIDEST_INT_PRINT_DEC"x",
+	     (HOST_WIDEST_INT)node->max_bb_count);
   if (node->origin)
     fprintf (f, " nested in: %s", cgraph_node_asm_name (node->origin));
   if (gimple_has_body_p (node->symbol.decl))
@@ -2223,6 +2269,7 @@ verify_edge_count_and_frequency (struct cgraph_edge *e)
       error_found = true;
     }
   if (gimple_has_body_p (e->caller->symbol.decl)
+      && e->call_stmt
       && !e->caller->global.inlined_to
       /* FIXME: Inline-analysis sets frequency to 0 when edge is optimized out.
 	 Remove this once edges are actually removed from the function at that time.  */
@@ -2460,7 +2507,9 @@ verify_cgraph_node (struct cgraph_node *node)
 	    error ("Alias has non-alias reference");
 	    error_found = true;
 	  }
-	else if (ref_found)
+	else if (ref_found
+                 /* in LIPO mode, the alias can refer to the real target also  */
+                 && !L_IPO_COMP_MODE)
 	  {
 	    error ("Alias has more than one alias reference");
 	    error_found = true;
@@ -2554,7 +2603,7 @@ verify_cgraph_node (struct cgraph_node *node)
 
       for (e = node->callees; e; e = e->next_callee)
 	{
-	  if (!e->aux)
+	  if (!e->aux && e->call_stmt)
 	    {
 	      error ("edge %s->%s has no corresponding call_stmt",
 		     identifier_to_locale (cgraph_node_name (e->caller)),
@@ -2596,4 +2645,47 @@ verify_cgraph (void)
   FOR_EACH_FUNCTION (node)
     verify_cgraph_node (node);
 }
+
+/* Create external decl node for DECL.
+   The difference i nbetween cgraph_get_create_node and
+   cgraph_get_create_real_symbol_node is that cgraph_get_create_node
+   may return inline clone, while cgraph_get_create_real_symbol_node
+   will create a new node in this case.
+   FIXME: This function should be removed once clones are put out of decl
+   hash.  */
+
+struct cgraph_node *
+cgraph_get_create_real_symbol_node (tree decl)
+{
+  struct cgraph_node *first_clone = cgraph_get_node (decl);
+  struct cgraph_node *node;
+  /* create symbol table node.  even if inline clone exists, we can not take
+     it as a target of non-inlined call.  */
+  node = cgraph_get_node (decl);
+  if (node && !node->global.inlined_to)
+    return node;
+
+  node = cgraph_create_node (decl);
+
+  /* ok, we previously inlined the function, then removed the offline copy and
+     now we want it back for external call.  this can happen when devirtualizing
+     while inlining function called once that happens after extern inlined and
+     virtuals are already removed.  in this case introduce the external node
+     and make it available for call.  */
+  if (first_clone)
+    {
+      first_clone->clone_of = node;
+      node->clones = first_clone;
+      symtab_prevail_in_asm_name_hash ((symtab_node) node);
+      symtab_insert_node_to_hashtable ((symtab_node) node);
+      if (dump_file)
+	fprintf (dump_file, "Introduced new external node "
+		 "(%s/%i) and turned into root of the clone tree.\n",
+		 xstrdup (cgraph_node_name (node)), node->uid);
+    }
+  else if (dump_file)
+    fprintf (dump_file, "Introduced new external node "
+	     "(%s/%i).\n", xstrdup (cgraph_node_name (node)), node->uid);
+  return node;
+}
 #include "gt-cgraph.h"
diff --git a/gcc/cgraph.h b/gcc/cgraph.h
index 5df7fb4..fec9c8c 100644
--- a/gcc/cgraph.h
+++ b/gcc/cgraph.h
@@ -162,6 +162,9 @@ struct GTY(()) cgraph_local_info {
    once compilation is finished.  Available only with -funit-at-a-time.  */
 
 struct GTY(()) cgraph_global_info {
+  /* Estimated stack frame consumption by the function.  */
+  HOST_WIDE_INT estimated_stack_size;
+
   /* For inline clones this points to the function they will be
      inlined into.  */
   struct cgraph_node *inlined_to;
@@ -245,6 +248,8 @@ struct GTY(()) cgraph_node {
 
   /* Expected number of executions: calculated in profile.c.  */
   gcov_type count;
+  /* Maximum count of any basic block in the function.  */
+  gcov_type max_bb_count;
   /* How to scale counts at materialization time; used to merge
      LTO units with different number of profile runs.  */
   int count_materialization_scale;
@@ -263,6 +268,10 @@ struct GTY(()) cgraph_node {
   unsigned process : 1;
   /* Set for aliases once they got through assemble_alias.  */
   unsigned alias : 1;
+  /* Set for nodes that was constructed and finalized by frontend.  */
+  unsigned finalized_by_frontend : 1;
+  /* Is this function cloned during versioning ?  */
+  unsigned is_versioned_clone : 1;
   /* Set for aliases created as C++ same body aliases.  */
   unsigned same_body_alias : 1;
   /* How commonly executed the node is.  Initialized during branch
@@ -453,6 +462,8 @@ struct GTY(()) varpool_node {
   /* For aliases points to declaration DECL is alias of.  */
   tree alias_of;
 
+  /* The module in which it is first declared.  */
+  unsigned module_id;
   /* Set once the variable has been instantiated and its callee
      lists created.  */
   unsigned analyzed : 1;
@@ -556,6 +567,8 @@ void verify_symtab_node (symtab_node);
 bool verify_symtab_base (symtab_node);
 bool symtab_used_from_object_file_p (symtab_node);
 void symtab_make_decl_local (tree);
+void unlink_from_assembler_name_hash (symtab_node);
+void insert_to_assembler_name_hash (symtab_node);
 
 /* In cgraph.c  */
 void dump_cgraph (FILE *);
@@ -564,6 +577,11 @@ void dump_cgraph_node (FILE *, struct cgraph_node *);
 void debug_cgraph_node (struct cgraph_node *);
 void cgraph_remove_edge (struct cgraph_edge *);
 void cgraph_remove_node (struct cgraph_node *);
+void cgraph_remove_fake_indirect_call_in_edges (struct cgraph_node *);
+extern bool cgraph_pre_profiling_inlining_done;
+extern bool cgraph_is_fake_indirect_call_edge (struct cgraph_edge *e);
+void cgraph_add_to_same_comdat_group (struct cgraph_node *, struct cgraph_node *);
+void cgraph_remove_node_and_inline_clones (struct cgraph_node *);
 void cgraph_release_function_body (struct cgraph_node *);
 void cgraph_node_remove_callees (struct cgraph_node *node);
 struct cgraph_edge *cgraph_create_edge (struct cgraph_node *,
@@ -575,6 +593,7 @@ struct cgraph_indirect_call_info *cgraph_allocate_init_indirect_info (void);
 struct cgraph_node * cgraph_create_node (tree);
 struct cgraph_node * cgraph_create_empty_node (void);
 struct cgraph_node * cgraph_get_create_node (tree);
+struct cgraph_node * cgraph_get_create_real_symbol_node (tree);
 struct cgraph_node * cgraph_same_body_alias (struct cgraph_node *, tree, tree);
 struct cgraph_node * cgraph_add_thunk (struct cgraph_node *, tree, tree, bool, HOST_WIDE_INT,
 				       HOST_WIDE_INT, tree, tree);
@@ -625,6 +644,50 @@ void verify_cgraph (void);
 void verify_cgraph_node (struct cgraph_node *);
 void cgraph_mark_address_taken_node (struct cgraph_node *);
 
+/* Module info structure.  */
+struct GTY (()) cgraph_mod_info
+{
+  unsigned module_id;
+};
+
+/* LIPO linker symbol table entry for function symbols.  */
+struct GTY (()) cgraph_sym
+{
+  tree assembler_name;
+  struct cgraph_node *rep_node;
+  tree rep_decl;
+  htab_t GTY ((param_is (struct cgraph_mod_info))) def_module_hash;
+  bool is_promoted_static;
+};
+
+void cgraph_init_gid_map (void);
+void cgraph_add_fake_indirect_call_edges (void);
+void cgraph_remove_zero_count_fake_edges (void);
+void cgraph_do_link (void);
+struct cgraph_sym *cgraph_link_node (struct cgraph_node *);
+tree cgraph_find_decl (tree asm_name);
+void cgraph_remove_link_node (struct cgraph_node *node);
+struct cgraph_node *cgraph_lipo_get_resolved_node (tree decl);
+struct cgraph_node *cgraph_lipo_get_resolved_node_1 (tree decl, bool);
+unsigned  cgraph_get_module_id (tree fndecl);
+bool cgraph_is_auxiliary (tree fndecl);
+void cgraph_process_module_scope_statics (void);
+bool cgraph_is_promoted_static_func (tree fndecl);
+bool cgraph_is_inline_body_available_in_module (tree fndecl, unsigned module_id);
+bool cgraph_is_aux_decl_external (struct cgraph_node *);
+void cgraph_unify_type_alias_sets (void);
+void varpool_do_link (void);
+void varpool_link_node (struct varpool_node *);
+void varpool_remove_link_node (struct varpool_node *node);
+struct varpool_node *real_varpool_node (tree decl);
+bool varpool_is_auxiliary (struct varpool_node *node);
+void varpool_get_referenced_asm_ids (vec<tree, va_gc> **);
+void varpool_clear_asm_id_reference_bit (void);
+void varpool_reset_queue (void);
+void varpool_remove_duplicate_weak_decls (void);
+
+bool cgraph_decide_is_function_needed (struct cgraph_node *, tree);
+
 typedef void (*cgraph_edge_hook)(struct cgraph_edge *, void *);
 typedef void (*cgraph_node_hook)(struct cgraph_node *, void *);
 typedef void (*cgraph_2edge_hook)(struct cgraph_edge *, struct cgraph_edge *,
diff --git a/gcc/cgraphbuild.c b/gcc/cgraphbuild.c
index fb01f24..6249022 100644
--- a/gcc/cgraphbuild.c
+++ b/gcc/cgraphbuild.c
@@ -29,10 +29,15 @@ along with GCC; see the file COPYING3.  If not see
 #include "cgraph.h"
 #include "intl.h"
 #include "gimple.h"
+#include "toplev.h"
+#include "gcov-io.h"
+#include "coverage.h"
 #include "tree-pass.h"
 #include "ipa-utils.h"
 #include "except.h"
+#include "l-ipo.h"
 #include "ipa-inline.h"
+#include "auto-profile.h"
 
 /* Context of record_reference.  */
 struct record_reference_ctx
@@ -73,7 +78,7 @@ record_reference (tree *tp, int *walk_subtrees, void *data)
       decl = get_base_var (*tp);
       if (TREE_CODE (decl) == FUNCTION_DECL)
 	{
-	  struct cgraph_node *node = cgraph_get_create_node (decl);
+	  struct cgraph_node *node = cgraph_get_create_real_symbol_node (decl);
 	  if (!ctx->only_vars)
 	    cgraph_mark_address_taken_node (node);
 	  ipa_record_reference ((symtab_node)ctx->varpool_node,
@@ -143,7 +148,7 @@ record_eh_tables (struct cgraph_node *node, struct function *fun)
     {
       struct cgraph_node *per_node;
 
-      per_node = cgraph_get_create_node (DECL_FUNCTION_PERSONALITY (node->symbol.decl));
+      per_node = cgraph_get_create_real_symbol_node (DECL_FUNCTION_PERSONALITY (node->symbol.decl));
       ipa_record_reference ((symtab_node)node, (symtab_node)per_node, IPA_REF_ADDR, NULL);
       cgraph_mark_address_taken_node (per_node);
     }
@@ -215,6 +220,162 @@ compute_call_stmt_bb_frequency (tree decl, basic_block bb)
   return freq;
 }
 
+
+bool cgraph_pre_profiling_inlining_done = false;
+
+/* Return true if E is a fake indirect call edge.  */
+
+bool
+cgraph_is_fake_indirect_call_edge (struct cgraph_edge *e)
+{
+  return !e->call_stmt;
+}
+
+
+/* Add fake cgraph edges from NODE to its indirect call callees
+   using profile data.  */
+
+static void
+add_fake_indirect_call_edges (struct cgraph_node *node)
+{
+  unsigned n_counts, i;
+  gcov_type *ic_counts;
+
+  /* Enable this only for LIPO for now.  */
+  if (!L_IPO_COMP_MODE)
+    return;
+
+  if (cgraph_pre_profiling_inlining_done)
+    return;
+
+  ic_counts
+      = get_coverage_counts_no_warn (DECL_STRUCT_FUNCTION (node->symbol.decl),
+                                     GCOV_COUNTER_ICALL_TOPNV, &n_counts);
+
+  if (!ic_counts)
+    return;
+
+  gcc_assert ((n_counts % GCOV_ICALL_TOPN_NCOUNTS) == 0);
+  gcc_assert (!flag_auto_profile);
+
+/* After the early_inline_1 before value profile transformation,
+   functions that are indirect call targets may have their bodies
+   removed (extern inline functions or functions from aux modules,
+   functions in comdat etc) if all direct callsites are inlined. This
+   will lead to missing inline opportunities after profile based
+   indirect call promotion. The solution is to add fake edges to
+   indirect call targets. Note that such edges are not associated
+   with actual indirect call sites because it is not possible to
+   reliably match pre-early-inline indirect callsites with indirect
+   call profile counters which are from post-early inline function body.  */
+
+  for (i = 0; i < n_counts;
+       i += GCOV_ICALL_TOPN_NCOUNTS, ic_counts += GCOV_ICALL_TOPN_NCOUNTS)
+    {
+      gcov_type val1, val2, count1, count2;
+      struct cgraph_node *direct_call1 = 0, *direct_call2 = 0;
+
+      val1 = ic_counts[1];
+      count1 = ic_counts[2];
+      val2 = ic_counts[3];
+      count2 = ic_counts[4];
+
+      if (val1 == 0 || count1 == 0)
+        continue;
+
+      direct_call1 = find_func_by_global_id (val1, false);
+      if (direct_call1)
+        {
+          tree decl = direct_call1->symbol.decl;
+          cgraph_create_edge (node,
+	                      cgraph_get_create_node (decl),
+			      NULL,
+                              count1, 0);
+        }
+
+      if (val2 == 0 || count2 == 0)
+        continue;
+      direct_call2 = find_func_by_global_id (val2, false);
+      if (direct_call2)
+        {
+          tree decl = direct_call2->symbol.decl;
+          cgraph_create_edge (node,
+	                      cgraph_get_create_node (decl),
+                              NULL,
+                              count2, 0);
+        }
+    }
+}
+
+
+/* This can be implemented as an IPA pass that must be first one 
+   before any unreachable node elimination. */
+
+void
+cgraph_add_fake_indirect_call_edges (void)
+{
+  struct cgraph_node *node;
+
+  /* Enable this only for LIPO for now.  */
+  if (!L_IPO_COMP_MODE)
+    return;
+
+  FOR_EACH_DEFINED_FUNCTION (node)
+    {
+      if (!gimple_has_body_p (node->symbol.decl))
+	continue;
+      add_fake_indirect_call_edges (node);
+    }
+}
+
+/* Remove zero count fake edges added for the purpose of ensuring
+   the right processing order.  This should be called after all
+   small ipa passes.  */
+void
+cgraph_remove_zero_count_fake_edges (void)
+{
+  struct cgraph_node *node;
+
+  /* Enable this only for LIPO for now.  */
+  if (!L_IPO_COMP_MODE)
+    return;
+
+  FOR_EACH_DEFINED_FUNCTION (node)
+    {
+      if (!gimple_has_body_p (node->symbol.decl))
+	continue;
+
+     struct cgraph_edge *e, *f;
+     for (e = node->callees; e; e = f)
+       {
+         f = e->next_callee;
+	 if (!e->call_stmt && !e->count && !e->frequency)
+           cgraph_remove_edge (e);
+       }
+    }
+}
+
+static void
+record_reference_to_real_target_from_alias (struct cgraph_node *alias)
+{
+  if (!L_IPO_COMP_MODE || !cgraph_pre_profiling_inlining_done)
+    return;
+
+  /* Need to add a reference to the resolved node in LIPO
+     mode to avoid the real node from eliminated  */
+  if (alias->alias && alias->analyzed)
+    {
+      struct cgraph_node *target, *real_target;
+
+      target = cgraph_alias_aliased_node (alias);
+      real_target = cgraph_lipo_get_resolved_node (target->symbol.decl);
+      /* TODO: this make create duplicate entries in the reference list.  */
+      if (real_target != target)
+        ipa_record_reference ((symtab_node)alias, (symtab_node)real_target,
+                              IPA_REF_ALIAS, NULL);
+    }
+}
+
 /* Mark address taken in STMT.  */
 
 static bool
@@ -224,10 +385,14 @@ mark_address (gimple stmt, tree addr, void *data)
   if (TREE_CODE (addr) == FUNCTION_DECL)
     {
       struct cgraph_node *node = cgraph_get_create_node (addr);
+      if (L_IPO_COMP_MODE && cgraph_pre_profiling_inlining_done)
+        node = cgraph_lipo_get_resolved_node (addr);
+
       cgraph_mark_address_taken_node (node);
       ipa_record_reference ((symtab_node)data,
 			    (symtab_node)node,
 			    IPA_REF_ADDR, stmt);
+      record_reference_to_real_target_from_alias (node);
     }
   else if (addr && TREE_CODE (addr) == VAR_DECL
 	   && (TREE_STATIC (addr) || DECL_EXTERNAL (addr)))
@@ -237,6 +402,14 @@ mark_address (gimple stmt, tree addr, void *data)
       ipa_record_reference ((symtab_node)data,
 			    (symtab_node)vnode,
 			    IPA_REF_ADDR, stmt);
+      if (L_IPO_COMP_MODE && cgraph_pre_profiling_inlining_done)
+        {
+          struct varpool_node *rvnode = real_varpool_node (addr);
+          if (rvnode != vnode)
+            ipa_record_reference ((symtab_node)data,
+                                  (symtab_node)rvnode,
+                                  IPA_REF_ADDR, stmt);
+        }
     }
 
   return false;
@@ -252,7 +425,7 @@ mark_load (gimple stmt, tree t, void *data)
     {
       /* ??? This can happen on platforms with descriptors when these are
 	 directly manipulated in the code.  Pretend that it's an address.  */
-      struct cgraph_node *node = cgraph_get_create_node (t);
+      struct cgraph_node *node = cgraph_get_create_real_symbol_node (t);
       cgraph_mark_address_taken_node (node);
       ipa_record_reference ((symtab_node)data,
 			    (symtab_node)node,
@@ -266,6 +439,15 @@ mark_load (gimple stmt, tree t, void *data)
       ipa_record_reference ((symtab_node)data,
 			    (symtab_node)vnode,
 			    IPA_REF_LOAD, stmt);
+
+      if (L_IPO_COMP_MODE && cgraph_pre_profiling_inlining_done)
+        {
+          struct varpool_node *rvnode = real_varpool_node (t);
+          if (rvnode != vnode)
+            ipa_record_reference ((symtab_node)data,
+                                  (symtab_node)rvnode,
+                                  IPA_REF_ADDR, stmt);
+        }
     }
   return false;
 }
@@ -284,6 +466,14 @@ mark_store (gimple stmt, tree t, void *data)
       ipa_record_reference ((symtab_node)data,
 			    (symtab_node)vnode,
 			    IPA_REF_STORE, stmt);
+      if (L_IPO_COMP_MODE && cgraph_pre_profiling_inlining_done)
+        {
+          struct varpool_node *rvnode = real_varpool_node (t);
+          if (rvnode != vnode)
+            ipa_record_reference ((symtab_node)data,
+                                  (symtab_node)rvnode,
+                                  IPA_REF_ADDR, stmt);
+        }
      }
   return false;
 }
@@ -301,6 +491,9 @@ build_cgraph_edges (void)
   tree decl;
   unsigned ix;
 
+  if (flag_auto_profile)
+    afdo_set_current_function_count ();
+
   /* Create the callgraph edges and record the nodes referenced by the function.
      body.  */
   FOR_EACH_BB (bb)
@@ -330,7 +523,7 @@ build_cgraph_edges (void)
 	    {
 	      tree fn = gimple_omp_parallel_child_fn (stmt);
 	      ipa_record_reference ((symtab_node)node,
-				    (symtab_node)cgraph_get_create_node (fn),
+				    (symtab_node)cgraph_get_create_real_symbol_node (fn),
 				    IPA_REF_ADDR, stmt);
 	    }
 	  if (gimple_code (stmt) == GIMPLE_OMP_TASK)
@@ -338,12 +531,12 @@ build_cgraph_edges (void)
 	      tree fn = gimple_omp_task_child_fn (stmt);
 	      if (fn)
 		ipa_record_reference ((symtab_node)node,
-				      (symtab_node) cgraph_get_create_node (fn),
+				      (symtab_node) cgraph_get_create_real_symbol_node (fn),
 				      IPA_REF_ADDR, stmt);
 	      fn = gimple_omp_task_copy_fn (stmt);
 	      if (fn)
 		ipa_record_reference ((symtab_node)node,
-				      (symtab_node)cgraph_get_create_node (fn),
+				      (symtab_node)cgraph_get_create_real_symbol_node (fn),
 				      IPA_REF_ADDR, stmt);
 	    }
 	}
@@ -352,6 +545,7 @@ build_cgraph_edges (void)
 				       mark_load, mark_store, mark_address);
    }
 
+
   /* Look for initializers of constant variables and private statics.  */
   FOR_EACH_LOCAL_DECL (cfun, ix, decl)
     if (TREE_CODE (decl) == VAR_DECL
@@ -416,9 +610,12 @@ rebuild_cgraph_edges (void)
   ipa_remove_all_references (&node->symbol.ref_list);
 
   node->count = ENTRY_BLOCK_PTR->count;
+  node->max_bb_count = 0;
 
   FOR_EACH_BB (bb)
     {
+      if (bb->count > node->max_bb_count)
+	node->max_bb_count = bb->count;
       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
 	{
 	  gimple stmt = gsi_stmt (gsi);
@@ -430,8 +627,30 @@ rebuild_cgraph_edges (void)
 							 bb);
 	      decl = gimple_call_fndecl (stmt);
 	      if (decl)
-		cgraph_create_edge (node, cgraph_get_create_node (decl), stmt,
-				    bb->count, freq);
+	        {
+		  struct cgraph_node *callee;
+                  struct cgraph_edge *edge;
+		  /* In LIPO mode, before tree_profiling, the call graph edge
+		     needs to be built with the original target node to make
+		     sure consistent early inline decisions between profile
+                     generate and profile use. After tree-profiling, the target
+                     needs to be set to the resolved node so that ipa-inline
+                     sees the definitions.  */
+		  if (L_IPO_COMP_MODE && cgraph_pre_profiling_inlining_done)
+                    {
+                      callee = cgraph_lipo_get_resolved_node (decl);
+                      record_reference_to_real_target_from_alias (callee);
+                    }
+                  else
+		    callee = cgraph_get_create_node (decl);
+
+                  edge = cgraph_create_edge (node, callee, stmt,
+                                             bb->count, freq);
+
+                  if (L_IPO_COMP_MODE && cgraph_pre_profiling_inlining_done
+		      && decl != callee->symbol.decl)
+                    cgraph_redirect_edge_call_stmt_to_callee (edge);
+                }
 	      else
 		cgraph_create_indirect_edge (node, stmt,
 					     gimple_call_flags (stmt),
@@ -445,6 +664,7 @@ rebuild_cgraph_edges (void)
 	walk_stmt_load_store_addr_ops (gsi_stmt (gsi), node,
 				       mark_load, mark_store, mark_address);
     }
+  add_fake_indirect_call_edges (node);
   record_eh_tables (node, cfun);
   gcc_assert (!node->global.inlined_to);
 
@@ -502,10 +722,18 @@ struct gimple_opt_pass pass_rebuild_cgraph_edges =
  }
 };
 
+/* Defined in tree-optimize.c  */
+extern bool cgraph_callee_edges_final_cleanup; 
 
 static unsigned int
 remove_cgraph_callee_edges (void)
 {
+  /* The -freorder-functions=* needs the call-graph preserved till
+     pass_final.  */
+  if (cgraph_callee_edges_final_cleanup
+      && (flag_reorder_functions > 1))
+      return 0;
+
   cgraph_node_remove_callees (cgraph_get_node (current_function_decl));
   return 0;
 }
diff --git a/gcc/cgraphclones.c b/gcc/cgraphclones.c
index 3a2e3d6..f7a9b32 100644
--- a/gcc/cgraphclones.c
+++ b/gcc/cgraphclones.c
@@ -94,6 +94,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "ipa-utils.h"
 #include "lto-streamer.h"
 #include "except.h"
+#include "auto-profile.h"
 
 /* Create clone of E in the node N represented by CALL_EXPR the callgraph.  */
 struct cgraph_edge *
@@ -196,6 +197,10 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,
   new_node->global = n->global;
   new_node->rtl = n->rtl;
   new_node->count = count;
+  new_node->max_bb_count = count;
+  if (n->count)
+    new_node->max_bb_count = ((n->max_bb_count + n->count / 2)
+                              / n->count) * count;
   new_node->frequency = n->frequency;
   new_node->clone = n->clone;
   new_node->clone.tree_map = NULL;
@@ -208,11 +213,19 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,
     }
   else
     count_scale = 0;
+  /* In AutoFDO, if edge count is larger than callee's entry block
+     count, we will not update the original callee because it may
+     mistakenly mark some hot function as cold.  */
+  if (flag_auto_profile && count >= n->count)
+    update_original = false;
   if (update_original)
     {
       n->count -= count;
       if (n->count < 0)
-	n->count = 0;
+        n->count = 0;
+      n->max_bb_count -= new_node->max_bb_count;
+      if (n->max_bb_count < 0)
+        n->max_bb_count = 0;
     }
 
   FOR_EACH_VEC_ELT (redirect_callers, i, e)
@@ -265,6 +278,9 @@ clone_function_name (tree decl, const char *suffix)
   prefix[len] = '_';
 #endif
   ASM_FORMAT_PRIVATE_NAME (tmp_name, prefix, clone_fn_id_num++);
+  if (flag_auto_profile)
+    afdo_add_bfd_name_mapping (xstrdup (tmp_name),
+			       xstrdup (lang_hooks.dwarf_name (decl, 0)));
   return get_identifier (tmp_name);
 }
 
@@ -637,6 +653,7 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,
    new_version->global = old_version->global;
    new_version->rtl = old_version->rtl;
    new_version->count = old_version->count;
+   new_version->max_bb_count = old_version->max_bb_count;
 
    for (e = old_version->callees; e; e=e->next_callee)
      if (!bbs_to_copy
diff --git a/gcc/cgraphunit.c b/gcc/cgraphunit.c
index 7fa8055..daa97bd 100644
--- a/gcc/cgraphunit.c
+++ b/gcc/cgraphunit.c
@@ -181,6 +181,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "function.h"
 #include "ipa-prop.h"
 #include "gimple.h"
+#include "gcov-io.h"
 #include "tree-iterator.h"
 #include "tree-pass.h"
 #include "tree-dump.h"
@@ -191,8 +192,10 @@ along with GCC; see the file COPYING3.  If not see
 #include "ipa-inline.h"
 #include "ipa-utils.h"
 #include "lto-streamer.h"
+#include "l-ipo.h"
 #include "except.h"
 #include "regset.h"     /* FIXME: For reg_obstack.  */
+#include "auto-profile.h"
 
 /* Queue of cgraph nodes scheduled to be added into cgraph.  This is a
    secondary queue used during optimization to accommodate passes that
@@ -221,7 +224,7 @@ static GTY (()) tree vtable_entry_type;
    and differs from later logic removing unnecessary functions that can
    take into account results of analysis, whole program info etc.  */
 
-static bool
+bool
 cgraph_decide_is_function_needed (struct cgraph_node *node, tree decl)
 {
   /* If the user told us it is used, then it must be so.  */
@@ -466,6 +469,7 @@ void
 cgraph_add_new_function (tree fndecl, bool lowered)
 {
   struct cgraph_node *node;
+
   switch (cgraph_state)
     {
       case CGRAPH_STATE_PARSING:
@@ -525,7 +529,6 @@ cgraph_add_new_function (tree fndecl, bool lowered)
 	pop_cfun ();
 	expand_function (node);
 	break;
-
       default:
 	gcc_unreachable ();
     }
@@ -847,7 +850,9 @@ varpool_finalize_decl (tree decl)
     varpool_analyze_node (node);
   /* Some frontends produce various interface variables after compilation
      finished.  */
-  if (cgraph_state == CGRAPH_STATE_FINISHED)
+  if (cgraph_state == CGRAPH_STATE_FINISHED
+      || (cgraph_state == CGRAPH_STATE_EXPANSION
+          && flag_dyn_ipa && !flag_toplevel_reorder))
     varpool_assemble_decl (node);
 }
 
@@ -1132,6 +1137,137 @@ handle_alias_pairs (void)
   vec_free (alias_pairs);
 }
 
+/* Hash function for symbol (function) resolution.  */
+
+static hashval_t
+hash_node_by_assembler_name (const void *p)
+{
+  const struct cgraph_node *n = (const struct cgraph_node *) p;
+  return (hashval_t) decl_assembler_name_hash (
+      DECL_ASSEMBLER_NAME (n->symbol.decl));
+}
+
+/* Equality function for cgraph_node table.  */
+
+static int
+eq_node_assembler_name (const void *p1, const void *p2)
+{
+  const struct cgraph_node *n1 = (const struct cgraph_node *) p1;
+  const_tree name = (const_tree)p2;
+  return (decl_assembler_name_equal (n1->symbol.decl, name));
+}
+
+/* In l-ipo mode compilation (light weight IPO), multiple bodies may
+   be available for the same inline declared function. cgraph linking
+   does not really merge them in order to keep the context (module info)
+   of each body. After inlining, the linkage of the function may require
+   them to be output (even if it is defined in an auxiliary module). This
+   in term may result in duplicate emission.  */
+
+static GTY((param_is (struct cgraph_node))) htab_t output_node_hash = NULL;
+
+/* Add NODE that is expanded into the hashtable.  */
+
+static struct cgraph_node *
+cgraph_add_output_node (struct cgraph_node *node)
+{
+  void **aslot;
+  tree name;
+
+  if (!L_IPO_COMP_MODE)
+    return node;
+
+  /* Never common non public names except for compiler
+     generated static functions. (they are not promoted
+     to globals either.  */
+  if (!TREE_PUBLIC (node->symbol.decl)
+      && !(DECL_ARTIFICIAL (node->symbol.decl)
+	   && DECL_ASSEMBLER_NAME_SET_P (node->symbol.decl)))
+    return node;
+
+  if (!output_node_hash)
+      output_node_hash =
+	htab_create_ggc (10, hash_node_by_assembler_name,
+                         eq_node_assembler_name, NULL);
+
+  name = DECL_ASSEMBLER_NAME (node->symbol.decl);
+
+  aslot = htab_find_slot_with_hash (output_node_hash, name,
+                                    decl_assembler_name_hash (name),
+                                    INSERT);
+  if (*aslot == NULL)
+    {
+      *aslot = node;
+      return node;
+    }
+  else
+    return (struct cgraph_node *)(*aslot);
+}
+
+#if ENABLE_CHECKING
+/* Return the cgraph_node if the function symbol for NODE is
+   expanded in the output. Returns NULL otherwise.  */
+
+static struct cgraph_node *
+cgraph_find_output_node (struct cgraph_node *node)
+{
+  void **aslot;
+  tree name;
+
+  if (!L_IPO_COMP_MODE)
+    return node;
+
+  /* We do not track non-public functions.  */
+  if (!TREE_PUBLIC (node->symbol.decl))
+    return NULL;
+
+  /* Never addedd.  */
+  if (!output_node_hash)
+    return NULL;
+
+  name = DECL_ASSEMBLER_NAME (node->symbol.decl);
+
+  aslot = htab_find_slot_with_hash (output_node_hash, name,
+                                    decl_assembler_name_hash (name),
+                                    NO_INSERT);
+  if (!aslot)
+    return NULL;
+
+  return (struct cgraph_node *)(*aslot);
+}
+#endif
+
+
+#if ENABLE_CHECKING
+/* A function used in validation. Return true if NODE was
+   not expanded and its body was not reclaimed.  */
+
+static bool
+cgraph_node_expansion_skipped (struct cgraph_node *node)
+{
+  struct cgraph_node *output_node;
+
+  if (!L_IPO_COMP_MODE)
+    return false;
+
+  output_node = cgraph_find_output_node (node);
+
+  if (output_node == node)
+    return false;
+
+  if (output_node)
+    return true;
+
+  /* No output, no duplicate being output, and the node is not
+     inlined (and reclaimed) either -- check if the caller node
+     is output/expanded or not.  */
+  if (node->global.inlined_to)
+    return cgraph_node_expansion_skipped (node->global.inlined_to);
+
+  /* External functions not marked for output.  */
+  return true;
+}
+#endif
 
 /* Figure out what functions we want to assemble.  */
 
@@ -1162,19 +1298,23 @@ mark_functions_to_output (void)
 	  && !node->alias
 	  && !node->global.inlined_to
 	  && !TREE_ASM_WRITTEN (decl)
-	  && !DECL_EXTERNAL (decl))
-	{
-	  node->process = 1;
-	  if (node->symbol.same_comdat_group)
-	    {
-	      struct cgraph_node *next;
-	      for (next = cgraph (node->symbol.same_comdat_group);
-		   next != node;
-		   next = cgraph (next->symbol.same_comdat_group))
-		if (!next->thunk.thunk_p && !next->alias)
-		  next->process = 1;
-	    }
-	}
+	  && !(DECL_EXTERNAL (decl) || cgraph_is_aux_decl_external (node)))
+        {
+          if (cgraph_add_output_node (node) == node)
+            {
+              node->process = 1;
+              if (node->symbol.same_comdat_group)
+                {
+                  struct cgraph_node *next;
+                  for (next = cgraph (node->symbol.same_comdat_group);
+                       next != node;
+                       next = cgraph (next->symbol.same_comdat_group))
+                    if (!next->thunk.thunk_p && !next->alias
+                        && cgraph_add_output_node (next) == next)
+                      next->process = 1;
+                }
+            }
+ 	}
       else if (node->symbol.same_comdat_group)
 	{
 #ifdef ENABLE_CHECKING
@@ -1192,6 +1332,7 @@ mark_functions_to_output (void)
 		 have analyzed node pointing to it.  */
 	      && !node->symbol.in_other_partition
 	      && !node->alias
+              && !cgraph_is_auxiliary (node->symbol.decl)
 	      && !node->clones
 	      && !DECL_EXTERNAL (decl))
 	    {
@@ -1204,13 +1345,14 @@ mark_functions_to_output (void)
 		      || node->symbol.in_other_partition
 		      || node->clones
 		      || DECL_ARTIFICIAL (decl)
-		      || DECL_EXTERNAL (decl));
+		      || DECL_EXTERNAL (decl)
+                      || cgraph_is_auxiliary (node->symbol.decl));
 
 	}
 
     }
 #ifdef ENABLE_CHECKING
-  if (check_same_comdat_groups)
+  if (check_same_comdat_groups && !L_IPO_COMP_MODE)
     FOR_EACH_FUNCTION (node)
       if (node->symbol.same_comdat_group && !node->process)
 	{
@@ -1223,7 +1365,8 @@ mark_functions_to_output (void)
 		 analyzed node pointing to it.  */
 	      && !node->symbol.in_other_partition
 	      && !node->clones
-	      && !DECL_EXTERNAL (decl))
+	      && !(DECL_EXTERNAL (decl) || cgraph_is_aux_decl_external (node))
+	      && !L_IPO_COMP_MODE)
 	    {
 	      dump_cgraph_node (stderr, node);
 	      internal_error ("failed to reclaim unneeded function in same "
@@ -1790,6 +1933,8 @@ output_in_order (void)
   max = symtab_order;
   nodes = XCNEWVEC (struct cgraph_order_sort, max);
 
+  varpool_remove_duplicate_weak_decls ();
+
   FOR_EACH_DEFINED_FUNCTION (pf)
     {
       if (pf->process && !pf->thunk.thunk_p && !pf->alias)
@@ -1883,8 +2028,11 @@ ipa_passes (void)
 
   if (!in_lto_p)
     {
-      /* Generate coverage variables and constructors.  */
-      coverage_finish ();
+      /* Generate coverage variables and constructors.
+         In LIPO mode, delay this until direct call profiling
+         is done.   */
+      if (!flag_dyn_ipa)
+        coverage_finish ();
 
       /* Process new functions added.  */
       set_cfun (NULL);
@@ -1982,6 +2130,12 @@ compile (void)
     fprintf (stderr, "Performing interprocedural optimizations\n");
   cgraph_state = CGRAPH_STATE_IPA;
 
+  if (L_IPO_COMP_MODE)
+    {
+      cgraph_init_gid_map ();
+      cgraph_add_fake_indirect_call_edges ();
+    }
+
   /* If LTO is enabled, initialize the streamer hooks needed by GIMPLE.  */
   if (flag_lto)
     lto_streamer_hooks_init ();
@@ -2040,6 +2194,7 @@ compile (void)
       output_asm_statements ();
 
       expand_all_functions ();
+      varpool_remove_duplicate_weak_decls ();
       varpool_output_variables ();
     }
 
@@ -2055,15 +2210,21 @@ compile (void)
 #ifdef ENABLE_CHECKING
   verify_symtab ();
   /* Double check that all inline clones are gone and that all
-     function bodies have been released from memory.  */
+     function bodies have been released from memory.
+     As an exception, allow inline clones in the callgraph if
+     they are auxiliary functions. This is because we don't
+     expand any of the auxiliary functions, which may result
+     in inline clones of some auxiliary functions to be left
+     in the callgraph.  */
   if (!seen_error ())
     {
       struct cgraph_node *node;
       bool error_found = false;
 
       FOR_EACH_DEFINED_FUNCTION (node)
-	if (node->global.inlined_to
+	if (((node->global.inlined_to && !cgraph_is_auxiliary (node->symbol.decl))
 	    || gimple_has_body_p (node->symbol.decl))
+            && !cgraph_node_expansion_skipped (node))
 	  {
 	    error_found = true;
 	    dump_cgraph_node (stderr, node);
@@ -2082,6 +2243,13 @@ finalize_compilation_unit (void)
 {
   timevar_push (TV_CGRAPH);
 
+  /* Before compilation, auto profile will process the profile to build the
+     hash tables for later optimizations. We delay this function call here
+     because all the parsing should be done so that we will have the bfd
+     name mapping ready. */
+  if (flag_auto_profile)
+    process_auto_profile ();
+
   /* If we're here there's no current function anymore.  Some frontends
      are lazy in clearing these.  */
   current_function_decl = NULL;
diff --git a/gcc/cif-code.def b/gcc/cif-code.def
index 55e0ef4..035f1f0 100644
--- a/gcc/cif-code.def
+++ b/gcc/cif-code.def
@@ -87,6 +87,14 @@ DEFCIFCODE(MISMATCHED_ARGUMENTS, N_("mismatched arguments"))
 DEFCIFCODE(ORIGINALLY_INDIRECT_CALL,
 	   N_("originally indirect function call not considered for inlining"))
 
+/* Cross module inlining not allowed in first early inline phase.  */
+DEFCIFCODE(NO_INTERMODULE_INLINE,
+	   N_("inter-module inlining is disabled"))
+
+/* Artificial edge.  */
+DEFCIFCODE(ARTIFICIAL_EDGE,
+	   N_("artificial call graph edge"))
+
 /* Ths edge represents an indirect edge with a yet-undetermined callee .  */
 DEFCIFCODE(INDIRECT_UNKNOWN_CALL,
 	   N_("indirect function call with a yet undetermined callee"))
diff --git a/gcc/common.opt b/gcc/common.opt
index 8ad9408..48b6f48 100644
--- a/gcc/common.opt
+++ b/gcc/common.opt
@@ -284,6 +284,9 @@ Driver Joined Alias(L)
 -no-canonical-prefixes
 Driver Alias(no-canonical-prefixes)
 
+-canonical-prefixes
+Driver Alias(canonical-prefixes)
+
 -no-standard-libraries
 Driver Alias(nostdlib)
 
@@ -549,6 +552,10 @@ Wfatal-errors
 Common Var(flag_fatal_errors)
 Exit on the first error occurred
 
+Wforce-warnings
+Common Var(flag_force_warnings)
+Disable promoting warnings to errors
+
 Wframe-larger-than=
 Common RejectNegative Joined UInteger
 -Wframe-larger-than=<number>	Warn if a function's stack frame requires more than <number> bytes
@@ -591,6 +598,14 @@ Wpadded
 Common Var(warn_padded) Warning
 Warn when padding is required to align structure members
 
+Wripa-opt-mismatch
+Common Var(warn_ripa_opt_mismatch) Warning EnabledBy(Wall)
+Warn if primary and auxiliary modules have mismatched command line options
+
+Wself-assign
+Common Var(warn_self_assign) Init(0) Warning
+Warn when a variable is assigned to itself
+
 Wpedantic
 Common Var(pedantic) Warning
 Issue warnings needed for strict compliance to the standard
@@ -599,6 +614,15 @@ Wshadow
 Common Var(warn_shadow) Warning
 Warn when one local variable shadows another
 
+Wshadow-local
+Common Var(warn_shadow_local) Warning
+Warn when one local variable shadows another local variable or parameter
+
+Wshadow-compatible-local
+Common Var(warn_shadow_compatible_local) Warning
+Warn when one local variable shadows another local variable or parameter
+of compatible type
+
 Wstack-protector
 Common Var(warn_stack_protect) Warning
 Warn when not issuing stack smashing protection for some reason
@@ -643,6 +667,50 @@ Wtrampolines
 Common Var(warn_trampolines) Warning
 Warn whenever a trampoline is generated
 
+; FIXME.  The following -Wthread-* flags are placeholders to prevent
+; confusing the compiler when applications are built with these flags.
+; Actual support for these flags is being implemented in the
+; thread-annotations branch.
+Wthread-safety
+Common Var(warn_thread_safety) Warning
+Warn about potential thread safety issues when the code is annotated with thread safety attributes
+
+Wthread-safety-analysis
+Common Ignore
+Does nothing.  For compatibility with clang thread safety analysis.
+
+Wthread-safety-attributes
+Common Ignore
+Does nothing.  For compatibility with clang thread safety analysis.
+
+Wthread-safety-precise
+Common Ignore
+Does nothing.  For compatibility with clang thread safety analysis.
+
+Wthread-unguarded-var
+Common Var(warn_thread_unguarded_var) Init(1) Warning
+Warn about shared variables not properly protected by locks specified in the attributes
+
+Wthread-unguarded-func
+Common Var(warn_thread_unguarded_func) Init(1) Warning
+Warn about function calls not properly protected by locks specified in the attributes
+
+Wthread-mismatched-lock-order
+Common Var(warn_thread_mismatched_lock_order) Init(1) Warning
+Warn about lock acquisition order inconsistent with what specified in the attributes
+
+Wthread-mismatched-lock-acq-rel
+Common Var(warn_thread_mismatched_lock_acq_rel) Init(1) Warning
+Warn about mismatched lock acquisition and release
+
+Wthread-reentrant-lock
+Common Var(warn_thread_reentrant_lock) Init(1) Warning
+Warn about a lock being acquired recursively
+
+Wthread-unsupported-lock-name
+Common Var(warn_unsupported_lock_name) Init(0) Warning
+Warn about uses of unsupported lock names in attributes
+
 Wtype-limits
 Common Var(warn_type_limits) Warning EnabledBy(Wextra)
 Warn if a comparison is always true or always false due to the limited range of the data type
@@ -702,6 +770,9 @@ Warn when a vector operation is compiled outside the SIMD
 Xassembler
 Driver Separate
 
+Xclang-only=
+Driver Joined Ignore
+
 Xlinker
 Driver Separate
 
@@ -861,6 +932,16 @@ fauto-inc-dec
 Common Report Var(flag_auto_inc_dec) Init(1)
 Generate auto-inc/dec instructions
 
+fauto-profile
+Common Report Var(flag_auto_profile) Optimization
+Use sample profile information for call graph node weights. The default
+profile file is fbdata.afdo in 'pwd'.
+
+fauto-profile=
+Common Joined RejectNegative Var(auto_profile_file)
+Use sample profile information for call graph node weights. The profile
+file is specified in the argument.
+
 ; -fcheck-bounds causes gcc to generate array bounds checks.
 ; For C, C++ and ObjC: defaults off.
 ; For Java: defaults to on.
@@ -1094,6 +1175,27 @@ fdwarf2-cfi-asm
 Common Report Var(flag_dwarf2_cfi_asm) Init(HAVE_GAS_CFI_DIRECTIVE)
 Enable CFI tables via GAS assembler directives.
 
+fripa
+Common Report Var(flag_dyn_ipa)
+Perform Dynamic Inter-Procedural Analysis.
+
+fripa-disallow-asm-modules
+Common Report Var(flag_ripa_disallow_asm_modules)
+Don't import an auxiliary module if it contains asm statements
+
+fripa-disallow-opt-mismatch
+Common Report Var(flag_ripa_disallow_opt_mismatch)
+Don't import an auxiliary module if the command line options mismatch with the primary module
+
+fripa-no-promote-always-inline-func
+Common Report Var(flag_ripa_no_promote_always_inline) Init(0)
+Don't promote always inline static functions assuming they
+will be inlined and no copy is needed.
+
+fripa-inc-path-sub=
+Common Joined RejectNegative Var(lipo_inc_path_pattern)
+Substitute substring in include paths with a new string to allow reuse profile data
+
 fearly-inlining
 Common Report Var(flag_early_inlining) Init(1) Optimization
 Perform early inlining
@@ -1183,6 +1285,10 @@ Enum(fp_contract_mode) String(on) Value(FP_CONTRACT_OFF)
 EnumValue
 Enum(fp_contract_mode) String(fast) Value(FP_CONTRACT_FAST)
 
+ffunction-attribute-list=
+Common Joined RejectNegative Var(common_deferred_options) Defer
+-ffunction-attribute-list=attribute:name,...  Add attribute to named functions
+
 ; Nonzero means don't put addresses of constant functions in registers.
 ; Used for compiling the Unix kernel, where strange substitutions are
 ; done on the assembly output.
@@ -1610,6 +1716,10 @@ fpcc-struct-return
 Common Report Var(flag_pcc_struct_return,1) Init(DEFAULT_PCC_STRUCT_RETURN)
 Return small aggregates in memory, not registers
 
+fpeel-codesize-limit
+Common Report Var(flag_peel_codesize_limit) Init(1) Optimization
+Limit non-const non-FP loop peeling under profile estimates of large code footprint
+
 fpeel-loops
 Common Report Var(flag_peel_loops) Optimization
 Perform loop peeling
@@ -1671,6 +1781,19 @@ fprofile-correction
 Common Report Var(flag_profile_correction)
 Enable correction of flow inconsistent profile data input
 
+fprofile-dump
+Common Report Var(flag_profile_dump) Init(0) Optimization
+Dump CFG profile for comparison.
+
+; fprofile-generate-atomic=0: disable aotimically update.
+; fprofile-generate-atomic=1: aotimically update edge profile counters.
+; fprofile-generate-atomic=2: aotimically update value profile counters.
+; fprofile-generate-atomic=3: aotimically update edge and value profile counters.
+; other values will be ignored (fall back to the default of 0).
+fprofile-generate-atomic=
+Common Joined UInteger Report Var(flag_profile_gen_atomic) Init(0) Optimization
+fprofile-generate-atomic=[0..3] Atomically increments for profile counters.
+
 fprofile-generate
 Common
 Enable common options for generating profile info for profile feedback directed optimizations
@@ -1679,6 +1802,14 @@ fprofile-generate=
 Common Joined RejectNegative
 Enable common options for generating profile info for profile feedback directed optimizations, and set -fprofile-dir=
 
+fprofile-generate-sampling
+Common Var(flag_profile_generate_sampling)
+Turn on instrumentation sampling with -fprofile-generate with rate set by --param profile-generate-sampling-rate or environment variable GCOV_SAMPLING_RATE
+
+fprofile-strip=
+Common Joined RejectNegative Var(profile_base_name_suffix_to_strip)
+Specify a substring to be stripped from the profile base file name
+
 fprofile-use
 Common Var(flag_profile_use)
 Enable common options for performing profile feedback directed optimizations
@@ -1712,6 +1843,14 @@ frecord-gcc-switches
 Common Report Var(flag_record_gcc_switches)
 Record gcc command line switches in the object file.
 
+; This option differs from frecord-gcc-switches in the way that it
+; divide the command line options into several categories. And the
+; section is not mergable so that linker can save gcc switches for
+; each module.
+frecord-compilation-info-in-elf
+Common Report Var(flag_record_compilation_info_in_elf)
+Record the compiler optimizations in a .gnu.switches.text section.
+
 freg-struct-return
 Common Report Var(flag_pcc_struct_return,0) Optimization
 Return small aggregates in registers
@@ -1736,6 +1875,16 @@ freorder-functions
 Common Report Var(flag_reorder_functions) Optimization
 Reorder functions to improve code placement
 
+freorder-functions=
+Common Joined RejectNegative Enum(function_reorder) Var(flag_reorder_functions) Init(0) Optimization
+-freorder-functions=[callgraph]	Select the scheme for function reordering. This invokes a linker plugin.  Generate .gnu.callgraph.text sections listing callees and edge counts.
+
+Enum
+Name(function_reorder) Type(int) UnknownError(unrecognized function reorder value %qs)
+ 
+EnumValue
+Enum(function_reorder) String(callgraph) Value(2)
+
 frerun-cse-after-loop
 Common Report Var(flag_rerun_cse_after_loop) Optimization
 Add a common subexpression elimination pass after loop optimizations
@@ -1894,6 +2043,10 @@ fsingle-precision-constant
 Common Report Var(flag_single_precision_constant) Optimization
 Convert floating point constants to single precision constants
 
+fsized-delete
+Common Report Var(flag_sized_delete) Optimization
+Support delete operator with objetc's size as the second parameter.
+
 fsplit-ivs-in-unroller
 Common Report Var(flag_split_ivs_in_unroller) Init(1) Optimization
 Split lifetimes of induction variables when loops are unrolled
@@ -1933,8 +2086,12 @@ fstack-protector
 Common Report Var(flag_stack_protect, 1)
 Use propolice as a stack protection method
 
-fstack-protector-all
+fstack-protector-strong
 Common Report RejectNegative Var(flag_stack_protect, 2)
+Use a smart stack protection method for certain functions
+
+fstack-protector-all
+Common Report RejectNegative Var(flag_stack_protect, 3)
 Use a stack protection method for every function
 
 fstack-usage
@@ -2163,6 +2320,10 @@ ftree-vrp
 Common Report Var(flag_tree_vrp) Init(0) Optimization
 Perform Value Range Propagation on trees
 
+fstrict-enum-precision
+Common Report Var(flag_strict_enum_precision) Init(1) Optimization
+Perform transformations based on enum precision
+
 funit-at-a-time
 Common Report Var(flag_unit_at_a_time) Init(1) Optimization
 Compile whole compilation unit at a time
@@ -2175,6 +2336,10 @@ funroll-all-loops
 Common Report Var(flag_unroll_all_loops) Optimization
 Perform loop unrolling for all loops
 
+funroll-codesize-limit
+Common Report Var(flag_unroll_codesize_limit) Init(1) Optimization
+Limit non-const non-FP loop unrolling under profile estimates of large code footprint
+
 ; Nonzero means that loop optimizer may assume that the induction variables
 ; that control loops do not overflow and that the loops with nontrivial
 ; exit condition are not infinite
@@ -2343,13 +2508,17 @@ Common JoinedOrMissing
 Generate debug information in default extended format
 
 gno-pubnames
-Common RejectNegative Var(debug_generate_pub_sections, 0) Init(-1)
+Common Negative(gpubnames) Var(debug_generate_pub_sections, 0) Init(-1)
 Don't generate DWARF pubnames and pubtypes sections.
 
 gpubnames
-Common RejectNegative Var(debug_generate_pub_sections, 1)
+Common Negative(ggnu-pubnames) Var(debug_generate_pub_sections, 1)
 Generate DWARF pubnames and pubtypes sections.
 
+ggnu-pubnames
+Common Negative(gno-pubnames) Var(debug_generate_pub_sections, 2)
+Generate DWARF pubnames and pubtypes sections with GNU extensions.
+
 gno-record-gcc-switches
 Common RejectNegative Var(dwarf_record_gcc_switches,0) Init(1)
 Don't record gcc command line switches in DWARF DW_AT_producer.
@@ -2358,6 +2527,10 @@ grecord-gcc-switches
 Common RejectNegative Var(dwarf_record_gcc_switches,1)
 Record gcc command line switches in DWARF DW_AT_producer.
 
+gmlt
+Common RejectNegative
+Generate debug information at level 1 with minimal line table
+
 gno-split-dwarf
 Common Driver RejectNegative Var(dwarf_split_debug_info,0) Init(0)
 Don't generate debug information in separate .dwo files
@@ -2366,6 +2539,12 @@ gsplit-dwarf
 Common Driver RejectNegative Var(dwarf_split_debug_info,1)
 Generate debug information in separate .dwo files
 
+gfission
+Common Driver Alias(gsplit-dwarf)
+
+gno-fission
+Common Driver Alias(gno-split-dwarf)
+
 gstabs
 Common JoinedOrMissing Negative(gstabs+)
 Generate debug information in STABS format
@@ -2418,6 +2597,9 @@ Driver
 no-canonical-prefixes
 Driver
 
+canonical-prefixes
+Driver
+
 nodefaultlibs
 Driver
 
diff --git a/gcc/common/config/i386/i386-common.c b/gcc/common/config/i386/i386-common.c
index f22f6a43..b73e369 100644
--- a/gcc/common/config/i386/i386-common.c
+++ b/gcc/common/config/i386/i386-common.c
@@ -87,6 +87,7 @@ along with GCC; see the file COPYING3.  If not see
 
 #define OPTION_MASK_ISA_BMI_SET OPTION_MASK_ISA_BMI
 #define OPTION_MASK_ISA_BMI2_SET OPTION_MASK_ISA_BMI2
+#define OPTION_MASK_ISA_LZCNT_SET OPTION_MASK_ISA_LZCNT
 #define OPTION_MASK_ISA_TBM_SET OPTION_MASK_ISA_TBM
 #define OPTION_MASK_ISA_POPCNT_SET OPTION_MASK_ISA_POPCNT
 #define OPTION_MASK_ISA_CX16_SET OPTION_MASK_ISA_CX16
@@ -154,6 +155,7 @@ along with GCC; see the file COPYING3.  If not see
 #define OPTION_MASK_ISA_ABM_UNSET OPTION_MASK_ISA_ABM
 #define OPTION_MASK_ISA_BMI_UNSET OPTION_MASK_ISA_BMI
 #define OPTION_MASK_ISA_BMI2_UNSET OPTION_MASK_ISA_BMI2
+#define OPTION_MASK_ISA_LZCNT_UNSET OPTION_MASK_ISA_LZCNT
 #define OPTION_MASK_ISA_TBM_UNSET OPTION_MASK_ISA_TBM
 #define OPTION_MASK_ISA_POPCNT_UNSET OPTION_MASK_ISA_POPCNT
 #define OPTION_MASK_ISA_CX16_UNSET OPTION_MASK_ISA_CX16
@@ -438,6 +440,19 @@ ix86_handle_option (struct gcc_options *opts,
 	}
       return true;
 
+    case OPT_mlzcnt:
+      if (value)
+	{
+	  opts->x_ix86_isa_flags |= OPTION_MASK_ISA_LZCNT_SET;
+	  opts->x_ix86_isa_flags_explicit |= OPTION_MASK_ISA_LZCNT_SET;
+	}
+      else
+	{
+	  opts->x_ix86_isa_flags &= ~OPTION_MASK_ISA_LZCNT_UNSET;
+	  opts->x_ix86_isa_flags_explicit |= OPTION_MASK_ISA_LZCNT_UNSET;
+	}
+      return true;
+
     case OPT_mtbm:
       if (value)
 	{
diff --git a/gcc/config.gcc b/gcc/config.gcc
index 048702a..10d0cf5 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -879,6 +879,27 @@ arm*-*-linux-*)			# ARM GNU/Linux with ELF
 	tm_file="$tm_file arm/bpabi.h arm/linux-eabi.h arm/aout.h vxworks-dummy.h arm/arm.h"
 	# Define multilib configuration for arm-linux-androideabi.
 	case ${target} in
+	arm*-*-linux-*eabi)
+	    tmake_file="$tmake_file arm/t-arm-elf arm/t-bpabi arm/t-linux-eabi"
+	    # Define multilib configuration for arm-linux-androideabi.
+	    case ${target} in
+	    *-androideabi)
+		tmake_file="$tmake_file arm/t-linux-androideabi"
+		;;
+	    esac
+	    # Pull in spec changes for GRTE configurations.
+	    case ${target} in
+	    *-grte*)
+		tm_file="${tm_file} linux-grte.h arm/linux-grte.h"
+		;;
+	    esac
+  	    # The BPABI long long divmod functions return a 128-bit value in
+	    # registers r0-r3.  Correctly modeling that requires the use of
+	    # TImode.
+	    need_64bit_hwint=yes
+	    # The EABI requires the use of __cxa_atexit.
+	    default_use_cxa_atexit=yes
+	    ;;
 	*-androideabi)
 	    tmake_file="$tmake_file arm/t-linux-androideabi"
 	    ;;
@@ -1304,6 +1325,12 @@ i[34567]86-*-linux* | i[34567]86-*-kfreebsd*-gnu | i[34567]86-*-knetbsd*-gnu | i
 		else
 			tm_file="${tm_file} i386/gnu-user-common.h i386/gnu-user.h i386/linux-common.h i386/linux.h"
 		fi
+		# Pull in spec changes for GRTE configurations.
+		case ${target} in
+		*-grte*)
+			tm_file="${tm_file} linux-grte.h"
+			;;
+		esac
 		;;
 	i[34567]86-*-knetbsd*-gnu)
 		tm_file="${tm_file} i386/gnu-user-common.h i386/gnu-user.h knetbsd-gnu.h i386/knetbsd-gnu.h"
@@ -1327,6 +1354,12 @@ x86_64-*-linux* | x86_64-*-kfreebsd*-gnu | x86_64-*-knetbsd*-gnu)
 		tm_file="${tm_file} linux.h i386/linux-common.h i386/linux64.h"
 		# Assume modern glibc
 		default_gnu_indirect_function=yes
+		# Pull in spec changes for GRTE configurations.
+		case ${target} in
+		*-grte*)
+			tm_file="${tm_file} linux-grte.h"
+			;;
+		esac
 	  	;;
 	x86_64-*-kfreebsd*-gnu)
 		tm_file="${tm_file} kfreebsd-gnu.h i386/kfreebsd-gnu64.h"
@@ -2122,6 +2155,12 @@ powerpc*-*-linux*)
 	if test x${enable_secureplt} = xyes; then
 		tm_file="rs6000/secureplt.h ${tm_file}"
 	fi
+	# Pull in spec changes for GRTE configurations.
+	case ${target} in
+	*-grte*)
+	    tm_file="${tm_file} rs6000/linux-grte.h"
+	    ;;
+	esac
 	;;
 powerpc-wrs-vxworks|powerpc-wrs-vxworksae)
 	tm_file="${tm_file} elfos.h freebsd-spec.h rs6000/sysv4.h"
diff --git a/gcc/config.host b/gcc/config.host
index 1196ec5..b3df890 100644
--- a/gcc/config.host
+++ b/gcc/config.host
@@ -75,6 +75,7 @@ out_host_hook_obj=host-default.o
 host_can_use_collect2=yes
 use_long_long_for_widest_fast_int=no
 host_lto_plugin_soname=liblto_plugin.so
+host_function_reordering_plugin_soname=libfunction_reordering_plugin.so
 
 # Unsupported hosts list.  Generally, only include hosts known to fail here,
 # since we allow hosts not listed to be supported generically.
diff --git a/gcc/config.in b/gcc/config.in
index 3df6af9..76235f9 100644
--- a/gcc/config.in
+++ b/gcc/config.in
@@ -45,6 +45,12 @@
 #endif
 
 
+/* Define to enable prefix canonicalization. */
+#ifndef USED_FOR_TARGET
+#undef ENABLE_CANONICAL_PREFIXES
+#endif
+
+
 /* Define if you want more run-time sanity checks. This one gets a grab bag of
    miscellaneous but relatively cheap checks. */
 #ifndef USED_FOR_TARGET
@@ -1641,6 +1647,11 @@
 #undef LINKER_HASH_STYLE
 #endif
 
+/* Define to the name of the function reordering plugin DSO that must be
+   passed to the linker's -plugin=LIB option. */
+#ifndef USED_FOR_TARGET
+#undef FRPLUGINSONAME
+#endif
 
 /* Define to the name of the LTO plugin DSO that must be passed to the
    linker's -plugin=LIB option. */
@@ -1846,6 +1857,12 @@
 #endif
 
 
+/* Define to be extra text for frame size warnings. */
+#ifndef USED_FOR_TARGET
+#undef WARN_FRAME_LARGER_THAN_EXTRA_TEXT
+#endif
+
+
 /* Define to be the last component of the Windows registry key under which to
    look for installation paths. The full key used will be
    HKEY_LOCAL_MACHINE/SOFTWARE/Free Software Foundation/{WIN32_REGISTRY_KEY}.
diff --git a/gcc/config/aarch64/arm_neon.h b/gcc/config/aarch64/arm_neon.h
index 60e1f7d..1f38751 100644
--- a/gcc/config/aarch64/arm_neon.h
+++ b/gcc/config/aarch64/arm_neon.h
@@ -8518,6 +8518,28 @@ vld1_dup_u64 (const uint64_t * a)
   return result;
 }
 
+__extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
+vld1_f32 (const float32_t * a)
+{
+  float32x2_t result;
+  __asm__ ("ld1 {%0.2s}, %1"
+	   : "=w"(result)
+	   : "Utv"(({const float32x2_t *_a = (float32x2_t *) a; *_a;}))
+	   : /* No clobbers */);
+  return result;
+}
+
+__extension__ static __inline float64x1_t __attribute__ ((__always_inline__))
+vld1_f64 (const float64_t * a)
+{
+  float64x1_t result;
+  __asm__ ("ld1 {%0.1d}, %1"
+	   : "=w"(result)
+	   : "Utv"(*a)
+	   : /* No clobbers */);
+  return result;
+}
+
 #define vld1_lane_f32(a, b, c)                                          \
   __extension__                                                         \
     ({                                                                  \
@@ -8674,6 +8696,116 @@ vld1_dup_u64 (const uint64_t * a)
        result;                                                          \
      })
 
+__extension__ static __inline poly8x8_t __attribute__ ((__always_inline__))
+vld1_p8 (const poly8_t * a)
+{
+  poly8x8_t result;
+  __asm__ ("ld1 {%0.8b}, %1"
+	   : "=w"(result)
+	   : "Utv"(({const poly8x8_t *_a = (poly8x8_t *) a; *_a;}))
+	   : /* No clobbers */);
+  return result;
+}
+
+__extension__ static __inline poly16x4_t __attribute__ ((__always_inline__))
+vld1_p16 (const poly16_t * a)
+{
+  poly16x4_t result;
+  __asm__ ("ld1 {%0.4h}, %1"
+	   : "=w"(result)
+	   : "Utv"(({const poly16x4_t *_a = (poly16x4_t *) a; *_a;}))
+	   : /* No clobbers */);
+  return result;
+}
+
+__extension__ static __inline int8x8_t __attribute__ ((__always_inline__))
+vld1_s8 (const int8_t * a)
+{
+  int8x8_t result;
+  __asm__ ("ld1 {%0.8b}, %1"
+	   : "=w"(result)
+	   : "Utv"(({const int8x8_t *_a = (int8x8_t *) a; *_a;}))
+	   : /* No clobbers */);
+  return result;
+}
+
+__extension__ static __inline int16x4_t __attribute__ ((__always_inline__))
+vld1_s16 (const int16_t * a)
+{
+  int16x4_t result;
+  __asm__ ("ld1 {%0.4h}, %1"
+	   : "=w"(result)
+	   : "Utv"(({const int16x4_t *_a = (int16x4_t *) a; *_a;}))
+	   : /* No clobbers */);
+  return result;
+}
+
+__extension__ static __inline int32x2_t __attribute__ ((__always_inline__))
+vld1_s32 (const int32_t * a)
+{
+  int32x2_t result;
+  __asm__ ("ld1 {%0.2s}, %1"
+	   : "=w"(result)
+	   : "Utv"(({const int32x2_t *_a = (int32x2_t *) a; *_a;}))
+	   : /* No clobbers */);
+  return result;
+}
+
+__extension__ static __inline int64x1_t __attribute__ ((__always_inline__))
+vld1_s64 (const int64_t * a)
+{
+  int64x1_t result;
+  __asm__ ("ld1 {%0.1d}, %1"
+	   : "=w"(result)
+	   : "Utv"(*a)
+	   : /* No clobbers */);
+  return result;
+}
+
+__extension__ static __inline uint8x8_t __attribute__ ((__always_inline__))
+vld1_u8 (const uint8_t * a)
+{
+  uint8x8_t result;
+  __asm__ ("ld1 {%0.8b}, %1"
+	   : "=w"(result)
+	   : "Utv"(({const uint8x8_t *_a = (uint8x8_t *) a; *_a;}))
+	   : /* No clobbers */);
+  return result;
+}
+
+__extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))
+vld1_u16 (const uint16_t * a)
+{
+  uint16x4_t result;
+  __asm__ ("ld1 {%0.4h}, %1"
+	   : "=w"(result)
+	   : "Utv"(({const uint16x4_t *_a = (uint16x4_t *) a; *_a;}))
+	   : /* No clobbers */);
+  return result;
+}
+
+__extension__ static __inline uint32x2_t __attribute__ ((__always_inline__))
+vld1_u32 (const uint32_t * a)
+{
+  uint32x2_t result;
+  __asm__ ("ld1 {%0.2s}, %1"
+	   : "=w"(result)
+	   : "Utv"(({const uint32x2_t *_a = (uint32x2_t *) a; *_a;}))
+	   : /* No clobbers */);
+  return result;
+}
+
+__extension__ static __inline uint64x1_t __attribute__ ((__always_inline__))
+vld1_u64 (const uint64_t * a)
+{
+  uint64x1_t result;
+  __asm__ ("ld1 {%0.1d}, %1"
+	   : "=w"(result)
+	   : "Utv"(*a)
+	   : /* No clobbers */);
+  return result;
+}
+
 __extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
 vld1q_dup_f32 (const float32_t * a)
 {
@@ -8806,6 +8938,28 @@ vld1q_dup_u64 (const uint64_t * a)
   return result;
 }
 
+__extension__ static __inline float32x4_t __attribute__ ((__always_inline__))
+vld1q_f32 (const float32_t * a)
+{
+  float32x4_t result;
+  __asm__ ("ld1 {%0.4s}, %1"
+	   : "=w"(result)
+	   : "Utv"(({const float32x4_t *_a = (float32x4_t *) a; *_a;}))
+	   : /* No clobbers */);
+  return result;
+}
+
+__extension__ static __inline float64x2_t __attribute__ ((__always_inline__))
+vld1q_f64 (const float64_t * a)
+{
+  float64x2_t result;
+  __asm__ ("ld1 {%0.2d}, %1"
+	   : "=w"(result)
+	   : "Utv"(({const float64x2_t *_a = (float64x2_t *) a; *_a;}))
+	   : /* No clobbers */);
+  return result;
+}
+
 #define vld1q_lane_f32(a, b, c)                                         \
   __extension__                                                         \
     ({                                                                  \
@@ -8962,6 +9116,116 @@ vld1q_dup_u64 (const uint64_t * a)
        result;                                                          \
      })
 
+__extension__ static __inline poly8x16_t __attribute__ ((__always_inline__))
+vld1q_p8 (const poly8_t * a)
+{
+  poly8x16_t result;
+  __asm__ ("ld1 {%0.16b}, %1"
+	   : "=w"(result)
+	   : "Utv"(({const poly8x16_t *_a = (poly8x16_t *) a; *_a;}))
+	   : /* No clobbers */);
+  return result;
+}
+
+__extension__ static __inline poly16x8_t __attribute__ ((__always_inline__))
+vld1q_p16 (const poly16_t * a)
+{
+  poly16x8_t result;
+  __asm__ ("ld1 {%0.16b}, %1"
+	   : "=w"(result)
+	   : "Utv"(({const poly16x8_t *_a = (poly16x8_t *) a; *_a;}))
+	   : /* No clobbers */);
+  return result;
+}
+
+__extension__ static __inline int8x16_t __attribute__ ((__always_inline__))
+vld1q_s8 (const int8_t * a)
+{
+  int8x16_t result;
+  __asm__ ("ld1 {%0.16b}, %1"
+	   : "=w"(result)
+	   : "Utv"(({const int8x16_t *_a = (int8x16_t *) a; *_a;}))
+	   : /* No clobbers */);
+  return result;
+}
+
+__extension__ static __inline int16x8_t __attribute__ ((__always_inline__))
+vld1q_s16 (const int16_t * a)
+{
+  int16x8_t result;
+  __asm__ ("ld1 {%0.8h}, %1"
+	   : "=w"(result)
+	   : "Utv"(({const int16x8_t *_a = (int16x8_t *) a; *_a;}))
+	   : /* No clobbers */);
+  return result;
+}
+
+__extension__ static __inline int32x4_t __attribute__ ((__always_inline__))
+vld1q_s32 (const int32_t * a)
+{
+  int32x4_t result;
+  __asm__ ("ld1 {%0.4s}, %1"
+	   : "=w"(result)
+	   : "Utv"(({const int32x4_t *_a = (int32x4_t *) a; *_a;}))
+	   : /* No clobbers */);
+  return result;
+}
+
+__extension__ static __inline int64x2_t __attribute__ ((__always_inline__))
+vld1q_s64 (const int64_t * a)
+{
+  int64x2_t result;
+  __asm__ ("ld1 {%0.2d}, %1"
+	   : "=w"(result)
+	   : "Utv"(({const int64x2_t *_a = (int64x2_t *) a; *_a;}))
+	   : /* No clobbers */);
+  return result;
+}
+
+__extension__ static __inline uint8x16_t __attribute__ ((__always_inline__))
+vld1q_u8 (const uint8_t * a)
+{
+  uint8x16_t result;
+  __asm__ ("ld1 {%0.16b}, %1"
+	   : "=w"(result)
+	   : "Utv"(({const uint8x16_t *_a = (uint8x16_t *) a; *_a;}))
+	   : /* No clobbers */);
+  return result;
+}
+
+__extension__ static __inline uint16x8_t __attribute__ ((__always_inline__))
+vld1q_u16 (const uint16_t * a)
+{
+  uint16x8_t result;
+  __asm__ ("ld1 {%0.8h}, %1"
+	   : "=w"(result)
+	   : "Utv"(({const uint16x8_t *_a = (uint16x8_t *) a; *_a;}))
+	   : /* No clobbers */);
+  return result;
+}
+
+__extension__ static __inline uint32x4_t __attribute__ ((__always_inline__))
+vld1q_u32 (const uint32_t * a)
+{
+  uint32x4_t result;
+  __asm__ ("ld1 {%0.4s}, %1"
+	   : "=w"(result)
+	   : "Utv"(({const uint32x4_t *_a = (uint32x4_t *) a; *_a;}))
+	   : /* No clobbers */);
+  return result;
+}
+
+__extension__ static __inline uint64x2_t __attribute__ ((__always_inline__))
+vld1q_u64 (const uint64_t * a)
+{
+  uint64x2_t result;
+  __asm__ ("ld1 {%0.2d}, %1"
+	   : "=w"(result)
+	   : "Utv"(({const uint64x2_t *_a = (uint64x2_t *) a; *_a;}))
+	   : /* No clobbers */);
+  return result;
+}
+
 __extension__ static __inline float32x2_t __attribute__ ((__always_inline__))
 vmaxnm_f32 (float32x2_t a, float32x2_t b)
 {
diff --git a/gcc/config/arm/arm.md b/gcc/config/arm/arm.md
index da7415f..b582d96 100644
--- a/gcc/config/arm/arm.md
+++ b/gcc/config/arm/arm.md
@@ -75,6 +75,8 @@
   ]
 )
 
+;; UNSPEC_VOLATILE Usage:
+
 
 ;;---------------------------------------------------------------------------
 ;; Attributes
diff --git a/gcc/config/arm/linux-eabi.h b/gcc/config/arm/linux-eabi.h
index 6afbf1f..6d9611a 100644
--- a/gcc/config/arm/linux-eabi.h
+++ b/gcc/config/arm/linux-eabi.h
@@ -68,8 +68,9 @@
    GLIBC_DYNAMIC_LINKER_DEFAULT and TARGET_DEFAULT_FLOAT_ABI.  */
 
 #undef  GLIBC_DYNAMIC_LINKER
-#define GLIBC_DYNAMIC_LINKER_SOFT_FLOAT "/lib/ld-linux.so.3"
-#define GLIBC_DYNAMIC_LINKER_HARD_FLOAT "/lib/ld-linux-armhf.so.3"
+
+#define GLIBC_DYNAMIC_LINKER_SOFT_FLOAT RUNTIME_ROOT_PREFIX "/lib/ld-linux.so.3"
+#define GLIBC_DYNAMIC_LINKER_HARD_FLOAT RUNTIME_ROOT_PREFIX "/lib/ld-linux-armhf.so.3"
 #define GLIBC_DYNAMIC_LINKER_DEFAULT GLIBC_DYNAMIC_LINKER_SOFT_FLOAT
 
 #define GLIBC_DYNAMIC_LINKER \
diff --git a/gcc/config/arm/linux-elf.h b/gcc/config/arm/linux-elf.h
index 488efa4..fead0c0 100644
--- a/gcc/config/arm/linux-elf.h
+++ b/gcc/config/arm/linux-elf.h
@@ -57,7 +57,7 @@
 
 #define LIBGCC_SPEC "%{mfloat-abi=soft*:-lfloat} -lgcc"
 
-#define GLIBC_DYNAMIC_LINKER "/lib/ld-linux.so.2"
+#define GLIBC_DYNAMIC_LINKER RUNTIME_ROOT_PREFIX "/lib/ld-linux.so.2"
 
 #define LINUX_TARGET_LINK_SPEC  "%{h*} \
    %{static:-Bstatic} \
diff --git a/gcc/config/arm/linux-grte.h b/gcc/config/arm/linux-grte.h
new file mode 100644
index 0000000..7ee5806
--- /dev/null
+++ b/gcc/config/arm/linux-grte.h
@@ -0,0 +1,27 @@
+/* Definitions for ARM Linux-based GRTE (Google RunTime Environment).
+   Copyright (C) 2011 Free Software Foundation, Inc.
+   Contributed by Chris Demetriou.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#undef SUBSUBTARGET_EXTRA_SPECS
+#define SUBSUBTARGET_EXTRA_SPECS LINUX_GRTE_EXTRA_SPECS
diff --git a/gcc/config/arm/unspecs.md b/gcc/config/arm/unspecs.md
index c43a6a6..4d84a11 100644
--- a/gcc/config/arm/unspecs.md
+++ b/gcc/config/arm/unspecs.md
@@ -24,6 +24,12 @@
 ;; Unspec enumerators for iwmmxt2 are defined in iwmmxt2.md
 
 (define_c_enum "unspec" [
+  UNSPEC_SIN            ; `sin' operation (MODE_FLOAT):
+                        ;   operand 0 is the result,
+                        ;   operand 1 the parameter.
+  UNPSEC_COS            ; `cos' operation (MODE_FLOAT):
+                        ;   operand 0 is the result,
+                        ;   operand 1 the parameter.
   UNSPEC_PUSH_MULT      ; `push multiple' operation:
                         ;   operand 0 is the first register,
                         ;   subsequent registers are in parallel (use ...)
@@ -51,6 +57,8 @@
   UNSPEC_WMACU          ; Used by the intrinsic form of the iWMMXt WMACU instruction.
   UNSPEC_WMACSZ         ; Used by the intrinsic form of the iWMMXt WMACSZ instruction.
   UNSPEC_WMACUZ         ; Used by the intrinsic form of the iWMMXt WMACUZ instruction.
+  UNSPEC_WMADDS         ; Used by the intrinsic form of the iWMMXt WMADDS instruction.
+  UNSPEC_WMADDU         ; Used by the intrinsic form of the iWMMXt WMADDU instruction.
   UNSPEC_CLRDI          ; Used by the intrinsic form of the iWMMXt CLRDI instruction.
   UNSPEC_WALIGNI        ; Used by the intrinsic form of the iWMMXt WALIGN instruction.
   UNSPEC_TLS            ; A symbol that has been treated properly for TLS usage.
@@ -58,6 +66,7 @@
                         ; instruction stream.
   UNSPEC_PIC_OFFSET     ; A symbolic 12-bit OFFSET that has been treated
                         ; correctly for PIC usage.
+  UNSPEC_GOT_PREL_SYM   ; Specify an R_ARM_GOT_PREL relocation of a symbol.			
   UNSPEC_GOTSYM_OFF     ; The offset of the start of the GOT from a
                         ; a given symbolic address.
   UNSPEC_THUMB1_CASESI  ; A Thumb1 compressed dispatch-table call.
@@ -70,6 +79,11 @@
 			; that.
   UNSPEC_UNALIGNED_STORE ; Same for str/strh.
   UNSPEC_PIC_UNIFIED    ; Create a common pic addressing form.
+  UNSPEC_PROLOGUE_USE   ; As USE insns are not meaningful after reload,
+                        ; this unspec is used to prevent the deletion of
+                        ; instructions setting registers for EH handling
+                        ; and stack frame generation.  Operand 0 is the
+                        ; register to "use".
   UNSPEC_LL		; Represent an unpaired load-register-exclusive.
   UNSPEC_VRINTZ         ; Represent a float to integral float rounding
                         ; towards zero.
diff --git a/gcc/config/i386/ammintrin.h b/gcc/config/i386/ammintrin.h
index 311292c..297b98d 100644
--- a/gcc/config/i386/ammintrin.h
+++ b/gcc/config/i386/ammintrin.h
@@ -27,13 +27,15 @@
 #ifndef _AMMINTRIN_H_INCLUDED
 #define _AMMINTRIN_H_INCLUDED
 
-#ifndef __SSE4A__
-# error "SSE4A instruction set not enabled"
-#else
-
 /* We need definitions from the SSE3, SSE2 and SSE header files*/
 #include <pmmintrin.h>
 
+#ifndef __SSE4A__
+#pragma GCC push_options
+#pragma GCC target("sse4a")
+#define __DISABLE_SSE4A__
+#endif /* __SSE4A__ */
+
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_stream_sd (double * __P, __m128d __Y)
 {
@@ -83,6 +85,9 @@ _mm_inserti_si64(__m128i __X, __m128i __Y, unsigned const int __I, unsigned cons
 				      (unsigned int)(I), (unsigned int)(L)))
 #endif
 
-#endif /* __SSE4A__ */
+#ifdef __DISABLE_SSE4A__
+#undef __DISABLE_SSE4A__
+#pragma GCC pop_options
+#endif /* __DISABLE_SSE4A__ */
 
 #endif /* _AMMINTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/avx2intrin.h b/gcc/config/i386/avx2intrin.h
index 1537bf5..4030dfe 100644
--- a/gcc/config/i386/avx2intrin.h
+++ b/gcc/config/i386/avx2intrin.h
@@ -25,6 +25,15 @@
 # error "Never use <avx2intrin.h> directly; include <immintrin.h> instead."
 #endif
 
+#ifndef _AVX2INTRIN_H_INCLUDED
+#define _AVX2INTRIN_H_INCLUDED
+
+#ifndef __AVX2__
+#pragma GCC push_options
+#pragma GCC target("avx2")
+#define __DISABLE_AVX2__
+#endif /* __AVX2__ */
+
 /* Sum absolute 8-bit integer difference of adjacent groups of 4
    byte integers in the first 2 operands.  Starting offsets within
    operands are determined by the 3rd mask operand.  */
@@ -1871,3 +1880,10 @@ _mm256_mask_i64gather_epi32 (__m128i src, int const *base,
 					   (__v4si)(__m128i)MASK,  \
 					   (int)SCALE)
 #endif  /* __OPTIMIZE__ */
+
+#ifdef __DISABLE_AVX2__
+#undef __DISABLE_AVX2__
+#pragma GCC pop_options
+#endif /* __DISABLE_AVX2__ */
+
+#endif /* _AVX2INTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/avxintrin.h b/gcc/config/i386/avxintrin.h
index b75de45..7f2109a 100644
--- a/gcc/config/i386/avxintrin.h
+++ b/gcc/config/i386/avxintrin.h
@@ -28,6 +28,15 @@
 # error "Never use <avxintrin.h> directly; include <immintrin.h> instead."
 #endif
 
+#ifndef _AVXINTRIN_H_INCLUDED
+#define _AVXINTRIN_H_INCLUDED
+
+#ifndef __AVX__
+#pragma GCC push_options
+#pragma GCC target("avx")
+#define __DISABLE_AVX__
+#endif /* __AVX__ */
+
 /* Internal data types for implementing the intrinsics.  */
 typedef double __v4df __attribute__ ((__vector_size__ (32)));
 typedef float __v8sf __attribute__ ((__vector_size__ (32)));
@@ -1424,3 +1433,10 @@ _mm256_castsi128_si256 (__m128i __A)
 {
   return (__m256i) __builtin_ia32_si256_si ((__v4si)__A);
 }
+
+#ifdef __DISABLE_AVX__
+#undef __DISABLE_AVX__
+#pragma GCC pop_options
+#endif /* __DISABLE_AVX__ */
+
+#endif /* _AVXINTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/bmi2intrin.h b/gcc/config/i386/bmi2intrin.h
index 929ea20..0c6cb96 100644
--- a/gcc/config/i386/bmi2intrin.h
+++ b/gcc/config/i386/bmi2intrin.h
@@ -25,13 +25,15 @@
 # error "Never use <bmi2intrin.h> directly; include <x86intrin.h> instead."
 #endif
 
-#ifndef __BMI2__
-# error "BMI2 instruction set not enabled"
-#endif /* __BMI2__ */
-
 #ifndef _BMI2INTRIN_H_INCLUDED
 #define _BMI2INTRIN_H_INCLUDED
 
+#ifndef __BMI2__
+#pragma GCC push_options
+#pragma GCC target("bmi2")
+#define __DISABLE_BMI2__
+#endif /* __BMI2__ */
+
 extern __inline unsigned int
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _bzhi_u32 (unsigned int __X, unsigned int __Y)
@@ -99,4 +101,9 @@ _mulx_u32 (unsigned int __X, unsigned int __Y, unsigned int *__P)
 
 #endif /* !__x86_64__  */
 
+#ifdef __DISABLE_BMI2__
+#undef __DISABLE_BMI2__
+#pragma GCC pop_options
+#endif /* __DISABLE_BMI2__ */
+
 #endif /* _BMI2INTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/bmiintrin.h b/gcc/config/i386/bmiintrin.h
index fc7f2ec..2323334 100644
--- a/gcc/config/i386/bmiintrin.h
+++ b/gcc/config/i386/bmiintrin.h
@@ -25,13 +25,15 @@
 # error "Never use <bmiintrin.h> directly; include <x86intrin.h> instead."
 #endif
 
-#ifndef __BMI__
-# error "BMI instruction set not enabled"
-#endif /* __BMI__ */
-
 #ifndef _BMIINTRIN_H_INCLUDED
 #define _BMIINTRIN_H_INCLUDED
 
+#ifndef __BMI__
+#pragma GCC push_options
+#pragma GCC target("bmi")
+#define __DISABLE_BMI__
+#endif /* __BMI__ */
+
 extern __inline unsigned short __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 __tzcnt_u16 (unsigned short __X)
 {
@@ -174,4 +176,9 @@ _tzcnt_u64 (unsigned long long __X)
 
 #endif /* __x86_64__  */
 
+#ifdef __DISABLE_BMI__
+#undef __DISABLE_BMI__
+#pragma GCC pop_options
+#endif /* __DISABLE_BMI__ */
+
 #endif /* _BMIINTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/emmintrin.h b/gcc/config/i386/emmintrin.h
index cf404a1..c30f056 100644
--- a/gcc/config/i386/emmintrin.h
+++ b/gcc/config/i386/emmintrin.h
@@ -27,13 +27,15 @@
 #ifndef _EMMINTRIN_H_INCLUDED
 #define _EMMINTRIN_H_INCLUDED
 
-#ifndef __SSE2__
-# error "SSE2 instruction set not enabled"
-#else
-
 /* We need definitions from the SSE header files*/
 #include <xmmintrin.h>
 
+#ifndef __SSE2__
+#pragma GCC push_options
+#pragma GCC target("sse2")
+#define __DISABLE_SSE2__
+#endif /* __SSE2__ */
+
 /* SSE2 */
 typedef double __v2df __attribute__ ((__vector_size__ (16)));
 typedef long long __v2di __attribute__ ((__vector_size__ (16)));
@@ -1515,6 +1517,9 @@ _mm_castsi128_pd(__m128i __A)
   return (__m128d) __A;
 }
 
-#endif /* __SSE2__  */
+#ifdef __DISABLE_SSE2__
+#undef __DISABLE_SSE2__
+#pragma GCC pop_options
+#endif /* __DISABLE_SSE2__ */
 
 #endif /* _EMMINTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/f16cintrin.h b/gcc/config/i386/f16cintrin.h
index 88903c1..76f35fa 100644
--- a/gcc/config/i386/f16cintrin.h
+++ b/gcc/config/i386/f16cintrin.h
@@ -25,13 +25,15 @@
 # error "Never use <f16intrin.h> directly; include <x86intrin.h> or <immintrin.h> instead."
 #endif
 
-#ifndef __F16C__
-# error "F16C instruction set not enabled"
-#else
-
 #ifndef _F16CINTRIN_H_INCLUDED
 #define _F16CINTRIN_H_INCLUDED
 
+#ifndef __F16C__
+#pragma GCC push_options
+#pragma GCC target("f16c")
+#define __DISABLE_F16C__
+#endif /* __F16C__ */
+
 extern __inline float __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _cvtsh_ss (unsigned short __S)
 {
@@ -88,5 +90,9 @@ _mm256_cvtps_ph (__m256 __A, const int __I)
   ((__m128i) __builtin_ia32_vcvtps2ph256 ((__v8sf)(__m256) A, (int) (I)))
 #endif /* __OPTIMIZE */
 
+#ifdef __DISABLE_F16C__
+#undef __DISABLE_F16C__
+#pragma GCC pop_options
+#endif /* __DISABLE_F16C__ */
+
 #endif /* _F16CINTRIN_H_INCLUDED */
-#endif /* __F16C__ */
diff --git a/gcc/config/i386/fma4intrin.h b/gcc/config/i386/fma4intrin.h
index 00ba781..e615f3e 100644
--- a/gcc/config/i386/fma4intrin.h
+++ b/gcc/config/i386/fma4intrin.h
@@ -28,13 +28,15 @@
 #ifndef _FMA4INTRIN_H_INCLUDED
 #define _FMA4INTRIN_H_INCLUDED
 
-#ifndef __FMA4__
-# error "FMA4 instruction set not enabled"
-#else
-
 /* We need definitions from the SSE4A, SSE3, SSE2 and SSE header files.  */
 #include <ammintrin.h>
 
+#ifndef __FMA4__
+#pragma GCC push_options
+#pragma GCC target("fma4")
+#define __DISABLE_FMA4__
+#endif /* __FMA4__ */
+
 /* 128b Floating point multiply/add type instructions.  */
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_macc_ps (__m128 __A, __m128 __B, __m128 __C)
@@ -231,6 +233,9 @@ _mm256_msubadd_pd (__m256d __A, __m256d __B, __m256d __C)
   return (__m256d) __builtin_ia32_vfmaddsubpd256 ((__v4df)__A, (__v4df)__B, -(__v4df)__C);
 }
 
-#endif
+#ifdef __DISABLE_FMA4__
+#undef __DISABLE_FMA4__
+#pragma GCC pop_options
+#endif /* __DISABLE_FMA4__ */
 
 #endif
diff --git a/gcc/config/i386/fmaintrin.h b/gcc/config/i386/fmaintrin.h
index 6ede84b..97de93f 100644
--- a/gcc/config/i386/fmaintrin.h
+++ b/gcc/config/i386/fmaintrin.h
@@ -29,8 +29,10 @@
 #define _FMAINTRIN_H_INCLUDED
 
 #ifndef __FMA__
-# error "FMA instruction set not enabled"
-#else
+#pragma GCC push_options
+#pragma GCC target("fma")
+#define __DISABLE_FMA__
+#endif /* __FMA__ */
 
 extern __inline __m128d
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -292,6 +294,9 @@ _mm256_fmsubadd_ps (__m256 __A, __m256 __B, __m256 __C)
                                                 -(__v8sf)__C);
 }
 
-#endif
+#ifdef __DISABLE_FMA__
+#undef __DISABLE_FMA__
+#pragma GCC pop_options
+#endif /* __DISABLE_FMA__ */
 
 #endif
diff --git a/gcc/config/i386/fxsrintrin.h b/gcc/config/i386/fxsrintrin.h
index 9b63222..41d4085 100644
--- a/gcc/config/i386/fxsrintrin.h
+++ b/gcc/config/i386/fxsrintrin.h
@@ -28,6 +28,12 @@
 #ifndef _FXSRINTRIN_H_INCLUDED
 #define _FXSRINTRIN_H_INCLUDED
 
+#ifndef __FXSR__
+#pragma GCC push_options
+#pragma GCC target("fxsr")
+#define __DISABLE_FXSR__
+#endif /* __FXSR__ */
+
 extern __inline void
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _fxsave (void *__P)
@@ -58,4 +64,10 @@ _fxrstor64 (void *__P)
 }
 #endif
 
+#ifdef __DISABLE_FXSR__
+#undef __DISABLE_FXSR__
+#pragma GCC pop_options
+#endif /* __DISABLE_FXSR__ */
+
+
 #endif /* _FXSRINTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/gnu-user.h b/gcc/config/i386/gnu-user.h
index 2f0a4d7..505fc9b 100644
--- a/gcc/config/i386/gnu-user.h
+++ b/gcc/config/i386/gnu-user.h
@@ -70,10 +70,12 @@ along with GCC; see the file COPYING3.  If not see
   "--32 %{!mno-sse2avx:%{mavx:-msse2avx}} %{msse2avx:%{!mavx:-msse2avx}} " \
   LINUX_OR_ANDROID_CC ("", ANDROID_ASM_SPEC)
 
-#undef  SUBTARGET_EXTRA_SPECS
-#define SUBTARGET_EXTRA_SPECS \
+#undef  SUBTARGET_EXTRA_SPECS_STR
+#define SUBTARGET_EXTRA_SPECS_STR \
   { "link_emulation", GNU_USER_LINK_EMULATION },\
   { "dynamic_linker", GNU_USER_DYNAMIC_LINKER }
+#undef  SUBTARGET_EXTRA_SPECS
+#define SUBTARGET_EXTRA_SPECS SUBTARGET_EXTRA_SPECS_STR
 
 #define GNU_USER_TARGET_LINK_SPEC "-m %(link_emulation) %{shared:-shared} \
   %{!shared: \
diff --git a/gcc/config/i386/i386-c.c b/gcc/config/i386/i386-c.c
index 51fec84..bc3c60f 100644
--- a/gcc/config/i386/i386-c.c
+++ b/gcc/config/i386/i386-c.c
@@ -369,20 +369,23 @@ ix86_pragma_target_parse (tree args, tree pop_target)
 
   if (! args)
     {
-      cur_tree = ((pop_target)
-		  ? pop_target
-		  : target_option_default_node);
+      cur_tree = (pop_target ? pop_target : target_option_default_node);
       cl_target_option_restore (&global_options,
 				TREE_TARGET_OPTION (cur_tree));
     }
   else
     {
       cur_tree = ix86_valid_target_attribute_tree (args);
-      if (!cur_tree)
-	return false;
+      if (!cur_tree || cur_tree == error_mark_node)
+       {
+         cl_target_option_restore (&global_options,
+                                   TREE_TARGET_OPTION (prev_tree));
+         return false;
+       }
     }
 
   target_option_current_node = cur_tree;
+  ix86_reset_previous_fndecl ();
 
   /* Figure out the previous/current isa, arch, tune and the differences.  */
   prev_opt  = TREE_TARGET_OPTION (prev_tree);
diff --git a/gcc/config/i386/i386-protos.h b/gcc/config/i386/i386-protos.h
index 602e6fc..d06a95d 100644
--- a/gcc/config/i386/i386-protos.h
+++ b/gcc/config/i386/i386-protos.h
@@ -28,6 +28,16 @@ extern bool ix86_target_stack_probe (void);
 extern bool ix86_can_use_return_insn_p (void);
 extern void ix86_setup_frame_addresses (void);
 
+/* Section names for function patch prologue and epilogue section. See
+   ix86_output_function_nops_prologue_epilogue() in i386.c for details.  */
+#define FUNCTION_PATCH_PROLOGUE_SECTION "_function_patch_prologue"
+#define FUNCTION_PATCH_EPILOGUE_SECTION "_function_patch_epilogue"
+
+extern bool ix86_output_function_nops_prologue_epilogue (FILE *,
+                                                         const char *,
+                                                         const char *,
+                                                         int);
+
 extern HOST_WIDE_INT ix86_initial_elimination_offset (int, int);
 extern void ix86_expand_prologue (void);
 extern void ix86_maybe_emit_epilogue_vzeroupper (void);
@@ -40,6 +50,8 @@ extern void ix86_output_addr_diff_elt (FILE *, int, int);
 extern enum calling_abi ix86_cfun_abi (void);
 extern enum calling_abi ix86_function_type_abi (const_tree);
 
+extern void ix86_reset_previous_fndecl (void);
+
 #ifdef RTX_CODE
 extern int standard_80387_constant_p (rtx);
 extern const char *standard_80387_constant_opcode (rtx);
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index 954fc25..3781289 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -62,6 +62,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "dumpfile.h"
 #include "tree-pass.h"
 #include "tree-flow.h"
+#include "cfgloop.h"
 
 static rtx legitimize_dllimport_symbol (rtx, bool);
 
@@ -2482,7 +2483,7 @@ static const char *const cpu_names[TARGET_CPU_DEFAULT_max] =
 static bool
 gate_insert_vzeroupper (void)
 {
-  return TARGET_VZEROUPPER;
+  return TARGET_AVX && TARGET_VZEROUPPER;
 }
 
 static unsigned int
@@ -3838,34 +3839,26 @@ ix86_option_override_internal (bool main_args_p)
 #endif
    }
 
-  if (TARGET_AVX)
-    {
-      /* When not optimize for size, enable vzeroupper optimization for
-	 TARGET_AVX with -fexpensive-optimizations and split 32-byte
-	 AVX unaligned load/store.  */
-      if (!optimize_size)
-	{
-	  if (flag_expensive_optimizations
-	      && !(target_flags_explicit & MASK_VZEROUPPER))
-	    target_flags |= MASK_VZEROUPPER;
-	  if ((x86_avx256_split_unaligned_load & ix86_tune_mask)
-	      && !(target_flags_explicit & MASK_AVX256_SPLIT_UNALIGNED_LOAD))
-	    target_flags |= MASK_AVX256_SPLIT_UNALIGNED_LOAD;
-	  if ((x86_avx256_split_unaligned_store & ix86_tune_mask)
-	      && !(target_flags_explicit & MASK_AVX256_SPLIT_UNALIGNED_STORE))
-	    target_flags |= MASK_AVX256_SPLIT_UNALIGNED_STORE;
-	  /* Enable 128-bit AVX instruction generation
-	     for the auto-vectorizer.  */
-	  if (TARGET_AVX128_OPTIMAL
-	      && !(target_flags_explicit & MASK_PREFER_AVX128))
-	    target_flags |= MASK_PREFER_AVX128;
-	}
-    }
-  else
-    {
-      /* Disable vzeroupper pass if TARGET_AVX is disabled.  */
-      target_flags &= ~MASK_VZEROUPPER;
-    }
+  /* When not optimize for size, enable vzeroupper optimization for
+     TARGET_AVX with -fexpensive-optimizations and split 32-byte
+     AVX unaligned load/store.  */
+  if (!optimize_size)
+  {
+     if (flag_expensive_optimizations
+	   && !(target_flags_explicit & MASK_VZEROUPPER))
+	target_flags |= MASK_VZEROUPPER;
+     if ((x86_avx256_split_unaligned_load & ix86_tune_mask)
+	   && !(target_flags_explicit & MASK_AVX256_SPLIT_UNALIGNED_LOAD))
+	target_flags |= MASK_AVX256_SPLIT_UNALIGNED_LOAD;
+     if ((x86_avx256_split_unaligned_store & ix86_tune_mask)
+	   && !(target_flags_explicit & MASK_AVX256_SPLIT_UNALIGNED_STORE))
+	target_flags |= MASK_AVX256_SPLIT_UNALIGNED_STORE;
+     /* Enable 128-bit AVX instruction generation
+	for the auto-vectorizer.  */
+     if (TARGET_AVX128_OPTIMAL
+	   && !(target_flags_explicit & MASK_PREFER_AVX128))
+	target_flags |= MASK_PREFER_AVX128;
+  }
 
   if (ix86_recip_name)
     {
@@ -4547,6 +4540,13 @@ ix86_can_inline_p (tree caller, tree callee)
 /* Remember the last target of ix86_set_current_function.  */
 static GTY(()) tree ix86_previous_fndecl;
 
+/* Invalidate ix86_previous_fndecl cache.  */
+void
+ix86_reset_previous_fndecl (void)
+{
+  ix86_previous_fndecl = NULL_TREE;
+}
+
 /* Establish appropriate back-end context for processing the function
    FNDECL.  The argument might be NULL to indicate processing at top
    level, outside of any function scope.  */
@@ -11166,6 +11166,246 @@ ix86_expand_epilogue (int style)
   m->fs = frame_state_save;
 }
 
+
+/* True if the current function should be patched with nops at prologue and
+   returns.  */
+static bool patch_current_function_p = false;
+
+static inline bool
+has_attribute (const char* attribute_name)
+{
+  return lookup_attribute (attribute_name,
+                           DECL_ATTRIBUTES (current_function_decl)) != NULL;
+}
+
+/* Return true if we patch the current function. By default a function
+   is patched if it has loops or if the number of insns is greater than
+   patch_functions_min_instructions (number of insns roughly translates
+   to number of instructions).  */
+
+static bool
+check_should_patch_current_function (void)
+{
+  int num_insns = 0;
+  rtx insn;
+  const char *func_name = NULL;
+  struct loops *loops;
+  int num_loops = 0;
+  int min_functions_instructions;
+
+  /* If a function has an attribute forcing patching on or off, do as it
+     indicates.  */
+  if (has_attribute ("always_patch_for_instrumentation"))
+    return true;
+  else if (has_attribute ("never_patch_for_instrumentation"))
+    return false;
+
+  /* Patch the function if it has at least a loop.  */
+  if (!patch_functions_ignore_loops)
+    {
+      if (DECL_STRUCT_FUNCTION (current_function_decl)->cfg)
+        {
+          loops = flow_loops_find (NULL);
+          num_loops = loops->larray->length();
+          /* FIXME - Deallocating the loop causes a seg-fault.  */
+#if 0
+          flow_loops_free (loops);
+#endif
+          /* We are not concerned with the function body as a loop.  */
+          if (num_loops > 1)
+            return true;
+        }
+    }
+
+  /* Else, check if function has more than patch_functions_min_instrctions.  */
+
+  /* Borrowed this code from rest_of_handle_final() in final.c.  */
+  func_name = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);
+  if (!patch_functions_dont_always_patch_main &&
+      func_name &&
+      strcmp("main", func_name) == 0)
+    return true;
+
+  min_functions_instructions =
+      PARAM_VALUE (PARAM_FUNCTION_PATCH_MIN_INSTRUCTIONS);
+  if (min_functions_instructions > 0)
+    {
+      /* Calculate the number of instructions in this function and only emit
+         function patch for instrumentation if it is greater than
+         patch_functions_min_instructions.  */
+      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))
+        {
+          if (NONDEBUG_INSN_P (insn))
+            ++num_insns;
+        }
+      if (num_insns < min_functions_instructions)
+        return false;
+    }
+
+  return true;
+}
+
+/* Emit the 11-byte patch space for the function prologue for functions that
+   qualify.  */
+
+static void
+ix86_output_function_prologue (FILE *file,
+                               HOST_WIDE_INT size ATTRIBUTE_UNUSED)
+{
+  /* Only for 64-bit target.  */
+  if (TARGET_64BIT && patch_functions_for_instrumentation)
+    {
+      patch_current_function_p = check_should_patch_current_function();
+      /* Emit the instruction 'jmp 09' followed by 9 bytes to make it 11-bytes
+         of nop.  */
+      ix86_output_function_nops_prologue_epilogue (
+          file,
+          FUNCTION_PATCH_PROLOGUE_SECTION,
+          ASM_BYTE"0xeb,0x09",
+          9);
+    }
+}
+
+/* Emit the nop bytes at function prologue or return (including tail call
+   jumps). The number of nop bytes generated is at least 8.
+   Also emits a section named SECTION_NAME, which is a backpointer section
+   holding the addresses of the nop bytes in the text section.
+   SECTION_NAME is either '_function_patch_prologue' or
+   '_function_patch_epilogue'. The backpointer section can be used to navigate
+   through all the function entry and exit points which are patched with nops.
+   PRE_INSTRUCTIONS are the instructions, if any, at the start of the nop byte
+   sequence. NUM_REMAINING_NOPS are the number of nop bytes to fill,
+   excluding the number of bytes in PRE_INSTRUCTIONS.
+   Returns true if the function was patched, false otherwise.  */
+
+bool
+ix86_output_function_nops_prologue_epilogue (FILE *file,
+                                             const char *section_name,
+                                             const char *pre_instructions,
+                                             int num_remaining_nops)
+{
+  static int labelno = 0;
+  char label[32], section_label[32];
+  section *section = NULL;
+  int num_actual_nops = num_remaining_nops - sizeof(void *);
+  unsigned int section_flags = SECTION_RELRO;
+  char *section_name_comdat = NULL;
+  const char *decl_section_name = NULL;
+  const char *func_name = NULL;
+  char *section_name_function_sections = NULL;
+  size_t len;
+
+  gcc_assert (num_remaining_nops >= 0);
+
+  if (!patch_current_function_p)
+    return false;
+
+  ASM_GENERATE_INTERNAL_LABEL (label, "LFPEL", labelno);
+  ASM_GENERATE_INTERNAL_LABEL (section_label, "LFPESL", labelno++);
+
+  /* Align the start of nops to 2-byte boundary so that the 2-byte jump
+     instruction can be patched atomically at run time.  */
+  ASM_OUTPUT_ALIGN (file, 1);
+
+  /* Emit nop bytes. They look like the following:
+       $LFPEL0:
+         <pre_instruction>
+         0x90 (repeated num_actual_nops times)
+         .quad $LFPESL0 - .
+     followed by section 'section_name' which contains the address
+     of instruction at 'label'.
+   */
+  ASM_OUTPUT_INTERNAL_LABEL (file, label);
+  if (pre_instructions)
+    fprintf (file, "%s\n", pre_instructions);
+
+  while (num_actual_nops-- > 0)
+    asm_fprintf (file, ASM_BYTE"0x90\n");
+
+  fprintf (file, ASM_QUAD);
+  /* Output "section_label - ." for the relative address of the entry in
+     the section 'section_name'.  */
+  assemble_name_raw (file, section_label);
+  fprintf (file, " - .");
+  fprintf (file, "\n");
+
+  /* Emit the backpointer section. For functions belonging to comdat group,
+     we emit a different section named '<section_name>.foo' where 'foo' is
+     the name of the comdat section. This section is later renamed to
+     '<section_name>' by ix86_elf_asm_named_section().
+     We emit a unique section name for the back pointer section for comdat
+     functions because otherwise the 'get_section' call may return an existing
+     non-comdat section with the same name, leading to references from
+     non-comdat section to comdat functions.
+  */
+  if (current_function_decl != NULL_TREE &&
+      DECL_ONE_ONLY (current_function_decl) &&
+      HAVE_COMDAT_GROUP)
+    {
+      decl_section_name =
+          TREE_STRING_POINTER (DECL_SECTION_NAME (current_function_decl));
+      len = strlen (decl_section_name) + strlen (section_name) + 2;
+      section_name_comdat = (char *) alloca (len);
+      sprintf (section_name_comdat, "%s.%s", section_name, decl_section_name);
+      section_name = section_name_comdat;
+      section_flags |= SECTION_LINKONCE;
+    }
+  else if (flag_function_sections)
+    {
+      func_name = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);
+      if (func_name)
+        {
+          len = strlen (func_name) + strlen (section_name) + 2;
+          section_name_function_sections = (char *) alloca (len);
+          sprintf (section_name_function_sections, "%s.%s", section_name,
+                   func_name);
+          section_name = section_name_function_sections;
+        }
+    }
+  section = get_section (section_name, section_flags, current_function_decl);
+  switch_to_section (section);
+  /* Align the section to 8-byte boundary.  */
+  ASM_OUTPUT_ALIGN (file, 3);
+
+  /* Emit address of the start of nop bytes in the section:
+       $LFPESP0:
+         .quad $LFPEL0
+   */
+  ASM_OUTPUT_INTERNAL_LABEL (file, section_label);
+  fprintf(file, ASM_QUAD);
+  assemble_name_raw (file, label);
+  fprintf (file, "\n");
+
+  /* Switching back to text section.  */
+  switch_to_section (function_section (current_function_decl));
+  return true;
+}
+
+/* Strips the characters after '_function_patch_prologue' or
+   '_function_patch_epilogue' and emits the section.  */
+
+static void
+ix86_elf_asm_named_section (const char *name, unsigned int flags,
+                            tree decl)
+{
+  const char *section_name = name;
+  if (!flag_function_sections && HAVE_COMDAT_GROUP && flags & SECTION_LINKONCE)
+    {
+      const int prologue_section_name_length =
+          sizeof(FUNCTION_PATCH_PROLOGUE_SECTION) - 1;
+      const int epilogue_section_name_length =
+          sizeof(FUNCTION_PATCH_EPILOGUE_SECTION) - 1;
+
+      if (strncmp (name, FUNCTION_PATCH_PROLOGUE_SECTION,
+                   prologue_section_name_length) == 0)
+        section_name = FUNCTION_PATCH_PROLOGUE_SECTION;
+      else if (strncmp (name, FUNCTION_PATCH_EPILOGUE_SECTION,
+                        epilogue_section_name_length) == 0)
+        section_name = FUNCTION_PATCH_EPILOGUE_SECTION;
+    }
+  default_elf_asm_named_section (section_name, flags, decl);
+}
+
 /* Reset from the function's potential modifications.  */
 
 static void
@@ -23709,6 +23949,15 @@ ix86_output_call_insn (rtx insn, rtx call_op)
       else
 	xasm = "jmp\t%A0";
 
+      /* Just before the sibling call, add 11-bytes of nops to patch function
+         exit: 2 bytes for 'jmp 09' and remaining 9 bytes.  */
+      if (TARGET_64BIT && patch_functions_for_instrumentation)
+        ix86_output_function_nops_prologue_epilogue (
+            asm_out_file,
+            FUNCTION_PATCH_EPILOGUE_SECTION,
+            ASM_BYTE"0xeb, 0x09",
+            9);
+
       output_asm_insn (xasm, &call_op);
       return "";
     }
@@ -26710,7 +26959,8 @@ def_builtin (HOST_WIDE_INT mask, const char *name,
       ix86_builtins_isa[(int) code].isa = mask;
 
       mask &= ~OPTION_MASK_ISA_64BIT;
-      if (mask == 0
+      if (flag_dyn_ipa
+	  || mask == 0
 	  || (mask & ix86_isa_flags) != 0
 	  || (lang_hooks.builtin_function
 	      == lang_hooks.builtin_function_ext_scope))
@@ -42289,9 +42539,15 @@ ix86_memmodel_check (unsigned HOST_WIDE_INT val)
 #undef TARGET_BUILTIN_RECIPROCAL
 #define TARGET_BUILTIN_RECIPROCAL ix86_builtin_reciprocal
 
+#undef TARGET_ASM_FUNCTION_PROLOGUE
+#define TARGET_ASM_FUNCTION_PROLOGUE ix86_output_function_prologue
+
 #undef TARGET_ASM_FUNCTION_EPILOGUE
 #define TARGET_ASM_FUNCTION_EPILOGUE ix86_output_function_epilogue
 
+#undef TARGET_ASM_NAMED_SECTION
+#define TARGET_ASM_NAMED_SECTION ix86_elf_asm_named_section
+
 #undef TARGET_ENCODE_SECTION_INFO
 #ifndef SUBTARGET_ENCODE_SECTION_INFO
 #define TARGET_ENCODE_SECTION_INFO ix86_encode_section_info
diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
index 57e0dca..99b5442 100644
--- a/gcc/config/i386/i386.md
+++ b/gcc/config/i386/i386.md
@@ -11713,7 +11713,18 @@
 (define_insn "simple_return_internal"
   [(simple_return)]
   "reload_completed"
-  "ret"
+{
+  if (TARGET_64BIT && patch_functions_for_instrumentation)
+    {
+      /* Emit 10 nop bytes after ret.  */
+      if (ix86_output_function_nops_prologue_epilogue (asm_out_file,
+      	 					       FUNCTION_PATCH_EPILOGUE_SECTION,
+						       "\tret",
+						       10))
+	return "";
+    }
+  return "ret";
+}
   [(set_attr "length" "1")
    (set_attr "atom_unit" "jeu")
    (set_attr "length_immediate" "0")
@@ -11726,7 +11737,18 @@
   [(simple_return)
    (unspec [(const_int 0)] UNSPEC_REP)]
   "reload_completed"
-  "rep%; ret"
+{
+  if (TARGET_64BIT && patch_functions_for_instrumentation)
+    {
+      /* Emit 9 nop bytes after rep;ret.  */
+      if (ix86_output_function_nops_prologue_epilogue (asm_out_file,
+						       FUNCTION_PATCH_EPILOGUE_SECTION,
+						       "\trep\;ret",
+						       9))
+	return "";
+    }
+  return "rep\;ret";
+}
   [(set_attr "length" "2")
    (set_attr "atom_unit" "jeu")
    (set_attr "length_immediate" "0")
diff --git a/gcc/config/i386/i386.opt b/gcc/config/i386/i386.opt
index 084a248..b6630a1 100644
--- a/gcc/config/i386/i386.opt
+++ b/gcc/config/i386/i386.opt
@@ -626,3 +626,15 @@ Split 32-byte AVX unaligned store
 mrtm
 Target Report Mask(ISA_RTM) Var(ix86_isa_flags) Save
 Support RTM built-in functions and code generation
+
+mpatch-functions-for-instrumentation
+Target RejectNegative Report Var(patch_functions_for_instrumentation) Save
+Patch function prologue and epilogue with custom NOPs for dynamic instrumentation. By default, functions with loops (controlled by -mpatch-functions-without-loop) or functions having instructions more than -mpatch-functions-min-instructions are patched.
+
+mpatch-functions-ignore-loops
+Target RejectNegative Report Var(patch_functions_ignore_loops) Save
+Ignore loops when deciding whether to patch a function for instrumentation (for use with -mpatch-functions-for-instrumentation).
+
+mno-patch-functions-main-always
+Target Report RejectNegative Var(patch_functions_dont_always_patch_main) Save
+Treat 'main' as any other function and only patch it if it meets the criteria for loops and minimum number of instructions (for use with -mpatch-functions-for-instrumentation).
diff --git a/gcc/config/i386/ia32intrin.h b/gcc/config/i386/ia32intrin.h
index 131af0b..b26dc46 100644
--- a/gcc/config/i386/ia32intrin.h
+++ b/gcc/config/i386/ia32intrin.h
@@ -49,7 +49,12 @@ __bswapd (int __X)
   return __builtin_bswap32 (__X);
 }
 
-#ifdef __SSE4_2__
+#ifndef __SSE4_2__
+#pragma GCC push_options
+#pragma GCC target("sse4.2")
+#define __DISABLE_SSE4_2__
+#endif /* __SSE4_2__ */
+
 /* 32bit accumulate CRC32 (polynomial 0x11EDC6F41) value.  */
 extern __inline unsigned int
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -71,7 +76,11 @@ __crc32d (unsigned int __C, unsigned int __V)
 {
   return __builtin_ia32_crc32si (__C, __V);
 }
-#endif /* SSE4.2 */
+
+#ifdef __DISABLE_SSE4_2__
+#undef __DISABLE_SSE4_2__
+#pragma GCC pop_options
+#endif /* __DISABLE_SSE4_2__ */
 
 /* 32bit popcnt */
 extern __inline int
@@ -186,7 +195,12 @@ __bswapq (long long __X)
   return __builtin_bswap64 (__X);
 }
 
-#ifdef __SSE4_2__
+#ifndef __SSE4_2__
+#pragma GCC push_options
+#pragma GCC target("sse4.2")
+#define __DISABLE_SSE4_2__
+#endif /* __SSE4_2__ */
+
 /* 64bit accumulate CRC32 (polynomial 0x11EDC6F41) value.  */
 extern __inline unsigned long long
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -194,7 +208,11 @@ __crc32q (unsigned long long __C, unsigned long long __V)
 {
   return __builtin_ia32_crc32di (__C, __V);
 }
-#endif
+
+#ifdef __DISABLE_SSE4_2__
+#undef __DISABLE_SSE4_2__
+#pragma GCC pop_options
+#endif /* __DISABLE_SSE4_2__ */
 
 /* 64bit popcnt */
 extern __inline long long
diff --git a/gcc/config/i386/immintrin.h b/gcc/config/i386/immintrin.h
index b137753..e825c34 100644
--- a/gcc/config/i386/immintrin.h
+++ b/gcc/config/i386/immintrin.h
@@ -24,71 +24,43 @@
 #ifndef _IMMINTRIN_H_INCLUDED
 #define _IMMINTRIN_H_INCLUDED
 
-#ifdef __MMX__
 #include <mmintrin.h>
-#endif
 
-#ifdef __SSE__
 #include <xmmintrin.h>
-#endif
 
-#ifdef __SSE2__
 #include <emmintrin.h>
-#endif
 
-#ifdef __SSE3__
 #include <pmmintrin.h>
-#endif
 
-#ifdef __SSSE3__
 #include <tmmintrin.h>
-#endif
 
-#if defined (__SSE4_2__) || defined (__SSE4_1__)
 #include <smmintrin.h>
-#endif
 
-#if defined (__AES__) || defined (__PCLMUL__)
 #include <wmmintrin.h>
-#endif
 
-#ifdef __AVX__
 #include <avxintrin.h>
-#endif
 
-#ifdef __AVX2__
 #include <avx2intrin.h>
-#endif
 
-#ifdef __LZCNT__
 #include <lzcntintrin.h>
-#endif
 
-#ifdef __BMI__
 #include <bmiintrin.h>
-#endif
 
-#ifdef __BMI2__
 #include <bmi2intrin.h>
-#endif
 
-#ifdef __FMA__
 #include <fmaintrin.h>
-#endif
 
-#ifdef __F16C__
 #include <f16cintrin.h>
-#endif
 
-#ifdef __RTM__
 #include <rtmintrin.h>
-#endif
 
-#ifdef __RTM__
 #include <xtestintrin.h>
-#endif
 
-#ifdef __RDRND__
+#ifndef __RDRND__
+#pragma GCC push_options
+#pragma GCC target("rdrnd")
+#define __DISABLE_RDRND__
+#endif /* __RDRND__ */
 extern __inline int
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _rdrand16_step (unsigned short *__P)
@@ -102,10 +74,18 @@ _rdrand32_step (unsigned int *__P)
 {
   return __builtin_ia32_rdrand32_step (__P);
 }
-#endif /* __RDRND__ */
+#ifdef __DISABLE_RDRND__
+#undef __DISABLE_RDRND__
+#pragma GCC pop_options
+#endif /* __DISABLE_RDRND__ */
 
 #ifdef  __x86_64__
-#ifdef __FSGSBASE__
+
+#ifndef __FSGSBASE__
+#pragma GCC push_options
+#pragma GCC target("fsgsbase")
+#define __DISABLE_FSGSBASE__
+#endif /* __FSGSBASE__ */
 extern __inline unsigned int
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _readfsbase_u32 (void)
@@ -161,16 +141,27 @@ _writegsbase_u64 (unsigned long long __B)
 {
   __builtin_ia32_wrgsbase64 (__B);
 }
-#endif /* __FSGSBASE__ */
-
-#ifdef __RDRND__
+#ifdef __DISABLE_FSGSBASE__
+#undef __DISABLE_FSGSBASE__
+#pragma GCC pop_options
+#endif /* __DISABLE_FSGSBASE__ */
+
+#ifndef __RDRND__
+#pragma GCC push_options
+#pragma GCC target("rdrnd")
+#define __DISABLE_RDRND__
+#endif /* __RDRND__ */
 extern __inline int
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _rdrand64_step (unsigned long long *__P)
 {
   return __builtin_ia32_rdrand64_step (__P);
 }
-#endif /* __RDRND__ */
+#ifdef __DISABLE_RDRND__
+#undef __DISABLE_RDRND__
+#pragma GCC pop_options
+#endif /* __DISABLE_RDRND__ */
+
 #endif /* __x86_64__  */
 
 #endif /* _IMMINTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/linux.h b/gcc/config/i386/linux.h
index 3c95ee0..288433b 100644
--- a/gcc/config/i386/linux.h
+++ b/gcc/config/i386/linux.h
@@ -20,4 +20,22 @@ along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
 #define GNU_USER_LINK_EMULATION "elf_i386"
-#define GLIBC_DYNAMIC_LINKER "/lib/ld-linux.so.2"
+#ifndef RUNTIME_ROOT_PREFIX
+#define RUNTIME_ROOT_PREFIX ""
+#endif
+#define GLIBC_DYNAMIC_LINKER RUNTIME_ROOT_PREFIX "/lib/ld-linux.so.2"
+
+/* These may be provided by config/linux-grtev*.h.  */
+#ifndef LINUX_GRTE_EXTRA_SPECS
+#define LINUX_GRTE_EXTRA_SPECS
+#endif
+
+#undef  SUBTARGET_EXTRA_SPECS
+#ifndef SUBTARGET_EXTRA_SPECS_STR
+#define SUBTARGET_EXTRA_SPECS \
+  LINUX_GRTE_EXTRA_SPECS
+#else
+#define SUBTARGET_EXTRA_SPECS \
+  LINUX_GRTE_EXTRA_SPECS \
+  SUBTARGET_EXTRA_SPECS_STR
+#endif
diff --git a/gcc/config/i386/linux64.h b/gcc/config/i386/linux64.h
index b793e08..405a50e 100644
--- a/gcc/config/i386/linux64.h
+++ b/gcc/config/i386/linux64.h
@@ -27,6 +27,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #define GNU_USER_LINK_EMULATION64 "elf_x86_64"
 #define GNU_USER_LINK_EMULATIONX32 "elf32_x86_64"
 
-#define GLIBC_DYNAMIC_LINKER32 "/lib/ld-linux.so.2"
-#define GLIBC_DYNAMIC_LINKER64 "/lib64/ld-linux-x86-64.so.2"
-#define GLIBC_DYNAMIC_LINKERX32 "/libx32/ld-linux-x32.so.2"
+#ifndef RUNTIME_ROOT_PREFIX
+#define RUNTIME_ROOT_PREFIX ""
+#endif
+#define GLIBC_DYNAMIC_LINKER32 RUNTIME_ROOT_PREFIX "/lib/ld-linux.so.2"
+#define GLIBC_DYNAMIC_LINKER64 RUNTIME_ROOT_PREFIX "/lib64/ld-linux-x86-64.so.2"
+#define GLIBC_DYNAMIC_LINKERX32 RUNTIME_ROOT_PREFIX "/libx32/ld-linux-x32.so.2"
+
+/* These may be provided by config/linux-grtev*.h.  */
+#ifndef LINUX_GRTE_EXTRA_SPECS
+#define LINUX_GRTE_EXTRA_SPECS
+#endif
+
+#undef  SUBTARGET_EXTRA_SPECS
+#define SUBTARGET_EXTRA_SPECS \
+  LINUX_GRTE_EXTRA_SPECS
+
diff --git a/gcc/config/i386/lwpintrin.h b/gcc/config/i386/lwpintrin.h
index 8c70850..64ba732 100644
--- a/gcc/config/i386/lwpintrin.h
+++ b/gcc/config/i386/lwpintrin.h
@@ -29,8 +29,10 @@
 #define _LWPINTRIN_H_INCLUDED
 
 #ifndef __LWP__
-# error "LWP instruction set not enabled"
-#else
+#pragma GCC push_options
+#pragma GCC target("lwp")
+#define __DISABLE_LWP__
+#endif /* __LWP__ */
 
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 __llwpcb (void *pcbAddress)
@@ -95,6 +97,9 @@ __lwpins64 (unsigned long long data2, unsigned int data1, unsigned int flags)
 #endif
 #endif
 
-#endif /* __LWP__ */
+#ifdef __DISABLE_LWP__
+#undef __DISABLE_LWP__
+#pragma GCC pop_options
+#endif /* __DISABLE_LWP__ */
 
 #endif /* _LWPINTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/lzcntintrin.h b/gcc/config/i386/lzcntintrin.h
index 9382bb9..22b9ee7 100644
--- a/gcc/config/i386/lzcntintrin.h
+++ b/gcc/config/i386/lzcntintrin.h
@@ -25,13 +25,16 @@
 # error "Never use <lzcntintrin.h> directly; include <x86intrin.h> instead."
 #endif
 
-#ifndef __LZCNT__
-# error "LZCNT instruction is not enabled"
-#endif /* __LZCNT__ */
 
 #ifndef _LZCNTINTRIN_H_INCLUDED
 #define _LZCNTINTRIN_H_INCLUDED
 
+#ifndef __LZCNT__
+#pragma GCC push_options
+#pragma GCC target("lzcnt")
+#define __DISABLE_LZCNT__
+#endif /* __LZCNT__ */
+
 extern __inline unsigned short __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 __lzcnt16 (unsigned short __X)
 {
@@ -64,4 +67,9 @@ _lzcnt_u64 (unsigned long long __X)
 }
 #endif
 
+#ifdef __DISABLE_LZCNT__
+#undef __DISABLE_LZCNT__
+#pragma GCC pop_options
+#endif /* __DISABLE_LZCNT__ */
+
 #endif /* _LZCNTINTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/mm3dnow.h b/gcc/config/i386/mm3dnow.h
index 7e806b7..093d5e7 100644
--- a/gcc/config/i386/mm3dnow.h
+++ b/gcc/config/i386/mm3dnow.h
@@ -27,11 +27,15 @@
 #ifndef _MM3DNOW_H_INCLUDED
 #define _MM3DNOW_H_INCLUDED
 
-#ifdef __3dNOW__
-
 #include <mmintrin.h>
 #include <prfchwintrin.h>
 
+#ifndef __3dNOW__
+#pragma GCC push_options
+#pragma GCC target("3dnow")
+#define __DISABLE_3dNOW__
+#endif /* __3dNOW__ */
+
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _m_femms (void)
 {
@@ -205,6 +209,10 @@ _m_pswapd (__m64 __A)
 }
 
 #endif /* __3dNOW_A__ */
-#endif /* __3dNOW__ */
+
+#ifdef __DISABLE_3dNOW__
+#undef __DISABLE_3dNOW__
+#pragma GCC pop_options
+#endif /* __DISABLE_3dNOW__ */
 
 #endif /* _MM3DNOW_H_INCLUDED */
diff --git a/gcc/config/i386/mmintrin.h b/gcc/config/i386/mmintrin.h
index c76203b..c072970 100644
--- a/gcc/config/i386/mmintrin.h
+++ b/gcc/config/i386/mmintrin.h
@@ -28,8 +28,11 @@
 #define _MMINTRIN_H_INCLUDED
 
 #ifndef __MMX__
-# error "MMX instruction set not enabled"
-#else
+#pragma GCC push_options
+#pragma GCC target("mmx")
+#define __DISABLE_MMX__
+#endif /* __MMX__ */
+
 /* The Intel API is flexible enough that we must allow aliasing with other
    vector types, and their scalar components.  */
 typedef int __m64 __attribute__ ((__vector_size__ (8), __may_alias__));
@@ -303,13 +306,21 @@ _m_paddd (__m64 __m1, __m64 __m2)
 }
 
 /* Add the 64-bit values in M1 to the 64-bit values in M2.  */
-#ifdef __SSE2__
+#ifndef __SSE2__
+#pragma GCC push_options
+#pragma GCC target("sse2")
+#define __DISABLE_SSE2__
+#endif /* __SSE2__ */
+
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_add_si64 (__m64 __m1, __m64 __m2)
 {
   return (__m64) __builtin_ia32_paddq ((__v1di)__m1, (__v1di)__m2);
 }
-#endif
+#ifdef __DISABLE_SSE2__
+#undef __DISABLE_SSE2__
+#pragma GCC pop_options
+#endif /* __DISABLE_SSE2__ */
 
 /* Add the 8-bit values in M1 to the 8-bit values in M2 using signed
    saturated arithmetic.  */
@@ -407,13 +418,21 @@ _m_psubd (__m64 __m1, __m64 __m2)
 }
 
 /* Add the 64-bit values in M1 to the 64-bit values in M2.  */
-#ifdef __SSE2__
+#ifndef __SSE2__
+#pragma GCC push_options
+#pragma GCC target("sse2")
+#define __DISABLE_SSE2__
+#endif /* __SSE2__ */
+
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_sub_si64 (__m64 __m1, __m64 __m2)
 {
   return (__m64) __builtin_ia32_psubq ((__v1di)__m1, (__v1di)__m2);
 }
-#endif
+#ifdef __DISABLE_SSE2__
+#undef __DISABLE_SSE2__
+#pragma GCC pop_options
+#endif /* __DISABLE_SSE2__ */
 
 /* Subtract the 8-bit values in M2 from the 8-bit values in M1 using signed
    saturating arithmetic.  */
@@ -915,6 +934,9 @@ _mm_set1_pi8 (char __b)
 {
   return _mm_set_pi8 (__b, __b, __b, __b, __b, __b, __b, __b);
 }
+#ifdef __DISABLE_MMX__
+#undef __DISABLE_MMX__
+#pragma GCC pop_options
+#endif /* __DISABLE_MMX__ */
 
-#endif /* __MMX__ */
 #endif /* _MMINTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/nmmintrin.h b/gcc/config/i386/nmmintrin.h
index a4fbed2..aefe3ef 100644
--- a/gcc/config/i386/nmmintrin.h
+++ b/gcc/config/i386/nmmintrin.h
@@ -27,11 +27,7 @@
 #ifndef _NMMINTRIN_H_INCLUDED
 #define _NMMINTRIN_H_INCLUDED
 
-#ifndef __SSE4_2__
-# error "SSE4.2 instruction set not enabled"
-#else
 /* We just include SSE4.1 header file.  */
 #include <smmintrin.h>
-#endif /* __SSE4_2__ */
 
 #endif /* _NMMINTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/pmmintrin.h b/gcc/config/i386/pmmintrin.h
index 9c6956c..2447d5a 100644
--- a/gcc/config/i386/pmmintrin.h
+++ b/gcc/config/i386/pmmintrin.h
@@ -27,13 +27,15 @@
 #ifndef _PMMINTRIN_H_INCLUDED
 #define _PMMINTRIN_H_INCLUDED
 
-#ifndef __SSE3__
-# error "SSE3 instruction set not enabled"
-#else
-
 /* We need definitions from the SSE2 and SSE header files*/
 #include <emmintrin.h>
 
+#ifndef __SSE3__
+#pragma GCC push_options
+#pragma GCC target("sse3")
+#define __DISABLE_SSE3__
+#endif /* __SSE3__ */
+
 /* Additional bits in the MXCSR.  */
 #define _MM_DENORMALS_ZERO_MASK		0x0040
 #define _MM_DENORMALS_ZERO_ON		0x0040
@@ -122,6 +124,9 @@ _mm_mwait (unsigned int __E, unsigned int __H)
   __builtin_ia32_mwait (__E, __H);
 }
 
-#endif /* __SSE3__ */
+#ifdef __DISABLE_SSE3__
+#undef __DISABLE_SSE3__
+#pragma GCC pop_options
+#endif /* __DISABLE_SSE3__ */
 
 #endif /* _PMMINTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/popcntintrin.h b/gcc/config/i386/popcntintrin.h
index af7efdf..ee3a8e0 100644
--- a/gcc/config/i386/popcntintrin.h
+++ b/gcc/config/i386/popcntintrin.h
@@ -21,13 +21,15 @@
    see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
    <http://www.gnu.org/licenses/>.  */
 
-#ifndef __POPCNT__
-# error "POPCNT instruction set not enabled"
-#endif /* __POPCNT__ */
-
 #ifndef _POPCNTINTRIN_H_INCLUDED
 #define _POPCNTINTRIN_H_INCLUDED
 
+#ifndef __POPCNT__
+#pragma GCC push_options
+#pragma GCC target("popcnt")
+#define __DISABLE_POPCNT__
+#endif /* __POPCNT__ */
+
 /* Calculate a number of bits set to 1.  */
 extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_popcnt_u32 (unsigned int __X)
@@ -43,4 +45,9 @@ _mm_popcnt_u64 (unsigned long long __X)
 }
 #endif
 
+#ifdef __DISABLE_POPCNT__
+#undef __DISABLE_POPCNT__
+#pragma GCC pop_options
+#endif  /* __DISABLE_POPCNT__ */
+
 #endif /* _POPCNTINTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/prfchwintrin.h b/gcc/config/i386/prfchwintrin.h
index b8011bb..73aa4ca 100644
--- a/gcc/config/i386/prfchwintrin.h
+++ b/gcc/config/i386/prfchwintrin.h
@@ -26,17 +26,24 @@
 #endif
 
 
-#if !defined (__PRFCHW__) && !defined (__3dNOW__)
-# error "PRFCHW instruction not enabled"
-#endif /* __PRFCHW__ or  __3dNOW__*/
-
 #ifndef _PRFCHWINTRIN_H_INCLUDED
 #define _PRFCHWINTRIN_H_INCLUDED
 
+#ifndef __PRFCHW__
+#pragma GCC push_options
+#pragma GCC target("prfchw")
+#define __DISABLE_PRFCHW__
+#endif /* __PRFCHW__ */
+
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _m_prefetchw (void *__P)
 {
   __builtin_prefetch (__P, 1, 3 /* _MM_HINT_T0 */);
 }
 
+#ifdef __DISABLE_PRFCHW__
+#undef __DISABLE_PRFCHW__
+#pragma GCC pop_options
+#endif /* __DISABLE_PRFCHW__ */
+
 #endif /* _PRFCHWINTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/rdseedintrin.h b/gcc/config/i386/rdseedintrin.h
index f30c237..3d040ab 100644
--- a/gcc/config/i386/rdseedintrin.h
+++ b/gcc/config/i386/rdseedintrin.h
@@ -25,12 +25,15 @@
 # error "Never use <rdseedintrin.h> directly; include <x86intrin.h> instead."
 #endif
 
+#ifndef _RDSEEDINTRIN_H_INCLUDED
+#define _RDSEEDINTRIN_H_INCLUDED
+
 #ifndef __RDSEED__
-# error "RDSEED instruction not enabled"
+#pragma GCC push_options
+#pragma GCC target("rdseed")
+#define __DISABLE_RDSEED__
 #endif /* __RDSEED__ */
 
-#ifndef _RDSEEDINTRIN_H_INCLUDED
-#define _RDSEEDINTRIN_H_INCLUDED
 
 extern __inline int
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -55,4 +58,9 @@ _rdseed64_step (unsigned long long *p)
 }
 #endif
 
+#ifdef __DISABLE_RDSEED__
+#undef __DISABLE_RDSEED__
+#pragma GCC pop_options
+#endif /* __DISABLE_RDSEED__ */
+
 #endif /* _RDSEEDINTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/rtmintrin.h b/gcc/config/i386/rtmintrin.h
index 003a771..eb2812f 100644
--- a/gcc/config/i386/rtmintrin.h
+++ b/gcc/config/i386/rtmintrin.h
@@ -25,13 +25,15 @@
 # error "Never use <rtmintrin.h> directly; include <immintrin.h> instead."
 #endif
 
-#ifndef __RTM__
-# error "RTM instruction set not enabled"
-#endif /* __RTM__ */
-
 #ifndef _RTMINTRIN_H_INCLUDED
 #define _RTMINTRIN_H_INCLUDED
 
+#ifndef __RTM__
+#pragma GCC push_options
+#pragma GCC target("rtm")
+#define __DISABLE_RTM__
+#endif /* __RTM__ */
+
 #define _XBEGIN_STARTED		(~0u)
 #define _XABORT_EXPLICIT	(1 << 0)
 #define _XABORT_RETRY		(1 << 1)
@@ -74,4 +76,9 @@ _xabort (const unsigned int imm)
 #define _xabort(N)  __builtin_ia32_xabort (N)
 #endif /* __OPTIMIZE__ */
 
+#ifdef __DISABLE_RTM__
+#undef __DISABLE_RTM__
+#pragma GCC pop_options
+#endif /* __DISABLE_RTM__ */
+
 #endif /* _RTMINTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/smmintrin.h b/gcc/config/i386/smmintrin.h
index 3ae916c..20fa2ca 100644
--- a/gcc/config/i386/smmintrin.h
+++ b/gcc/config/i386/smmintrin.h
@@ -27,14 +27,16 @@
 #ifndef _SMMINTRIN_H_INCLUDED
 #define _SMMINTRIN_H_INCLUDED
 
-#ifndef __SSE4_1__
-# error "SSE4.1 instruction set not enabled"
-#else
-
 /* We need definitions from the SSSE3, SSE3, SSE2 and SSE header
    files.  */
 #include <tmmintrin.h>
 
+#ifndef __SSE4_1__
+#pragma GCC push_options
+#pragma GCC target("sse4.1")
+#define __DISABLE_SSE4_1__
+#endif /* __SSE4_1__ */
+
 /* Rounding mode macros. */
 #define _MM_FROUND_TO_NEAREST_INT	0x00
 #define _MM_FROUND_TO_NEG_INF		0x01
@@ -582,7 +584,11 @@ _mm_stream_load_si128 (__m128i *__X)
   return (__m128i) __builtin_ia32_movntdqa ((__v2di *) __X);
 }
 
-#ifdef __SSE4_2__
+#ifndef __SSE4_2__
+#pragma GCC push_options
+#pragma GCC target("sse4.2")
+#define __DISABLE_SSE4_2__
+#endif /* __SSE4_2__ */
 
 /* These macros specify the source data format.  */
 #define _SIDD_UBYTE_OPS			0x00
@@ -792,9 +798,29 @@ _mm_cmpgt_epi64 (__m128i __X, __m128i __Y)
   return (__m128i) __builtin_ia32_pcmpgtq ((__v2di)__X, (__v2di)__Y);
 }
 
-#ifdef __POPCNT__
+#ifdef __DISABLE_SSE4_2__
+#undef __DISABLE_SSE4_2__
+#pragma GCC pop_options
+#endif /* __DISABLE_SSE4_2__ */
+
+#ifdef __DISABLE_SSE4_1__
+#undef __DISABLE_SSE4_1__
+#pragma GCC pop_options
+#endif /* __DISABLE_SSE4_1__ */
+
 #include <popcntintrin.h>
-#endif
+
+#ifndef __SSE4_1__
+#pragma GCC push_options
+#pragma GCC target("sse4.1")
+#define __DISABLE_SSE4_1__
+#endif /* __SSE4_1__ */
+
+#ifndef __SSE4_2__
+#pragma GCC push_options
+#pragma GCC target("sse4.2")
+#define __DISABLE_SSE4_2__
+#endif /* __SSE4_1__ */
 
 /* Accumulate CRC32 (polynomial 0x11EDC6F41) value.  */
 extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -823,8 +849,14 @@ _mm_crc32_u64 (unsigned long long __C, unsigned long long __V)
 }
 #endif
 
-#endif /* __SSE4_2__ */
+#ifdef __DISABLE_SSE4_2__
+#undef __DISABLE_SSE4_2__
+#pragma GCC pop_options
+#endif /* __DISABLE_SSE4_2__ */
 
-#endif /* __SSE4_1__ */
+#ifdef __DISABLE_SSE4_1__
+#undef __DISABLE_SSE4_1__
+#pragma GCC pop_options
+#endif /* __DISABLE_SSE4_1__ */
 
 #endif /* _SMMINTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/tbmintrin.h b/gcc/config/i386/tbmintrin.h
index 07c4f77..9235d6c 100644
--- a/gcc/config/i386/tbmintrin.h
+++ b/gcc/config/i386/tbmintrin.h
@@ -25,13 +25,15 @@
 # error "Never use <tbmintrin.h> directly; include <x86intrin.h> instead."
 #endif
 
-#ifndef __TBM__
-# error "TBM instruction set not enabled"
-#endif /* __TBM__ */
-
 #ifndef _TBMINTRIN_H_INCLUDED
 #define _TBMINTRIN_H_INCLUDED
 
+#ifndef __TBM__
+#pragma GCC push_options
+#pragma GCC target("tbm")
+#define __DISABLE_TBM__
+#endif /* __TBM__ */
+
 #ifdef __OPTIMIZE__
 extern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 __bextri_u32 (unsigned int __X, const unsigned int __I)
@@ -169,4 +171,10 @@ __tzmsk_u64 (unsigned long long __X)
 
 
 #endif /* __x86_64__  */
+
+#ifdef __DISABLE_TBM__
+#undef __DISABLE_TBM__
+#pragma GCC pop_options
+#endif /* __DISABLE_TBM__ */
+
 #endif /* _TBMINTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/tmmintrin.h b/gcc/config/i386/tmmintrin.h
index 767b199..3f63b4f 100644
--- a/gcc/config/i386/tmmintrin.h
+++ b/gcc/config/i386/tmmintrin.h
@@ -27,13 +27,15 @@
 #ifndef _TMMINTRIN_H_INCLUDED
 #define _TMMINTRIN_H_INCLUDED
 
-#ifndef __SSSE3__
-# error "SSSE3 instruction set not enabled"
-#else
-
 /* We need definitions from the SSE3, SSE2 and SSE header files*/
 #include <pmmintrin.h>
 
+#ifndef __SSSE3__
+#pragma GCC push_options
+#pragma GCC target("ssse3")
+#define __DISABLE_SSSE3__
+#endif /* __SSSE3__ */
+
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_hadd_epi16 (__m128i __X, __m128i __Y)
 {
@@ -239,6 +241,9 @@ _mm_abs_pi32 (__m64 __X)
   return (__m64) __builtin_ia32_pabsd ((__v2si)__X);
 }
 
-#endif /* __SSSE3__ */
+#ifdef __DISABLE_SSSE3__
+#undef __DISABLE_SSSE3__
+#pragma GCC pop_options
+#endif /* __DISABLE_SSSE3__ */
 
 #endif /* _TMMINTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/wmmintrin.h b/gcc/config/i386/wmmintrin.h
index 93c24f4..defcfd8 100644
--- a/gcc/config/i386/wmmintrin.h
+++ b/gcc/config/i386/wmmintrin.h
@@ -30,13 +30,14 @@
 /* We need definitions from the SSE2 header file.  */
 #include <emmintrin.h>
 
-#if !defined (__AES__) && !defined (__PCLMUL__)
-# error "AES/PCLMUL instructions not enabled"
-#else
-
 /* AES */
 
-#ifdef __AES__
+#ifndef __AES__
+#pragma GCC push_options
+#pragma GCC target("aes")
+#define __DISABLE_AES__
+#endif /* __AES__ */
+
 /* Performs 1 round of AES decryption of the first m128i using 
    the second m128i as a round key.  */
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
@@ -92,11 +93,20 @@ _mm_aeskeygenassist_si128 (__m128i __X, const int __C)
   ((__m128i) __builtin_ia32_aeskeygenassist128 ((__v2di)(__m128i)(X),	\
 						(int)(C)))
 #endif
-#endif  /* __AES__ */
+
+#ifdef __DISABLE_AES__
+#undef __DISABLE_AES__
+#pragma GCC pop_options
+#endif /* __DISABLE_AES__ */
 
 /* PCLMUL */
 
-#ifdef __PCLMUL__
+#ifndef __PCLMUL__
+#pragma GCC push_options
+#pragma GCC target("pclmul")
+#define __DISABLE_PCLMUL__
+#endif /* __PCLMUL__ */
+
 /* Performs carry-less integer multiplication of 64-bit halves of
    128-bit input operands.  The third parameter inducates which 64-bit
    haves of the input parameters v1 and v2 should be used. It must be
@@ -113,8 +123,10 @@ _mm_clmulepi64_si128 (__m128i __X, __m128i __Y, const int __I)
   ((__m128i) __builtin_ia32_pclmulqdq128 ((__v2di)(__m128i)(X),		\
 					  (__v2di)(__m128i)(Y), (int)(I)))
 #endif
-#endif  /* __PCLMUL__  */
 
-#endif /* __AES__/__PCLMUL__ */
+#ifdef __DISABLE_PCLMUL__
+#undef __DISABLE_PCLMUL__
+#pragma GCC pop_options
+#endif /* __DISABLE_PCLMUL__ */
 
 #endif /* _WMMINTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/x86intrin.h b/gcc/config/i386/x86intrin.h
index 5bf29d5..46ced96 100644
--- a/gcc/config/i386/x86intrin.h
+++ b/gcc/config/i386/x86intrin.h
@@ -26,96 +26,52 @@
 
 #include <ia32intrin.h>
 
-#ifdef __MMX__
 #include <mmintrin.h>
-#endif
 
-#ifdef __SSE__
 #include <xmmintrin.h>
-#endif
 
-#ifdef __SSE2__
 #include <emmintrin.h>
-#endif
 
-#ifdef __SSE3__
 #include <pmmintrin.h>
-#endif
 
-#ifdef __SSSE3__
 #include <tmmintrin.h>
-#endif
 
-#ifdef __SSE4A__
 #include <ammintrin.h>
-#endif
 
-#if defined (__SSE4_2__) || defined (__SSE4_1__)
 #include <smmintrin.h>
-#endif
 
-#if defined (__AES__) || defined (__PCLMUL__)
 #include <wmmintrin.h>
-#endif
 
 /* For including AVX instructions */
 #include <immintrin.h>
 
-#ifdef __3dNOW__
 #include <mm3dnow.h>
-#endif
 
-#ifdef __FMA4__
 #include <fma4intrin.h>
-#endif
 
-#ifdef __XOP__
 #include <xopintrin.h>
-#endif
 
-#ifdef __LWP__
 #include <lwpintrin.h>
-#endif
 
-#ifdef __BMI__
 #include <bmiintrin.h>
-#endif
 
-#ifdef __BMI2__
 #include <bmi2intrin.h>
-#endif
 
-#ifdef __TBM__
 #include <tbmintrin.h>
-#endif
 
-#ifdef __LZCNT__
 #include <lzcntintrin.h>
-#endif
 
-#ifdef __POPCNT__
 #include <popcntintrin.h>
-#endif
 
-#ifdef __RDSEED__
 #include <rdseedintrin.h>
-#endif
 
-#ifdef __PRFCHW__
 #include <prfchwintrin.h>
-#endif
 
-#ifdef __FXSR__
 #include <fxsrintrin.h>
-#endif
 
-#ifdef __XSAVE__
 #include <xsaveintrin.h>
-#endif
 
-#ifdef __XSAVEOPT__
 #include <xsaveoptintrin.h>
-#endif
 
 #include <adxintrin.h>
 
diff --git a/gcc/config/i386/xmmintrin.h b/gcc/config/i386/xmmintrin.h
index a223562..14d1e7f 100644
--- a/gcc/config/i386/xmmintrin.h
+++ b/gcc/config/i386/xmmintrin.h
@@ -27,16 +27,18 @@
 #ifndef _XMMINTRIN_H_INCLUDED
 #define _XMMINTRIN_H_INCLUDED
 
-#ifndef __SSE__
-# error "SSE instruction set not enabled"
-#else
-
 /* We need type definitions from the MMX header file.  */
 #include <mmintrin.h>
 
 /* Get _mm_malloc () and _mm_free ().  */
 #include <mm_malloc.h>
 
+#ifndef __SSE__
+#pragma GCC push_options
+#pragma GCC target("sse")
+#define __DISABLE_SSE__
+#endif /* __SSE__ */
+
 /* The Intel API is flexible enough that we must allow aliasing with other
    vector types, and their scalar components.  */
 typedef float __m128 __attribute__ ((__vector_size__ (16), __may_alias__));
@@ -1242,9 +1244,11 @@ do {									\
 } while (0)
 
 /* For backward source compatibility.  */
-#ifdef __SSE2__
 # include <emmintrin.h>
-#endif
 
-#endif /* __SSE__ */
+#ifdef __DISABLE_SSE__
+#undef __DISABLE_SSE__
+#pragma GCC pop_options
+#endif /* __DISABLE_SSE__ */
+
 #endif /* _XMMINTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/xopintrin.h b/gcc/config/i386/xopintrin.h
index 66b0f0d..e0d148a 100644
--- a/gcc/config/i386/xopintrin.h
+++ b/gcc/config/i386/xopintrin.h
@@ -28,12 +28,14 @@
 #ifndef _XOPMMINTRIN_H_INCLUDED
 #define _XOPMMINTRIN_H_INCLUDED
 
-#ifndef __XOP__
-# error "XOP instruction set not enabled"
-#else
-
 #include <fma4intrin.h>
 
+#ifndef __XOP__
+#pragma GCC push_options
+#pragma GCC target("xop")
+#define __DISABLE_XOP__
+#endif /* __XOP__ */
+
 /* Integer multiply/add intructions. */
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_maccs_epi16(__m128i __A, __m128i __B, __m128i __C)
@@ -830,6 +832,9 @@ _mm256_permute2_ps (__m256 __X, __m256 __Y, __m256i __C, const int __I)
  					  (int)(I)))
 #endif /* __OPTIMIZE__ */
 
-#endif /* __XOP__ */
+#ifdef __DISABLE_XOP__
+#undef __DISABLE_XOP__
+#pragma GCC pop_options
+#endif /* __DISABLE_XOP__ */
 
 #endif /* _XOPMMINTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/xsaveintrin.h b/gcc/config/i386/xsaveintrin.h
index f566589..31c17b1 100644
--- a/gcc/config/i386/xsaveintrin.h
+++ b/gcc/config/i386/xsaveintrin.h
@@ -28,6 +28,12 @@
 #ifndef _XSAVEINTRIN_H_INCLUDED
 #define _XSAVEINTRIN_H_INCLUDED
 
+#ifndef __XSAVE__
+#pragma GCC push_options
+#pragma GCC target("xsave")
+#define __DISABLE_XSAVE__
+#endif /* __XSAVE__ */
+
 extern __inline void
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _xsave (void *__P, long long __M)
@@ -58,4 +64,9 @@ _xrstor64 (void *__P, long long __M)
 }
 #endif
 
+#ifdef __DISABLE_XSAVE__
+#undef __DISABLE_XSAVE__
+#pragma GCC pop_options
+#endif /* __DISABLE_XSAVE__ */
+
 #endif /* _XSAVEINTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/xsaveoptintrin.h b/gcc/config/i386/xsaveoptintrin.h
index 0d73e34..aa9538d 100644
--- a/gcc/config/i386/xsaveoptintrin.h
+++ b/gcc/config/i386/xsaveoptintrin.h
@@ -28,6 +28,12 @@
 #ifndef _XSAVEOPTINTRIN_H_INCLUDED
 #define _XSAVEOPTINTRIN_H_INCLUDED
 
+#ifndef __XSAVEOPT__
+#pragma GCC push_options
+#pragma GCC target("xsaveopt")
+#define __DISABLE_XSAVEOPT__
+#endif /* __XSAVEOPT__ */
+
 extern __inline void
 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _xsaveopt (void *__P, long long __M)
@@ -44,4 +50,9 @@ _xsaveopt64 (void *__P, long long __M)
 }
 #endif
 
+#ifdef __DISABLE_XSAVEOPT__
+#undef __DISABLE_XSAVEOPT__
+#pragma GCC pop_options
+#endif /* __DISABLE_XSAVEOPT__ */
+
 #endif /* _XSAVEOPTINTRIN_H_INCLUDED */
diff --git a/gcc/config/i386/xtestintrin.h b/gcc/config/i386/xtestintrin.h
index c82fb7a..a6afa89 100644
--- a/gcc/config/i386/xtestintrin.h
+++ b/gcc/config/i386/xtestintrin.h
@@ -25,13 +25,15 @@
 # error "Never use <xtestintrin.h> directly; include <immintrin.h> instead."
 #endif
 
-#ifndef __RTM__
-# error "RTM instruction set not enabled"
-#endif /* __RTM__ */
-
 #ifndef _XTESTINTRIN_H_INCLUDED
 #define _XTESTINTRIN_H_INCLUDED
 
+#ifndef __RTM__
+#pragma GCC push_options
+#pragma GCC target("rtm")
+#define __DISABLE_RTM__
+#endif /* __RTM__ */
+
 /* Return non-zero if the instruction executes inside an RTM or HLE code
    region.  Return zero otherwise.   */
 extern __inline int
@@ -41,4 +43,9 @@ _xtest (void)
   return __builtin_ia32_xtest ();
 }
 
+#ifdef __DISABLE_RTM__
+#undef __DISABLE_RTM__
+#pragma GCC pop_options
+#endif /* __DISABLE_RTM__ */
+
 #endif /* _XTESTINTRIN_H_INCLUDED */
diff --git a/gcc/config/linux-grte.h b/gcc/config/linux-grte.h
new file mode 100644
index 0000000..afcbddf
--- /dev/null
+++ b/gcc/config/linux-grte.h
@@ -0,0 +1,43 @@
+/* Definitions for Linux-based GRTE (Google RunTime Environment).
+   Copyright (C) 2009,2010,2011,2012 Free Software Foundation, Inc.
+   Contributed by Chris Demetriou and Ollie Wild.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+/* Overrides LIB_SPEC from gnu-user.h.  */
+#undef	LIB_SPEC
+#define LIB_SPEC \
+  "%{pthread:-lpthread} \
+   %{shared:-lc} \
+   %{!shared:%{mieee-fp:-lieee} %{profile:%(libc_p)}%{!profile:%(libc)}}"
+
+/* When GRTE links statically, it needs its NSS and resolver libraries
+   linked in as well.  Note that when linking statically, these are
+   enclosed in a group by LINK_GCC_C_SEQUENCE_SPEC.  */
+#undef LINUX_GRTE_EXTRA_SPECS
+#define LINUX_GRTE_EXTRA_SPECS \
+  { "libc", "%{static:%(libc_static);:-lc}" }, \
+  { "libc_p", "%{static:%(libc_p_static);:-lc_p}" }, \
+  { "libc_static", \
+    "-lc -lnss_borg -lnss_cache -lnss_dns -lnss_files -lresolv" }, \
+  { "libc_p_static", \
+    "-lc_p -lnss_borg_p -lnss_cache_p -lnss_dns_p -lnss_files_p -lresolv_p" },
diff --git a/gcc/config/linux.h b/gcc/config/linux.h
index 1cd6455..112da8a 100644
--- a/gcc/config/linux.h
+++ b/gcc/config/linux.h
@@ -73,13 +73,16 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
    GLIBC_DYNAMIC_LINKER must be defined for each target using them, or
    GLIBC_DYNAMIC_LINKER32 and GLIBC_DYNAMIC_LINKER64 for targets
    supporting both 32-bit and 64-bit compilation.  */
-#define UCLIBC_DYNAMIC_LINKER "/lib/ld-uClibc.so.0"
-#define UCLIBC_DYNAMIC_LINKER32 "/lib/ld-uClibc.so.0"
-#define UCLIBC_DYNAMIC_LINKER64 "/lib/ld64-uClibc.so.0"
-#define UCLIBC_DYNAMIC_LINKERX32 "/lib/ldx32-uClibc.so.0"
-#define BIONIC_DYNAMIC_LINKER "/system/bin/linker"
-#define BIONIC_DYNAMIC_LINKER32 "/system/bin/linker"
-#define BIONIC_DYNAMIC_LINKER64 "/system/bin/linker64"
+#ifndef RUNTIME_ROOT_PREFIX
+#define RUNTIME_ROOT_PREFIX ""
+#endif
+#define UCLIBC_DYNAMIC_LINKER RUNTIME_ROOT_PREFIX "/lib/ld-uClibc.so.0"
+#define UCLIBC_DYNAMIC_LINKER32 RUNTIME_ROOT_PREFIX "/lib/ld-uClibc.so.0"
+#define UCLIBC_DYNAMIC_LINKER64 RUNTIME_ROOT_PREFIX "/lib/ld64-uClibc.so.0"
+#define UCLIBC_DYNAMIC_LINKERX32 RUNTIME_ROOT_PREFIX "/lib/ldx32-uClibc.so.0"
+#define BIONIC_DYNAMIC_LINKER RUNTIME_ROOT_PREFIX "/system/bin/linker"
+#define BIONIC_DYNAMIC_LINKER32 RUNTIME_ROOT_PREFIX "/system/bin/linker"
+#define BIONIC_DYNAMIC_LINKER64 RUNTIME_ROOT_PREFIX "/system/bin/linker64"
 #define BIONIC_DYNAMIC_LINKERX32 "/system/bin/linkerx32"
 
 #define GNU_USER_DYNAMIC_LINKER						\
diff --git a/gcc/config/rs6000/linux-grte.h b/gcc/config/rs6000/linux-grte.h
new file mode 100644
index 0000000..28f748f
--- /dev/null
+++ b/gcc/config/rs6000/linux-grte.h
@@ -0,0 +1,43 @@
+/* Definitions for Linux-based GRTE (Google RunTime Environment).
+   Copyright (C) 2009,2010,2011,2012 Free Software Foundation, Inc.
+   Contributed by Chris Demetriou and Ollie Wild.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+/* Overrides LIB_LINUX_SPEC from sysv4.h.  */
+#undef	LIB_LINUX_SPEC
+#define LIB_LINUX_SPEC \
+  "%{pthread:-lpthread} \
+   %{shared:-lc} \
+   %{!shared:%{mieee-fp:-lieee} %{profile:%(libc_p)}%{!profile:%(libc)}}"
+
+/* When GRTE links statically, it needs its NSS and resolver libraries
+   linked in as well.  Note that when linking statically, these are
+   enclosed in a group by LINK_GCC_C_SEQUENCE_SPEC.  */
+#undef LINUX_GRTE_EXTRA_SPECS
+#define LINUX_GRTE_EXTRA_SPECS \
+  { "libc", "%{static:%(libc_static);:-lc}" }, \
+  { "libc_p", "%{static:%(libc_p_static);:-lc_p}" }, \
+  { "libc_static", \
+    "-lc -lnss_borg -lnss_cache -lnss_dns -lnss_files -lresolv" }, \
+  { "libc_p_static", \
+    "-lc_p -lnss_borg_p -lnss_cache_p -lnss_dns_p -lnss_files_p -lresolv_p" },
diff --git a/gcc/config/rs6000/linux64.h b/gcc/config/rs6000/linux64.h
index 3f28058..681338f 100644
--- a/gcc/config/rs6000/linux64.h
+++ b/gcc/config/rs6000/linux64.h
@@ -350,8 +350,8 @@ extern int dot_symbols;
 #undef	LINK_OS_DEFAULT_SPEC
 #define LINK_OS_DEFAULT_SPEC "%(link_os_linux)"
 
-#define GLIBC_DYNAMIC_LINKER32 "/lib/ld.so.1"
-#define GLIBC_DYNAMIC_LINKER64 "/lib64/ld64.so.1"
+#define GLIBC_DYNAMIC_LINKER32 RUNTIME_ROOT_PREFIX "/lib/ld.so.1"
+#define GLIBC_DYNAMIC_LINKER64 RUNTIME_ROOT_PREFIX "/lib64/ld64.so.1"
 #define UCLIBC_DYNAMIC_LINKER32 "/lib/ld-uClibc.so.0"
 #define UCLIBC_DYNAMIC_LINKER64 "/lib/ld64-uClibc.so.0"
 #if DEFAULT_LIBC == LIBC_UCLIBC
diff --git a/gcc/config/rs6000/sysv4.h b/gcc/config/rs6000/sysv4.h
index 0cc8ffb..286d57a 100644
--- a/gcc/config/rs6000/sysv4.h
+++ b/gcc/config/rs6000/sysv4.h
@@ -776,7 +776,10 @@ ENDIAN_SELECT(" -mbig", " -mlittle", DEFAULT_ASM_ENDIAN)
 
 #define LINK_START_LINUX_SPEC ""
 
-#define GLIBC_DYNAMIC_LINKER "/lib/ld.so.1"
+#ifndef RUNTIME_ROOT_PREFIX
+#define RUNTIME_ROOT_PREFIX ""
+#endif
+#define GLIBC_DYNAMIC_LINKER RUNTIME_ROOT_PREFIX "/lib/ld.so.1"
 #define UCLIBC_DYNAMIC_LINKER "/lib/ld-uClibc.so.0"
 #if DEFAULT_LIBC == LIBC_UCLIBC
 #define CHOOSE_DYNAMIC_LINKER(G, U) "%{mglibc:" G ";:" U "}"
@@ -854,6 +857,11 @@ ncrtn.o%s"
 #define CPP_OS_OPENBSD_SPEC "%{posix:-D_POSIX_SOURCE} %{pthread:-D_POSIX_THREADS}"
 #endif
 
+/* These may be provided by rs6000/linux-grtev2.h.  */
+#ifndef LINUX_GRTE_EXTRA_SPECS
+#define LINUX_GRTE_EXTRA_SPECS
+#endif
+
 /* Define any extra SPECS that the compiler needs to generate.  */
 /* Override rs6000.h definition.  */
 #undef	SUBTARGET_EXTRA_SPECS
@@ -922,6 +930,7 @@ ncrtn.o%s"
   { "cpp_os_openbsd",		CPP_OS_OPENBSD_SPEC },			\
   { "cpp_os_default",		CPP_OS_DEFAULT_SPEC },			\
   { "fbsd_dynamic_linker",	FBSD_DYNAMIC_LINKER },			\
+  LINUX_GRTE_EXTRA_SPECS						\
   SUBSUBTARGET_EXTRA_SPECS
 
 #define	SUBSUBTARGET_EXTRA_SPECS
diff --git a/gcc/configure b/gcc/configure
index 827c2f3..7d811a0 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -760,6 +760,7 @@ CONFIGURE_SPECS
 CROSS_SYSTEM_HEADER_DIR
 TARGET_SYSTEM_ROOT_DEFINE
 TARGET_SYSTEM_ROOT
+RUNTIME_ROOT_PREFIX_DEFINE
 SYSROOT_CFLAGS_FOR_TARGET
 enable_shared
 enable_fixed_point
@@ -888,6 +889,7 @@ with_dwarf2
 enable_shared
 with_native_system_header_dir
 with_build_sysroot
+with_runtime_root_prefix
 with_sysroot
 with_specs
 with_pkgversion
@@ -917,8 +919,10 @@ with_gc
 with_system_zlib
 enable_maintainer_mode
 enable_version_specific_runtime_libs
+enable_canonical_prefixes
 enable_plugin
 enable_libquadmath_support
+with_warn_frame_larger_than_extra_text
 with_linker_hash_style
 '
       ac_precious_vars='build_alias
@@ -1630,6 +1634,8 @@ Optional Features:
   --enable-version-specific-runtime-libs
                           specify that runtime libraries should be installed
                           in a compiler-specific directory
+  --enable-canonical-prefixes
+                          enable or disable prefix canonicalization
   --enable-plugin         enable plugin support
   --disable-libquadmath-support
                           disable libquadmath support for Fortran
@@ -1656,6 +1662,10 @@ Optional Packages:
                           system header files in.  Defaults to /usr/include.
   --with-build-sysroot=sysroot
                           use sysroot as the system root during the build
+  --with-runtime-root-prefix=prefix
+                          prepend prefix to paths used by the compiler to
+                          name the dynamic linker and other files used at
+                          runtime.  Defaults to empty (no prefix).
   --with-sysroot[=DIR]    search for usr/lib, usr/include, et al, within DIR
   --with-specs=SPECS      add SPECS to driver command-line processing
   --with-pkgversion=PKG   Use PKG in the version string in place of "GCC"
@@ -1673,6 +1683,8 @@ Optional Packages:
                           choose the garbage collection mechanism to use with
                           the compiler
   --with-system-zlib      use installed libz
+  --with-warn-frame-larger-than-extra-text=TEXT
+                          specifies extra text for frame size warnings
   --with-linker-hash-style={sysv,gnu,both}
                           specify the linker hash style
 
@@ -7261,6 +7273,23 @@ fi
 
 
 
+
+# Check whether --with-runtime-root-prefix was given.
+if test "${with_runtime_root_prefix+set}" = set; then :
+  withval=$with_runtime_root_prefix;
+ case ${with_runtime_root_prefix} in
+ yes|no) as_fn_error "bad value ${withval} given for runtime root prefix" "$LINENO" 5 ;;
+ /*) ;;
+ *) as_fn_error "${withval} should be an absolute directory" "$LINENO" 5 ;;
+ esac
+ RUNTIME_ROOT_PREFIX_DEFINE="-DRUNTIME_ROOT_PREFIX=\\\"${withval}\\\""
+
+else
+  RUNTIME_ROOT_PREFIX_DEFINE=""
+fi
+
+
+
 if test "x$prefix" = xNONE; then
  test_prefix=/usr/local
 else
@@ -11743,6 +11772,12 @@ esac
 
 
 cat >>confdefs.h <<_ACEOF
+#define FRPLUGINSONAME "${host_function_reordering_plugin_soname}"
+_ACEOF
+
+
+
+cat >>confdefs.h <<_ACEOF
 #define LTOPLUGINSONAME "${host_lto_plugin_soname}"
 _ACEOF
 
@@ -14429,7 +14464,22 @@ fi
 
 # Check whether --with-pic was given.
 if test "${with_pic+set}" = set; then :
-  withval=$with_pic; pic_mode="$withval"
+  withval=$with_pic; p=${PACKAGE-default}
+    case "$withval" in
+    yes|no) pic_mode="$withval" ;;
+    *)
+      pic_mode=default
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $withval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  pic_mode=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
 else
   pic_mode=default
 fi
@@ -17828,7 +17878,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 17831 "configure"
+#line 17881 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -17934,7 +17984,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 17937 "configure"
+#line 17987 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -27108,6 +27158,21 @@ if test "${enable_version_specific_runtime_libs+set}" = set; then :
 fi
 
 
+# Set default prefix canonicalization.
+
+# Check whether --enable-canonical-prefixes was given.
+if test "${enable_canonical_prefixes+set}" = set; then :
+  enableval=$enable_canonical_prefixes;
+else
+  enable_canonical_prefixes=yes
+fi
+
+if test x"$enable_canonical_prefixes" = xyes; then
+
+$as_echo "#define ENABLE_CANONICAL_PREFIXES 1" >>confdefs.h
+
+fi
+
 # Substitute configuration variables
 
 
@@ -27406,6 +27471,24 @@ $as_echo "#define ENABLE_LIBQUADMATH_SUPPORT 1" >>confdefs.h
 fi
 
 
+warn_frame_larger_than_extra_text=
+
+# Check whether --with-warn-frame-larger-than-extra-text was given.
+if test "${with_warn_frame_larger_than_extra_text+set}" = set; then :
+  withval=$with_warn_frame_larger_than_extra_text; case "${withval}" in
+yes)	as_fn_error "bad value ${withval} given for frame size warning text" "$LINENO" 5 ;;
+no)	;;
+*)	warn_frame_larger_than_extra_text="$withval" ;;
+esac
+fi
+
+
+cat >>confdefs.h <<_ACEOF
+#define WARN_FRAME_LARGER_THAN_EXTRA_TEXT "$warn_frame_larger_than_extra_text"
+_ACEOF
+
+
+
 # Specify what hash style to use by default.
 
 # Check whether --with-linker-hash-style was given.
diff --git a/gcc/configure.ac b/gcc/configure.ac
index 1a39e27..425ed3f 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -764,6 +764,21 @@ AC_ARG_WITH(build-sysroot,
   [SYSROOT_CFLAGS_FOR_TARGET=])
 AC_SUBST(SYSROOT_CFLAGS_FOR_TARGET)
 
+AC_ARG_WITH([runtime-root-prefix],
+  [  --with-runtime-root-prefix=prefix
+                          prepend prefix to paths used by the compiler to
+                          name the dynamic linker and other files used at
+                          runtime.  Defaults to empty (no prefix).],
+[
+ case ${with_runtime_root_prefix} in
+ yes|no) AC_MSG_ERROR([bad value ${withval} given for runtime root prefix]) ;;
+ /*) ;;
+ *) AC_MSG_ERROR([${withval} should be an absolute directory]) ;;
+ esac
+ RUNTIME_ROOT_PREFIX_DEFINE="-DRUNTIME_ROOT_PREFIX=\\\"${withval}\\\""
+], [RUNTIME_ROOT_PREFIX_DEFINE=""])
+AC_SUBST(RUNTIME_ROOT_PREFIX_DEFINE)
+
 if test "x$prefix" = xNONE; then
  test_prefix=/usr/local
 else
@@ -1925,6 +1940,10 @@ case $use_collect2 in
     ;;
 esac
 
+AC_DEFINE_UNQUOTED(FRPLUGINSONAME,"${host_function_reordering_plugin_soname}",
+[Define to the name of the function reordering plugin DSO that must be
+  passed to the linker's -plugin=LIB option.])
+
 AC_DEFINE_UNQUOTED(LTOPLUGINSONAME,"${host_lto_plugin_soname}",
 [Define to the name of the LTO plugin DSO that must be
   passed to the linker's -plugin=LIB option.])
@@ -5068,6 +5087,18 @@ AC_ARG_ENABLE(version-specific-runtime-libs,
                 [specify that runtime libraries should be
                  installed in a compiler-specific directory])])
 
+# Set default prefix canonicalization.
+
+AC_ARG_ENABLE(canonical-prefixes,
+[  --enable-canonical-prefixes
+                          enable or disable prefix canonicalization],
+[],
+enable_canonical_prefixes=yes)
+if test x"$enable_canonical_prefixes" = xyes; then
+  AC_DEFINE(ENABLE_CANONICAL_PREFIXES,
+            1, [Define to enable prefix canonicalization.])
+fi
+
 # Substitute configuration variables
 AC_SUBST(subdirs)
 AC_SUBST(srcdir)
@@ -5278,6 +5309,20 @@ if test "${ENABLE_LIBQUADMATH_SUPPORT}" != "no" ; then
 fi
 
 
+warn_frame_larger_than_extra_text=
+AC_ARG_WITH(warn-frame-larger-than-extra-text,
+[  --with-warn-frame-larger-than-extra-text=TEXT
+                          specifies extra text for frame size warnings],
+[case "${withval}" in
+yes)	AC_MSG_ERROR(bad value ${withval} given for frame size warning text) ;;
+no)	;;
+*)	warn_frame_larger_than_extra_text="$withval" ;;
+esac])
+AC_DEFINE_UNQUOTED(WARN_FRAME_LARGER_THAN_EXTRA_TEXT,
+                   "$warn_frame_larger_than_extra_text",
+                   [Define to be extra text for frame size warnings.])
+
+
 # Specify what hash style to use by default.
 AC_ARG_WITH([linker-hash-style],
 [AC_HELP_STRING([--with-linker-hash-style={sysv,gnu,both}],
diff --git a/gcc/coverage.c b/gcc/coverage.c
index bc6a46f..f1f27cb 100644
--- a/gcc/coverage.c
+++ b/gcc/coverage.c
@@ -45,13 +45,25 @@ along with GCC; see the file COPYING3.  If not see
 #include "tree-iterator.h"
 #include "cgraph.h"
 #include "dumpfile.h"
+#include "opts.h"
+#include "gcov-io.h"
+#include "tree-flow.h"
+#include "tree-pass.h"
+#include "cpplib.h"
+#include "incpath.h"
 #include "diagnostic-core.h"
 #include "intl.h"
+#include "l-ipo.h"
 #include "filenames.h"
+#include "dwarf2asm.h"
 #include "target.h"
+#include "auto-profile.h"
 
 #include "gcov-io.h"
 #include "gcov-io.c"
+#include "params.h"
+#include "dbgcnt.h"
+#include "input.h"
 
 struct GTY((chain_next ("%h.next"))) coverage_data
 {
@@ -63,11 +75,20 @@ struct GTY((chain_next ("%h.next"))) coverage_data
   tree ctr_vars[GCOV_COUNTERS];	 /* counter variables.  */
 };
 
+static bool profiling_enabled_p (void);
+
+/* Linked list of -D/-U/-imacro/-include strings for a source module.  */
+struct str_list
+{
+  char *str;
+  struct str_list *next;
+};
+
 /* Counts information for a function.  */
 typedef struct counts_entry
 {
   /* We hash by  */
-  unsigned ident;
+  unsigned HOST_WIDEST_INT ident;
   unsigned ctr;
 
   /* Store  */
@@ -113,13 +134,31 @@ static unsigned bbg_file_stamp;
 
 /* Name of the count data (gcda) file.  */
 static char *da_file_name;
+static char *da_base_file_name;
+static char *main_input_file_name;
 
 /* The names of merge functions for counters.  */
 static const char *const ctr_merge_functions[GCOV_COUNTERS] = GCOV_MERGE_FUNCTIONS;
 static const char *const ctr_names[GCOV_COUNTERS] = GCOV_COUNTER_NAMES;
 
+/* True during the period that counts_hash is being rebuilt.  */
+static bool rebuilding_counts_hash = false;
+
+struct gcov_module_info **module_infos = NULL;
+
+/* List of -D/-U options.  */
+static struct str_list *cpp_defines_head = NULL, *cpp_defines_tail = NULL;
+static unsigned num_cpp_defines = 0;
+
+/* List of -imcaro/-include options.  */
+static struct str_list *cpp_includes_head = NULL, *cpp_includes_tail = NULL;
+static unsigned num_cpp_includes = 0;
+
+/* True if the current module has any asm statements.  */
+static bool has_asm_statement;
+
 /* Forward declarations.  */
-static void read_counts_file (void);
+static void read_counts_file (const char *, unsigned);
 static tree build_var (tree, tree, int);
 static void build_fn_info_type (tree, unsigned, tree);
 static void build_info_type (tree, tree);
@@ -129,6 +168,8 @@ static bool coverage_obj_init (void);
 static vec<constructor_elt, va_gc> *coverage_obj_fn
 (vec<constructor_elt, va_gc> *, tree, struct coverage_data const *);
 static void coverage_obj_finish (vec<constructor_elt, va_gc> *);
+static char * get_da_file_name (const char *);
+static tree build_gcov_module_info_type (void);
 
 /* Return the type node for gcov_type.  */
 
@@ -141,7 +182,7 @@ get_gcov_type (void)
 
 /* Return the type node for gcov_unsigned_t.  */
 
-static tree
+tree
 get_gcov_unsigned_t (void)
 {
   enum machine_mode mode = smallest_mode_for_size (32, MODE_INT);
@@ -164,28 +205,474 @@ counts_entry::equal (const value_type *entry1,
 inline void
 counts_entry::remove (value_type *entry)
 {
-  free (entry->counts);
-  free (entry);
+  /* When rebuilding counts_hash, we will reuse the entry.  */
+  if (!rebuilding_counts_hash)
+    {
+      free (entry->counts);
+      free (entry);
+    }
 }
 
 /* Hash table of count data.  */
 static hash_table <counts_entry> counts_hash;
 
-/* Read in the counts file, if available.  */
+/* Returns true if MOD_ID is the id of the last source module.  */
+int
+is_last_module (unsigned mod_id)
+{
+  return (mod_id == module_infos[num_in_fnames - 1]->ident);
+}
+
+/* String hash function  */
+
+struct string_hasher
+{
+  /* hash_table support.  */
+  typedef  char value_type;
+  typedef  char compare_type;
+  static inline hashval_t hash (const value_type *);
+  static int equal (const value_type *, const compare_type *);
+  static void remove (value_type *) {};
+};
+
+hashval_t
+string_hasher::hash (const char* s)
+{
+  return htab_hash_string (s);
+}
+
+/* String equal function  */
+
+int
+string_hasher::equal (const char *s1, const char *s2)
+{
+  return !strcmp (s1, s2);
+}
+
+/* Command line option descriptor.  */
+
+struct opt_desc
+{
+  const char *opt_str;
+  const char *opt_neg_str;
+  bool default_val;  /* TODO better handling of default  */
+};
+
+static struct opt_desc force_matching_cg_opts[] =
+  {
+    { "-fexceptions", "-fno-exceptions", true },
+    { "-fsized-delete", "-fno-sized-delete", false },
+    { "-frtti", "-fno-rtti", true },
+    { "-fstrict-aliasing", "-fno-strict-aliasing", true },
+    { NULL, NULL, false }
+  };
+
+/* A helper function to check if OPTION_STRING is one of the codegen
+   options specified in FORCE_MATCHING_CG_ARGS. If yes, set the
+   corresponding entry in CG_ARG_VAL to the value of the option specified
+   in OPTION_STRING.  */
+
+static void
+check_cg_opts (bool *cg_opt_val, const char *option_str)
+{
+  unsigned int i;
+  for (i = 0; force_matching_cg_opts[i].opt_str; i++)
+    {
+      if (!strcmp (force_matching_cg_opts[i].opt_str, option_str))
+        cg_opt_val[i] = true;
+      else if (!strcmp (force_matching_cg_opts[i].opt_neg_str, option_str))
+        cg_opt_val[i] = false;
+    }
+}
+
+/* A helper function to check if CG_OPTS1 and CG_OPTS are identical. It returns
+   true if yes, false otherwise.  */
+
+static bool
+has_incompatible_cg_opts (bool *cg_opts1, bool *cg_opts2, unsigned num_cg_opts)
+{
+  unsigned i;
+
+  for (i = 0; i < num_cg_opts; i++)
+    {
+      if (cg_opts1[i] != cg_opts2[i])
+        return true;
+    }
+
+  return false;
+}
+
+/* Returns true if the command-line arguments stored in the given module-infos
+   are incompatible.  */
+bool
+incompatible_cl_args (struct gcov_module_info* mod_info1,
+		      struct gcov_module_info* mod_info2)
+{
+  char **warning_opts1 = XNEWVEC (char *, mod_info1->num_cl_args);
+  char **warning_opts2 = XNEWVEC (char *, mod_info2->num_cl_args);
+  char **non_warning_opts1 = XNEWVEC (char *, mod_info1->num_cl_args);
+  char **non_warning_opts2 = XNEWVEC (char *, mod_info2->num_cl_args);
+  char *std_opts1 = NULL, *std_opts2 = NULL;
+  unsigned int i, num_warning_opts1 = 0, num_warning_opts2 = 0;
+  unsigned int num_non_warning_opts1 = 0, num_non_warning_opts2 = 0;
+  bool warning_mismatch = false;
+  bool non_warning_mismatch = false;
+  hash_table <string_hasher> option_tab1, option_tab2;
+  unsigned int start_index1 = mod_info1->num_quote_paths +
+    mod_info1->num_bracket_paths + mod_info1->num_cpp_defines +
+    mod_info1->num_cpp_includes;
+  unsigned int start_index2 = mod_info2->num_quote_paths +
+    mod_info2->num_bracket_paths + mod_info2->num_cpp_defines +
+    mod_info2->num_cpp_includes;
+
+  bool *cg_opts1, *cg_opts2, has_any_incompatible_cg_opts, has_incompatible_std;
+  unsigned int num_cg_opts = 0;
+
+  for (i = 0; force_matching_cg_opts[i].opt_str; i++)
+    num_cg_opts++;
+
+  cg_opts1 = XCNEWVEC (bool, num_cg_opts);
+  cg_opts2 = XCNEWVEC (bool, num_cg_opts);
+
+  /* Initialize the array to default value  */
+  for (i = 0; force_matching_cg_opts[i].opt_str; i++)
+    {
+      cg_opts1[i] = force_matching_cg_opts[i].default_val;
+      cg_opts2[i] = force_matching_cg_opts[i].default_val;
+    }
+
+  option_tab1.create (10);
+  option_tab2.create (10);
+
+  /* First, separate the warning and non-warning options.  */
+  for (i = 0; i < mod_info1->num_cl_args; i++)
+    if (mod_info1->string_array[start_index1 + i][1] == 'W')
+      warning_opts1[num_warning_opts1++] =
+	mod_info1->string_array[start_index1 + i];
+    else
+      {
+        char **slot;
+        char *option_string = mod_info1->string_array[start_index1 + i];
+
+        check_cg_opts (cg_opts1, option_string);
+	if (strstr (option_string, "-std="))
+	  std_opts1 = option_string;
+
+        slot = option_tab1.find_slot (option_string, INSERT);
+        if (!*slot)
+          {
+            *slot = option_string;
+            non_warning_opts1[num_non_warning_opts1++] = option_string;
+          }
+      }
+
+  for (i = 0; i < mod_info2->num_cl_args; i++)
+    if (mod_info2->string_array[start_index2 + i][1] == 'W')
+      warning_opts2[num_warning_opts2++] =
+	mod_info2->string_array[start_index2 + i];
+    else
+      {
+        char **slot;
+        char *option_string = mod_info2->string_array[start_index2 + i];
+
+        check_cg_opts (cg_opts2, option_string);
+	if (strstr (option_string, "-std="))
+	  std_opts2 = option_string;
+
+        slot = option_tab2.find_slot (option_string, INSERT);
+        if (!*slot)
+          {
+            *slot = option_string;
+            non_warning_opts2[num_non_warning_opts2++] = option_string;
+          }
+      }
+
+  has_incompatible_std =
+      std_opts1 != std_opts2 && (std_opts1 == NULL || std_opts2 == NULL
+				 || strcmp (std_opts1, std_opts2));
+
+  /* Compare warning options. If these mismatch, we emit a warning.  */
+  if (num_warning_opts1 != num_warning_opts2)
+    warning_mismatch = true;
+  else
+    for (i = 0; i < num_warning_opts1 && !warning_mismatch; i++)
+      warning_mismatch = strcmp (warning_opts1[i], warning_opts2[i]) != 0;
+
+  /* Compare non-warning options. If these mismatch, we emit a warning, and if
+     -fripa-disallow-opt-mismatch is supplied, the two modules are also
+     incompatible.  */
+  if (num_non_warning_opts1 != num_non_warning_opts2)
+    non_warning_mismatch = true;
+  else
+    for (i = 0; i < num_non_warning_opts1 && !non_warning_mismatch; i++)
+      non_warning_mismatch =
+	strcmp (non_warning_opts1[i], non_warning_opts2[i]) != 0;
+
+  if (warn_ripa_opt_mismatch && (warning_mismatch || non_warning_mismatch))
+    warning (OPT_Wripa_opt_mismatch, "command line arguments mismatch for %s "
+	     "and %s", mod_info1->source_filename, mod_info2->source_filename);
+
+   if (warn_ripa_opt_mismatch && non_warning_mismatch && dump_enabled_p ())
+     {
+       dump_printf_loc (MSG_MISSED_OPTIMIZATION, UNKNOWN_LOCATION,
+                        "Options for %s", mod_info1->source_filename);
+       for (i = 0; i < num_non_warning_opts1; i++)
+         dump_printf_loc (MSG_MISSED_OPTIMIZATION, UNKNOWN_LOCATION,
+                          non_warning_opts1[i]);
+       dump_printf_loc (MSG_MISSED_OPTIMIZATION, UNKNOWN_LOCATION,
+                        "Options for %s", mod_info2->source_filename);
+       for (i = 0; i < num_non_warning_opts2; i++)
+         dump_printf_loc (MSG_MISSED_OPTIMIZATION, UNKNOWN_LOCATION,
+                          non_warning_opts2[i]);
+     }
+
+   has_any_incompatible_cg_opts
+       = has_incompatible_cg_opts (cg_opts1, cg_opts2, num_cg_opts);
+
+   XDELETEVEC (warning_opts1);
+   XDELETEVEC (warning_opts2);
+   XDELETEVEC (non_warning_opts1);
+   XDELETEVEC (non_warning_opts2);
+   XDELETEVEC (cg_opts1);
+   XDELETEVEC (cg_opts2);
+   option_tab1.dispose ();
+   option_tab2.dispose ();
+   return ((flag_ripa_disallow_opt_mismatch && non_warning_mismatch)
+           || has_any_incompatible_cg_opts || has_incompatible_std);
+}
+
+
+/* Support for module sorting based on user specfication.  */
+struct module_name_entry
+{
+  typedef module_name_entry value_type;
+  typedef module_name_entry compare_type;
+  static inline hashval_t hash (const value_type *entry);
+  static inline int equal (const value_type *entry1, const compare_type *entry2);
+  static inline void remove (value_type *v);
+
+  const char *source_name;
+  int order;
+};
+
+/* Hash function for module name  */
+
+hashval_t
+module_name_entry::hash (const value_type *s)
+{
+  return htab_hash_string (s->source_name);
+}
+
+/* Delete function for module name  */
+
+void
+module_name_entry::remove (value_type  *entry)
+{
+  /* XDELETE (entry->source_name); */
+  XDELETE (entry);
+}
+
+/* Equal function for module name  */
+
+int
+module_name_entry::equal (const value_type *s1, const compare_type *s2)
+{
+  return !strcmp (s1->source_name, s2->source_name);
+}
+
+static  hash_table<module_name_entry> module_name_tab;
+
+/* Comparison function for sorting module_infos array.  */
+
+static int
+cmp_module_name_entry (const void *p1, const void *p2)
+{
+  module_name_entry **slot1, **slot2;
+  module_name_entry *m_e1, *m_e2;
+
+  struct gcov_module_info *const *e1 = (struct gcov_module_info *const *) p1;
+  struct gcov_module_info *const *e2 = (struct gcov_module_info *const *) p2;
+
+  module_name_entry e;
+  e.source_name = (*e1)->source_filename;
+  slot1 = module_name_tab.find_slot (&e, NO_INSERT);
+  e.source_name = (*e2)->source_filename;
+  slot2 = module_name_tab.find_slot (&e, NO_INSERT);
+
+  if (!slot1 || !*slot1)
+    return 1;
+
+  if (!slot2 || !*slot2)
+    return -1;
+
+  gcc_assert (slot1 && *slot1 && slot2 && *slot2);
+  m_e1 = *slot1;
+  m_e2 = *slot2;
+
+  return m_e1->order - m_e2->order;
+}
+
+/* Comparison function for sorting fname array  */
+
+static int
+cmp_fname_entry (const void *p1, const void *p2)
+{
+  module_name_entry **slot1, **slot2;
+  module_name_entry *m_e1, *m_e2;
+
+  const char *const *e1 = (const char *const *) p1;
+  const char *const *e2 = (const char *const *) p2;
+
+  module_name_entry e;
+
+  e.source_name = *e1;
+  slot1 = module_name_tab.find_slot (&e, NO_INSERT);
+  e.source_name = *e2;
+  slot2 = module_name_tab.find_slot (&e, NO_INSERT);
+
+  if (!slot1 || !*slot1)
+    return 1;
+
+  if (!slot2 || !*slot2)
+    return -1;
+
+  gcc_assert (slot1 && *slot1 && slot2 && *slot2);
+  m_e1 = *slot1;
+  m_e2 = *slot2;
+
+  return m_e1->order - m_e2->order;
+}
+
+/* Reorder module group according to file IMPORTS_FILE  */
+
+static void
+reorder_module_groups (const char *imports_file, unsigned max_group)
+{
+  FILE *f;
+  int n, order = 0;
+  size_t len;
+  char *line = NULL;
+
+  module_name_tab.create (20);
+
+  f = fopen (imports_file, "r");
+  if (!f)
+    error ("Can't open file %s", imports_file);
+
+  while ((n = getline (&line, &len, f)) != -1)
+    {
+      module_name_entry **slot;
+      module_name_entry *m_e = XCNEW (module_name_entry);
+
+      line[n - 1] = '\0';
+      m_e->source_name = line;
+      m_e->order = order;
+
+      slot = module_name_tab.find_slot (m_e, INSERT);
+      gcc_assert (!*slot);
+      *slot = m_e;
+
+      line = NULL;
+      order++;
+    }
+
+  /* Now do the sorting  */
+
+  qsort (&module_infos[1], num_in_fnames - 1, sizeof (void *),
+         cmp_module_name_entry);
+  qsort (&in_fnames[1], num_in_fnames - 1, sizeof (void *),
+         cmp_fname_entry);
+
+  {
+    unsigned i;
+
+    for (i = 0; i < num_in_fnames; i++)
+      fprintf (stderr, "*** %s (%s)\n", in_fnames[i],
+	       i < max_group ? "Kept":"Skipped");
+
+    for (i = 0; i < num_in_fnames; i++)
+      fprintf (stderr, "### %s (%s)\n", module_infos[i]->source_filename,
+	       i < max_group ? "Kept":"Skipped");
+
+  }
+
+  if (num_in_fnames > max_group)
+    num_in_fnames = max_group;
+
+  module_name_tab.dispose ();
+}
+
+typedef struct {
+  unsigned int mod_id;
+  const char *mod_name;
+} mod_id_to_name_t;
+
+static vec<mod_id_to_name_t> *mod_names;
+
+static void
+record_module_name (unsigned int mod_id, const char *name)
+{
+  mod_id_to_name_t t;
+
+  t.mod_id = mod_id;
+  t.mod_name = xstrdup (name);
+  if (!mod_names)
+    vec_alloc (mod_names, 10);
+  mod_names->safe_push (t);
+}
+
+/* Return the module name for module with MOD_ID.  */
+
+const char *
+get_module_name (unsigned int mod_id)
+{
+  size_t i;
+  mod_id_to_name_t *elt;
+
+  for (i = 0; mod_names->iterate (i, &elt); i++)
+    {
+      if (elt->mod_id == mod_id)
+        return elt->mod_name;
+    }
+
+  gcc_assert (0);
+  return NULL;
+}
+
+/* Read in the counts file, if available. DA_FILE_NAME is the
+   name of the gcda file, and MODULE_ID is the module id of the
+   associated source module.  */
 
 static void
-read_counts_file (void)
+read_counts_file (const char *da_file_name, unsigned module_id)
 {
   gcov_unsigned_t fn_ident = 0;
   struct gcov_summary summary;
   unsigned new_summary = 1;
   gcov_unsigned_t tag;
   int is_error = 0;
+  unsigned module_infos_read = 0;
+  struct pointer_set_t *modset = 0;
+  unsigned max_group = PARAM_VALUE (PARAM_MAX_LIPO_GROUP);
   unsigned lineno_checksum = 0;
   unsigned cfg_checksum = 0;
+  const char *imports_filename;
+
+  if (max_group == 0)
+    max_group = (unsigned) -1;
 
   if (!gcov_open (da_file_name, 1))
-    return;
+    {
+      if (PARAM_VALUE (PARAM_GCOV_DEBUG))
+        {
+          /* Try to find .gcda file in the current working dir.  */
+          da_file_name = lbasename (da_file_name);
+          if (!gcov_open (da_file_name, 1))
+            return;
+        }
+      else
+        return;
+    }
 
   if (!gcov_magic (gcov_read_unsigned (), GCOV_DATA_MAGIC))
     {
@@ -210,7 +697,9 @@ read_counts_file (void)
   tag = gcov_read_unsigned ();
   bbg_file_stamp = crc32_unsigned (bbg_file_stamp, tag);
 
-  counts_hash.create (10);
+  if (!counts_hash.is_created ())
+    counts_hash.create (10);
+
   while ((tag = gcov_read_unsigned ()))
     {
       gcov_unsigned_t length;
@@ -262,7 +751,7 @@ read_counts_file (void)
 	  unsigned n_counts = GCOV_TAG_COUNTER_NUM (length);
 	  unsigned ix;
 
-	  elt.ident = fn_ident;
+	  elt.ident = GEN_FUNC_GLOBAL_ID (module_id, fn_ident);
 	  elt.ctr = GCOV_COUNTER_FOR_TAG (tag);
 
 	  slot = counts_hash.find_slot (&elt, INSERT);
@@ -270,7 +759,7 @@ read_counts_file (void)
 	  if (!entry)
 	    {
 	      *slot = entry = XCNEW (counts_entry_t);
-	      entry->ident = fn_ident;
+	      entry->ident = elt.ident;
 	      entry->ctr = elt.ctr;
 	      entry->lineno_checksum = lineno_checksum;
 	      entry->cfg_checksum = cfg_checksum;
@@ -314,6 +803,132 @@ read_counts_file (void)
 	    entry->counts[ix] += gcov_read_counter ();
 	skip_merge:;
 	}
+      /* Skip the MODULE_INFO records if not in dyn-ipa mode, or when reading
+	 auxiliary modules.  */
+      else if (tag == GCOV_TAG_MODULE_INFO && flag_dyn_ipa && !module_id)
+        {
+	  struct gcov_module_info* mod_info;
+          size_t info_sz;
+          /* each string has at least 8 bytes, so MOD_INFO's
+             persistent length >= in core size.  */
+          mod_info
+              = (struct gcov_module_info *) alloca ((length + 2)
+                                                    * sizeof (gcov_unsigned_t));
+	  gcov_read_module_info (mod_info, length);
+          info_sz = (sizeof (struct gcov_module_info) +
+		     sizeof (void *) * (mod_info->num_quote_paths +
+					mod_info->num_bracket_paths +
+					mod_info->num_cpp_defines +
+					mod_info->num_cpp_includes +
+					mod_info->num_cl_args));
+	  /* The first MODULE_INFO record must be for the primary module.  */
+	  if (module_infos_read == 0)
+	    {
+	      gcc_assert (mod_info->is_primary && !modset);
+	      module_infos_read++;
+              modset = pointer_set_create ();
+              pointer_set_insert (modset, (void *)(size_t)mod_info->ident);
+	      primary_module_id = mod_info->ident;
+              include_all_aux = MODULE_INCLUDE_ALL_AUX_FLAG (mod_info);
+              module_infos = XCNEWVEC (struct gcov_module_info *, 1);
+              module_infos[0] = XCNEWVAR (struct gcov_module_info, info_sz);
+              memcpy (module_infos[0], mod_info, info_sz);
+	    }
+	  else
+            {
+	      int fd;
+	      char *aux_da_filename = get_da_file_name (mod_info->da_filename);
+              gcc_assert (!mod_info->is_primary);
+	      if (pointer_set_insert (modset, (void *)(size_t)mod_info->ident))
+                {
+                  if (dump_enabled_p ())
+                    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, input_location,
+                                     "Not importing %s: already imported",
+                                     mod_info->source_filename);
+                }
+	      else if ((module_infos[0]->lang & GCOV_MODULE_LANG_MASK) !=
+		       (mod_info->lang & GCOV_MODULE_LANG_MASK))
+                {
+                  if (dump_enabled_p ())
+                    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, input_location,
+                                     "Not importing %s: source language"
+                                     " different from primary module's source"
+                                     " language",
+                                     mod_info->source_filename);
+                }
+	      else if (module_infos_read == max_group
+                       /* If reordering is specified, delay the cutoff
+			  until after sorting.  */
+		       && !getenv ("LIPO_REORDER_GROUP"))
+                {
+                  if (dump_enabled_p ())
+                    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, input_location,
+                                     "Not importing %s: maximum group size"
+                                     " reached", mod_info->source_filename);
+                }
+	      else if (incompatible_cl_args (module_infos[0], mod_info))
+                {
+                  if (dump_enabled_p ())
+                    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, input_location,
+                                     "Not importing %s: command-line"
+                                     " arguments not compatible with primary"
+                                     " module",
+                                     mod_info->source_filename);
+                }
+	      else if ((fd = open (aux_da_filename, O_RDONLY)) < 0)
+                {
+                  if (dump_enabled_p ())
+                    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, input_location,
+                                     "Not importing %s: couldn't open %s",
+                                     mod_info->source_filename,
+                                     aux_da_filename);
+                }
+	      else if ((mod_info->lang & GCOV_MODULE_ASM_STMTS)
+		       && flag_ripa_disallow_asm_modules)
+                {
+                  if (dump_enabled_p ())
+                    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, input_location,
+                                     "Not importing %s: contains assembler"
+                                     " statements", mod_info->source_filename);
+                }
+              else if (mod_info->is_primary == false 
+                       && MODULE_EXPORTED_FLAG (mod_info) == false)
+                {
+                  warning (0, "MODULE_ID=%d (%s) is an auxiliary module, "
+                              "but export_bit is not set. \n",
+                              mod_info->ident, mod_info->source_filename);
+                }
+	      else
+		{
+		  close (fd);
+		  module_infos_read++;
+		  add_input_filename (mod_info->source_filename);
+		  module_infos = XRESIZEVEC (struct gcov_module_info *,
+					     module_infos, num_in_fnames);
+		  gcc_assert (num_in_fnames == module_infos_read);
+		  module_infos[module_infos_read - 1]
+		    = XCNEWVAR (struct gcov_module_info, info_sz);
+		  memcpy (module_infos[module_infos_read - 1], mod_info,
+			  info_sz);
+		}
+            }
+
+          record_module_name (mod_info->ident,
+                              lbasename (mod_info->source_filename));
+
+          if (dump_enabled_p ())
+            {
+              dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, input_location,
+                               "MODULE Id=%d, Is_Primary=%s,"
+                               " Is_Exported=%s, Include_all=%s, Name=%s (%s)",
+                               mod_info->ident, mod_info->is_primary?"yes":"no",
+                               MODULE_EXPORTED_FLAG (mod_info)?"yes":"no",
+                               MODULE_INCLUDE_ALL_AUX_FLAG (mod_info)?"yes"
+                                                                     :"no",
+                               mod_info->source_filename,
+                               mod_info->da_filename);
+            }
+        }
       gcov_sync (offset, length);
       if ((is_error = gcov_is_error ()))
 	{
@@ -324,9 +939,44 @@ read_counts_file (void)
 	}
     }
 
+  if ((imports_filename = getenv ("LIPO_REORDER_GROUP"))
+      && flag_dyn_ipa && !module_id)
+    {
+      reorder_module_groups (imports_filename, max_group);
+      if (module_infos_read != num_in_fnames)
+	module_infos_read = num_in_fnames;
+    }
+
+  /* TODO: profile based multiple module compilation does not work
+     together with command line (-combine) based ipo -- add a nice
+     warning and bail out instead of asserting.  */
+
+  if (modset)
+    pointer_set_destroy (modset);
+  gcc_assert (module_infos_read == 0
+              || module_infos_read == num_in_fnames);
+
+  if (flag_dyn_ipa)
+    gcc_assert (primary_module_id && num_in_fnames >= 1);
+
   gcov_close ();
 }
 
+/* Returns the coverage data entry for counter type COUNTER of function
+   FUNC. EXPECTED is the number of expected counter entries.  */
+
+static counts_entry_t *
+get_coverage_counts_entry (struct function *func, unsigned counter)
+{
+  counts_entry_t *entry, elt;
+
+  elt.ident = FUNC_DECL_GLOBAL_ID (func);
+  elt.ctr = counter;
+  entry = counts_hash.find (&elt);
+
+  return entry;
+}
+
 /* Returns the counters for a particular tag.  */
 
 gcov_type *
@@ -334,30 +984,35 @@ get_coverage_counts (unsigned counter, unsigned expected,
                      unsigned cfg_checksum, unsigned lineno_checksum,
 		     const struct gcov_ctr_summary **summary)
 {
-  counts_entry_t *entry, elt;
+  counts_entry_t *entry;
 
   /* No hash table, no counts.  */
   if (!counts_hash.is_created ())
     {
       static int warned = 0;
 
-      if (!warned++)
-	inform (input_location, (flag_guess_branch_prob
-		 ? "file %s not found, execution counts estimated"
-		 : "file %s not found, execution counts assumed to be zero"),
-		da_file_name);
+      if (!warned++ && dump_enabled_p ())
+	dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, input_location,
+                         (flag_guess_branch_prob
+                          ? "file %s not found, execution counts estimated"
+                          : "file %s not found, execution counts assumed to "
+                            "be zero"),
+                         da_file_name);
       return NULL;
     }
 
-  elt.ident = current_function_funcdef_no + 1;
-  elt.ctr = counter;
-  entry = counts_hash.find (&elt);
+  entry = get_coverage_counts_entry (cfun, counter);
+
   if (!entry || !entry->summary.num)
-    /* The function was not emitted, or is weak and not chosen in the
-       final executable.  Silently fail, because there's nothing we
-       can do about it.  */
-    return NULL;
-  
+    {
+      if (!flag_dyn_ipa && dump_enabled_p ())
+	dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, input_location,
+                         "no coverage for function %s found",
+                         IDENTIFIER_POINTER
+                         (DECL_ASSEMBLER_NAME (current_function_decl)));
+      return NULL;
+    }
+
   if (entry->cfg_checksum != cfg_checksum
       || entry->summary.num != expected)
     {
@@ -369,32 +1024,37 @@ get_coverage_counts (unsigned counter, unsigned expected,
 	warning_at (input_location, OPT_Wcoverage_mismatch,
 		    "the control flow of function %qE does not match "
 		    "its profile data (counter %qs)", id, ctr_names[counter]);
-      if (warning_printed)
+      if (warning_printed && dump_enabled_p ())
 	{
-	 inform (input_location, "use -Wno-error=coverage-mismatch to tolerate "
-	 	 "the mismatch but performance may drop if the function is hot");
+          dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, input_location,
+                           "use -Wno-error=coverage-mismatch to tolerate "
+                           "the mismatch but performance may drop if the "
+                           "function is hot");
 	  
 	  if (!seen_error ()
 	      && !warned++)
 	    {
-	      inform (input_location, "coverage mismatch ignored");
-	      inform (input_location, flag_guess_branch_prob
-		      ? G_("execution counts estimated")
-		      : G_("execution counts assumed to be zero"));
+	      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, input_location,
+                               "coverage mismatch ignored");
+	      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, input_location,
+                               flag_guess_branch_prob
+                               ? G_("execution counts estimated")
+                               : G_("execution counts assumed to be zero"));
 	      if (!flag_guess_branch_prob)
-		inform (input_location,
-			"this can result in poorly optimized code");
+		dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, input_location,
+                                 "this can result in poorly optimized code");
 	    }
 	}
 
       return NULL;
     }
-  else if (entry->lineno_checksum != lineno_checksum)
-    {
-      warning (0, "source locations for function %qE have changed,"
-	       " the profile data may be out of date",
-	       DECL_ASSEMBLER_NAME (current_function_decl));
-    }
+    else if (entry->lineno_checksum != lineno_checksum)
+      {
+        warning (OPT_Wripa_opt_mismatch,
+                 "Source location for function %qE have changed,"
+                 " the profile data may be out of date",
+                 DECL_ASSEMBLER_NAME (current_function_decl));
+      }
 
   if (summary)
     *summary = &entry->summary;
@@ -402,6 +1062,28 @@ get_coverage_counts (unsigned counter, unsigned expected,
   return entry->counts;
 }
 
+/* Returns the coverage data entry for counter type COUNTER of function
+   FUNC. On return, *N_COUNTS is set to the number of entries in the counter.  */
+
+gcov_type *
+get_coverage_counts_no_warn (struct function *f, unsigned counter, unsigned *n_counts)
+{
+  counts_entry_t *entry, elt;
+
+  /* No hash table, no counts.  */
+  if (!counts_hash.is_created () || !f)
+    return NULL;
+
+  elt.ident = FUNC_DECL_GLOBAL_ID (f);
+  elt.ctr = counter;
+  entry = counts_hash.find (&elt);
+  if (!entry)
+    return NULL;
+
+  *n_counts = entry->summary.num;
+  return entry->counts;
+}
+
 /* Allocate NUM counters of type COUNTER. Returns nonzero if the
    allocation succeeded.  */
 
@@ -463,6 +1145,26 @@ tree_coverage_counter_addr (unsigned counter, unsigned no)
 }
 
 
+/* Generate a crc32 of a string with specified STR_LEN when it's not 0.
+   Non-zero STR_LEN should only be seen in LIPO mode.  */
+
+static unsigned
+crc32_string_1 (unsigned chksum, const char *string, unsigned str_len)
+{
+  char *dup;
+
+  if (!L_IPO_COMP_MODE || str_len == 0)
+    return crc32_string (chksum, string);
+
+  gcc_assert (str_len > 0 && str_len < strlen (string));
+  dup = xstrdup (string);
+  dup[str_len] = 0;
+  chksum = crc32_string (chksum, dup);
+  free (dup);
+
+  return chksum;
+}
+
 /* Generate a checksum for a string.  CHKSUM is the current
    checksum.  */
 
@@ -471,6 +1173,25 @@ coverage_checksum_string (unsigned chksum, const char *string)
 {
   int i;
   char *dup = NULL;
+  unsigned lipo_orig_str_len = 0;
+
+  /* Strip out the ending ".cmo.[0-9]*" string from function
+     name. Otherwise we will have lineno checksum mismatch.  */
+  if (L_IPO_COMP_MODE)
+    {
+      int len;
+
+      i = len = strlen (string);
+      while (i--)
+        if ((string[i] < '0' || string[i] > '9'))
+          break;
+      if ((i > 5) && (i != len - 1))
+        {
+          if (!strncmp (string + i - 4, ".cmo.", 5))
+            lipo_orig_str_len = i - 4;
+        }
+
+    }
 
   /* Look for everything that looks if it were produced by
      get_file_function_name and zero out the second part
@@ -517,8 +1238,9 @@ coverage_checksum_string (unsigned chksum, const char *string)
 	}
     }
 
-  chksum = crc32_string (chksum, string);
-  free (dup);
+  chksum = crc32_string_1 (chksum, string, lipo_orig_str_len);
+  if (dup)
+    free (dup);
 
   return chksum;
 }
@@ -528,13 +1250,32 @@ coverage_checksum_string (unsigned chksum, const char *string)
 unsigned
 coverage_compute_lineno_checksum (void)
 {
+  tree name;
   expanded_location xloc
     = expand_location (DECL_SOURCE_LOCATION (current_function_decl));
   unsigned chksum = xloc.line;
+  const char *pathless_filename = xloc.file;
+  int i;
+  for (i = strlen (xloc.file); i >= 0; i--)
+    if (IS_DIR_SEPARATOR (pathless_filename[i]))
+      {
+	pathless_filename += i + 1;
+	break;
+      }
+
+  chksum = coverage_checksum_string (chksum, pathless_filename);
+
+  /* Note: it is a bad design that C++ FE associate the convertion function type
+     with the name of the decl. This leads to cross contamination between different
+     conversion operators in different modules (If conv_type_names map is cleared
+     at the end of parsing of each module).  */
+  if (flag_dyn_ipa && lang_hooks.user_conv_function_p (current_function_decl))
+    name = DECL_ASSEMBLER_NAME (current_function_decl);
+  else
+    name = DECL_NAME (current_function_decl);
 
-  chksum = coverage_checksum_string (chksum, xloc.file);
   chksum = coverage_checksum_string
-    (chksum, IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (current_function_decl)));
+      (chksum, IDENTIFIER_POINTER (name));
 
   return chksum;
 }
@@ -587,7 +1328,7 @@ coverage_begin_function (unsigned lineno_checksum, unsigned cfg_checksum)
 
   /* Announce function */
   offset = gcov_write_tag (GCOV_TAG_FUNCTION);
-  gcov_write_unsigned (current_function_funcdef_no + 1);
+  gcov_write_unsigned (FUNC_DECL_FUNC_ID (cfun));
   gcov_write_unsigned (lineno_checksum);
   gcov_write_unsigned (cfg_checksum);
   gcov_write_string (IDENTIFIER_POINTER
@@ -625,7 +1366,7 @@ coverage_end_function (unsigned lineno_checksum, unsigned cfg_checksum)
 	{
 	  item = ggc_alloc_coverage_data ();
 	  
-	  item->ident = current_function_funcdef_no + 1;
+	  item->ident = FUNC_DECL_FUNC_ID (cfun);
 	  item->lineno_checksum = lineno_checksum;
 	  item->cfg_checksum = cfg_checksum;
 
@@ -659,32 +1400,96 @@ coverage_end_function (unsigned lineno_checksum, unsigned cfg_checksum)
     }
 }
 
-/* Build a coverage variable of TYPE for function FN_DECL.  If COUNTER
-   >= 0 it is a counter array, otherwise it is the function structure.  */
+/* True if a function entry corresponding to the given FN_IDENT
+   is present in the coverage internal data structures.  */
 
-static tree
-build_var (tree fn_decl, tree type, int counter)
+bool
+coverage_function_present (unsigned fn_ident)
 {
-  tree var = build_decl (BUILTINS_LOCATION, VAR_DECL, NULL_TREE, type);
-  const char *fn_name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (fn_decl));
-  char *buf;
-  size_t fn_name_len, len;
+  struct coverage_data *item = functions_head;
+  while (item && item->ident != fn_ident)
+    item = item->next;
+  return item != NULL;
+}
 
-  fn_name = targetm.strip_name_encoding (fn_name);
-  fn_name_len = strlen (fn_name);
-  buf = XALLOCAVEC (char, fn_name_len + 8 + sizeof (int) * 3);
+/* Update function and program direct-call coverage counts.  */
 
-  if (counter < 0)
-    strcpy (buf, "__gcov__");
-  else
-    sprintf (buf, "__gcov%u_", counter);
-  len = strlen (buf);
-#ifndef NO_DOT_IN_LABEL
-  buf[len - 1] = '.';
-#elif !defined NO_DOLLAR_IN_LABEL
-  buf[len - 1] = '$';
-#endif
-  memcpy (buf + len, fn_name, fn_name_len + 1);
+void
+coverage_dc_end_function (void)
+{
+  tree var;
+
+  if (fn_ctr_mask)
+    {
+      const unsigned idx = GCOV_COUNTER_DIRECT_CALL;
+      struct coverage_data *item = functions_head;
+      while (item && item->ident != (unsigned) FUNC_DECL_FUNC_ID (cfun))
+	item = item->next;
+
+      /* If a matching function entry hasn't been found, either this function
+	 has had no coverage counts added in the profile pass, or this
+	 is a new function (function versioning, etc). Create a new entry.  */
+      if (!item)
+	{
+          int cnt;
+
+	  item = ggc_alloc_coverage_data ();
+	  *functions_tail = item;
+	  functions_tail = &item->next;
+	  item->next = 0;
+	  item->ident = FUNC_DECL_FUNC_ID (cfun);
+	  item->fn_decl = current_function_decl;
+	  item->lineno_checksum = coverage_compute_lineno_checksum ();
+	  item->cfg_checksum = coverage_compute_cfg_checksum ();
+          for (cnt = 0; cnt < GCOV_COUNTERS; cnt++)
+            item->ctr_vars[cnt] = NULL_TREE;
+	}
+
+      var = fn_v_ctrs[idx];
+      item->ctr_vars[idx] = var;
+      if (var)
+        {
+          tree array_type = build_index_type (size_int (fn_n_ctrs[idx] - 1));
+          array_type = build_array_type (get_gcov_type (), array_type);
+          TREE_TYPE (var) = array_type;
+          DECL_SIZE (var) = TYPE_SIZE (array_type);
+          DECL_SIZE_UNIT (var) = TYPE_SIZE_UNIT (array_type);
+          varpool_finalize_decl (var);
+        }
+
+      fn_n_ctrs[idx] = fn_b_ctrs[idx] = 0;
+      fn_v_ctrs[idx] = NULL_TREE;
+      prg_ctr_mask |= fn_ctr_mask;
+      fn_ctr_mask = 0;
+    }
+}
+
+/* Build a coverage variable of TYPE for function FN_DECL.  If COUNTER
+   >= 0 it is a counter array, otherwise it is the function structure.  */
+
+static tree
+build_var (tree fn_decl, tree type, int counter)
+{
+  tree var = build_decl (BUILTINS_LOCATION, VAR_DECL, NULL_TREE, type);
+  const char *fn_name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (fn_decl));
+  char *buf;
+  size_t fn_name_len, len;
+
+  fn_name = targetm.strip_name_encoding (fn_name);
+  fn_name_len = strlen (fn_name);
+  buf = XALLOCAVEC (char, fn_name_len + 8 + sizeof (int) * 3);
+
+  if (counter < 0)
+    strcpy (buf, "__gcov__");
+  else
+    sprintf (buf, "__gcov%u_", counter);
+  len = strlen (buf);
+#ifndef NO_DOT_IN_LABEL
+  buf[len - 1] = '.';
+#elif !defined NO_DOLLAR_IN_LABEL
+  buf[len - 1] = '$';
+#endif
+  memcpy (buf + len, fn_name, fn_name_len + 1);
   DECL_NAME (var) = get_identifier (buf);
   TREE_STATIC (var) = 1;
   TREE_ADDRESSABLE (var) = 1;
@@ -703,18 +1508,18 @@ build_fn_info_type (tree type, unsigned counters, tree gcov_info_type)
   tree array_type;
 
   gcc_assert (counters);
-  
+
   /* ctr_info::num */
   field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE,
 		      get_gcov_unsigned_t ());
   fields = field;
-  
+
   /* ctr_info::values */
   field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE,
 		      build_pointer_type (get_gcov_type ()));
   DECL_CHAIN (field) = fields;
   fields = field;
-  
+
   finish_builtin_struct (ctr_info, "__gcov_ctr_info", fields, NULL_TREE);
 
   /* key */
@@ -722,13 +1527,13 @@ build_fn_info_type (tree type, unsigned counters, tree gcov_info_type)
 		      build_pointer_type (build_qualified_type
 					  (gcov_info_type, TYPE_QUAL_CONST)));
   fields = field;
-  
+
   /* ident */
   field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE,
 		      get_gcov_unsigned_t ());
   DECL_CHAIN (field) = fields;
   fields = field;
-  
+
   /* lineno_checksum */
   field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE,
 		      get_gcov_unsigned_t ());
@@ -811,6 +1616,12 @@ build_fn_info (const struct coverage_data *data, tree type, tree key)
 				  build_fold_addr_expr (var));
 	
 	CONSTRUCTOR_APPEND_ELT (v2, NULL, build_constructor (ctr_type, ctr));
+
+        /* In LIPO mode, coverage_finish is called late when pruning can not be
+         * done, so we need to force emitting counter variables even for
+         * eliminated functions to avoid unsat.  */
+        if (flag_dyn_ipa && var)
+          varpool_finalize_decl (var);
       }
   
   CONSTRUCTOR_APPEND_ELT (v1, fields,
@@ -826,7 +1637,7 @@ static void
 build_info_type (tree type, tree fn_info_ptr_type)
 {
   tree field, fields = NULL_TREE;
-  tree merge_fn_type;
+  tree merge_fn_type, mod_type;
 
   /* Version ident */
   field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE,
@@ -834,6 +1645,13 @@ build_info_type (tree type, tree fn_info_ptr_type)
   DECL_CHAIN (field) = fields;
   fields = field;
 
+  /* mod_info */
+  mod_type = build_gcov_module_info_type ();
+  mod_type = build_pointer_type (mod_type);
+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE, mod_type);
+  DECL_CHAIN (field) = fields;
+  fields = field;
+
   /* next pointer */
   field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE,
 		      build_pointer_type (build_qualified_type
@@ -854,6 +1672,12 @@ build_info_type (tree type, tree fn_info_ptr_type)
   DECL_CHAIN (field) = fields;
   fields = field;
 
+  /* eof_pos */
+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL,
+                      NULL_TREE, get_gcov_unsigned_t ());
+  DECL_CHAIN (field) = fields;
+  fields = field;
+
   /* merge fn array */
   merge_fn_type
     = build_function_type_list (void_type_node,
@@ -884,6 +1708,359 @@ build_info_type (tree type, tree fn_info_ptr_type)
   finish_builtin_struct (type, "__gcov_info", fields, NULL_TREE);
 }
 
+/* Compute an array (tree) of include path strings. STRING_TYPE is
+   the path string type, INC_PATH_VALUE is the initial value of the
+   path array, PATHS gives raw path string values, and NUM is the
+   number of paths.  */
+
+static void
+build_inc_path_array_value (tree string_type, vec<constructor_elt, va_gc> **v,
+                            cpp_dir *paths, int num)
+{
+  int i;
+  cpp_dir *pdir;
+  for (i = 0, pdir = paths; i < num; pdir = pdir->next)
+    {
+      const char *path_raw_string;
+      int path_string_length;
+      tree path_string;
+      path_raw_string = pdir->name;
+      path_string_length = strlen (path_raw_string);
+      path_string = build_string (path_string_length + 1, path_raw_string);
+      TREE_TYPE (path_string) = build_array_type
+          (char_type_node, build_index_type
+           (build_int_cst (NULL_TREE, path_string_length)));
+      CONSTRUCTOR_APPEND_ELT (*v, NULL,
+                              build1 (ADDR_EXPR, string_type, path_string));
+      i++;
+    }
+}
+
+/* Compute an array (tree) of strings. STR_TYPE is the string type,
+   STR_ARRAY_VALUE is the initial value of the string array, and HEAD gives
+   the list of raw strings.  */
+
+static void
+build_str_array_value (tree str_type, vec<constructor_elt, va_gc> **v,
+                       struct str_list *head)
+{
+  const char *raw_str;
+  int str_length;
+  while (head)
+    {
+      tree str;
+      raw_str = head->str;
+      str_length = strlen (raw_str);
+      str = build_string (str_length + 1, raw_str);
+      TREE_TYPE (str) =
+	build_array_type (char_type_node,
+			  build_index_type (build_int_cst (NULL_TREE,
+							   str_length)));
+      CONSTRUCTOR_APPEND_ELT (*v, NULL,
+                              build1 (ADDR_EXPR, str_type, str));
+      head = head->next;
+    }
+  return;
+}
+
+/* Compute an array (tree) of command-line argument strings. STRING_TYPE is
+   the string type, CL_ARGS_VALUE is the initial value of the command-line
+   args array. */
+
+static void
+build_cl_args_array_value (tree string_type, vec<constructor_elt, va_gc> **v)
+{
+  unsigned int i;
+
+  for (i = 0; i < num_lipo_cl_args; i++)
+    {
+      int arg_length = strlen (lipo_cl_args[i]);
+      tree arg_string = build_string (arg_length + 1, lipo_cl_args[i]);
+      TREE_TYPE (arg_string) =
+	build_array_type (char_type_node,
+			  build_index_type (build_int_cst (NULL_TREE,
+							   arg_length)));
+      CONSTRUCTOR_APPEND_ELT (*v, NULL,
+			       build1 (ADDR_EXPR, string_type, arg_string));
+    }
+  return;
+}
+
+/* Returns the type of the module info associated with the
+   current source module being compiled.  */
+
+static tree
+build_gcov_module_info_type (void)
+{
+  tree type, field, fields = NULL_TREE;
+  tree string_type, index_type, string_array_type;
+
+  cpp_dir *quote_paths, *bracket_paths, *pdir;
+  int num_quote_paths = 0, num_bracket_paths = 0;
+
+  type = lang_hooks.types.make_type (RECORD_TYPE);
+  string_type = build_pointer_type (
+      build_qualified_type (char_type_node,
+                            TYPE_QUAL_CONST));
+
+  /* ident */
+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL,
+                      NULL_TREE, get_gcov_unsigned_t ());
+  DECL_CHAIN (field) = fields;
+  fields = field;
+
+  /* is_primary */
+  /* We also overload this field to store a flag that indicates whether this
+     module was built in regular FDO or LIPO mode (-fripa). When reading this
+     field from a GCDA file, it should be used as the IS_PRIMARY flag. When
+     reading this field from the binary's data section, it should be used
+     as a FDO/LIPO flag.  */
+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL,
+                      NULL_TREE, get_gcov_unsigned_t ());
+  DECL_CHAIN (field) = fields;
+  fields = field;
+
+  /* flags: is_exported and include_all_aux flag.  */
+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL,
+                      NULL_TREE, get_gcov_unsigned_t ());
+  DECL_CHAIN (field) = fields;
+  fields = field;
+
+  /* lang field */
+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL,
+                      NULL_TREE, get_gcov_unsigned_t ());
+  DECL_CHAIN (field) = fields;
+  fields = field;
+
+  /* ggc_memory field */
+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL,
+                      NULL_TREE, get_gcov_unsigned_t ());
+  DECL_CHAIN (field) = fields;
+  fields = field;
+
+  /* da_filename */
+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL,
+                      NULL_TREE, string_type);
+  DECL_CHAIN (field) = fields;
+  fields = field;
+
+  /* Source name */
+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL,
+                      NULL_TREE, string_type);
+  DECL_CHAIN (field) = fields;
+  fields = field;
+
+  /* Num quote paths  */
+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL,
+                      NULL_TREE, get_gcov_unsigned_t ());
+  DECL_CHAIN (field) = fields;
+  fields = field;
+
+  /* Num bracket paths  */
+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL,
+                      NULL_TREE, get_gcov_unsigned_t ());
+  DECL_CHAIN (field) = fields;
+  fields = field;
+
+  /* Num -D/-U options.  */
+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL,
+                      NULL_TREE, get_gcov_unsigned_t ());
+  DECL_CHAIN (field) = fields;
+  fields = field;
+
+  /* Num -imacro/-include options.  */
+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL, NULL_TREE,
+		      get_gcov_unsigned_t ());
+  DECL_CHAIN (field) = fields;
+  fields = field;
+
+  /* Num command-line args.  */
+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL,
+		      NULL_TREE, get_gcov_unsigned_t ());
+  DECL_CHAIN (field) = fields;
+  fields = field;
+
+  get_include_chains (&quote_paths, &bracket_paths);
+  for (pdir = quote_paths; pdir; pdir = pdir->next)
+    {
+      if (pdir == bracket_paths)
+        break;
+      num_quote_paths++;
+    }
+  for (pdir = bracket_paths; pdir; pdir = pdir->next)
+    num_bracket_paths++;
+
+  /* string array  */
+  index_type = build_index_type (build_int_cst (NULL_TREE,
+						num_quote_paths	+
+						num_bracket_paths +
+						num_cpp_defines +
+						num_cpp_includes +
+						num_lipo_cl_args));
+  string_array_type = build_array_type (string_type, index_type);
+  field = build_decl (BUILTINS_LOCATION, FIELD_DECL,
+                      NULL_TREE, string_array_type);
+  DECL_CHAIN (field) = fields;
+  fields = field;
+
+  finish_builtin_struct (type, "__gcov_module_info", fields, NULL_TREE);
+
+  return type;
+}
+
+/* Returns the value of the module info associated with the
+   current source module being compiled.  */
+
+static tree
+build_gcov_module_info_value (tree mod_type)
+{
+  tree info_fields, mod_info;
+  tree value = NULL_TREE;
+  int file_name_len;
+  tree filename_string, string_array_type,  string_type;
+  cpp_dir *quote_paths, *bracket_paths, *pdir;
+  int num_quote_paths = 0, num_bracket_paths = 0;
+  unsigned lang;
+  char name_buf[50];
+  vec<constructor_elt,va_gc> *v = NULL, *path_v = NULL;
+
+  info_fields = TYPE_FIELDS (mod_type);
+
+  /* ident */
+  CONSTRUCTOR_APPEND_ELT (v, info_fields,
+                          build_int_cstu (get_gcov_unsigned_t (), 0));
+
+  info_fields = DECL_CHAIN (info_fields);
+
+  /* is_primary */
+  /* We also overload this field to store a flag that indicates whether this
+     module was built in regular FDO or LIPO mode (-fripa). When reading this
+     field from a GCDA file, it should be used as the IS_PRIMARY flag. When
+     reading this field from the binary's data section, it should be used
+     as a FDO/LIPO flag.  */
+  CONSTRUCTOR_APPEND_ELT (v, info_fields,
+                          build_int_cstu (get_gcov_unsigned_t (),
+                                          flag_dyn_ipa ? 1 : 0));
+  info_fields = DECL_CHAIN (info_fields);
+
+  /* flags */
+  CONSTRUCTOR_APPEND_ELT (v, info_fields,
+                          build_int_cstu (get_gcov_unsigned_t (), 0));
+  info_fields = DECL_CHAIN (info_fields);
+
+  /* lang field */
+  if (!strcmp (lang_hooks.name, "GNU C"))
+    lang = GCOV_MODULE_C_LANG;
+  else if (!strcmp (lang_hooks.name, "GNU C++"))
+    lang = GCOV_MODULE_CPP_LANG;
+  else
+    lang = GCOV_MODULE_UNKNOWN_LANG;
+  if (has_asm_statement)
+    lang |= GCOV_MODULE_ASM_STMTS;
+
+  CONSTRUCTOR_APPEND_ELT (v, info_fields,
+                          build_int_cstu (get_gcov_unsigned_t (), lang));
+  info_fields = DECL_CHAIN (info_fields);
+
+  /* ggc_memory field */
+  CONSTRUCTOR_APPEND_ELT (v, info_fields,
+                          build_int_cstu (get_gcov_unsigned_t (), ggc_total_memory));
+  info_fields = DECL_CHAIN (info_fields);
+
+  /* da_filename */
+
+  string_type = TREE_TYPE (info_fields);
+  file_name_len = strlen (da_base_file_name);
+  filename_string = build_string (file_name_len + 1, da_base_file_name);
+  TREE_TYPE (filename_string) = build_array_type
+    (char_type_node, build_index_type
+     (build_int_cst (NULL_TREE, file_name_len)));
+  CONSTRUCTOR_APPEND_ELT (v, info_fields,
+                          build1 (ADDR_EXPR, string_type, filename_string));
+  info_fields = DECL_CHAIN (info_fields);
+
+  /* Source name */
+
+  file_name_len = strlen (main_input_file_name);
+  filename_string = build_string (file_name_len + 1, main_input_file_name);
+  TREE_TYPE (filename_string) = build_array_type
+    (char_type_node, build_index_type
+     (build_int_cst (NULL_TREE, file_name_len)));
+  CONSTRUCTOR_APPEND_ELT (v, info_fields,
+                          build1 (ADDR_EXPR, string_type, filename_string));
+  info_fields = DECL_CHAIN (info_fields);
+
+  get_include_chains (&quote_paths, &bracket_paths);
+  for (pdir = quote_paths; pdir; pdir = pdir->next)
+    {
+      if (pdir == bracket_paths)
+        break;
+      num_quote_paths++;
+    }
+  for (pdir = bracket_paths; pdir; pdir = pdir->next)
+    num_bracket_paths++;
+
+  /* Num quote paths  */
+  CONSTRUCTOR_APPEND_ELT (v, info_fields,
+                          build_int_cstu (get_gcov_unsigned_t (),
+                                          num_quote_paths));
+  info_fields = DECL_CHAIN (info_fields);
+
+  /* Num bracket paths  */
+  CONSTRUCTOR_APPEND_ELT (v, info_fields,
+                          build_int_cstu (get_gcov_unsigned_t (),
+                                          num_bracket_paths));
+  info_fields = DECL_CHAIN (info_fields);
+
+  /* Num -D/-U options.  */
+  CONSTRUCTOR_APPEND_ELT (v, info_fields,
+                          build_int_cstu (get_gcov_unsigned_t (),
+                                          num_cpp_defines));
+  info_fields = DECL_CHAIN (info_fields);
+
+  /* Num -imacro/-include options.  */
+  CONSTRUCTOR_APPEND_ELT (v, info_fields,
+                          build_int_cstu (get_gcov_unsigned_t (),
+                                          num_cpp_includes));
+  info_fields = DECL_CHAIN (info_fields);
+
+  /* Num command-line args.  */
+  CONSTRUCTOR_APPEND_ELT (v, info_fields,
+                          build_int_cstu (get_gcov_unsigned_t (),
+                                          num_lipo_cl_args));
+  info_fields = DECL_CHAIN (info_fields);
+
+  /* string array  */
+  string_array_type = TREE_TYPE (info_fields);
+  build_inc_path_array_value (string_type, &path_v,
+                              quote_paths, num_quote_paths);
+  build_inc_path_array_value (string_type, &path_v,
+                              bracket_paths, num_bracket_paths);
+  build_str_array_value (string_type, &path_v,
+                         cpp_defines_head);
+  build_str_array_value (string_type, &path_v,
+                         cpp_includes_head);
+  build_cl_args_array_value (string_type, &path_v);
+  CONSTRUCTOR_APPEND_ELT (v, info_fields,
+                          build_constructor (string_array_type, path_v));
+  info_fields = DECL_CHAIN (info_fields);
+
+  gcc_assert (!info_fields);
+  value = build_constructor (mod_type, v);
+
+  mod_info = build_decl (BUILTINS_LOCATION, VAR_DECL,
+                         NULL_TREE, TREE_TYPE (value));
+  TREE_STATIC (mod_info) = 1;
+  ASM_GENERATE_INTERNAL_LABEL (name_buf, "MODINFO", 0);
+  DECL_NAME (mod_info) = get_identifier (name_buf);
+  DECL_INITIAL (mod_info) = value;
+
+  /* Build structure.  */
+  varpool_finalize_decl (mod_info);
+
+  return mod_info;
+}
+
 /* Returns a CONSTRUCTOR for the gcov_info object.  INFO_TYPE is the
    gcov_info structure type, FN_ARY is the array of pointers to
    function info objects.  */
@@ -894,6 +2071,7 @@ build_info (tree info_type, tree fn_ary)
   tree info_fields = TYPE_FIELDS (info_type);
   tree merge_fn_type, n_funcs;
   unsigned ix;
+  tree mod_value = NULL_TREE;
   tree filename_string;
   int da_file_name_len;
   vec<constructor_elt, va_gc> *v1 = NULL;
@@ -905,6 +2083,14 @@ build_info (tree info_type, tree fn_ary)
 					  GCOV_VERSION));
   info_fields = DECL_CHAIN (info_fields);
 
+  /* mod_info */
+  mod_value = build_gcov_module_info_value (TREE_TYPE (TREE_TYPE (info_fields)));
+  mod_value = build1 (ADDR_EXPR,
+          build_pointer_type (TREE_TYPE (mod_value)),
+          mod_value);
+  CONSTRUCTOR_APPEND_ELT (v1, info_fields, mod_value);
+  info_fields = DECL_CHAIN (info_fields);
+
   /* next -- NULL */
   CONSTRUCTOR_APPEND_ELT (v1, info_fields, null_pointer_node);
   info_fields = DECL_CHAIN (info_fields);
@@ -925,6 +2111,11 @@ build_info (tree info_type, tree fn_ary)
 				  filename_string));
   info_fields = DECL_CHAIN (info_fields);
 
+  /* eof_pos */
+  CONSTRUCTOR_APPEND_ELT (v1, info_fields,
+                          build_int_cstu (TREE_TYPE (info_fields), 0));
+  info_fields = DECL_CHAIN (info_fields);
+
   /* merge fn array -- NULL slots indicate unmeasured counters */
   merge_fn_type = TREE_TYPE (TREE_TYPE (info_fields));
   for (ix = 0; ix != GCOV_COUNTERS; ix++)
@@ -967,14 +2158,39 @@ build_info (tree info_type, tree fn_ary)
   return build_constructor (info_type, v1);
 }
 
-/* Create the gcov_info types and object.  Generate the constructor
-   function to call __gcov_init.  Does not generate the initializer
+/* Generate the constructor function to call __gcov_init.  */
+
+static void
+build_init_ctor (tree gcov_info_type)
+{
+  tree ctor, stmt, init_fn;
+
+  /* Build a decl for __gcov_init.  */
+  init_fn = build_pointer_type (gcov_info_type);
+  init_fn = build_function_type_list (void_type_node, init_fn, NULL);
+  init_fn = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,
+			get_identifier ("__gcov_init"), init_fn);
+  TREE_PUBLIC (init_fn) = 1;
+  DECL_EXTERNAL (init_fn) = 1;
+  DECL_ASSEMBLER_NAME (init_fn);
+
+  /* Generate a call to __gcov_init(&gcov_info).  */
+  ctor = NULL;
+  stmt = build_fold_addr_expr (gcov_info_var);
+  stmt = build_call_expr (init_fn, 1, stmt);
+  append_to_statement_list (stmt, &ctor);
+
+  /* Generate a constructor to run it.  */
+  cgraph_build_static_cdtor ('I', ctor, DEFAULT_INIT_PRIORITY);
+}
+
+/* Create the gcov_info types and object. Does not generate the initializer
    for the object.  Returns TRUE if coverage data is being emitted.  */
 
 static bool
 coverage_obj_init (void)
 {
-  tree gcov_info_type, ctor, stmt, init_fn;
+  tree gcov_info_type;
   unsigned n_counters = 0;
   unsigned ix;
   struct coverage_data *fn;
@@ -990,12 +2206,15 @@ coverage_obj_init (void)
     fprintf (cgraph_dump_file, "Using data file %s\n", da_file_name);
 
   /* Prune functions.  */
-  for (fn_prev = &functions_head; (fn = *fn_prev);)
-    if (DECL_STRUCT_FUNCTION (fn->fn_decl))
-      fn_prev = &fn->next;
-    else
-      /* The function is not being emitted, remove from list.  */
-      *fn_prev = fn->next;
+  if (!flag_dyn_ipa)
+    /* in lipo mode, coverage_finish is called when function struct is cleared,
+       so pruning code here will skip all functions.  */
+    for (fn_prev = &functions_head; (fn = *fn_prev);)
+      if (DECL_STRUCT_FUNCTION (fn->fn_decl))
+        fn_prev = &fn->next;
+      else
+        /* The function is not being emitted, remove from list.  */
+        *fn_prev = fn->next;
 
   if (functions_head == NULL)
     return false;
@@ -1020,24 +2239,6 @@ coverage_obj_init (void)
   ASM_GENERATE_INTERNAL_LABEL (name_buf, "LPBX", 0);
   DECL_NAME (gcov_info_var) = get_identifier (name_buf);
 
-  /* Build a decl for __gcov_init.  */
-  init_fn = build_pointer_type (gcov_info_type);
-  init_fn = build_function_type_list (void_type_node, init_fn, NULL);
-  init_fn = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,
-			get_identifier ("__gcov_init"), init_fn);
-  TREE_PUBLIC (init_fn) = 1;
-  DECL_EXTERNAL (init_fn) = 1;
-  DECL_ASSEMBLER_NAME (init_fn);
-
-  /* Generate a call to __gcov_init(&gcov_info).  */
-  ctor = NULL;
-  stmt = build_fold_addr_expr (gcov_info_var);
-  stmt = build_call_expr (init_fn, 1, stmt);
-  append_to_statement_list (stmt, &ctor);
-
-  /* Generate a constructor to run it.  */
-  cgraph_build_static_cdtor ('I', ctor, DEFAULT_INIT_PRIORITY);
-
   return true;
 }
 
@@ -1060,7 +2261,8 @@ coverage_obj_fn (vec<constructor_elt, va_gc> *ctor, tree fn,
 }
 
 /* Finalize the coverage data.  Generates the array of pointers to
-   function objects from CTOR.  Generate the gcov_info initializer.  */
+   function objects from CTOR.  Generate the gcov_info initializer.
+   Generate the constructor function to call __gcov_init.  */
 
 static void
 coverage_obj_finish (vec<constructor_elt, va_gc> *ctor)
@@ -1078,43 +2280,340 @@ coverage_obj_finish (vec<constructor_elt, va_gc> *ctor)
   DECL_NAME (fn_info_ary) = get_identifier (name_buf);
   DECL_INITIAL (fn_info_ary) = build_constructor (fn_info_ary_type, ctor);
   varpool_finalize_decl (fn_info_ary);
-  
+
   DECL_INITIAL (gcov_info_var)
     = build_info (TREE_TYPE (gcov_info_var), fn_info_ary);
+
+  build_init_ctor (TREE_TYPE (gcov_info_var));
+
   varpool_finalize_decl (gcov_info_var);
 }
 
-/* Perform file-level initialization. Read in data file, generate name
-   of notes file.  */
+/* Get the da file name, given base file name.  */
 
-void
-coverage_init (const char *filename)
+static char *
+get_da_file_name (const char *base_file_name)
 {
-  int len = strlen (filename);
+  char *da_file_name;
+  int len = strlen (base_file_name);
+  const char *prefix = profile_data_prefix;
   int prefix_len = 0;
 
-  if (!profile_data_prefix && !IS_ABSOLUTE_PATH (filename))
-    profile_data_prefix = getpwd ();
+  if (profile_data_prefix == 0 && !IS_ABSOLUTE_PATH(&base_file_name[0]))
+    {
+      profile_data_prefix = getpwd ();
+      prefix = profile_data_prefix;
+    }
 
-  if (profile_data_prefix)
-    prefix_len = strlen (profile_data_prefix);
+  prefix_len = (prefix) ? strlen (prefix) + 1 : 0;
 
   /* Name of da file.  */
   da_file_name = XNEWVEC (char, len + strlen (GCOV_DATA_SUFFIX)
 			  + prefix_len + 2);
 
-  if (profile_data_prefix)
+  if (prefix)
+    {
+      strcpy (da_file_name, prefix);
+      da_file_name[prefix_len - 1] = '/';
+      da_file_name[prefix_len] = 0;
+    }
+  else
+    da_file_name[0] = 0;
+  strcat (da_file_name, base_file_name);
+  if (profile_base_name_suffix_to_strip)
+    {
+      int base_name_len = strlen (da_file_name);
+      int suffix_to_strip_len = strlen (profile_base_name_suffix_to_strip);
+
+      if (base_name_len > suffix_to_strip_len
+          && !strcmp (da_file_name + (base_name_len - suffix_to_strip_len),
+                      profile_base_name_suffix_to_strip))
+        da_file_name[base_name_len - suffix_to_strip_len] = '\0';
+    }
+
+  strcat (da_file_name, GCOV_DATA_SUFFIX);
+  return da_file_name;
+}
+
+/* Callback to move counts_entry from one hash table to
+   the target hashtable  */
+
+int
+move_hash_entry_callback (counts_entry **x, 
+                          hash_table <counts_entry> *target_counts_hash)
+{
+  counts_entry *entry = *x;
+  counts_entry **slot;
+  slot = target_counts_hash->find_slot (entry, INSERT);
+  *slot = entry;
+  return 1;
+}
+
+/* Rebuild counts_hash already built the primary module. This hashtable
+   was built with a module-id of zero. It needs to be rebuilt taking the
+   correct primary module-id into account.  */
+
+int
+rehash_callback (counts_entry **x,
+                 hash_table <counts_entry> *target_counts_hash)
+{
+  counts_entry *entry = *x;
+  counts_entry **slot;
+
+  entry->ident = GEN_FUNC_GLOBAL_ID (primary_module_id, entry->ident);
+  slot = target_counts_hash->find_slot (entry, INSERT);
+  *slot = entry;
+  return 1;
+}
+
+/* Rebuild counts_hash already built the primary module. This hashtable
+   was built with a module-id of zero. It needs to be rebuilt taking the
+   correct primary module-id into account.  */
+
+static void
+rebuild_counts_hash (void)
+{
+  hash_table <counts_entry> tmp_counts_hash;
+  tmp_counts_hash.create (10);
+  gcc_assert (primary_module_id);
+
+  rebuilding_counts_hash = true;
+
+  /* Move the counts entries to the temporary hashtable. */
+  counts_hash.traverse_noresize <
+    hash_table <counts_entry> *,
+    move_hash_entry_callback> (&tmp_counts_hash);
+  counts_hash.empty ();
+
+  /* Now rehash and copy back.  */
+  tmp_counts_hash.traverse_noresize <
+    hash_table <counts_entry> *,
+    rehash_callback> (&counts_hash);
+  tmp_counts_hash.dispose();
+
+  rebuilding_counts_hash = false;
+}
+
+/* Add the module information record for the module with id
+   MODULE_ID. IS_PRIMARY is true if the module is the primary module.
+   INDEX is the index of the new record in the module info array.  */
+
+void
+add_module_info (unsigned module_id, bool is_primary, int index)
+{
+  struct gcov_module_info *cur_info;
+  module_infos = XRESIZEVEC (struct gcov_module_info *,
+                             module_infos, index + 1);
+  module_infos[index] = XNEW (struct gcov_module_info);
+  cur_info = module_infos[index];
+  cur_info->ident = module_id;
+  SET_MODULE_EXPORTED (cur_info);
+  cur_info->num_quote_paths = 0;
+  cur_info->num_bracket_paths = 0;
+  cur_info->da_filename = NULL;
+  cur_info->source_filename = NULL;
+  if (is_primary)
+    primary_module_id = module_id;
+}
+
+/* Process the include paths needed for parsing the aux modules.
+   The sub_pattern is in the form SUB_PATH:NEW_SUB_PATH. If it is
+   defined, the SUB_PATH in ORIG_INC_PATH will be replaced with
+   NEW_SUB_PATH.  */
+
+static void
+process_include (char **orig_inc_path, char* old_sub, char *new_sub)
+{
+  char *inc_path, *orig_sub;
+
+  if (strlen (*orig_inc_path) < strlen (old_sub))
+    return;
+
+  inc_path = (char*) xmalloc (strlen (*orig_inc_path) + strlen (new_sub)
+                              - strlen (old_sub) + 1);
+  orig_sub = strstr (*orig_inc_path, old_sub);
+  if (!orig_sub)
+    {
+      inform (UNKNOWN_LOCATION, "subpath %s not found in path %s",
+              old_sub, *orig_inc_path);
+      free (inc_path);
+      return;
+    }
+
+  strncpy (inc_path, *orig_inc_path, orig_sub - *orig_inc_path);
+  inc_path[orig_sub - *orig_inc_path] = '\0';
+  strcat (inc_path, new_sub);
+  strcat (inc_path, orig_sub + strlen (old_sub));
+
+  free (*orig_inc_path);
+  *orig_inc_path = inc_path;
+}
+
+/* Process include paths for MOD_INFO according to option
+   -fripa-inc-path-sub=OLD_SUB:NEW_SUB   */
+
+static void
+process_include_paths_1 (struct gcov_module_info *mod_info,
+                         char* old_sub, char *new_sub)
+{
+  unsigned i, j;
+
+  for (i = 0; i < mod_info->num_quote_paths; i++)
+    process_include (&mod_info->string_array[i], old_sub, new_sub);
+
+  for (i = 0, j = mod_info->num_quote_paths;
+       i < mod_info->num_bracket_paths; i++, j++)
+    process_include (&mod_info->string_array[j], old_sub, new_sub);
+
+  for (i = 0, j = mod_info->num_quote_paths + mod_info->num_bracket_paths +
+       mod_info->num_cpp_defines; i < mod_info->num_cpp_includes; i++, j++)
+    process_include (&mod_info->string_array[j], old_sub, new_sub);
+
+}
+
+/* Process include paths for MOD_INFO according to option
+   -fripa-inc-path-sub=old_sub1:new_sub1[,old_sub2:new_sub2]  */
+
+static void
+process_include_paths (struct gcov_module_info *mod_info)
+{
+  char *sub_pattern, *cur, *next,  *new_sub;
+
+  if (!lipo_inc_path_pattern)
+    return;
+
+  sub_pattern = xstrdup (lipo_inc_path_pattern);
+  cur = sub_pattern;
+
+  do
     {
-      memcpy (da_file_name, profile_data_prefix, prefix_len);
-      da_file_name[prefix_len++] = '/';
+      next = strchr (cur, ',');
+      if (next)
+        *next++ = '\0';
+      new_sub = strchr (cur, ':');
+      if (!new_sub)
+        {
+          error ("Invalid path substibution pattern %s", sub_pattern);
+          free (sub_pattern);
+          return;
+        }
+      *new_sub++ = '\0';
+      process_include_paths_1 (mod_info, cur, new_sub);
+      cur = next;
+    } while (cur);
+  free (sub_pattern);
+}
+
+/* Set the prepreprocessing context (include search paths, -D/-U).
+   PARSE_IN is the preprocessor reader, I is the index of the module,
+   and VERBOSE is the verbose flag.  */
+
+void
+set_lipo_c_parsing_context (struct cpp_reader *parse_in, int i, bool verbose)
+{
+  struct gcov_module_info *mod_info;
+  if (!L_IPO_COMP_MODE)
+    return;
+
+  mod_info = module_infos[i];
+
+  gcc_assert (flag_dyn_ipa);
+  current_module_id = mod_info->ident;
+  reset_funcdef_no ();
+
+  if (current_module_id != primary_module_id)
+    {
+      unsigned i, j;
+
+      process_include_paths (mod_info);
+      /* Setup include paths.  */
+      clear_include_chains ();
+      for (i = 0; i < mod_info->num_quote_paths; i++)
+        add_path (xstrdup (mod_info->string_array[i]),
+                  QUOTE, 0, 1);
+      for (i = 0, j = mod_info->num_quote_paths;
+	   i < mod_info->num_bracket_paths; i++, j++)
+        add_path (xstrdup (mod_info->string_array[j]),
+                  BRACKET, 0, 1);
+      register_include_chains (parse_in, NULL, NULL, NULL,
+                               0, 0, verbose);
+
+      /* Setup defines/undefs.  */
+      for (i = 0, j = mod_info->num_quote_paths + mod_info->num_bracket_paths;
+	   i < mod_info->num_cpp_defines; i++, j++)
+	if (mod_info->string_array[j][0] == 'D')
+	  cpp_define (parse_in, mod_info->string_array[j] + 1);
+	else
+	  cpp_undef (parse_in, mod_info->string_array[j] + 1);
+
+      /* Setup -imacro/-include.  */
+      for (i = 0, j = mod_info->num_quote_paths + mod_info->num_bracket_paths +
+	     mod_info->num_cpp_defines; i < mod_info->num_cpp_includes;
+	   i++, j++)
+	cpp_push_include (parse_in, mod_info->string_array[j]);
+    }
+}
+
+/* Perform file-level initialization. Read in data file, generate name
+   of graph file.  */
+
+void
+coverage_init (const char *filename, const char* source_name)
+{
+  char* src_name_prefix = 0;
+  int src_name_prefix_len = 0;
+  int len = strlen (filename);
+
+  /* Since coverage_init is invoked very early, before the pass
+     manager, we need to set up the dumping explicitly. This is
+     similar to the handling in finish_optimization_passes.  */
+  dump_start (pass_profile.pass.static_pass_number, NULL);
+
+  has_asm_statement = false;
+  da_file_name = get_da_file_name (filename);
+  da_base_file_name = XNEWVEC (char, strlen (filename) + 1);
+  strcpy (da_base_file_name, filename);
+
+  if (profile_data_prefix == 0 && !IS_ABSOLUTE_PATH (source_name))
+    {
+      src_name_prefix = getpwd ();
+      src_name_prefix_len = strlen (src_name_prefix) + 1;
+    }
+  main_input_file_name = XNEWVEC (char, strlen (source_name) + 1 
+                                  + src_name_prefix_len);
+  if (!src_name_prefix)
+    strcpy (main_input_file_name, source_name);
+  else
+    {
+      strcpy (main_input_file_name, src_name_prefix);
+      strcat (main_input_file_name, "/");
+      strcat (main_input_file_name, source_name);
     }
-  memcpy (da_file_name + prefix_len, filename, len);
-  strcpy (da_file_name + prefix_len + len, GCOV_DATA_SUFFIX);
 
   bbg_file_stamp = local_tick;
-  
-  if (flag_branch_probabilities)
-    read_counts_file ();
+
+  if (flag_branch_probabilities && !flag_auto_profile)
+    read_counts_file (da_file_name, 0);
+
+  /* Rebuild counts_hash and read the auxiliary GCDA files.  */
+  if (flag_profile_use && L_IPO_COMP_MODE)
+    {
+      unsigned i;
+      gcc_assert (flag_dyn_ipa);
+      rebuild_counts_hash ();
+      for (i = 1; i < num_in_fnames; i++)
+	read_counts_file (get_da_file_name (module_infos[i]->da_filename),
+			  module_infos[i]->ident);
+    }
+
+  /* Define variables which are referenced at runtime by libgcov.  */
+  if (profiling_enabled_p ())
+    {
+      tree_init_dyn_ipa_parameters ();
+      tree_init_instrumentation_sampling ();
+    }
+  if (flag_auto_profile)
+    init_auto_profile ();
 
   /* Name of bbg file.  */
   if (flag_test_coverage && !flag_compare_debug)
@@ -1122,7 +2621,6 @@ coverage_init (const char *filename)
       bbg_file_name = XNEWVEC (char, len + strlen (GCOV_NOTE_SUFFIX) + 1);
       memcpy (bbg_file_name, filename, len);
       strcpy (bbg_file_name + len, GCOV_NOTE_SUFFIX);
-
       if (!gcov_open (bbg_file_name, -1))
 	{
 	  error ("cannot open %s", bbg_file_name);
@@ -1135,9 +2633,21 @@ coverage_init (const char *filename)
 	  gcov_write_unsigned (bbg_file_stamp);
 	}
     }
+
+  dump_finish (pass_profile.pass.static_pass_number);
 }
 
-/* Performs file-level cleanup.  Close notes file, generate coverage
+/* Return True if any type of profiling is enabled which requires linking
+   in libgcov otherwise return False.  */
+
+static bool
+profiling_enabled_p (void)
+{
+  return  profile_arc_flag
+   || flag_profile_generate_sampling;
+}
+
+/* Performs file-level cleanup.  Close graph file, generate coverage
    variables and constructor.  */
 
 void
@@ -1163,4 +2673,140 @@ coverage_finish (void)
     }
 }
 
+/* Add S to the end of the string-list, the head and tail of which are
+   pointed-to by HEAD and TAIL, respectively.  */
+
+static void
+str_list_append (struct str_list **head, struct str_list **tail, const char *s)
+{
+  struct str_list *e = XNEW (struct str_list);
+  e->str = XNEWVEC (char, strlen (s) + 1);
+  strcpy (e->str, s);
+  e->next = NULL;
+  if (*tail)
+    (*tail)->next = e;
+  else
+    *head = e;
+  *tail = e;
+}
+
+/* Copies the macro def or undef CPP_DEF and saves the copy
+   in a list. IS_DEF is a flag indicating if CPP_DEF represents
+   a -D or -U.  */
+
+void
+coverage_note_define (const char *cpp_def, bool is_def)
+{
+  char *s = XNEWVEC (char, strlen (cpp_def) + 2);
+  s[0] = is_def ? 'D' : 'U';
+  strcpy (s + 1, cpp_def);
+  str_list_append (&cpp_defines_head, &cpp_defines_tail, s);
+  num_cpp_defines++;
+}
+
+/* Copies the -imacro/-include FILENAME and saves the copy in a list.  */
+
+void
+coverage_note_include (const char *filename)
+{
+  str_list_append (&cpp_includes_head, &cpp_includes_tail, filename);
+  num_cpp_includes++;
+}
+
+/* Mark this module as containing asm statements.  */
+
+void
+coverage_has_asm_stmt (void)
+{
+  has_asm_statement = flag_ripa_disallow_asm_modules;
+}
+
+/* Write compilation info to the .note section.  */
+
+void
+write_compilation_info_to_asm (void)
+{
+  unsigned lang;
+  /* Write lang, ggc_memory to ASM section.  */
+  switch_to_section (get_section (".gnu.switches.text.lipo_info",
+				  SECTION_DEBUG, NULL));
+  if (!strcmp (lang_hooks.name, "GNU C"))
+    lang = GCOV_MODULE_C_LANG;
+  else if (!strcmp (lang_hooks.name, "GNU C++"))
+    lang = GCOV_MODULE_CPP_LANG;
+  else
+    lang = GCOV_MODULE_UNKNOWN_LANG;
+  if (has_asm_statement)
+    lang |= GCOV_MODULE_ASM_STMTS;
+  dw2_asm_output_nstring (in_fnames[0], (size_t)-1, NULL);
+  dw2_asm_output_data_uleb128 (lang, NULL);
+  dw2_asm_output_data_uleb128 (ggc_total_memory, NULL);
+}
+
+
+/* Write command line options to the .note section.  */
+
+void
+write_compilation_flags_to_asm (void)
+{
+  size_t i;
+  cpp_dir *quote_paths, *bracket_paths, *pdir;
+  struct str_list *pdef, *pinc;
+  int num_quote_paths = 0;
+  int num_bracket_paths = 0;
+
+  get_include_chains (&quote_paths, &bracket_paths);
+
+  /* Write quote_paths to ASM section.  */
+  switch_to_section (get_section (".gnu.switches.text.quote_paths",
+				  SECTION_DEBUG, NULL));
+  for (pdir = quote_paths; pdir; pdir = pdir->next)
+    {
+      if (pdir == bracket_paths)
+	break;
+      num_quote_paths++;
+    }
+  dw2_asm_output_nstring (in_fnames[0], (size_t)-1, NULL);
+  dw2_asm_output_data_uleb128 (num_quote_paths, NULL);
+  for (pdir = quote_paths; pdir; pdir = pdir->next)
+    {
+      if (pdir == bracket_paths)
+	break;
+      dw2_asm_output_nstring (pdir->name, (size_t)-1, NULL);
+    }
+
+  /* Write bracket_paths to ASM section.  */
+  switch_to_section (get_section (".gnu.switches.text.bracket_paths",
+				  SECTION_DEBUG, NULL));
+  for (pdir = bracket_paths; pdir; pdir = pdir->next)
+    num_bracket_paths++;
+  dw2_asm_output_nstring (in_fnames[0], (size_t)-1, NULL);
+  dw2_asm_output_data_uleb128 (num_bracket_paths, NULL);
+  for (pdir = bracket_paths; pdir; pdir = pdir->next)
+    dw2_asm_output_nstring (pdir->name, (size_t)-1, NULL);
+
+  /* Write cpp_defines to ASM section.  */
+  switch_to_section (get_section (".gnu.switches.text.cpp_defines",
+				  SECTION_DEBUG, NULL));
+  dw2_asm_output_nstring (in_fnames[0], (size_t)-1, NULL);
+  dw2_asm_output_data_uleb128 (num_cpp_defines, NULL);
+  for (pdef = cpp_defines_head; pdef; pdef = pdef->next)
+    dw2_asm_output_nstring (pdef->str, (size_t)-1, NULL);
+
+  /* Write cpp_includes to ASM section.  */
+  switch_to_section (get_section (".gnu.switches.text.cpp_includes",
+				  SECTION_DEBUG, NULL));
+  dw2_asm_output_nstring (in_fnames[0], (size_t)-1, NULL);
+  dw2_asm_output_data_uleb128 (num_cpp_includes, NULL);
+  for (pinc = cpp_includes_head; pinc; pinc = pinc->next)
+    dw2_asm_output_nstring (pinc->str, (size_t)-1, NULL);
+
+  /* Write cl_args to ASM section.  */
+  switch_to_section (get_section (".gnu.switches.text.cl_args",
+				  SECTION_DEBUG, NULL));
+  dw2_asm_output_nstring (in_fnames[0], (size_t)-1, NULL);
+  dw2_asm_output_data_uleb128 (num_lipo_cl_args, NULL);
+  for (i = 0; i < num_lipo_cl_args; i++)
+    dw2_asm_output_nstring (lipo_cl_args[i], (size_t)-1, NULL);
+}
 #include "gt-coverage.h"
diff --git a/gcc/coverage.h b/gcc/coverage.h
index 21afe72..6dd199f 100644
--- a/gcc/coverage.h
+++ b/gcc/coverage.h
@@ -22,7 +22,7 @@ along with GCC; see the file COPYING3.  If not see
 
 #include "gcov-io.h"
 
-extern void coverage_init (const char *);
+extern void coverage_init (const char *, const char*);
 extern void coverage_finish (void);
 
 /* Start outputting coverage information for the current
@@ -51,7 +51,36 @@ extern gcov_type *get_coverage_counts (unsigned /*counter*/,
 				       unsigned /*cfg_checksum*/,
 				       unsigned /*lineno_checksum*/,
 				       const struct gcov_ctr_summary **);
+/* Get all the counters for the current function without warning.  */
+extern gcov_type *get_coverage_counts_no_warn (struct function *, 
+                                               unsigned /*counter*/, unsigned *);
+
+extern struct cgraph_node * find_func_by_global_id (unsigned HOST_WIDE_INT gid,
+						    bool);
+
+/* All the coverage counters are supposed to be allocated by the time
+   coverage_end_function is called. However, direct-call counters are
+   allocated after coverage_end_function has been called. This function
+   fixes up the various internal structures to reflect these counter
+   allocations. This function is called after coverage_end_function and
+   before coverage_finish.  */
+extern void coverage_dc_end_function (void);
+
+/* True if a function entry corresponding to the given function identifier
+   is present in the coverage internal data structures.  */
+extern bool coverage_function_present (unsigned fn_ident);
 
 extern tree get_gcov_type (void);
+extern tree get_gcov_unsigned_t (void);
+
+/* Mark this module as containing asm statements.  */
+extern void coverage_has_asm_stmt (void);
+
+extern bool incompatible_cl_args (struct gcov_module_info *,
+				  struct gcov_module_info *);
+
+/* Defined in tree-profile.c.  */
+extern void tree_init_instrumentation_sampling (void);
+extern void tree_init_dyn_ipa_parameters (void);
 
 #endif
diff --git a/gcc/cp/Make-lang.in b/gcc/cp/Make-lang.in
index dce523a..82eaa48 100644
--- a/gcc/cp/Make-lang.in
+++ b/gcc/cp/Make-lang.in
@@ -282,7 +282,7 @@ cp/decl2.o: cp/decl2.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) cp/decl.h \
   c-family/c-objc.h
 cp/cp-objcp-common.o : cp/cp-objcp-common.c $(CONFIG_H) $(SYSTEM_H) \
   coretypes.h $(TM_H) $(TREE_H) $(CXX_TREE_H) $(C_COMMON_H) \
-  langhooks.h $(LANGHOOKS_DEF_H) $(DIAGNOSTIC_H) debug.h \
+  langhooks.h $(LANGHOOKS_DEF_H) $(DIAGNOSTIC_H) debug.h l-ipo.h \
   $(CXX_PRETTY_PRINT_H) cp/cp-objcp-common.h gt-cp-cp-objcp-common.h
 cp/typeck2.o: cp/typeck2.c $(CXX_TREE_H) $(TM_H) $(FLAGS_H) \
   $(TM_P_H) $(DIAGNOSTIC_CORE_H) gt-cp-typeck2.h $(REAL_H) intl.h
diff --git a/gcc/cp/call.c b/gcc/cp/call.c
index a5be421..d2d5f76 100644
--- a/gcc/cp/call.c
+++ b/gcc/cp/call.c
@@ -5617,8 +5617,22 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,
 	       usual deallocation function."
 
 	       So (void*) beats (void*, size_t).  */
-	    if (FUNCTION_ARG_CHAIN (fn) == void_list_node)
-	      break;
+            /* If type is not void, pick (void*, size_t) version (which comes
+               first).  */
+	    if (!flag_sized_delete || TREE_CODE (type) == VOID_TYPE )
+              {
+                /* If -fsized-delete is not passed or if a void * is deleted,
+                   prefer delete (void *) version.  */
+                if (FUNCTION_ARG_CHAIN (fn) == void_list_node)
+                  break;
+              }
+            else
+              {
+                /* If -fsized-delete is passed and it is not a void *,
+                   prefer delete (void *, size_t) version.  */
+                if (FUNCTION_ARG_CHAIN (fn) != void_list_node)
+                  break;
+              }
 	  }
       }
 
diff --git a/gcc/cp/cp-lang.c b/gcc/cp/cp-lang.c
index 47a6004..d09fae0 100644
--- a/gcc/cp/cp-lang.c
+++ b/gcc/cp/cp-lang.c
@@ -37,6 +37,7 @@ enum c_language_kind c_language = clk_cxx;
 static void cp_init_ts (void);
 static const char * cxx_dwarf_name (tree t, int verbosity);
 static enum classify_record cp_classify_record (tree type);
+static bool cp_user_conv_function_p (tree);
 static tree cp_eh_personality (void);
 static tree get_template_innermost_arguments_folded (const_tree);
 static tree get_template_argument_pack_elems_folded (const_tree);
@@ -77,11 +78,46 @@ static tree get_template_argument_pack_elems_folded (const_tree);
 #define LANG_HOOKS_DWARF_NAME cxx_dwarf_name
 #undef LANG_HOOKS_INIT_TS
 #define LANG_HOOKS_INIT_TS cp_init_ts
+#undef LANG_HOOKS_USER_CONV_FUNCTION
+#define LANG_HOOKS_USER_CONV_FUNCTION cp_user_conv_function_p
 #undef LANG_HOOKS_EH_PERSONALITY
 #define LANG_HOOKS_EH_PERSONALITY cp_eh_personality
 #undef LANG_HOOKS_EH_RUNTIME_TYPE
 #define LANG_HOOKS_EH_RUNTIME_TYPE build_eh_type_type
 
+
+/* LIPO support.  */
+#undef LANG_HOOKS_ADD_BUILT_IN_DECL
+#define LANG_HOOKS_ADD_BUILT_IN_DECL cp_add_built_in_decl
+#undef LANG_HOOKS_SAVE_BUILT_IN_PRE
+#define LANG_HOOKS_SAVE_BUILT_IN_PRE cp_save_built_in_decl_pre_parsing
+#undef LANG_HOOKS_RESTORE_BUILT_IN_PRE
+#define LANG_HOOKS_RESTORE_BUILT_IN_PRE cp_restore_built_in_decl_pre_parsing
+#undef LANG_HOOKS_SAVE_BUILT_IN_POST
+#define LANG_HOOKS_SAVE_BUILT_IN_POST cp_save_built_in_decl_post_parsing
+#undef LANG_HOOKS_RESTORE_BUILT_IN_POST
+#define LANG_HOOKS_RESTORE_BUILT_IN_POST cp_restore_built_in_decl_post_parsing
+#undef LANG_HOOKS_CLEAR_NAME_BINDINGS
+#define LANG_HOOKS_CLEAR_NAME_BINDINGS cp_clear_global_name_bindings
+#undef LANG_HOOKS_HAS_GLOBAL_NAME
+#define LANG_HOOKS_HAS_GLOBAL_NAME cp_is_non_sharable_global_decl
+#undef LANG_HOOKS_GET_LANG_DECL_SIZE
+#define LANG_HOOKS_GET_LANG_DECL_SIZE cp_get_lang_decl_size
+#undef LANG_HOOKS_DUP_LANG_TYPE
+#define LANG_HOOKS_DUP_LANG_TYPE cp_lipo_dup_lang_type
+#undef LANG_HOOKS_COPY_LANG_TYPE
+#define LANG_HOOKS_COPY_LANG_TYPE cp_lipo_copy_lang_type
+#undef LANG_HOOKS_PROCESS_PENDING_DECLS
+#define LANG_HOOKS_PROCESS_PENDING_DECLS cp_process_pending_declarations
+#undef LANG_HOOKS_CLEAR_DEFFERED_FNS
+#define LANG_HOOKS_CLEAR_DEFFERED_FNS cp_clear_deferred_fns
+#undef LANG_HOOKS_IS_GENERATED_TYPE
+#define LANG_HOOKS_IS_GENERATED_TYPE cp_is_compiler_generated_type
+#undef LANG_HOOKS_CMP_LANG_TYPE
+#define LANG_HOOKS_CMP_LANG_TYPE cp_cmp_lang_type
+
+
+
 /* Each front end provides its own lang hook initializer.  */
 struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;
 
@@ -133,6 +169,13 @@ cp_classify_record (tree type)
   return RECORD_IS_STRUCT;
 }
 
+static bool
+cp_user_conv_function_p (tree decl)
+{
+  return DECL_CONV_FN_P (decl);
+}
+
+
 static GTY(()) tree cp_eh_personality_decl;
 
 static tree
diff --git a/gcc/cp/cp-objcp-common.c b/gcc/cp/cp-objcp-common.c
index fe96757..03fd775 100644
--- a/gcc/cp/cp-objcp-common.c
+++ b/gcc/cp/cp-objcp-common.c
@@ -25,12 +25,14 @@ along with GCC; see the file COPYING3.  If not see
 #include "tree.h"
 #include "cp-tree.h"
 #include "c-family/c-common.h"
+#include "cgraph.h"
 #include "langhooks.h"
 #include "langhooks-def.h"
 #include "diagnostic.h"
 #include "debug.h"
 #include "cxx-pretty-print.h"
 #include "cp-objcp-common.h"
+#include "l-ipo.h"
 
 /* Special routine to get the alias set for C++.  */
 
@@ -167,15 +169,474 @@ cp_function_decl_explicit_p (tree decl)
 	  && DECL_NONCONVERTING_P (decl));
 }
 
-/* Stubs to keep c-opts.c happy.  */
+/* LIPO support  */
+
+typedef struct GTY (()) sb
+{
+  tree decl;
+  tree decl_init_copy; /* copy at the start of file parsing.  */
+  tree decl_fini_copy; /* copy at the end of module_scope.  */
+  tree id;
+  cxx_binding *binding;
+  /* binding->value may get overwritten during parsing due to
+     an incompatible delcaration in the same scope (e.g. clog),
+     so we need to expliclitly save the binding value.  */
+  tree binding_value;
+  /* The binding value in the previous scope: std namespace.  */
+  tree std_binding_value;
+  tree real_type_value;
+} saved_builtin;
+
+static GTY (()) vec<saved_builtin, va_gc> *saved_builtins = NULL;
+
+/* Return true if the type is not user defined.  */
+
+bool
+cp_is_compiler_generated_type (tree t)
+{
+  if (TYPE_PTRMEMFUNC_P (t))
+    return true;
+  return false;
+}
+
+/* Clear symbol binding for name ID. */
+
+void
+cp_clear_global_name_bindings (tree id)
+{
+  if (id)
+    IDENTIFIER_NAMESPACE_BINDINGS (id) = NULL;
+}
+
+/* Return true if DECL is scoped in global/namespace scope, otherwise
+   return false.  This is a langhook method that is used to select declarations
+   that needs to be explicitly popped out the global/namespace scope
+   at the end of parsing the file.  */
+
+bool
+cp_is_non_sharable_global_decl (tree decl, void *scope)
+{
+  cp_binding_level *global_scope, *cur_scope;
+
+  cur_scope = (cp_binding_level *) scope;
+  global_scope = NAMESPACE_LEVEL (global_namespace);
+  if (cur_scope->kind != sk_namespace && cur_scope != global_scope)
+    return false;
+
+  /* Type info objects are compiler created -- allow such
+     decls to be shared (treated as other builtins) across modules.  */
+  if (TREE_CODE (decl) == VAR_DECL && DECL_TINFO_P (decl))
+    return false;
+
+  return true;
+}
+
+/* Duplicate language specific type information from SRC
+   to DEST.  */
+
+void
+cp_lipo_dup_lang_type (tree src, tree dest)
+{
+  struct lang_type *lang_type_clone = 0;
+  /* TODO check size.  */
+  lang_type_clone = ggc_alloc_cleared_lang_type (sizeof (struct lang_type));
+  *lang_type_clone = *TYPE_LANG_SPECIFIC (src);
+  TYPE_LANG_SPECIFIC (dest) = lang_type_clone;
+
+  TYPE_CACHED_VALUES_P (dest) = TYPE_CACHED_VALUES_P (src);
+  if (TYPE_CACHED_VALUES_P (src))
+    TYPE_CACHED_VALUES (dest) = TYPE_CACHED_VALUES (src);
+  /* Main variant's clone's main variant should be itself. */
+  TYPE_MAIN_VARIANT (dest) = dest;
+  /* Now copy the subdecl.
+     Do not reorder this with previous statement -- it
+     depends on the result of previous one.  */
+  TYPE_MAIN_DECL(dest) = TYPE_MAIN_DECL (src);
+}
+
+
+/* Copy DEST into SRC.  */
+
+void
+cp_lipo_copy_lang_type (tree src, tree dest)
+{
+  struct lang_type *old_ls;
+  unsigned old_uid;
+
+  old_ls = TYPE_LANG_SPECIFIC (dest);
+  *old_ls = *(TYPE_LANG_SPECIFIC (src));
+  old_uid = TYPE_UID (dest);
+  memcpy (dest, src, tree_size (dest));
+
+  TYPE_UID (dest) = old_uid;
+  TYPE_LANG_SPECIFIC (dest) = old_ls;
+  /* recover main variant. */
+  TYPE_MAIN_VARIANT (dest) = dest;
+  TYPE_MAIN_DECL (dest) = TYPE_MAIN_DECL (src);
+}
+
+/* Return the actual size of the lang_decl struct for
+   decl T.  */
+
+int
+cp_get_lang_decl_size (tree t)
+{
+  size_t size;
+  if (TREE_CODE (t) == FUNCTION_DECL)
+    size = sizeof (struct lang_decl_fn);
+  else if (TREE_CODE (t) == NAMESPACE_DECL)
+    size = sizeof (struct lang_decl_ns);
+  else if (TREE_CODE (t) == PARM_DECL)
+    size = sizeof (struct lang_decl_parm);
+  else if (LANG_DECL_HAS_MIN (t))
+    size = sizeof (struct lang_decl_min);
+  else
+    gcc_unreachable ();
+
+  return (int) size;
+}
+
+/* Return 1 if template arguments TA1 and TA2 is compatible.
+   Return 0 otherwise.  */
+
+static int
+cmp_templ_arg (tree ta1, tree ta2)
+{
+  if (ARGUMENT_PACK_P (ta1))
+    {
+      int n, i;
+      if (!ARGUMENT_PACK_P (ta2))
+        return 0;
+      n = TREE_VEC_LENGTH (ta1);
+      if (n != TREE_VEC_LENGTH (ta2))
+        return 0;
+      for (i = 0; i < n ; i++)
+        {
+          if (!cmp_templ_arg (TREE_VEC_ELT (ta1, i),
+                              TREE_VEC_ELT (ta2, i)))
+            return 0;
+        }
+      return 1;
+    }
+  else if (TYPE_P (ta1))
+    {
+      if (!TYPE_P (ta2))
+        return 0;
+
+      return lipo_cmp_type (ta1, ta2);
+    }
+  else if (TREE_CODE (ta1) == TEMPLATE_DECL)
+    {
+      if (TREE_CODE (ta2) != TEMPLATE_DECL)
+        return 0;
+
+      /* compare name -- need context comparison:  */
+      return !strcmp (IDENTIFIER_POINTER (DECL_NAME (ta1)),
+                      IDENTIFIER_POINTER (DECL_NAME (ta2)));
+    }
+  else /* integer expression  */
+    {
+      if (TREE_CODE (ta1) != TREE_CODE (ta2))
+        return 0;
+      if (TREE_CODE (ta1) == INTEGER_CST)
+        return (TREE_INT_CST_HIGH (ta1) == TREE_INT_CST_HIGH (ta2)
+                && TREE_INT_CST_LOW (ta1) == TREE_INT_CST_LOW (ta2));
+      else if (TREE_CODE (ta1) == ADDR_EXPR)
+        {
+          tree td1, td2;
+
+          td1 = TREE_OPERAND (ta1, 0);
+          td2 = TREE_OPERAND (ta2, 0);
+          if (TREE_CODE (td1) != TREE_CODE (td2))
+            return 0;
+          if (TREE_CODE (td1) == FUNCTION_DECL)
+            {
+              tree id1, id2;
+
+              if (!TREE_PUBLIC (td1) || !TREE_PUBLIC (td2))
+                return td1 == td2;
+
+              id1 = DECL_ASSEMBLER_NAME (td1);
+              id2 = DECL_ASSEMBLER_NAME (td2);
+              return !strcmp (IDENTIFIER_POINTER (id1),
+                              IDENTIFIER_POINTER (id2));
+            }
+          else
+            {
+              gcc_assert (TREE_CODE (td1) == VAR_DECL);
+              return real_varpool_node (td1) == real_varpool_node (td2);
+            }
+        }
+      else
+        /* Be conservative (from aliasing point of view) for now (TODO)  */
+        return 1;
+    }
+}
+
+/* Return 1 if template parameters of T1 and T2
+   are compatible, returns 0 otherwise.  */
+
+static int
+cmp_templ_parms (tree t1, tree t2)
+{
+  int n_lvl = 1, i;
+  tree a1, a2;
+  tree args1 = CLASSTYPE_TI_ARGS (t1);
+  tree args2 = CLASSTYPE_TI_ARGS (t2);
+  if (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (args1)
+      && !TMPL_ARGS_HAVE_MULTIPLE_LEVELS (args2))
+    return 0;
+  if (!TMPL_ARGS_HAVE_MULTIPLE_LEVELS (args1)
+      && TMPL_ARGS_HAVE_MULTIPLE_LEVELS (args2))
+    return 0;
+
+  if (TREE_VEC_LENGTH (args1) != TREE_VEC_LENGTH (args2))
+    return 0;
+
+  if (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (args1))
+    n_lvl = TREE_VEC_LENGTH (args1);
+
+  i = 0;
+  if (n_lvl == 1)
+    {
+      a1 = args1;
+      a2 = args2;
+    }
+  else
+    {
+      a1 = TREE_VEC_ELT (args1, 0);
+      a2 = TREE_VEC_ELT (args2, 0);
+    }
+
+  while (i < n_lvl)
+    {
+      int len1, len2, j;
+
+      len1 = TREE_VEC_LENGTH (a1);
+      len2 = TREE_VEC_LENGTH (a2);
+
+      if (len1 != len2)
+        return 0;
+
+      for (j = 0; j < len1; j++)
+        {
+          tree ta1, ta2;
+
+          ta1 = TREE_VEC_ELT (a1, j);
+          ta2 = TREE_VEC_ELT (a2, j);
+
+          if (!cmp_templ_arg (ta1, ta2))
+            return 0;
+        }
+       i++;
+       if (i < n_lvl)
+         {
+           a1 = TREE_VEC_ELT (args1, i);
+           a2 = TREE_VEC_ELT (args2, i);
+         }
+    }
+  return 1;
+}
+
+/* Return 1 if type T1 and T2 are compatible. Type comparison
+   is based on type kind and name.  */
+
+int
+cp_cmp_lang_type (tree t1, tree t2)
+{
+  int templ1, templ2;
+
+  /* Now check if the type is a template instantiation.  */
+  templ1 = (TYPE_LANG_SPECIFIC (t1) && CLASSTYPE_TEMPLATE_INFO (t1));
+  templ2 = (TYPE_LANG_SPECIFIC (t2) && CLASSTYPE_TEMPLATE_INFO (t2));
+
+  if ((templ1 && !templ2) || (!templ1 && templ2))
+    return 0;
+  if (!templ1 && !templ2)
+    return 1;
+
+  return cmp_templ_parms (t1, t2);
+}
+
+/* Push DECL to the list of builtins declared by the
+   frontend.  */
+
+void
+cp_add_built_in_decl (tree decl)
+{
+  saved_builtin *sb;
+
+  if (!flag_dyn_ipa)
+    return;
+
+  if (at_eof)
+    return;
+
+  if (parser_parsing_start)
+    return;
+
+  sb = vec_safe_push (saved_builtins, saved_builtin ());
+  sb->decl = decl;
+  sb->decl_init_copy = NULL;
+  sb->decl_fini_copy = NULL;
+  sb->id = NULL;
+  sb->binding = NULL;
+  sb->real_type_value = NULL;
+  sb->binding_value = NULL;
+  sb->std_binding_value = NULL;
+}
+
+/* Save SB->decl and its name id's binding values.  */
+
+static void
+save_built_in_decl_pre_parsing_1 (saved_builtin *sb)
+{
+  tree decl = sb->decl;
+
+  sb->decl_init_copy = lipo_save_decl (decl);
+  sb->decl_fini_copy = NULL;
+  sb->id = NULL;
+  sb->binding = NULL;
+  sb->real_type_value = NULL;
+  sb->binding_value = NULL;
+  sb->std_binding_value = NULL;
+  if (TREE_CODE_CLASS (TREE_CODE (decl)) != tcc_type)
+    sb->id = DECL_NAME (decl);
+  else
+    {
+      tree id;
+      id = TYPE_NAME (decl);
+      if (TREE_CODE (id) == TYPE_DECL)
+        id = DECL_NAME (id);
+      sb->id = id;
+    }
+
+  if (sb->id)
+    {
+      sb->real_type_value = REAL_IDENTIFIER_TYPE_VALUE (sb->id);
+      sb->binding = IDENTIFIER_NAMESPACE_BINDINGS (sb->id);
+      if (sb->binding)
+        {
+          sb->binding_value = sb->binding->value;
+
+          if (sb->binding->previous)
+            sb->std_binding_value = sb->binding->previous->value;
+        }
+    }
+  else
+    {
+      sb->real_type_value = NULL;
+      sb->binding = NULL;
+    }
+
+  return;
+}
+
+/* Add builtin types into the list of builtins.  */
+
+static void
+add_built_in_type_node (void)
+{
+  tree type_info_node;
+
+  type_info_node = TYPE_MAIN_VARIANT (const_type_info_type_node);
+  cp_add_built_in_decl (type_info_node);
+}
+
+/* Save the tree (by making a copy) and binding values for
+   builtins before parsing start.  */
+
+void
+cp_save_built_in_decl_pre_parsing (void)
+{
+  size_t i;
+  saved_builtin *bi;
+
+  add_built_in_type_node ();
+
+  for (i = 0; saved_builtins->iterate (i, &bi); ++i)
+    save_built_in_decl_pre_parsing_1 (bi);
+}
+
+/* Restore builtins and their bindings to their values
+   before parsing. */
+
+void
+cp_restore_built_in_decl_pre_parsing (void)
+{
+  size_t i;
+  saved_builtin *bi;
+
+  for (i = 0; saved_builtins->iterate (i, &bi); ++i)
+    {
+      tree decl = bi->decl;
+
+      lipo_restore_decl (decl, bi->decl_init_copy);
+
+      if (bi->id)
+        {
+          if (bi->binding)
+            {
+              bi->binding->value = bi->binding_value;
+              if (bi->binding->previous)
+                bi->binding->previous->value = bi->std_binding_value;
+            }
+          IDENTIFIER_NAMESPACE_BINDINGS (bi->id) = bi->binding;
+          REAL_IDENTIFIER_TYPE_VALUE (bi->id) = bi->real_type_value;
+        }
+    }
+  DECL_NAMESPACE_USING (global_namespace) = NULL;
+}
+
+/* Save the tree (by making a copy) and binding values for
+   builtins after parsing of a file.  */
+
+void
+cp_save_built_in_decl_post_parsing (void)
+{
+  size_t i;
+  saved_builtin *bi;
+
+  for (i = 0; saved_builtins->iterate (i, &bi); ++i)
+    {
+      if (!TREE_STATIC (bi->decl) || DECL_ARTIFICIAL (bi->decl))
+       	continue;
+      /* Remember the defining module.  */
+      cgraph_link_node (cgraph_get_create_node (bi->decl));
+      if (!bi->decl_fini_copy)
+        bi->decl_fini_copy = lipo_save_decl (bi->decl);
+      else
+ 	gcc_assert (TREE_STATIC (bi->decl_fini_copy));
+    }
+}
+
+/* Restore builtins and their bindings to their post parsing values.  */
+
+void
+cp_restore_built_in_decl_post_parsing (void)
+{
+  unsigned i;
+  saved_builtin *bi;
+
+  for (i = 0; saved_builtins->iterate (i, &bi); ++i)
+    {
+      tree decl = bi->decl;
+      /* Now restore the decl's state  */
+      if (bi->decl_fini_copy)
+        lipo_restore_decl (decl, bi->decl_fini_copy);
+    }
+}
+
 void
 push_file_scope (void)
 {
+  push_module_scope ();
 }
 
 void
 pop_file_scope (void)
 {
+  pop_module_scope ();
 }
 
 /* c-pragma.c needs to query whether a decl has extern "C" linkage.  */
diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
index b10c53b..0bac956 100644
--- a/gcc/cp/cp-tree.h
+++ b/gcc/cp/cp-tree.h
@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "function.h"
 #include "hashtab.h"
 #include "vec.h"
+#include "l-ipo.h"
 
 /* In order for the format checking to accept the C++ front end
    diagnostic framework extensions, you must include this file before
@@ -5047,6 +5048,7 @@ extern void note_name_declared_in_class		(tree, tree);
 extern tree get_vtbl_decl_for_binfo		(tree);
 extern void debug_class				(tree);
 extern void debug_thunks			(tree);
+extern tree cp_fold_obj_type_ref		(tree, tree);
 extern void set_linkage_according_to_type	(tree, tree);
 extern void determine_key_method		(tree);
 extern void check_for_override			(tree, tree);
@@ -5226,6 +5228,10 @@ extern tree cp_reconstruct_complex_type		(tree, tree);
 extern void cplus_decl_attributes		(tree *, tree, int);
 extern void finish_anon_union			(tree);
 extern void cp_write_global_declarations	(void);
+extern void cp_process_pending_declarations     (location_t);
+extern void cp_clear_deferred_fns               (void);
+extern void cp_clear_constexpr_hashtable        (void);
+extern void cp_clear_conv_type_map              (void);
 extern tree coerce_new_type			(tree);
 extern tree coerce_delete_type			(tree);
 extern void comdat_linkage			(tree);
@@ -6069,6 +6075,22 @@ extern int cxx_types_compatible_p		(tree, tree);
 extern void init_shadowed_var_for_decl		(void);
 extern bool cxx_block_may_fallthru		(const_tree);
 
+/* LIPO support.  */
+extern bool cp_is_compiler_generated_type        (tree);
+extern void cp_clear_global_name_bindings       (tree);
+extern bool
+cp_is_non_sharable_global_decl                  (tree, void *);
+extern void cp_lipo_dup_lang_type               (tree, tree);
+extern void cp_lipo_copy_lang_type              (tree, tree);
+extern int cp_get_lang_decl_size                (tree);
+extern int cp_cmp_lang_type                     (tree, tree);
+extern void cp_add_built_in_decl                (tree);
+extern void cp_save_built_in_decl_pre_parsing (void);
+extern void cp_restore_built_in_decl_pre_parsing (void);
+extern void cp_save_built_in_decl_post_parsing (void);
+extern void cp_restore_built_in_decl_post_parsing (void);
+
+
 /* in cp-gimplify.c */
 extern int cp_gimplify_expr			(tree *, gimple_seq *,
 						 gimple_seq *);
diff --git a/gcc/cp/decl.c b/gcc/cp/decl.c
index df979c2..d7ccdc5 100644
--- a/gcc/cp/decl.c
+++ b/gcc/cp/decl.c
@@ -50,6 +50,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "timevar.h"
 #include "pointer-set.h"
 #include "splay-tree.h"
+#include "cgraph.h"
 #include "plugin.h"
 #include "cgraph.h"
 
@@ -553,6 +554,7 @@ poplevel (int keep, int reverse, int functionbody)
   cp_label_binding *label_bind;
 
   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);
+
  restart:
 
   block = NULL_TREE;
@@ -857,7 +859,7 @@ walk_namespaces (walk_namespaces_fn f, void* data)
    wrapup_global_declarations for this NAMESPACE.  */
 
 int
-wrapup_globals_for_namespace (tree name_space, void* data)
+wrapup_globals_for_namespace (tree name_space, void *data)
 {
   cp_binding_level *level = NAMESPACE_LEVEL (name_space);
   vec<tree, va_gc> *statics = level->static_decls;
@@ -2409,7 +2411,26 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)
   /* The NEWDECL will no longer be needed.  Because every out-of-class
      declaration of a member results in a call to duplicate_decls,
      freeing these nodes represents in a significant savings.  */
-  ggc_free (newdecl);
+  {
+    tree clone;
+    bool found_clone = false;
+    /* Fix dangling reference.  */
+    FOR_EACH_CLONE (clone, newdecl)
+      {
+        if (DECL_CLONED_FUNCTION (clone) == newdecl)
+          {
+            found_clone = true;
+            break;
+          }
+        if (DECL_ABSTRACT_ORIGIN (clone) == newdecl)
+          {
+            found_clone = true;
+            break;
+          }
+      }
+    if (!found_clone)
+      ggc_free (newdecl);
+  }
 
   return olddecl;
 }
@@ -3637,6 +3658,7 @@ cxx_init_decl_processing (void)
 {
   tree void_ftype;
   tree void_ftype_ptr;
+  tree void_ftype_ptr_sizetype;
 
   /* Create all the identifiers we need.  */
   initialize_predefined_identifiers ();
@@ -3698,8 +3720,14 @@ cxx_init_decl_processing (void)
   void_ftype = build_function_type_list (void_type_node, NULL_TREE);
   void_ftype_ptr = build_function_type_list (void_type_node,
 					     ptr_type_node, NULL_TREE);
+  void_ftype_ptr_sizetype = build_function_type_list (void_type_node,
+                                                      ptr_type_node,
+                                                      size_type_node,
+                                                      NULL_TREE);
   void_ftype_ptr
     = build_exception_variant (void_ftype_ptr, empty_except_spec);
+  void_ftype_ptr_sizetype
+    = build_exception_variant (void_ftype_ptr_sizetype, empty_except_spec);
 
   /* C++ extensions */
 
@@ -3750,7 +3778,7 @@ cxx_init_decl_processing (void)
 
   {
     tree newattrs, extvisattr;
-    tree newtype, deltype;
+    tree newtype, deltype, deltype2;
     tree ptr_ftype_sizetype;
     tree new_eh_spec;
 
@@ -3788,8 +3816,10 @@ cxx_init_decl_processing (void)
     newtype = build_exception_variant (newtype, new_eh_spec);
     deltype = cp_build_type_attribute_variant (void_ftype_ptr, extvisattr);
     deltype = build_exception_variant (deltype, empty_except_spec);
+    deltype2 = build_exception_variant (void_ftype_ptr_sizetype, empty_except_spec);
     push_cp_library_fn (NEW_EXPR, newtype);
     push_cp_library_fn (VEC_NEW_EXPR, newtype);
+    push_cp_library_fn (DELETE_EXPR, deltype2);
     global_delete_fndecl = push_cp_library_fn (DELETE_EXPR, deltype);
     push_cp_library_fn (VEC_DELETE_EXPR, deltype);
 
@@ -5855,6 +5885,10 @@ make_rtl_for_nonlocal_decl (tree decl, tree init, const char* asmspec)
 	   && DECL_IMPLICIT_INSTANTIATION (decl))
     defer_p = 1;
 
+  /* Capture the current module info.  */
+  if (L_IPO_COMP_MODE)
+    varpool_node_for_decl (decl);
+
   /* If we're not deferring, go ahead and assemble the variable.  */
   if (!defer_p)
     rest_of_decl_compilation (decl, toplev, at_eof);
@@ -8046,9 +8080,18 @@ check_static_variable_definition (tree decl, tree type)
 	error ("in-class initialization of static data member %q#D of "
 	       "incomplete type", decl);
       else if (literal_type_p (type))
-	permerror (input_location,
-		   "%<constexpr%> needed for in-class initialization of "
-		   "static data member %q#D of non-integral type", decl);
+	{
+          /* FIXME google: This local modification allows us to
+             transition from C++98 to C++11 without moving static
+             const floats out of the class during the transition.  It
+             should not be forward-ported to a 4.8 branch, since by
+             then we should be able to just fix the code to use
+             constexpr.  */
+          pedwarn (input_location, OPT_Wpedantic,
+                   "%<constexpr%> needed for in-class initialization of "
+                   "static data member %q#D of non-integral type", decl);
+          return 0;
+	}
       else
 	error ("in-class initialization of static data member %q#D of "
 	       "non-literal type", decl);
diff --git a/gcc/cp/decl2.c b/gcc/cp/decl2.c
index 628be93..17bd0e7 100644
--- a/gcc/cp/decl2.c
+++ b/gcc/cp/decl2.c
@@ -98,10 +98,6 @@ static GTY(()) vec<tree, va_gc> *deferred_fns;
    sure are defined.  */
 static GTY(()) vec<tree, va_gc> *no_linkage_decls;
 
-/* Nonzero if we're done parsing and into end-of-file activities.  */
-
-int at_eof;
-
 
 
 /* Return a member function type (a METHOD_TYPE), given FNTYPE (a
@@ -3138,11 +3134,13 @@ start_static_storage_duration_function (unsigned count)
 {
   tree type;
   tree body;
-  char id[sizeof (SSDF_IDENTIFIER) + 1 /* '\0' */ + 32];
+  char id[sizeof (SSDF_IDENTIFIER) + 1 /* '\0' */ + 64];
 
   /* Create the identifier for this function.  It will be of the form
      SSDF_IDENTIFIER_<number>.  */
   sprintf (id, "%s_%u", SSDF_IDENTIFIER, count);
+  if (L_IPO_IS_AUXILIARY_MODULE)
+    sprintf (id, "%s.cmo.%u", id, current_module_id);
 
   type = build_function_type_list (void_type_node,
 				   integer_type_node, integer_type_node,
@@ -3554,6 +3552,9 @@ prune_vars_needing_no_initialization (tree *vars)
 	  continue;
 	}
 
+      gcc_assert (!L_IPO_IS_AUXILIARY_MODULE
+                  || varpool_is_auxiliary (varpool_node_for_decl (decl)));
+
       /* This variable is going to need initialization and/or
 	 finalization, so we add it to the list.  */
       *var = TREE_CHAIN (t);
@@ -3884,6 +3885,17 @@ no_linkage_error (tree decl)
 	       "is used but never defined", decl, t);
 }
 
+/* Clear the list of deferred functions.  */
+void
+cp_clear_deferred_fns (void)
+{
+  vec_free (deferred_fns);
+  keyed_classes = NULL;
+  vec_free (no_linkage_decls);
+  no_linkage_decls = NULL;
+  cp_clear_constexpr_hashtable ();
+}
+
 /* Collect declarations from all namespaces relevant to SOURCE_FILE.  */
 
 static void
@@ -3966,68 +3978,16 @@ handle_tls_init (void)
    first, since that way we only need to reverse the decls once.  */
 
 void
-cp_write_global_declarations (void)
+cp_process_pending_declarations (location_t locus)
 {
-  tree vars;
+  tree vars, decl;
   bool reconsider;
   size_t i;
-  location_t locus;
   unsigned ssdf_count = 0;
   int retries = 0;
-  tree decl;
-  struct pointer_set_t *candidates;
-
-  locus = input_location;
-  at_eof = 1;
-
-  /* Bad parse errors.  Just forget about it.  */
-  if (! global_bindings_p () || current_class_type
-      || !vec_safe_is_empty (decl_namespace_list))
-    return;
-
-  /* This is the point to write out a PCH if we're doing that.
-     In that case we do not want to do anything else.  */
-  if (pch_file)
-    {
-      c_common_write_pch ();
-      return;
-    }
-
-  cgraph_process_same_body_aliases ();
-
-  /* Handle -fdump-ada-spec[-slim] */
-  if (flag_dump_ada_spec || flag_dump_ada_spec_slim)
-    {
-      if (flag_dump_ada_spec_slim)
-	collect_source_ref (main_input_filename);
-      else
-	collect_source_refs (global_namespace);
-
-      dump_ada_specs (collect_all_refs, cpp_check);
-    }
-
-  /* FIXME - huh?  was  input_line -= 1;*/
 
   timevar_start (TV_PHASE_DEFERRED);
 
-  /* We now have to write out all the stuff we put off writing out.
-     These include:
-
-       o Template specializations that we have not yet instantiated,
-	 but which are needed.
-       o Initialization and destruction for non-local objects with
-	 static storage duration.  (Local objects with static storage
-	 duration are initialized when their scope is first entered,
-	 and are cleaned up via atexit.)
-       o Virtual function tables.
-
-     All of these may cause others to be needed.  For example,
-     instantiating one function may cause another to be needed, and
-     generating the initializer for an object may cause templates to be
-     instantiated, etc., etc.  */
-
-  emit_support_tinfos ();
-
   do
     {
       tree t;
@@ -4221,7 +4181,7 @@ cp_write_global_declarations (void)
 	  if (!DECL_EXTERNAL (decl)
 	      && decl_needed_p (decl)
 	      && !TREE_ASM_WRITTEN (decl)
-	      && !cgraph_get_node (decl)->local.finalized)
+	      && !cgraph_get_create_node (decl)->local.finalized)
 	    {
 	      /* We will output the function; no longer consider it in this
 		 loop.  */
@@ -4263,6 +4223,25 @@ cp_write_global_declarations (void)
     }
   while (reconsider);
 
+  if (L_IPO_IS_AUXILIARY_MODULE)
+    {
+      gcc_assert (flag_dyn_ipa && L_IPO_COMP_MODE);
+
+      /* Do some cleanup -- we do not really need static init function
+         to be created for auxiliary modules -- they are created to keep
+         funcdef_no consistent between profile use and profile gen.  */
+#if FIXME_LIPO
+      for (i = 0; ssdf_decls->iterator (i, fndecl); ++i)
+        /* Such ssdf_decls are not called from GLOBAL ctor/dtor, mark
+	   them reachable to avoid being eliminated too early before
+	   gimplication.  */
+        cgraph_mark_reachable_node (cgraph_get_create_node (fndecl));
+#endif
+      ssdf_decls = NULL;
+      timevar_stop (TV_PHASE_DEFERRED);
+      return;
+    }
+
   /* All used inline functions must have a definition at this point.  */
   FOR_EACH_VEC_SAFE_ELT (deferred_fns, i, decl)
     {
@@ -4315,7 +4294,10 @@ cp_write_global_declarations (void)
 
   /* We're done with the splay-tree now.  */
   if (priority_info_map)
-    splay_tree_delete (priority_info_map);
+    {
+      splay_tree_delete (priority_info_map);
+      priority_info_map = NULL;
+    }
 
   /* Generate any missing aliases.  */
   maybe_apply_pending_pragma_weaks ();
@@ -4324,10 +4306,78 @@ cp_write_global_declarations (void)
      linkage now.  */
   pop_lang_context ();
 
+  ssdf_decls = NULL;
+  timevar_stop (TV_PHASE_DEFERRED);
+}
+
+/* This routine is called at the end of compilation.
+   Its job is to create all the code needed to initialize and
+   destroy the global aggregates.  We do the destruction
+   first, since that way we only need to reverse the decls once.  */
+
+void
+cp_write_global_declarations (void)
+{
+  bool reconsider = false;
+  location_t locus;
+  struct pointer_set_t *candidates;
+
+  locus = input_location;
+  at_eof = 1;
+
+  /* Bad parse errors.  Just forget about it.  */
+  if (! global_bindings_p () || current_class_type
+      || !vec_safe_is_empty (decl_namespace_list))
+    return;
+
+  if (pch_file)
+    {
+      c_common_write_pch ();
+      return;
+    }
+
+  cgraph_process_same_body_aliases ();
+
+  /* Handle -fdump-ada-spec[-slim] */
+  if (flag_dump_ada_spec || flag_dump_ada_spec_slim)
+    {
+      if (flag_dump_ada_spec_slim)
+	collect_source_ref (main_input_filename);
+      else
+	collect_source_refs (global_namespace);
+
+      dump_ada_specs (collect_all_refs, cpp_check);
+    }
+
+  /* FIXME - huh?  was  input_line -= 1;*/
+
+  /* We now have to write out all the stuff we put off writing out.
+     These include:
+
+       o Template specializations that we have not yet instantiated,
+	 but which are needed.
+       o Initialization and destruction for non-local objects with
+	 static storage duration.  (Local objects with static storage
+	 duration are initialized when their scope is first entered,
+	 and are cleaned up via atexit.)
+       o Virtual function tables.
+
+     All of these may cause others to be needed.  For example,
+     instantiating one function may cause another to be needed, and
+     generating the initializer for an object may cause templates to be
+     instantiated, etc., etc.  */
+
+  timevar_push (TV_VARCONST);
+
+  emit_support_tinfos ();
+
+  if (!L_IPO_COMP_MODE)
+    cp_process_pending_declarations (locus);
+
   /* Collect candidates for Java hidden aliases.  */
   candidates = collect_candidates_for_java_method_aliases ();
 
-  timevar_stop (TV_PHASE_DEFERRED);
+
   timevar_start (TV_PHASE_OPT_GEN);
 
   finalize_compilation_unit ();
diff --git a/gcc/cp/error.c b/gcc/cp/error.c
index a3525874..03e031c 100644
--- a/gcc/cp/error.c
+++ b/gcc/cp/error.c
@@ -1831,7 +1831,8 @@ dump_expr (tree t, int flags)
     case SSA_NAME:
       if (SSA_NAME_VAR (t)
 	  && !DECL_ARTIFICIAL (SSA_NAME_VAR (t)))
-	dump_expr (SSA_NAME_VAR (t), flags);
+	dump_expr (SSA_NAME_VAR (t),
+                   (flags & ~TFF_DECL_SPECIFIERS) | TFF_NO_FUNCTION_ARGUMENTS);
       else
 	pp_cxx_ws_string (cxx_pp, M_("<unknown>"));
       break;
diff --git a/gcc/cp/friend.c b/gcc/cp/friend.c
index 0833728..2ed9ea0 100644
--- a/gcc/cp/friend.c
+++ b/gcc/cp/friend.c
@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "tree.h"
 #include "cp-tree.h"
 #include "flags.h"
+#include "cgraph.h"
 
 /* Friend data structures are described in cp-tree.h.  */
 
diff --git a/gcc/cp/init.c b/gcc/cp/init.c
index 6f3196a..d58bb0c 100644
--- a/gcc/cp/init.c
+++ b/gcc/cp/init.c
@@ -728,8 +728,8 @@ perform_member_init (tree member, tree init)
 						tf_warning_or_error);
 
       if (init)
-	finish_expr_stmt (cp_build_modify_expr (decl, INIT_EXPR, init,
-						tf_warning_or_error));
+          finish_expr_stmt (cp_build_modify_expr (decl, INIT_EXPR, init,
+                                                  tf_warning_or_error));
     }
 
   if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))
@@ -747,6 +747,11 @@ perform_member_init (tree member, tree init)
       if (expr != error_mark_node)
 	finish_eh_cleanup (expr);
     }
+
+  /* Check for and warn about self-initialization if -Wself-assign is
+     enabled.  */
+  if (warn_self_assign)
+    check_for_self_assign (input_location, decl, init);
 }
 
 /* Returns a TREE_LIST containing (as the TREE_PURPOSE of each node) all
diff --git a/gcc/cp/mangle.c b/gcc/cp/mangle.c
index 4a230d6..f12b626 100644
--- a/gcc/cp/mangle.c
+++ b/gcc/cp/mangle.c
@@ -3488,10 +3488,15 @@ mangle_decl (const tree decl)
       tree id2, alias;
 #endif
 
-      SET_IDENTIFIER_GLOBAL_VALUE (id, decl);
-      if (IDENTIFIER_GLOBAL_VALUE (id) != decl)
-	inform (DECL_SOURCE_LOCATION (decl), "-fabi-version=6 (or =0) "
-		"avoids this error with a change in mangling");
+      if (!L_IPO_COMP_MODE || !is_parsing_done_p ())
+        SET_IDENTIFIER_GLOBAL_VALUE (id, decl);
+      if (L_IPO_COMP_MODE && !is_parsing_done_p ())
+        add_decl_to_current_module_scope (decl,
+                                          NAMESPACE_LEVEL (global_namespace));
+      if (!L_IPO_COMP_MODE || !is_parsing_done_p ())
+        if (IDENTIFIER_GLOBAL_VALUE (id) != decl)
+          inform (DECL_SOURCE_LOCATION (decl), "-fabi-version=6 (or =0) "
+                  "avoids this error with a change in mangling");
 
 #ifdef ASM_OUTPUT_DEF
       save_ver = flag_abi_version;
@@ -3767,6 +3772,14 @@ mangle_conv_op_name_for_type (const tree type)
   return identifier;
 }
 
+/* Clear the conversion map.  */
+
+void
+cp_clear_conv_type_map (void)
+{
+  conv_type_names = NULL;
+}
+
 /* Write out the appropriate string for this variable when generating
    another mangled name based on this one.  */
 
diff --git a/gcc/cp/name-lookup.c b/gcc/cp/name-lookup.c
index 2a47331..a1c79fa 100644
--- a/gcc/cp/name-lookup.c
+++ b/gcc/cp/name-lookup.c
@@ -602,6 +602,10 @@ add_decl_to_level (tree decl, cp_binding_level *b)
 		&& (!TREE_PUBLIC (decl) || DECL_DECLARED_INLINE_P (decl))))
 	  vec_safe_push (b->static_decls, decl);
     }
+
+  /* The following call is needed for LIPO mode. In this mode, global
+     scope declarations are tracked on a per-module basis.  */
+  add_decl_to_current_module_scope (decl, b);
 }
 
 /* Record a decl-node X as belonging to the current lexical scope.
@@ -1136,26 +1140,49 @@ pushdecl_maybe_friend_1 (tree x, bool is_friend)
 		  error ("%q+#D previously declared here", oldlocal);
 		}
 
-	      if (warn_shadow && !nowarn)
+	      if ((warn_shadow
+		   || warn_shadow_local
+		   || warn_shadow_compatible_local)
+		  && !nowarn)
 		{
+                  enum opt_code warning_code;
+                  /* If '-Wshadow-compatible-local' is specified without other
+                     -Wshadow flags, we will warn only when the type of the
+                     shadowing variable (i.e. x) can be converted to that of
+                     the shadowed parameter (oldlocal). The reason why we only
+                     check if x's type can be converted to oldlocal's type
+                     (but not the other way around) is because when users
+                     accidentally shadow a parameter, more than often they
+                     would use the variable thinking (mistakenly) it's still
+                     the parameter. It would be rare that users would use the
+                     variable in the place that expects the parameter but
+                     thinking it's a new decl.  */
+                  if (can_convert (TREE_TYPE (oldlocal), TREE_TYPE (x),
+				   tf_none))
+                    warning_code = OPT_Wshadow_compatible_local;
+                  else
+                    warning_code = OPT_Wshadow_local;
 		  if (TREE_CODE (oldlocal) == PARM_DECL)
-		    warning_at (input_location, OPT_Wshadow,
+		    warning_at (input_location, warning_code,
 				"declaration of %q#D shadows a parameter", x);
 		  else if (is_capture_proxy (oldlocal))
-		    warning_at (input_location, OPT_Wshadow,
+		    warning_at (input_location, warning_code,
 				"declaration of %qD shadows a lambda capture",
 				x);
 		  else
-		    warning_at (input_location, OPT_Wshadow,
+		    warning_at (input_location, warning_code,
 				"declaration of %qD shadows a previous local",
 				x);
-		   warning_at (DECL_SOURCE_LOCATION (oldlocal), OPT_Wshadow,
+		   warning_at (DECL_SOURCE_LOCATION (oldlocal), warning_code,
 			       "shadowed declaration is here");
 		}
 	    }
 
 	  /* Maybe warn if shadowing something else.  */
-	  else if (warn_shadow && !DECL_EXTERNAL (x)
+	  else if ((warn_shadow
+		    || warn_shadow_local
+		    || warn_shadow_compatible_local)
+	           && !DECL_EXTERNAL (x)
                    /* No shadow warnings for internally generated vars unless
                       it's an implicit typedef (see create_implicit_typedef
                       in decl.c).  */
@@ -4967,7 +4994,6 @@ lookup_name_innermost_nonclass_level (tree name)
   return ret;
 }
 
-
 /* Returns true iff DECL is a block-scope extern declaration of a function
    or variable.  */
 
diff --git a/gcc/cp/name-lookup.h b/gcc/cp/name-lookup.h
index b88ada3..c578186 100644
--- a/gcc/cp/name-lookup.h
+++ b/gcc/cp/name-lookup.h
@@ -89,6 +89,7 @@ typedef struct GTY(()) cxx_saved_binding {
 extern tree identifier_type_value (tree);
 extern void set_identifier_type_value (tree, tree);
 extern void pop_binding (tree, tree);
+extern void pop_global_binding (tree, cxx_binding*);
 extern tree constructor_name (tree);
 extern bool constructor_name_p (tree, tree);
 
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index 8798fb3..cc0b586 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -7632,6 +7632,16 @@ cp_parser_question_colon_clause (cp_parser* parser, tree logical_or_expr)
                                    tf_warning_or_error);
 }
 
+/* A helpfer function to check if the given expression (EXPR) is of POD type.
+   Note that if the expression's type is NULL (e.g. when its type depends on
+   template parameters), we return false.  */
+
+static bool
+expr_is_pod (tree expr)
+{
+  return TREE_TYPE (expr) && pod_type_p (TREE_TYPE (expr));
+}
+
 /* Parse an assignment-expression.
 
    assignment-expression:
@@ -7690,6 +7700,16 @@ cp_parser_assignment_expression (cp_parser* parser, bool cast_p,
 	      if (cp_parser_non_integral_constant_expression (parser,
 							      NIC_ASSIGNMENT))
 		return error_mark_node;
+
+              /* Check for and warn about self-assignment if -Wself-assign is
+                 enabled and the assignment operator is "=".
+		 Checking for non-POD self-assignment will be performed only
+		 when -Wself-assign-non-pod is enabled. */
+              if (warn_self_assign
+		  && assignment_operator == NOP_EXPR
+		  && (warn_self_assign_non_pod || expr_is_pod (expr)))
+                check_for_self_assign (input_location, expr, rhs);
+
 	      /* Build the assignment expression.  Its default
 		 location is the location of the '=' token.  */
 	      saved_input_location = input_location;
@@ -9602,7 +9622,10 @@ cp_parser_range_for (cp_parser *parser, tree scope, tree init, tree range_decl)
 	range_expr = error_mark_node;
       stmt = begin_range_for_stmt (scope, init);
       finish_range_for_decl (stmt, range_decl, range_expr);
-      if (!type_dependent_expression_p (range_expr)
+      if (range_expr != error_mark_node
+	  && !type_dependent_expression_p (range_expr)
+	  /* The length of an array might be dependent.  */
+	  && COMPLETE_TYPE_P (complete_type (TREE_TYPE (range_expr)))
 	  /* do_auto_deduction doesn't mess with template init-lists.  */
 	  && !BRACE_ENCLOSED_INITIALIZER_P (range_expr))
 	do_range_for_auto_deduction (range_decl, range_expr);
@@ -15397,7 +15420,6 @@ cp_parser_alias_declaration (cp_parser* parser)
   id = cp_parser_identifier (parser);
   if (id == error_mark_node)
     return error_mark_node;
-
   cp_token *attrs_token = cp_lexer_peek_token (parser->lexer);
   attributes = cp_parser_attributes_opt (parser);
   if (attributes == error_mark_node)
@@ -16144,6 +16166,10 @@ cp_parser_init_declarator (cp_parser* parser,
 			 `explicit' constructor cannot be used.  */
 		      ((is_direct_init || !is_initialized)
 		       ? LOOKUP_NORMAL : LOOKUP_IMPLICIT));
+      /* Check for and warn about self-initialization if -Wself-assign is
+         enabled.  */
+      if (warn_self_assign && initializer)
+        check_for_self_assign (input_location, decl, initializer);
     }
   else if ((cxx_dialect != cxx98) && friend_p
 	   && decl && TREE_CODE (decl) == FUNCTION_DECL)
@@ -28333,14 +28359,6 @@ pragma_lex (tree *value)
 void
 c_parse_file (void)
 {
-  static bool already_called = false;
-
-  if (already_called)
-    {
-      sorry ("inter-module optimizations not implemented for C++");
-      return;
-    }
-  already_called = true;
 
   the_parser = cp_parser_new ();
   push_deferring_access_checks (flag_access_control
diff --git a/gcc/cp/parser.h b/gcc/cp/parser.h
index fe787e4..04a0352 100644
--- a/gcc/cp/parser.h
+++ b/gcc/cp/parser.h
@@ -333,6 +333,15 @@ typedef struct GTY(()) cp_parser {
      outermost class being defined is complete.  */
   vec<cp_unparsed_functions_entry, va_gc> *unparsed_queues;
 
+  /* A list of attributes whose arguments are not yet parsed. The
+     TREE_VALUE of each list node contains a delayed attribute.
+     The argument of the attribute (i.e. TREE_VALUE of the attribute)
+     is a special tree list node, where the TREE_PURPOSE is error_mark_node
+     and the TREE_VALUE points to the cached tokens of the arguments.
+     This list is processed once the outermost class being defined is
+     complete.  */
+  tree unparsed_attribute_args_queue;
+
   /* The number of classes whose definitions are currently in
      progress.  */
   unsigned num_classes_being_defined;
@@ -340,6 +349,16 @@ typedef struct GTY(()) cp_parser {
   /* The number of template parameter lists that apply directly to the
      current declaration.  */
   unsigned num_template_parameter_lists;
+
+  /* Record the paramter list of the function declaration that is being parsed
+     so that it can be looked up when later parsing the lock attributes which
+     might refer to a function parameter.  */
+  tree current_func_declarator_params;
+
+  /* Record the scope of the current declarator as we might need to use it
+     parsing the lock attributes with arguments that should be considered in
+     the declarator's scope.  */
+  tree current_declarator_scope;
 } cp_parser;
 
 /* In parser.c  */
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index ed4a689..2a28600 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -39,8 +39,10 @@ along with GCC; see the file COPYING3.  If not see
 #include "tree-inline.h"
 #include "decl.h"
 #include "toplev.h"
+#include "opts.h"
 #include "timevar.h"
 #include "tree-iterator.h"
+#include "cgraph.h"
 
 /* The type of functions taking a tree, and some additional data, and
    returning an int.  */
@@ -13496,11 +13498,7 @@ tsubst_copy_and_build (tree t,
 	if (error_msg)
 	  error (error_msg);
 	if (!function_p && TREE_CODE (decl) == IDENTIFIER_NODE)
-	  {
-	    if (complain & tf_error)
-	      unqualified_name_lookup_error (decl);
-	    decl = error_mark_node;
-	  }
+	  decl = unqualified_name_lookup_error (decl);
 	RETURN (decl);
       }
 
@@ -18821,7 +18819,13 @@ instantiate_decl (tree d, int defer_ok,
 	 when marked as "extern template".  */
       if (!(external_p && TREE_CODE (d) == VAR_DECL))
 	add_pending_template (d);
-      goto out;
+      {
+        if (L_IPO_COMP_MODE)
+          /* Capture module info.  */
+          if (TREE_CODE (d) == VAR_DECL)
+            varpool_node_for_decl (d);
+        goto out;
+      }
     }
   /* Tell the repository that D is available in this translation unit
      -- and see if it is supposed to be instantiated here.  */
diff --git a/gcc/cp/rtti.c b/gcc/cp/rtti.c
index 6c02c1c..c773330 100644
--- a/gcc/cp/rtti.c
+++ b/gcc/cp/rtti.c
@@ -1227,6 +1227,10 @@ create_pseudo_type_info (int tk, const char *real_name, ...)
   /* Create the pseudo type.  */
   pseudo_type = make_class_type (RECORD_TYPE);
   finish_builtin_struct (pseudo_type, pseudo_name, fields, NULL_TREE);
+  /* For lightweight IPO (LIPO), the list of builtin decls
+     and types are remembered.  */
+  cp_add_built_in_decl (pseudo_type);
+
   CLASSTYPE_AS_BASE (pseudo_type) = pseudo_type;
 
   ti = &(*tinfo_descs)[tk];
@@ -1392,6 +1396,9 @@ create_tinfo_types (void)
     ti->name = NULL_TREE;
     finish_builtin_struct (ti->type, "__type_info_pseudo",
 			   fields, NULL_TREE);
+    /* For lightweight IPO (LIPO), the list of builtin decls
+       and types are remembered.  */
+    cp_add_built_in_decl (ti->type);
   }
 
   /* Fundamental type_info */
@@ -1433,6 +1440,9 @@ create_tinfo_types (void)
     ti->name = NULL_TREE;
     finish_builtin_struct (ti->type, "__base_class_type_info_pseudo",
 			   fields, NULL_TREE);
+    /* For lightweight IPO (LIPO), the list of builtin decls
+       and types are remembered.  */
+    cp_add_built_in_decl (ti->type);
   }
 
   /* Pointer type_info. Adds two fields, qualification mask
diff --git a/gcc/cp/semantics.c b/gcc/cp/semantics.c
index 5b8197e..3d25476 100644
--- a/gcc/cp/semantics.c
+++ b/gcc/cp/semantics.c
@@ -3767,6 +3767,18 @@ emit_associated_thunks (tree fn)
     {
       tree thunk;
 
+      if (L_IPO_COMP_MODE)
+        {
+          /* In LIPO mode, multiple copies of definitions for the same function
+             may exist, but assembler hash table keeps only one copy which might
+             have been deleted at this point.  */
+          struct cgraph_node *n = cgraph_get_create_node (fn);
+	  #ifdef FIXME_LIPO
+          insert_to_assembler_name_hash ((symtab_node)n);
+	  #endif
+          cgraph_link_node (n);
+        }
+
       for (thunk = DECL_THUNKS (fn); thunk; thunk = DECL_CHAIN (thunk))
 	{
 	  if (!THUNK_ALIAS (thunk))
@@ -6317,6 +6329,15 @@ cx_check_missing_mem_inits (tree fun, tree body, bool complain)
   return bad;
 }
 
+/* Clear constexpr hash table  */
+
+void
+cp_clear_constexpr_hashtable (void)
+{
+  /* htab_delete (constexpr_fundef_table); */
+  constexpr_fundef_table = NULL;
+}
+
 /* We are processing the definition of the constexpr function FUN.
    Check that its BODY fulfills the propriate requirements and
    enter it in the constexpr function definition table.
diff --git a/gcc/dbgcnt.def b/gcc/dbgcnt.def
index 04d69ed..2e878b2 100644
--- a/gcc/dbgcnt.def
+++ b/gcc/dbgcnt.def
@@ -141,6 +141,7 @@ echo ubound: $ub
 */
 
 /* Debug counter definitions.  */
+DEBUG_COUNTER (alias)
 DEBUG_COUNTER (auto_inc_dec)
 DEBUG_COUNTER (ccp)
 DEBUG_COUNTER (cfg_cleanup)
@@ -165,6 +166,7 @@ DEBUG_COUNTER (if_conversion)
 DEBUG_COUNTER (if_conversion_tree)
 DEBUG_COUNTER (if_after_combine)
 DEBUG_COUNTER (if_after_reload)
+DEBUG_COUNTER (inl)
 DEBUG_COUNTER (local_alloc_for_sched)
 DEBUG_COUNTER (postreload_cse)
 DEBUG_COUNTER (pre)
diff --git a/gcc/dce.c b/gcc/dce.c
index b7ecc30..776a611 100644
--- a/gcc/dce.c
+++ b/gcc/dce.c
@@ -755,6 +755,9 @@ rest_of_handle_ud_dce (void)
 {
   rtx insn;
 
+  if (df_check_ud_du_memory_usage ())
+    return 0;
+
   init_dce (false);
 
   prescan_insns_for_dce (false);
diff --git a/gcc/debug.h b/gcc/debug.h
index 886de17..8a796cd 100644
--- a/gcc/debug.h
+++ b/gcc/debug.h
@@ -170,6 +170,7 @@ extern const struct gcc_debug_hooks sdb_debug_hooks;
 extern const struct gcc_debug_hooks xcoff_debug_hooks;
 extern const struct gcc_debug_hooks dwarf2_debug_hooks;
 extern const struct gcc_debug_hooks vmsdbg_debug_hooks;
+extern const struct gcc_debug_hooks auto_profile_debug_hooks;
 
 /* Dwarf2 frame information.  */
 
diff --git a/gcc/df-problems.c b/gcc/df-problems.c
index abe6958..c9e724b 100644
--- a/gcc/df-problems.c
+++ b/gcc/df-problems.c
@@ -59,6 +59,28 @@ static bitmap_head seen_in_insn;
    Utility functions.
 ----------------------------------------------------------------------------*/
 
+/* A helper function checking if UD/DU is large and dense. It returns true
+   if UD/DU can potentially consume huge amount of memory. Returns false
+   otherwise
+*/
+
+bool
+df_check_ud_du_memory_usage (void)
+{
+  /* TODO: make this a target hook. The heuristic applies only to x86 in
+     m32 mode with -Os. In that mode 'push' instruction is used in argument
+     passing, with sp adjustment instruction after each function call. The
+     side effect is that the DU/UD becomes really dense.  */
+#define DF_LARGE_FUNC 20000
+
+  if (optimize_size
+      && n_basic_blocks_for_function (cfun) > DF_LARGE_FUNC)  
+    return true;
+
+  return false;
+}
+
+
 /* Generic versions to get the void* version of the block info.  Only
    used inside the problem instance vectors.  */
 
@@ -4506,6 +4528,3 @@ df_md_add_problem (void)
 {
   df_add_problem (&problem_MD);
 }
-
-
-
diff --git a/gcc/df.h b/gcc/df.h
index c2bb826..859b0a6 100644
--- a/gcc/df.h
+++ b/gcc/df.h
@@ -1148,4 +1148,6 @@ extern void union_defs (df_ref, struct web_entry *,
 			unsigned int *used, struct web_entry *,
 			bool (*fun) (struct web_entry *, struct web_entry *));
 
+extern bool df_check_ud_du_memory_usage (void);
+
 #endif /* GCC_DF_H */
diff --git a/gcc/diagnostic.c b/gcc/diagnostic.c
index 46986ca..a74fa9f 100644
--- a/gcc/diagnostic.c
+++ b/gcc/diagnostic.c
@@ -126,6 +126,7 @@ diagnostic_initialize (diagnostic_context *context, int n_opts)
   memset (context->diagnostic_count, 0, sizeof context->diagnostic_count);
   context->some_warnings_are_errors = false;
   context->warning_as_error_requested = false;
+  context->force_warnings_requested = false;
   context->n_opts = n_opts;
   context->classify_diagnostic = XNEWVEC (diagnostic_t, n_opts);
   for (i = 0; i < n_opts; i++)
@@ -184,6 +185,7 @@ diagnostic_set_info_translated (diagnostic_info *diagnostic, const char *msg,
 				va_list *args, location_t location,
 				diagnostic_t kind)
 {
+  location = map_discriminator_location (location);
   diagnostic->message.err_no = errno;
   diagnostic->message.args_ptr = args;
   diagnostic->message.format_spec = msg;
@@ -502,6 +504,9 @@ diagnostic_report_current_module (diagnostic_context *context, location_t where)
   if (where <= BUILTINS_LOCATION)
     return;
 
+  if (has_discriminator (where))
+    where = map_discriminator_location (where);
+
   linemap_resolve_location (line_table, where,
 			    LRK_MACRO_DEFINITION_LOCATION,
 			    &map);
@@ -673,7 +678,8 @@ diagnostic_report_diagnostic (diagnostic_context *context,
      individual warnings can be overridden back to warnings with
      -Wno-error=*.  */
   if (context->warning_as_error_requested
-      && diagnostic->kind == DK_WARNING)
+      && diagnostic->kind == DK_WARNING
+      && !context->force_warnings_requested)
     {
       diagnostic->kind = DK_ERROR;
     }
@@ -719,7 +725,9 @@ diagnostic_report_diagnostic (diagnostic_context *context,
       /* This tests if the user provided the appropriate -Werror=foo
 	 option.  */
       if (diag_class == DK_UNSPECIFIED
-	  && context->classify_diagnostic[diagnostic->option_index] != DK_UNSPECIFIED)
+	  && context->classify_diagnostic[diagnostic->option_index] != DK_UNSPECIFIED
+	  && (context->classify_diagnostic[diagnostic->option_index] != DK_ERROR
+	      || !context->force_warnings_requested))
 	{
 	  diagnostic->kind = context->classify_diagnostic[diagnostic->option_index];
 	}
diff --git a/gcc/diagnostic.h b/gcc/diagnostic.h
index f0fae96..c9d16bf 100644
--- a/gcc/diagnostic.h
+++ b/gcc/diagnostic.h
@@ -72,6 +72,9 @@ struct diagnostic_context
   /* True if it has been requested that warnings be treated as errors.  */
   bool warning_as_error_requested;
 
+  /* True if it has been requested that warnings never be promoted to errors.  */
+  bool force_warnings_requested;
+
   /* The number of option indexes that can be passed to warning() et
      al.  */
   int n_opts;
diff --git a/gcc/doc/gcov.texi b/gcc/doc/gcov.texi
index 9db8e8f..2b67527 100644
--- a/gcc/doc/gcov.texi
+++ b/gcc/doc/gcov.texi
@@ -122,15 +122,17 @@ gcov [@option{-v}|@option{--version}] [@option{-h}|@option{--help}]
      [@option{-a}|@option{--all-blocks}]
      [@option{-b}|@option{--branch-probabilities}]
      [@option{-c}|@option{--branch-counts}]
-     [@option{-u}|@option{--unconditional-branches}]
-     [@option{-n}|@option{--no-output}]
+     [@option{-d}|@option{--display-progress}]
+     [@option{-f}|@option{--function-summaries}]
+     [@option{-i}|@option{--intermediate-format}]
      [@option{-l}|@option{--long-file-names}]
+     [@option{-m}|@option{--demangled-names}]
+     [@option{-n}|@option{--no-output}]
+     [@option{-o}|@option{--object-directory} @var{directory|file}]
      [@option{-p}|@option{--preserve-paths}]
      [@option{-r}|@option{--relative-only}]
-     [@option{-f}|@option{--function-summaries}]
-     [@option{-o}|@option{--object-directory} @var{directory|file}]
      [@option{-s}|@option{--source-prefix} @var{directory}]
-     [@option{-d}|@option{--display-progress}]
+     [@option{-u}|@option{--unconditional-branches}]
      @var{files}
 @c man end
 @c man begin SEEALSO
@@ -232,6 +234,50 @@ Unconditional branches are normally not interesting.
 @itemx --display-progress
 Display the progress on the standard output.
 
+@item -i
+@itemx --intermediate-format
+Output gcov file in an easy-to-parse intermediate text format that can
+be used by @command{lcov} or other tools. The output is a single
+@file{.gcov} file per @file{.gcda} file. No source code is required.
+
+The format of the intermediate @file{.gcov} file is plain text with
+one entry per line
+
+@smallexample
+file:@var{source_file_name}
+function:@var{line_number},@var{execution_count},@var{function_name}
+lcount:@var{line number},@var{execution_count}
+branch:@var{line_number},@var{branch_coverage_type}
+
+Where the @var{branch_coverage_type} is
+   notexec (Branch not executed)
+   taken (Branch executed and taken)
+   nottaken (Branch executed, but not taken)
+
+There can be multiple @var{file} entries in an intermediate gcov
+file. All entries following a @var{file} pertain to that source file
+until the next @var{file} entry.
+@end smallexample
+
+Here is a sample when @option{-i} is used in conjuction with @option{-b} option:
+
+@smallexample
+file:array.cc
+function:11,1,_Z3sumRKSt6vectorIPiSaIS0_EE
+function:22,1,main
+lcount:11,1
+lcount:12,1
+lcount:14,1
+branch:14,taken
+lcount:26,1
+branch:28,nottaken
+@end smallexample
+
+@item -m
+@itemx --demangled-names
+Display demangled function names in output. The default is to show
+mangled function names.
+
 @end table
 
 @command{gcov} should be run with the current directory the same as that
diff --git a/gcc/doc/install.texi b/gcc/doc/install.texi
index 1265129..17983e6 100644
--- a/gcc/doc/install.texi
+++ b/gcc/doc/install.texi
@@ -896,6 +896,18 @@ ideas of what it is for.  People use it as if it specified where to
 install part of GCC@.  Perhaps they make this assumption because
 installing GCC creates the directory.
 
+@item --with-runtime-root-prefix=@var{dirname}
+Specifies that @var{dirname} is to be used as a prefix before paths
+to files used at runtime, such as the path to the dynamic linker.
+For instance, if the dynamic linker is normally @file{/lib/ld.so} and
+this option is given as:
+@smallexample
+--with-runtime-root-prefix=/other
+@end smallexample
+then the compiler will cause compiled executables to use
+@file{/other/lib/ld.so} as their dynamic linker at runtime.  This option
+is currently only supported by some targets, notably Linux.
+
 @item --with-native-system-header-dir=@var{dirname}
 Specifies that @var{dirname} is the directory that contains native system
 header files, rather than @file{/usr/include}.  This option is most useful
@@ -1710,6 +1722,20 @@ This linker should have plugin support such as gold starting with
 version 2.20 or GNU ld starting with version 2.21.
 See @option{-fuse-linker-plugin} for details.
 
+@item --enable-canonical-prefixes
+@itemx --disable-canonical-prefixes
+Enable prefix canonicalization for GCC files that the GCC driver locates
+relative to its own path.  Canonicalized prefixes have any @code{/x/../}
+elements removed and symbolic links expanded.  This is enabled by default,
+and may be disabled using @option{--disable-canonical-prefixes}.
+See @option{-canonical-prefixes} or @option{-no-canonical-prefixes} for
+more details, including how to override this configuration option when
+compiling.
+
+@item --with-warn-frame-larger-than-extra-text=@var{text}
+Append @samp{@var{text}} to frame size warnings generated by
+the @option{-Wframe-larger-than} warning flag.
+
 @item --enable-canonical-system-headers
 @itemx --disable-canonical-system-headers
 Enable system header path canonicalization for @file{libcpp}.  This can
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index c3e38f1..8ecf77d 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -238,11 +238,11 @@ Objective-C and Objective-C++ Dialects}.
 -Wno-attributes -Wno-builtin-macro-redefined @gol
 -Wc++-compat -Wc++11-compat -Wcast-align  -Wcast-qual  @gol
 -Wchar-subscripts -Wclobbered  -Wcomment @gol
--Wconversion  -Wcoverage-mismatch  -Wno-cpp  -Wno-deprecated  @gol
+-Wconversion -Wreal-conversion -Wcoverage-mismatch  -Wno-cpp  -Wno-deprecated  @gol
 -Wno-deprecated-declarations -Wdisabled-optimization  @gol
 -Wno-div-by-zero -Wdouble-promotion -Wempty-body  -Wenum-compare @gol
 -Wno-endif-labels -Werror  -Werror=* @gol
--Wfatal-errors  -Wfloat-equal  -Wformat  -Wformat=2 @gol
+-Wfatal-errors  -Wfloat-equal -Wforce-warnings -Wformat  -Wformat=2 @gol
 -Wno-format-contains-nul -Wno-format-extra-args -Wformat-nonliteral @gol
 -Wformat-security  -Wformat-y2k @gol
 -Wframe-larger-than=@var{len} -Wno-free-nonheap-object -Wjump-misses-init @gol
@@ -259,8 +259,9 @@ Objective-C and Objective-C++ Dialects}.
 -Woverlength-strings  -Wpacked  -Wpacked-bitfield-compat  -Wpadded @gol
 -Wparentheses  -Wpedantic-ms-format -Wno-pedantic-ms-format @gol
 -Wpointer-arith  -Wno-pointer-to-int-cast @gol
--Wredundant-decls  -Wno-return-local-addr @gol
--Wreturn-type  -Wsequence-point  -Wshadow @gol
+-Wredundant-decls  -Wno-return-local-addr -Wipa-opt-mismatch @gol
+-Wreturn-type -Wself-assign -Wself-assign-non-pod -Wsequence-point  -Wshadow @gol
+-Wshadow-compatible-local -Wshadow-local @gol
 -Wsign-compare  -Wsign-conversion  -Wsizeof-pointer-memaccess @gol
 -Wstack-protector -Wstack-usage=@var{len} -Wstrict-aliasing @gol
 -Wstrict-aliasing=n @gol -Wstrict-overflow -Wstrict-overflow=@var{n} @gol
@@ -328,16 +329,19 @@ Objective-C and Objective-C++ Dialects}.
 -fenable-@var{kind}-@var{pass} @gol
 -fenable-@var{kind}-@var{pass}=@var{range-list} @gol
 -fdebug-types-section -fmem-report-wpa @gol
+-fenable-@var{kind}-@var{pass} @gol
+-fenable-@var{kind}-@var{pass}=@var{range-list} @gol
+-fdebug-types-section @gol
 -fmem-report -fpre-ipa-mem-report -fpost-ipa-mem-report -fprofile-arcs @gol
+-fprofile-strip=@var{suffix} -frandom-seed=@var{string} -fsched-verbose=@var{n} @gol
 -fopt-info @gol
 -fopt-info-@var{options}@r{[}=@var{file}@r{]} @gol
--frandom-seed=@var{string} -fsched-verbose=@var{n} @gol
 -fsel-sched-verbose -fsel-sched-dump-cfg -fsel-sched-pipelining-verbose @gol
 -fstack-usage  -ftest-coverage  -ftime-report -fvar-tracking @gol
 -fvar-tracking-assignments  -fvar-tracking-assignments-toggle @gol
 -g  -g@var{level}  -gtoggle  -gcoff  -gdwarf-@var{version} @gol
 -ggdb  -grecord-gcc-switches  -gno-record-gcc-switches @gol
--gstabs  -gstabs+  -gstrict-dwarf  -gno-strict-dwarf @gol
+-gmlt -gstabs  -gstabs+  -gstrict-dwarf  -gno-strict-dwarf @gol
 -gvms  -gxcoff  -gxcoff+ @gol
 -fno-merge-debug-strings -fno-dwarf2-cfi-asm @gol
 -fdebug-prefix-map=@var{old}=@var{new} @gol
@@ -354,10 +358,11 @@ Objective-C and Objective-C++ Dialects}.
 @gccoptlist{-faggressive-loop-optimizations -falign-functions[=@var{n}] @gol
 -falign-jumps[=@var{n}] @gol
 -falign-labels[=@var{n}] -falign-loops[=@var{n}] @gol
--fassociative-math -fauto-inc-dec -fbranch-probabilities @gol
+-fassociative-math -fauto-inc-dec -fauto-profile -fbranch-probabilities @gol
 -fbranch-target-load-optimize -fbranch-target-load-optimize2 @gol
 -fbtr-bb-exclusive -fcaller-saves @gol
--fcheck-data-deps -fcombine-stack-adjustments -fconserve-stack @gol
+-fcheck-data-deps -fclone-hot-version-paths @gol
+-fcombine-stack-adjustments -fconserve-stack @gol
 -fcompare-elim -fcprop-registers -fcrossjumping @gol
 -fcse-follow-jumps -fcse-skip-blocks -fcx-fortran-rules @gol
 -fcx-limited-range @gol
@@ -365,7 +370,8 @@ Objective-C and Objective-C++ Dialects}.
 -fdelete-null-pointer-checks -fdevirtualize -fdse @gol
 -fearly-inlining -fipa-sra -fexpensive-optimizations -ffat-lto-objects @gol
 -ffast-math -ffinite-math-only -ffloat-store -fexcess-precision=@var{style} @gol
--fforward-propagate -ffp-contract=@var{style} -ffunction-sections @gol
+-fforward-propagate -ffp-contract=@var{style} @gol
+-ffunction-attribute-list -ffunction-sections @gol
 -fgcse -fgcse-after-reload -fgcse-las -fgcse-lm -fgraphite-identity @gol
 -fgcse-sm -fhoist-adjacent-loads -fif-conversion @gol
 -fif-conversion2 -findirect-inlining @gol
@@ -388,15 +394,19 @@ Objective-C and Objective-C++ Dialects}.
 -fno-sched-interblock -fno-sched-spec -fno-signed-zeros @gol
 -fno-toplevel-reorder -fno-trapping-math -fno-zero-initialized-in-bss @gol
 -fomit-frame-pointer -foptimize-register-move -foptimize-sibling-calls @gol
--foptimize-sincos -fpartial-inlining -fpeel-loops -fpredictive-commoning @gol
+-foptimize-sincos -fpartial-inlining -fpeel-codesize-limit -fpeel-loops -fpredictive-commoning @gol
 -fprefetch-loop-arrays -fprofile-report @gol
 -fprofile-correction -fprofile-dir=@var{path} -fprofile-generate @gol
--fprofile-generate=@var{path} @gol
+-fprofile-generate=@var{path} -fprofile-generate-sampling @gol
 -fprofile-use -fprofile-use=@var{path} -fprofile-values @gol
 -freciprocal-math -free -fregmove -frename-registers -freorder-blocks @gol
+-frecord-gcc-switches-in-elf@gol
 -freorder-blocks-and-partition -freorder-functions @gol
 -frerun-cse-after-loop -freschedule-modulo-scheduled-loops @gol
--frounding-math -fsched2-use-superblocks -fsched-pressure @gol
+-fripa -fripa-disallow-asm-modules -fripa-disallow-opt-mismatch @gol
+-fripa-inc-path-sub=@var{path_mapping} -fripa-no-promote-always-inline-func @gol
+-fripa-verbose -frounding-math @gol
+-fsched2-use-superblocks -fsched-pressure @gol
 -fsched-spec-load -fsched-spec-load-dangerous @gol
 -fsched-stalled-insns-dep[=@var{n}] -fsched-stalled-insns[=@var{n}] @gol
 -fsched-group-heuristic -fsched-critical-path-heuristic @gol
@@ -407,8 +417,8 @@ Objective-C and Objective-C++ Dialects}.
 -fsel-sched-pipelining -fsel-sched-pipelining-outer-loops @gol
 -fshrink-wrap -fsignaling-nans -fsingle-precision-constant @gol
 -fsplit-ivs-in-unroller -fsplit-wide-types -fstack-protector @gol
--fstack-protector-all -fstrict-aliasing -fstrict-overflow @gol
--fthread-jumps -ftracer -ftree-bit-ccp @gol
+-fstack-protector-all -fstack-protector-strong -fstrict-aliasing @gol
+-fstrict-overflow -fthread-jumps -ftracer -ftree-bit-ccp @gol
 -ftree-builtin-call-dce -ftree-ccp -ftree-ch @gol
 -ftree-coalesce-inline-vars -ftree-coalesce-vars -ftree-copy-prop @gol
 -ftree-copyrename -ftree-dce -ftree-dominator-opts -ftree-dse @gol
@@ -420,7 +430,7 @@ Objective-C and Objective-C++ Dialects}.
 -ftree-reassoc -ftree-sink -ftree-slsr -ftree-sra @gol
 -ftree-switch-conversion -ftree-tail-merge @gol
 -ftree-ter -ftree-vect-loop-version -ftree-vectorize -ftree-vrp @gol
--funit-at-a-time -funroll-all-loops -funroll-loops @gol
+-funit-at-a-time -funroll-all-loops -funroll-loops -funroll-codesize-limit @gol
 -funsafe-loop-optimizations -funsafe-math-optimizations -funswitch-loops @gol
 -fvariable-expansion-in-unroller -fvect-cost-model -fvpt -fweb @gol
 -fwhole-program -fwpa -fuse-ld=@var{linker} -fuse-linker-plugin @gol
@@ -1423,11 +1433,20 @@ gcc -c -Q -O2 --help=optimizers > /tmp/O2-opts
 diff /tmp/O2-opts /tmp/O3-opts | grep enabled
 @end smallexample
 
+@item -canonical-prefixes
+@opindex canonical-prefixes
+Always expand any symbolic links, resolve references to @samp{/../}
+or @samp{/./}, and make the path absolute when generating a relative
+prefix.
+
 @item -no-canonical-prefixes
 @opindex no-canonical-prefixes
-Do not expand any symbolic links, resolve references to @samp{/../}
+Never expand any symbolic links, resolve references to @samp{/../}
 or @samp{/./}, or make the path absolute when generating a relative
-prefix.
+prefix. If neither @option{-canonical-prefixes} nor
+@option{-nocanonical-prefixes} is given, GCC tries to set an appropriate
+default by looking for a target-specific subdirectory alongside the
+directory containing the compiler driver.
 
 @item --version
 @opindex version
@@ -3109,6 +3128,11 @@ This option causes the compiler to abort compilation on the first error
 occurred rather than trying to keep going and printing further error
 messages.
 
+@item -Wforce-warnings
+@opindex Wforce-warnings
+This option causes the compiler to ignore @option{-Werror} and
+@option{-Werror=} and suppress promotion of warnings to errors.
+
 @end table
 
 You can request many specific warnings with options beginning with
@@ -3206,6 +3230,7 @@ Options} and @ref{Objective-C and Objective-C++ Dialect Options}.
 -Wpointer-sign  @gol
 -Wreorder   @gol
 -Wreturn-type  @gol
+-Wripa-opt-mismatch @gol
 -Wsequence-point  @gol
 -Wsign-compare @r{(only in C++)}  @gol
 -Wstrict-aliasing  @gol
@@ -3441,7 +3466,7 @@ If @option{-Wformat} is specified, also warn about @code{strftime}
 formats that may yield only a two-digit year.
 @end table
 
-@item -Wnonnull
+@item -Wnonnull @r{(C and Objective-C only)}
 @opindex Wnonnull
 @opindex Wno-nonnull
 Warn about passing a null pointer for arguments marked as
@@ -3639,6 +3664,61 @@ definitions, may be found on the GCC readings page, at
 
 This warning is enabled by @option{-Wall} for C and C++.
 
+@item -Wself-assign
+@opindex Wself-assign
+@opindex Wno-self-assign
+Warn about self-assignment and self-initialization. This warning is intended
+for detecting accidental self-assignment due to typos, and therefore does
+not warn on a statement that is semantically a self-assignment after
+constant folding. Here is an example of what will trigger a self-assign
+warning and what will not:
+
+@smallexample
+@group
+void func()
+@{
+   int i = 2;
+   int x = x;   /* warn */
+   float f = 5.0;
+   double a[3];
+
+   i = i + 0;   /* not warn */
+   f = f / 1;   /* not warn */
+   a[1] = a[1]; /* warn */
+   i += 0;      /* not warn */
+@}
+@end group
+@end smallexample
+
+In C++ it will not warn on self-assignment of non-POD variables unless
+@option{-Wself-assign-non-pod} is also enabled.
+
+@item -Wself-assign-non-pod
+@opindex Wself-assign-non-pod
+@opindex Wno-self-assign-non-pod
+Warn about self-assignment of non-POD variables. This is a C++-specific
+warning and only effective when @option{-Wself-assign} is enabled.
+
+There are cases where self-assignment might be intentional. For example,
+a C++ programmer might write code to test whether an overloaded
+@code{operator=} works when the same object is assigned to itself.
+One way to work around the self-assign warning in such cases when this flag
+is enabled is using the functional form @code{object.operator=(object)}
+instead of the assignment form @code{object = object}, as shown in the
+following example.
+
+@smallexample
+@group
+void test_func()
+@{
+   MyType t;
+
+   t.operator=(t);  // not warn
+   t = t;           // warn
+@}
+@end group
+@end smallexample
+
 @item -Wno-return-local-addr
 @opindex Wno-return-local-addr
 @opindex Wreturn-local-addr
@@ -3661,6 +3741,16 @@ exceptions are @samp{main} and functions defined in system headers.
 
 This warning is enabled by @option{-Wall}.
 
+@item -Wripa-opt-mismatch
+@opindex Wripa-opt-mismatch
+@opindex Wno-ripa-opt-mismatch
+When doing an FDO build with @option{-fprofile-use} and @option{-fripa},
+warn if importing an axuiliary module that was built with a different
+GCC command line during the profile-generate phase than the primary
+module.
+
+This warning is enabled by @option{-Wall}.
+
 @item -Wswitch
 @opindex Wswitch
 @opindex Wno-switch
@@ -3773,6 +3863,10 @@ This warning is enabled by @option{-Wall}.
 To suppress this warning use the @samp{unused} attribute
 (@pxref{Variable Attributes}).
 
+Note that a classic way to avoid @option{-Wunused-variable} warning is
+using @code{x = x}, but that does not work with @option{-Wself-assign}.
+Use @code{(void) x} or @code{static_cast<void>(x)} instead.
+
 @item -Wunused-value
 @opindex Wunused-value
 @opindex Wno-unused-value
@@ -4219,6 +4313,43 @@ parameter, type, or class member (in C++), or whenever a built-in function
 is shadowed. Note that in C++, the compiler warns if a local variable
 shadows an explicit typedef, but not if it shadows a struct/class/enum.
 
+@item -Wshadow-local
+@opindex Wshadow-local
+@opindex Wno-shadow-local
+Warn when a local variable shadows another local variable or parameter.
+
+@item -Wshadow-compatible-local
+@opindex Wshadow-compatible-local
+@opindex Wno-shadow-compatible-local
+Warn when a local variable shadows another local variable or parameter
+whose type is compatible with that of the shadowing variable. In C++,
+type compatibility here means the type of the shadowing variable can be
+converted to that of the shadowed variable. The creation of this flag
+(in addition to @option{-Wshadow-local}) is based on the idea that when
+a local variable shadows another one of incompatible type, it is most
+likely intentional, not a bug or typo, as shown in the following example:
+
+@smallexample
+@group
+for (SomeIterator i = SomeObj.begin(); i != SomeObj.end(); ++i)
+@{
+  for (int i = 0; i < N; ++i)
+  @{
+    ...
+  @}
+  ...
+@}
+@end group
+@end smallexample
+
+Since the two variable @code{i} in the example above have incompatible types, 
+enabling only @option{-Wshadow-compatible-local} will not emit a warning.
+Because their types are incompatible, if a programmer accidentally uses one
+in place of the other, type checking will catch that and emit an error or
+warning. So not warning (about shadowing) in this case will not lead to
+undetected bugs. Use of this flag instead of @option{-Wshadow-local} can
+possibly reduce the number of warnings triggered by intentional shadowing.
+
 @item -Wlarger-than=@var{len}
 @opindex Wlarger-than=@var{len}
 @opindex Wlarger-than-@var{len}
@@ -4394,6 +4525,12 @@ reference to them. Warnings about conversions between signed and
 unsigned integers are disabled by default in C++ unless
 @option{-Wsign-conversion} is explicitly enabled.
 
+@item -Wreal-conversion
+@opindex Wreal-conversion
+@opindex Wno-real-conversion
+Warn for implicit type conversions from real (@code{double} or @code{float})
+to integral values. This warning is also enabled by @option{-Wconversion}.
+
 @item -Wno-conversion-null @r{(C++ and Objective-C++ only)}
 @opindex Wconversion-null
 @opindex Wno-conversion-null
@@ -4791,6 +4928,12 @@ Suppress warnings from casts to pointer type of an integer of a
 different size. In C++, casting to a pointer type of smaller size is
 an error. @option{Wint-to-pointer-cast} is enabled by default.
 
+@item max-lipo-mem
+When importing auxiliary modules during profile-use, check current
+memory consumption after parsing each auxiliary module. If it exceeds
+this limit (specified in kb), don't import any more auxiliary modules.
+Specifying a value of 0 means don't enforce this limit. This parameter
+is only useful when using @option{-fprofile-use} and @option{-fripa}.
 
 @item -Wno-pointer-to-int-cast @r{(C and Objective-C only)}
 @opindex Wno-pointer-to-int-cast
@@ -4974,6 +5117,12 @@ possible.
 @opindex gpubnames
 Generate dwarf .debug_pubnames and .debug_pubtypes sections.
 
+@item -ggnu-pubnames
+@opindex ggnu-pubnames
+Generate .debug_pubnames and .debug_pubtypes sections in a format
+suitable for conversion into a GDB@ index.  This option is only useful
+with a linker that can produce GDB@ index version 7.
+
 @item -gstabs
 @opindex gstabs
 Produce debugging information in stabs format (if that is supported),
@@ -5088,8 +5237,8 @@ Level 0 produces no debug information at all.  Thus, @option{-g0} negates
 
 Level 1 produces minimal information, enough for making backtraces in
 parts of the program that you don't plan to debug.  This includes
-descriptions of functions and external variables, but no information
-about local variables and no line numbers.
+descriptions of functions and external variables, and line number
+tables, but no information about local variables.
 
 Level 3 includes extra information, such as all the macro definitions
 present in the program.  Some debuggers support macro expansion when
@@ -6155,7 +6304,7 @@ Controls optimization dumps from various optimization passes. If the
 @samp{-@var{options}} form is used, @var{options} is a list of
 @samp{-} separated options to select the dump details and
 optimizations.  If @var{options} is not specified, it defaults to
-@option{all} for details and @option{optall} for optimization
+@option{optimized} for details and @option{optall} for optimization
 groups. If the @var{filename} is not specified, it defaults to
 @file{stderr}. Note that the output @var{filename} will be overwritten
 in case of multiple translation units. If a combined output from
@@ -6209,6 +6358,9 @@ Enable dumps from all loop optimizations.
 Enable dumps from all inlining optimizations.
 @item vec
 Enable dumps from all vectorization optimizations.
+@item optall
+Enable dumps from all optimizations. This is a superset of
+the optimization groups listed above.
 @end table
 
 For example,
@@ -8061,6 +8213,10 @@ Also profile feedback must be available to make this option effective.  See
 
 Enabled at levels @option{-O2}, @option{-O3}, @option{-Os}.
 
+@item -freorder-functions=@var{alg}
+@opindex freorder-functions
+This invokes a linker plugin that globally reorders functions in the final binary according to the algorithm specified. Currently, only one type of reordering is supported, @code{callgraph}.  This algorithm places functions that are connected by hot callgraph edges closer.  This option also enables @option{-ffunction-sections}.  Also, profile feedback must be available to makes this option effective.  This option emits callgraph edge profile information in special sections named .gnu.callgraph.text. The params variable "gnu-cgraph-section-edge-threshold" can be used to only list edges above a certain threshold.
+
 @item -fstrict-aliasing
 @opindex fstrict-aliasing
 Allow the compiler to assume the strictest aliasing rules applicable to
@@ -8527,6 +8683,19 @@ and occasionally eliminate the copy.
 
 Enabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.
 
+@item -fauto-profile
+@itemx -fauto-profile=@var{path}
+@opindex fauto-profile
+Enable auto-profile feedback directed optimizations, and optimizations
+generally profitable only with profile feedback available.
+
+The following options are enabled: @code{-fbranch-probabilities},
+@code{-funroll-loops}, @code{-fpeel-loops}.
+
+If @var{path} is specified, GCC will look at the @var{path} to find
+the profile feedback data files. Otherwise, GCC will find fbdata.afdo
+in the current directory.
+
 @item -fprofile-correction
 @opindex fprofile-correction
 Profiles collected using an instrumented binary for multi-threaded programs may
@@ -8559,6 +8728,20 @@ The following options are enabled: @code{-fprofile-arcs}, @code{-fprofile-values
 If @var{path} is specified, GCC looks at the @var{path} to find
 the profile feedback data files. See @option{-fprofile-dir}.
 
+@item -fprofile-generate-sampling
+@opindex -fprofile-generate-sampling
+
+Enable sampling for instrumented binaries.  Instead of recording every event,
+record only every N-th event, where N (the sampling period) can be set either
+at compile time using
+@option{--param profile-generate-sampling-period=@var{value}}, or at
+execution start time through environment variable @samp{GCOV_SAMPLING_PERIOD}.
+
+At this time sampling applies only to branch counters.  A sampling period of 100
+decreases instrumentated binary slowdown from up to 20x for heavily threaded
+applications down to around 2x.  @option{-fprofile-correction} is always
+needed with sampling.
+
 @item -fprofile-use
 @itemx -fprofile-use=@var{path}
 @opindex fprofile-use
@@ -8576,6 +8759,59 @@ code.
 
 If @var{path} is specified, GCC looks at the @var{path} to find
 the profile feedback data files. See @option{-fprofile-dir}.
+
+@item -fprofile-strip=@var{base_suffix}
+@opindex fprofile-strip
+
+The option causes the compiler to strip @var{base_suffix} from the
+base file name and use that to find the gcda file.
+
+@item -fripa
+@opindex fripa
+Perform dynamic inter-procedural analysis. This is used in conjunction with
+the @option{-fprofile-generate} and @option{-fprofile-use} options.
+During the @option{-fprofile-generate} phase, this flag turns on some additional
+instrumentation code that enables dynamic call-graph analysis.
+During the @option{-fprofile-use} phase, this flag enables cross-module
+optimizations such as inlining.
+
+@item -fripa-disallow-asm-modules
+@opindex fripa-disallow-asm-modules
+During profile-gen, if this flag is enabled, and the module has asm statements,
+arrange so that a bit recording this information will be set in the profile
+feedback data file.
+During profile-use, if this flag is enabled, and the same bit in auxiliary
+module's profile feedback data is set, don't import this auxiliary module.
+If this is the primary module, don't export it.
+
+@item -fripa-disallow-opt-mismatch
+@opindex fripa-disallow-opt-mismatch
+Don't import an auxiliary module, if the GCC command line options used for this
+auxiliary module during the profile-generate stage were different from those used
+for the primary module. Note that any mismatches in warning-related options are
+ignored for this comparison.
+
+@item -fripa-inc-path-sub=@var{path_mapping}
+@opindex fripa-inc-path-sub
+This option allows LIPO profile data associated with one compiler to be usable
+by another compiler at different installation path. A user can use this option
+to specify an include search path mapping so that the compiler can convert include
+search paths stored in gcda files into exisiting paths. The mapping is specified
+as a comma separated sub path pairs in the form: OLD_SUBPATH:NEW_SUBPATH.
+
+@item -fripa-no-promote-always-inline-func
+@opindex fripa-no-promote-always-inline-func
+Do not promote static functions with always inline attribute in LIPO compilation.
+
+@item -fripa-verbose
+@opindex fripa-verbose
+Enable printing of verbose information about dynamic inter-procedural optimizations.
+This is used in conjunction with the @option{-fripa}.
+
+@item -frecord-gcc-switches-in-elf
+@opindex frecord-gcc-switches-in-elf
+Record the command line options in the .gnu.switches.text elf section for sample
+based LIPO to do module grouping.
 @end table
 
 The following options control compiler behavior regarding floating-point 
@@ -8805,6 +9041,12 @@ whether the result of a complex multiplication or division is @code{NaN
 
 The default is @option{-fno-cx-fortran-rules}.
 
+@item min-mcf-cancel-iters
+The minimum number of iterations of negative cycle cancellation during
+MCF profile correction before early termination.  This parameter is
+only useful when using @option{-fprofile-correction}.
+
+
 @end table
 
 The following options control optimizations that may improve
@@ -8889,6 +9131,14 @@ the loop is entered.  This usually makes programs run more slowly.
 @option{-funroll-all-loops} implies the same options as
 @option{-funroll-loops}.
 
+@item -funroll-codesize-limit
+@opindex funroll-codesize-limit
+Limit loop unrolling of non-const non-FP loops in a profile feedback compilation
+under estimates of a large code footprint. Enabled by default with
+@option{-fprofile-use}. Code size and execution weight thresholds are controlled
+by the @option{unrollpeel-codesize-threshold} and
+@option{unrollpeel-hotness-threshold} parameters.
+
 @item -fpeel-loops
 @opindex fpeel-loops
 Peels loops for which there is enough information that they do not
@@ -8897,6 +9147,14 @@ roll much (from profile feedback).  It also turns on complete loop peeling
 
 Enabled with @option{-fprofile-use}.
 
+@item -fpeel-codesize-limit
+@opindex fpeel-codesize-limit
+Limit loop peeling of non-const non-FP loops in a profile feedback compilation
+under estimates of a large code footprint. Enabled by default with
+@option{-fprofile-use}. Code size and execution weight thresholds are controlled
+by the @option{unrollpeel-codesize-threshold} and
+@option{unrollpeel-hotness-threshold} parameters.
+
 @item -fmove-loop-invariants
 @opindex fmove-loop-invariants
 Enables the loop invariant motion pass in the RTL loop optimizer.  Enabled
@@ -8929,6 +9187,15 @@ You cannot use @code{gprof} on all systems if you
 specify this option, and you may have problems with debugging if
 you specify both this option and @option{-g}.
 
+@item -ffunction-attribute-list
+@opindex ffunction-attribute-list
+List of function name patterns that will be applied specified attribute.
+For example, the following command line will add "cold" attribute to
+functions that has "ErrorMessage" in its name.
+@smallexample
+gcc -ffunction-atribute-list=cold:ErrorMessage -c foo.c
+@end smallexample
+
 @item -fbranch-target-load-optimize
 @opindex fbranch-target-load-optimize
 Perform branch target register load optimization before prologue / epilogue
@@ -8960,6 +9227,12 @@ If a guard check fails, an error message is printed and the program exits.
 @opindex fstack-protector-all
 Like @option{-fstack-protector} except that all functions are protected.
 
+@item -fstack-protector-strong
+@opindex fstack-protector-strong
+Like @option{-fstack-protector} but includes additional functions to be
+protected - those that have local array definitions, or have references to
+local frame addresses.
+
 @item -fsection-anchors
 @opindex fsection-anchors
 Try to reduce the number of symbolic address calculations by using
@@ -9260,12 +9533,27 @@ The maximum number of iterations of a loop to be suitable for complete peeling.
 @item max-completely-peel-loop-nest-depth
 The maximum depth of a loop nest suitable for complete peeling.
 
+@item unrollpeel-codesize-threshold
+Maximum profile-based code size footprint estimate for loop unrolling and
+peeling.
+
+@item unrollpeel-hotness-threshold
+Maximum ratio of total execution count to loop entry block count under which
+most profile-based code size estimates will be ignored for loop unrolling and
+peeling.
+
 @item max-unswitch-insns
 The maximum number of insns of an unswitched loop.
 
 @item max-unswitch-level
 The maximum number of branches unswitched in a single loop.
 
+@item min-iter-unroll-with-branches
+Minimum iteration count to ignore branch effects when unrolling.
+
+@item unroll-outer-loop-branch-budget
+Maximum number of branches allowed in hot outer loop region after unroll.
+
 @item lim-expensive
 The minimum cost of an expensive expression in the loop invariant motion.
 
@@ -9783,6 +10071,14 @@ The default choice depends on the target.
 Set the maximum number of existing candidates that will be considered when
 seeking a basis for a new straight-line strength reduction candidate.
 
+@item coverage-callback
+Set to 1 to instrument a callback function together with
+arc counter update. The name of the callback function
+is "__coverage_callback".
+
+@item coverage-exec_once
+Set to 1 to update each arc counter only once.
+
 @end table
 @end table
 
@@ -9860,6 +10156,9 @@ recognize.
 If you want to pass an option that takes an argument, you must use
 @option{-Xassembler} twice, once for the option and once for the argument.
 
+@item profile-generate-sampling-rate
+Set the sampling rate with @option{-fprofile-generate-sampling}.
+
 @end table
 
 @node Link Options
@@ -10100,6 +10399,11 @@ systems using the GNU linker.  On some targets, such as bare-board
 targets without an operating system, the @option{-T} option may be required
 when linking to avoid references to undefined symbols.
 
+@item -Xclang-only @var{option}
+@opindex Xclang-only
+Ignore @var{option}.  This is used by some custom drivers to pass options
+to Clang but not GCC.
+
 @item -Xlinker @var{option}
 @opindex Xlinker
 Pass @var{option} as an option to the linker.  You can use this to
@@ -10814,6 +11118,12 @@ given to GCC, substitutes @code{Y}; else substitutes @code{D}.  There can
 be as many clauses as you need.  This may be combined with @code{.},
 @code{,}, @code{!}, @code{|}, and @code{*} as needed.
 
+@item max-lipo-mem
+When importing auxiliary modules during profile-use, check current
+memory consumption after parsing each auxiliary module. If it exceeds
+this limit (specified in kb), don't import any more auxiliary modules.
+Specifying a value of 0 means don't enforce this limit. This parameter
+is only useful when using @option{-fprofile-use} and @option{-fripa}.
 
 @end table
 
diff --git a/gcc/doc/options.texi b/gcc/doc/options.texi
index 73a2a31..b6cb221 100644
--- a/gcc/doc/options.texi
+++ b/gcc/doc/options.texi
@@ -478,4 +478,8 @@ record.  @xref{Option file format}.
 @item NoDWARFRecord
 The option is omitted from the producer string written by
 @option{-grecord-gcc-switches}.
+
+@item NoDWARFRecord
+The option is omitted from the producer string written by
+@option{-grecord-gcc-switches}.
 @end table
diff --git a/gcc/dumpfile.c b/gcc/dumpfile.c
index 7442a27..16700f2 100644
--- a/gcc/dumpfile.c
+++ b/gcc/dumpfile.c
@@ -257,16 +257,18 @@ dump_open_alternate_stream (struct dump_file_info *dfi)
 void
 dump_loc (int dump_kind, FILE *dfile, source_location loc)
 {
-  /* Currently vectorization passes print location information.  */
   if (dump_kind)
     {
+      /* Ensure dump message starts on a new line.  */
+      fprintf (dfile, "\n");
       if (LOCATION_LOCUS (loc) > BUILTINS_LOCATION)
-        fprintf (dfile, "\n%s:%d: note: ", LOCATION_FILE (loc),
-                 LOCATION_LINE (loc));
+        fprintf (dfile, "%s:%d:%d: note: ", LOCATION_FILE (loc),
+                 LOCATION_LINE (loc), LOCATION_COLUMN (loc));
       else if (current_function_decl)
-        fprintf (dfile, "\n%s:%d: note: ",
+        fprintf (dfile, "%s:%d:%d: note: ",
                  DECL_SOURCE_FILE (current_function_decl),
-                 DECL_SOURCE_LINE (current_function_decl));
+                 DECL_SOURCE_LINE (current_function_decl),
+                 DECL_SOURCE_COLUMN (current_function_decl));
     }
 }
 
@@ -866,7 +868,7 @@ opt_info_switch_p (const char *arg)
 
   file_seen = xstrdup (filename);
   if (!flags)
-    flags = MSG_ALL;
+    flags = MSG_OPTIMIZED_LOCATIONS;
   if (!optgroup_flags)
     optgroup_flags = OPTGROUP_ALL;
 
diff --git a/gcc/dumpfile.h b/gcc/dumpfile.h
index b912ccf..7730286 100644
--- a/gcc/dumpfile.h
+++ b/gcc/dumpfile.h
@@ -97,8 +97,9 @@ enum tree_dump_index
 #define OPTGROUP_LOOP        (1 << 2)   /* Loop optimization passes */
 #define OPTGROUP_INLINE      (1 << 3)   /* Inlining passes */
 #define OPTGROUP_VEC         (1 << 4)   /* Vectorization passes */
+#define OPTGROUP_OTHER       (1 << 5)   /* All other passes */
 #define OPTGROUP_ALL	     (OPTGROUP_IPA | OPTGROUP_LOOP | OPTGROUP_INLINE \
-                              | OPTGROUP_VEC)
+                              | OPTGROUP_VEC | OPTGROUP_OTHER)
 
 /* Define a tree dump switch.  */
 struct dump_file_info
diff --git a/gcc/dwarf2asm.c b/gcc/dwarf2asm.c
index 65d0b02..37dc895 100644
--- a/gcc/dwarf2asm.c
+++ b/gcc/dwarf2asm.c
@@ -906,6 +906,7 @@ dw2_output_indirect_constant_1 (splay_tree_node node,
   DECL_IGNORED_P (decl) = 1;
   DECL_INITIAL (decl) = decl;
   TREE_READONLY (decl) = 1;
+  TREE_STATIC (decl) = 1;
 
   if (TREE_PUBLIC (id))
     {
@@ -914,8 +915,6 @@ dw2_output_indirect_constant_1 (splay_tree_node node,
       if (USE_LINKONCE_INDIRECT)
 	DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;
     }
-  else
-    TREE_STATIC (decl) = 1;
 
   sym_ref = gen_rtx_SYMBOL_REF (Pmode, sym);
   assemble_variable (decl, 1, 1, 1);
diff --git a/gcc/dwarf2out.c b/gcc/dwarf2out.c
index 2bf53a1..14d1e78 100644
--- a/gcc/dwarf2out.c
+++ b/gcc/dwarf2out.c
@@ -92,6 +92,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "lra.h"
 #include "dumpfile.h"
 #include "opts.h"
+#include "l-ipo.h"
+#include "gdb/gdb-index.h"
 
 static void dwarf2out_source_line (unsigned int, const char *, int, bool);
 static rtx last_var_location_insn;
@@ -157,6 +159,7 @@ static GTY(()) section *debug_loc_section;
 static GTY(()) section *debug_pubnames_section;
 static GTY(()) section *debug_pubtypes_section;
 static GTY(()) section *debug_str_section;
+static GTY(()) section *debug_str_dwo_section;
 static GTY(()) section *debug_str_offsets_section;
 static GTY(()) section *debug_ranges_section;
 static GTY(()) section *debug_frame_section;
@@ -206,6 +209,28 @@ struct GTY(()) indirect_string_node {
 
 static GTY ((param_is (struct indirect_string_node))) htab_t debug_str_hash;
 
+/* With split_debug_info, both the comp_dir and dwo_name go in the
+   main object file, rather than the dwo, similar to the force_direct
+   parameter elsewhere but with additional complications:
+
+   1) The string is needed in both the main object file and the dwo.
+   That is, the comp_dir and dwo_name will appear in both places.
+
+   2) Strings can use three forms: DW_FORM_string, DW_FORM_strp or
+   DW_FORM_GNU_str_index.
+
+   3) GCC chooses the form to use late, depending on the size and
+   reference count.
+
+   Rather than forcing the all debug string handling functions and
+   callers to deal with these complications, simply use a separate,
+   special-cased string table for any attribute that should go in the
+   main object file.  This limits the complexity to just the places
+   that need it.  */
+
+static GTY ((param_is (struct indirect_string_node)))
+  htab_t skeleton_debug_str_hash;
+
 static GTY(()) int dw2_string_counter;
 
 /* True if the compilation unit places functions in more than one section.  */
@@ -923,7 +948,7 @@ dwarf2out_do_cfi_startproc (bool second)
 
       enc = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/0, /*global=*/0);
       ASM_GENERATE_INTERNAL_LABEL (lab, second ? "LLSDAC" : "LLSDA",
-				   current_function_funcdef_no);
+                                   FUNC_LABEL_ID (cfun));
       ref = gen_rtx_SYMBOL_REF (Pmode, lab);
       SYMBOL_REF_FLAGS (ref) = SYMBOL_FLAG_LOCAL;
 
@@ -946,7 +971,7 @@ dwarf2out_alloc_current_fde (void)
 
   fde = ggc_alloc_cleared_dw_fde_node ();
   fde->decl = current_function_decl;
-  fde->funcdef_number = current_function_funcdef_no;
+  fde->funcdef_number = FUNC_LABEL_ID (cfun);
   fde->fde_index = vec_safe_length (fde_vec);
   fde->all_throwers_are_sibcalls = crtl->all_throwers_are_sibcalls;
   fde->uses_eh_lsda = crtl->uses_eh_lsda;
@@ -988,9 +1013,9 @@ dwarf2out_begin_prologue (unsigned int line ATTRIBUTE_UNUSED,
   fnsec = function_section (current_function_decl);
   switch_to_section (fnsec);
   ASM_GENERATE_INTERNAL_LABEL (label, FUNC_BEGIN_LABEL,
-			       current_function_funcdef_no);
+			       FUNC_LABEL_ID (cfun));
   ASM_OUTPUT_DEBUG_LABEL (asm_out_file, FUNC_BEGIN_LABEL,
-			  current_function_funcdef_no);
+			  FUNC_LABEL_ID (cfun));
   dup_label = xstrdup (label);
   current_function_func_begin_label = dup_label;
 
@@ -1049,9 +1074,9 @@ dwarf2out_vms_end_prologue (unsigned int line ATTRIBUTE_UNUSED,
   /* Output a label to mark the endpoint of the code generated for this
      function.  */
   ASM_GENERATE_INTERNAL_LABEL (label, PROLOGUE_END_LABEL,
-			       current_function_funcdef_no);
+			       FUNC_LABEL_ID (cfun));
   ASM_OUTPUT_DEBUG_LABEL (asm_out_file, PROLOGUE_END_LABEL,
-			  current_function_funcdef_no);
+			  FUNC_LABEL_ID (cfun));
   cfun->fde->dw_fde_vms_end_prologue = xstrdup (label);
 }
 
@@ -1072,9 +1097,9 @@ dwarf2out_vms_begin_epilogue (unsigned int line ATTRIBUTE_UNUSED,
   /* Output a label to mark the endpoint of the code generated for this
      function.  */
   ASM_GENERATE_INTERNAL_LABEL (label, EPILOGUE_BEGIN_LABEL,
-			       current_function_funcdef_no);
+			       FUNC_LABEL_ID (cfun));
   ASM_OUTPUT_DEBUG_LABEL (asm_out_file, EPILOGUE_BEGIN_LABEL,
-			  current_function_funcdef_no);
+			  FUNC_LABEL_ID (cfun));
   fde->dw_fde_vms_begin_epilogue = xstrdup (label);
 }
 
@@ -1098,7 +1123,7 @@ dwarf2out_end_epilogue (unsigned int line ATTRIBUTE_UNUSED,
   /* Output a label to mark the endpoint of the code generated for this
      function.  */
   ASM_GENERATE_INTERNAL_LABEL (label, FUNC_END_LABEL,
-			       current_function_funcdef_no);
+			       FUNC_LABEL_ID (cfun));
   ASM_OUTPUT_LABEL (asm_out_file, label);
   fde = cfun->fde;
   gcc_assert (fde != NULL);
@@ -2397,6 +2422,41 @@ const struct gcc_debug_hooks dwarf2_debug_hooks =
   1,                            /* start_end_main_source_file */
   TYPE_SYMTAB_IS_DIE            /* tree_type_symtab_field */
 };
+
+const struct gcc_debug_hooks auto_profile_debug_hooks =
+{
+  debug_nothing_charstar,
+  debug_nothing_charstar,
+  debug_nothing_void,
+  debug_nothing_int_charstar,
+  debug_nothing_int_charstar,
+  debug_nothing_int_charstar,
+  debug_nothing_int,
+  debug_nothing_int_int,                 /* begin_block */
+  debug_nothing_int_int,                 /* end_block */
+  dwarf2out_ignore_block,                 /* ignore_block */
+  debug_nothing_int_charstar_int_bool,   /* source_line */
+  debug_nothing_int_charstar,            /* begin_prologue */
+  debug_nothing_int_charstar,            /* end_prologue */
+  debug_nothing_int_charstar,            /* begin_epilogue */
+  debug_nothing_int_charstar,            /* end_epilogue */
+  debug_nothing_tree,                    /* begin_function */
+  debug_nothing_int,                     /* end_function */
+  debug_nothing_tree,                    /* function_decl */
+  debug_nothing_tree,                    /* global_decl */
+  debug_nothing_tree_int,                /* type_decl */
+  debug_nothing_tree_tree_tree_bool,     /* imported_module_or_decl */
+  debug_nothing_tree,                    /* deferred_inline_function */
+  debug_nothing_tree,                    /* outlining_inline_function */
+  debug_nothing_rtx,                     /* label */
+  debug_nothing_int,                     /* handle_pch */
+  debug_nothing_rtx,                     /* var_location */
+  debug_nothing_void,                    /* switch_text_section */
+  debug_nothing_tree_tree,               /* set_name */
+  0,                                     /* start_end_main_source_file */
+  TYPE_SYMTAB_IS_ADDRESS                 /* tree_type_symtab_field */
+};
+
 
 /* NOTE: In the comments in this file, many references are made to
    "Debugging Information Entries".  This term is abbreviated as `DIE'
@@ -3000,6 +3060,7 @@ static void compute_section_prefix (dw_die_ref);
 static int is_type_die (dw_die_ref);
 static int is_comdat_die (dw_die_ref);
 static int is_symbol_die (dw_die_ref);
+static inline bool is_template_instantiation (dw_die_ref);
 static void assign_symbol_names (dw_die_ref);
 static void break_out_includes (dw_die_ref);
 static int is_declaration_die (dw_die_ref);
@@ -3197,6 +3258,10 @@ static bool generic_type_p (tree);
 static void schedule_generic_params_dies_gen (tree t);
 static void gen_scheduled_generic_parms_dies (void);
 
+static const char *comp_dir_string (void);
+
+static hashval_t hash_loc_operands (dw_loc_descr_ref, hashval_t);
+
 /* enum for tracking thread-local variables whose address is really an offset
    relative to the TLS pointer, which will need link-time relocation, but will
    not need relocation by the DWARF consumer.  */
@@ -3298,10 +3363,14 @@ new_addr_loc_descr (rtx addr, enum dtprel_bool dtprel)
 #define DEBUG_DWO_LOC_SECTION  ".debug_loc.dwo"
 #endif
 #ifndef DEBUG_PUBNAMES_SECTION
-#define DEBUG_PUBNAMES_SECTION	".debug_pubnames"
+#define DEBUG_PUBNAMES_SECTION	\
+  ((debug_generate_pub_sections == 2) \
+   ? ".debug_gnu_pubnames" : ".debug_pubnames")
 #endif
 #ifndef DEBUG_PUBTYPES_SECTION
-#define DEBUG_PUBTYPES_SECTION	".debug_pubtypes"
+#define DEBUG_PUBTYPES_SECTION	\
+  ((debug_generate_pub_sections == 2) \
+   ? ".debug_gnu_pubtypes" : ".debug_pubtypes")
 #endif
 #define DEBUG_NORM_STR_OFFSETS_SECTION ".debug_str_offsets"
 #define DEBUG_DWO_STR_OFFSETS_SECTION ".debug_str_offsets.dwo"
@@ -3310,11 +3379,11 @@ new_addr_loc_descr (rtx addr, enum dtprel_bool dtprel)
   (!dwarf_split_debug_info                                              \
    ? (DEBUG_NORM_STR_OFFSETS_SECTION) : (DEBUG_DWO_STR_OFFSETS_SECTION))
 #endif
-#define DEBUG_DWO_STR_SECTION   ".debug_str.dwo"
-#define DEBUG_NORM_STR_SECTION  ".debug_str"
+#ifndef DEBUG_STR_DWO_SECTION
+#define DEBUG_STR_DWO_SECTION   ".debug_str.dwo"
+#endif
 #ifndef DEBUG_STR_SECTION
-#define DEBUG_STR_SECTION                               \
-  (!dwarf_split_debug_info ? (DEBUG_NORM_STR_SECTION) : (DEBUG_DWO_STR_SECTION))
+#define DEBUG_STR_SECTION  ".debug_str"
 #endif
 #ifndef DEBUG_RANGES_SECTION
 #define DEBUG_RANGES_SECTION	".debug_ranges"
@@ -3326,16 +3395,17 @@ new_addr_loc_descr (rtx addr, enum dtprel_bool dtprel)
 #endif
 
 /* Section flags for .debug_macinfo/.debug_macro section.  */
-#define DEBUG_MACRO_SECTION_FLAGS \
+#define DEBUG_MACRO_SECTION_FLAGS                                       \
   (dwarf_split_debug_info ? SECTION_DEBUG | SECTION_EXCLUDE : SECTION_DEBUG)
 
 /* Section flags for .debug_str section.  */
-#define DEBUG_STR_SECTION_FLAGS \
-  (dwarf_split_debug_info \
-   ? SECTION_DEBUG | SECTION_EXCLUDE \
-   : (HAVE_GAS_SHF_MERGE && flag_merge_debug_strings \
-      ? SECTION_DEBUG | SECTION_MERGE | SECTION_STRINGS | 1        \
-      : SECTION_DEBUG))
+#define DEBUG_STR_SECTION_FLAGS                                 \
+  (HAVE_GAS_SHF_MERGE && flag_merge_debug_strings               \
+   ? SECTION_DEBUG | SECTION_MERGE | SECTION_STRINGS | 1        \
+   : SECTION_DEBUG)
+
+/* Section flags for .debug_str.dwo section.  */
+#define DEBUG_STR_DWO_SECTION_FLAGS (SECTION_DEBUG | SECTION_EXCLUDE)
 
 /* Labels we insert at beginning sections we can reference instead of
    the section names themselves.  */
@@ -3819,19 +3889,15 @@ debug_str_eq (const void *x1, const void *x2)
 		 (const char *)x2) == 0;
 }
 
-/* Add STR to the indirect string hash table.  */
+/* Add STR to the given string hash table.  */
 
 static struct indirect_string_node *
-find_AT_string (const char *str)
+find_AT_string_in_table (const char *str, htab_t table)
 {
   struct indirect_string_node *node;
   void **slot;
 
-  if (! debug_str_hash)
-    debug_str_hash = htab_create_ggc (10, debug_str_do_hash,
-				      debug_str_eq, NULL);
-
-  slot = htab_find_slot_with_hash (debug_str_hash, str,
+  slot = htab_find_slot_with_hash (table, str,
 				   htab_hash_string (str), INSERT);
   if (*slot == NULL)
     {
@@ -3846,6 +3912,18 @@ find_AT_string (const char *str)
   return node;
 }
 
+/* Add STR to the indirect string hash table.  */
+
+static struct indirect_string_node *
+find_AT_string (const char *str)
+{
+  if (! debug_str_hash)
+    debug_str_hash = htab_create_ggc (10, debug_str_do_hash,
+				      debug_str_eq, NULL);
+
+  return find_AT_string_in_table (str, debug_str_hash);
+}
+
 /* Add a string attribute value to a DIE.  */
 
 static inline void
@@ -4535,6 +4613,16 @@ is_cxx (void)
   return lang == DW_LANG_C_plus_plus || lang == DW_LANG_ObjC_plus_plus;
 }
 
+/* Return TRUE if the language is Java.  */
+
+static inline bool
+is_java (void)
+{
+  unsigned int lang = get_AT_unsigned (comp_unit_die (), DW_AT_language);
+
+  return lang == DW_LANG_Java;
+}
+
 /* Return TRUE if the language is Fortran.  */
 
 static inline bool
@@ -5395,11 +5483,12 @@ static inline void
 loc_checksum (dw_loc_descr_ref loc, struct md5_ctx *ctx)
 {
   int tem;
+  hashval_t hash = 0;
 
   tem = (loc->dtprel << 8) | ((unsigned int) loc->dw_loc_opc);
   CHECKSUM (tem);
-  CHECKSUM (loc->dw_loc_oprnd1);
-  CHECKSUM (loc->dw_loc_oprnd2);
+  hash = hash_loc_operands (loc, hash);
+  CHECKSUM (hash);
 }
 
 /* Calculate the checksum of an attribute.  */
@@ -5601,9 +5690,12 @@ loc_checksum_ordered (dw_loc_descr_ref loc, struct md5_ctx *ctx)
   /* Otherwise, just checksum the raw location expression.  */
   while (loc != NULL)
     {
+      hashval_t hash = 0;
+
+      CHECKSUM_ULEB128 (loc->dtprel);
       CHECKSUM_ULEB128 (loc->dw_loc_opc);
-      CHECKSUM (loc->dw_loc_oprnd1);
-      CHECKSUM (loc->dw_loc_oprnd2);
+      hash = hash_loc_operands (loc, hash);
+      CHECKSUM (hash);
       loc = loc->dw_loc_next;
     }
 }
@@ -6029,22 +6121,29 @@ die_checksum_ordered (dw_die_ref die, struct md5_ctx *ctx, int *mark)
   CHECKSUM_ATTR (attrs.at_type);
   CHECKSUM_ATTR (attrs.at_friend);
 
-  /* Checksum the child DIEs, except for nested types and member functions.  */
+  /* Checksum the child DIEs.  */
   c = die->die_child;
   if (c) do {
     dw_attr_ref name_attr;
 
     c = c->die_sib;
     name_attr = get_AT (c, DW_AT_name);
-    if ((is_type_die (c) || c->die_tag == DW_TAG_subprogram)
-        && name_attr != NULL)
+    if (is_template_instantiation (c))
+      {
+	/* Ignore instantiations of member type and function templates.  */
+      }
+    else if (name_attr != NULL
+	     && (is_type_die (c) || c->die_tag == DW_TAG_subprogram))
       {
+	/* Use a shallow checksum for named nested types and member
+	   functions.  */
         CHECKSUM_ULEB128 ('S');
         CHECKSUM_ULEB128 (c->die_tag);
         CHECKSUM_STRING (AT_string (name_attr));
       }
     else
       {
+	/* Use a deep checksum for other children.  */
         /* Mark this DIE so it gets processed when unmarking.  */
         if (c->die_mark == 0)
           c->die_mark = -1;
@@ -6449,6 +6548,36 @@ is_class_die (dw_die_ref c)
                || c->die_tag == DW_TAG_structure_type);
 }
 
+/* Return non-zero if this DIE is a template parameter.  */
+
+static inline bool
+is_template_parameter (dw_die_ref die)
+{
+  switch (die->die_tag)
+    {
+    case DW_TAG_template_type_param:
+    case DW_TAG_template_value_param:
+    case DW_TAG_GNU_template_template_param:
+    case DW_TAG_GNU_template_parameter_pack:
+      return true;
+    default:
+      return false;
+    }
+}
+
+/* Return non-zero if this DIE represents a template instantiation.  */
+
+static inline bool
+is_template_instantiation (dw_die_ref die)
+{
+  dw_die_ref c;
+
+  if (!is_type_die (die) && die->die_tag != DW_TAG_subprogram)
+    return false;
+  FOR_EACH_CHILD (die, c, if (is_template_parameter (c)) return true);
+  return false;
+}
+
 static char *
 gen_internal_sym (const char *prefix)
 {
@@ -6692,14 +6821,13 @@ should_move_die_to_comdat (dw_die_ref die)
     case DW_TAG_structure_type:
     case DW_TAG_enumeration_type:
     case DW_TAG_union_type:
-      /* Don't move declarations, inlined instances, or types nested in a
-	 subprogram.  */
+      /* Don't move declarations, inlined instances, types nested in a
+	 subprogram, or types that contain subprogram definitions.  */
       if (is_declaration_die (die)
           || get_AT (die, DW_AT_abstract_origin)
-          || is_nested_in_subprogram (die))
+          || is_nested_in_subprogram (die)
+	  || contains_subprogram_definition (die))
         return 0;
-      /* A type definition should never contain a subprogram definition.  */
-      gcc_assert (!contains_subprogram_definition (die));
       return 1;
     case DW_TAG_array_type:
     case DW_TAG_interface_type:
@@ -6788,6 +6916,7 @@ clone_as_declaration (dw_die_ref die)
 
       switch (a->dw_attr)
         {
+        case DW_AT_abstract_origin:
         case DW_AT_artificial:
         case DW_AT_containing_type:
         case DW_AT_external:
@@ -6914,17 +7043,36 @@ generate_skeleton_bottom_up (skeleton_chain_node *parent)
     node.new_die = NULL;
     if (is_declaration_die (c))
       {
-        /* Clone the existing DIE, move the original to the skeleton
-           tree (which is in the main CU), and put the clone, with
-           all the original's children, where the original came from.  */
-        dw_die_ref clone = clone_die (c);
-        move_all_children (c, clone);
-
-        replace_child (c, clone, prev);
-        generate_skeleton_ancestor_tree (parent);
-        add_child_die (parent->new_die, c);
-        node.new_die = c;
-        c = clone;
+	if (is_template_instantiation (c))
+	  {
+	    /* Instantiated templates do not need to be cloned into the
+	       type unit.  Just move the DIE and its children back to
+	       the skeleton tree (in the main CU).  */
+	    remove_child_with_prev (c, prev);
+	    add_child_die (parent->new_die, c);
+	    c = prev;
+	  }
+	else
+	  {
+	    /* Clone the existing DIE, move the original to the skeleton
+	       tree (which is in the main CU), and put the clone, with
+	       all the original's children, where the original came from
+	       (which is about to be moved to the type unit).  */
+	    dw_die_ref clone = clone_die (c);
+	    move_all_children (c, clone);
+
+	    /* If the original has a DW_AT_object_pointer attribute,
+	       it would now point to a child DIE just moved to the
+	       cloned tree, so we need to remove that attribute from
+	       the original.  */
+	    remove_AT (c, DW_AT_object_pointer);
+
+	    replace_child (c, clone, prev);
+	    generate_skeleton_ancestor_tree (parent);
+	    add_child_die (parent->new_die, c);
+	    node.new_die = c;
+	    c = clone;
+	  }
       }
     generate_skeleton_bottom_up (&node);
   } while (next != NULL);
@@ -6942,8 +7090,11 @@ generate_skeleton (dw_die_ref die)
   node.parent = NULL;
 
   /* If this type definition is nested inside another type,
-     always leave at least a declaration in its place.  */
-  if (die->die_parent != NULL && is_type_die (die->die_parent))
+     and is not an instantiation of a template, always leave
+     at least a declaration in its place.  */
+  if (die->die_parent != NULL
+      && is_type_die (die->die_parent)
+      && !is_template_instantiation (die))
     node.new_die = clone_as_declaration (die);
 
   generate_skeleton_bottom_up (&node);
@@ -7018,6 +7169,9 @@ break_out_comdat_types (dw_die_ref die)
         dw_die_ref replacement;
 	comdat_type_node_ref type_node;
 
+        /* Break out nested types into their own type units.  */
+        break_out_comdat_types (c);
+
         /* Create a new type unit DIE as the root for the new tree, and
            add it to the list of comdat types.  */
         unit = new_die (DW_TAG_type_unit, NULL, NULL);
@@ -7037,9 +7191,6 @@ break_out_comdat_types (dw_die_ref die)
 	replacement = remove_child_or_replace_with_skeleton (unit, c, prev);
 	type_node->skeleton_die = replacement;
 
-        /* Break out nested types into their own type units.  */
-        break_out_comdat_types (c);
-
         /* Add the DIE to the new compunit.  */
 	add_child_die (unit, c);
 
@@ -7147,28 +7298,36 @@ copy_ancestor_tree (dw_die_ref unit, dw_die_ref die, htab_t decl_table)
   return copy;
 }
 
-/* Like clone_tree, but additionally enter all the children into
-   the hash table decl_table.  */
+/* Like clone_tree, but copy DW_TAG_subprogram DIEs as declarations.
+   Enter all the cloned children into the hash table decl_table.  */
 
 static dw_die_ref
-clone_tree_hash (dw_die_ref die, htab_t decl_table)
+clone_tree_partial (dw_die_ref die, htab_t decl_table)
 {
   dw_die_ref c;
-  dw_die_ref clone = clone_die (die);
+  dw_die_ref clone;
   struct decl_table_entry *entry;
-  void **slot = htab_find_slot_with_hash (decl_table, die,
-					  htab_hash_pointer (die), INSERT);
+  void **slot;
+
+  if (die->die_tag == DW_TAG_subprogram)
+    clone = clone_as_declaration (die);
+  else
+    clone = clone_die (die);
+
+  slot = htab_find_slot_with_hash (decl_table, die,
+				   htab_hash_pointer (die), INSERT);
   /* Assert that DIE isn't in the hash table yet.  If it would be there
      before, the ancestors would be necessarily there as well, therefore
-     clone_tree_hash wouldn't be called.  */
+     clone_tree_partial wouldn't be called.  */
   gcc_assert (*slot == HTAB_EMPTY_ENTRY);
   entry = XCNEW (struct decl_table_entry);
   entry->orig = die;
   entry->copy = clone;
   *slot = entry;
 
-  FOR_EACH_CHILD (die, c,
-		  add_child_die (clone, clone_tree_hash (c, decl_table)));
+  if (die->die_tag != DW_TAG_subprogram)
+    FOR_EACH_CHILD (die, c,
+		    add_child_die (clone, clone_tree_partial (c, decl_table)));
 
   return clone;
 }
@@ -7219,9 +7378,15 @@ copy_decls_walk (dw_die_ref unit, dw_die_ref die, htab_t decl_table)
               entry->copy = copy;
               *slot = entry;
 
-	      FOR_EACH_CHILD (targ, c,
-			      add_child_die (copy,
-					     clone_tree_hash (c, decl_table)));
+	      /* If TARG is not a declaration DIE, we need to copy its
+		 children.  */
+	      if (!is_declaration_die (targ))
+	        {
+		  FOR_EACH_CHILD (
+		      targ, c,
+		      add_child_die (copy,
+				     clone_tree_partial (c, decl_table)));
+		}
 
               /* Make sure the cloned tree is marked as part of the
                  type unit.  */
@@ -7335,7 +7500,17 @@ static hashval_t
 hash_external_ref (const void *p)
 {
   const struct external_ref *r = (const struct external_ref *)p;
-  return htab_hash_pointer (r->type);
+  dw_die_ref die = r->type;
+  hashval_t h = 0;
+
+  if (! die->comdat_type_p)
+    h = htab_hash_string (die->die_id.die_symbol);
+  else
+    {
+      comdat_type_node_ref type_node = die->die_id.die_type_node;
+      memcpy (&h, type_node->signature, sizeof (h));
+    }
+  return h;
 }
 
 /* Compare external_refs.  */
@@ -7806,6 +7981,32 @@ unmark_all_dies (dw_die_ref die)
       unmark_all_dies (AT_ref (a));
 }
 
+/* Calculate if the entry should appear in the final output file.  It may be
+   from a pruned a type.  */
+
+static bool
+include_pubname_in_output (vec<pubname_entry, va_gc> *table, pubname_entry *p)
+{
+  if (table == pubname_table)
+    {
+      /* Enumerator names are part of the pubname table, but the
+         parent DW_TAG_enumeration_type die may have been pruned.
+         Don't output them if that is the case.  */
+      if (p->die->die_tag == DW_TAG_enumerator &&
+          (p->die->die_parent == NULL
+           || !p->die->die_parent->die_perennial_p))
+        return false;
+
+      /* Everything else in the pubname table is included.  */
+      return true;
+    }
+
+  /* The pubtypes table shouldn't include types that have been
+     pruned.  */
+  return (p->die->die_offset != 0
+          || !flag_eliminate_unused_debug_types);
+}
+
 /* Return the size of the .debug_pubnames or .debug_pubtypes table
    generated for the compilation unit.  */
 
@@ -7815,13 +8016,12 @@ size_of_pubnames (vec<pubname_entry, va_gc> *names)
   unsigned long size;
   unsigned i;
   pubname_ref p;
+  int space_for_flags = (debug_generate_pub_sections == 2) ? 1 : 0;
 
   size = DWARF_PUBNAMES_HEADER_SIZE;
   FOR_EACH_VEC_ELT (*names, i, p)
-    if (names != pubtype_table
-	|| p->die->die_offset != 0
-	|| !flag_eliminate_unused_debug_types)
-      size += strlen (p->name) + DWARF_OFFSET_SIZE + 1;
+    if (include_pubname_in_output (names, p))
+      size += strlen (p->name) + DWARF_OFFSET_SIZE + 1 + space_for_flags;
 
   size += DWARF_OFFSET_SIZE;
   return size;
@@ -8650,9 +8850,11 @@ output_comp_unit (dw_die_ref die, int output_if_empty)
 static inline bool
 want_pubnames (void)
 {
-  return (debug_generate_pub_sections != -1
-	  ? debug_generate_pub_sections
-	  : targetm.want_debug_pub_sections);
+  if (debug_info_level <= DINFO_LEVEL_TERSE)
+    return false;
+  if (debug_generate_pub_sections != -1)
+    return debug_generate_pub_sections;
+  return targetm.want_debug_pub_sections;
 }
 
 /* Add the DW_AT_GNU_pubnames and DW_AT_GNU_pubtypes attributes.  */
@@ -8664,6 +8866,31 @@ add_AT_pubnames (dw_die_ref die)
     add_AT_flag (die, DW_AT_GNU_pubnames, 1);
 }
 
+/* Add a string attribute value to a skeleton DIE.  */
+
+static inline void
+add_skeleton_AT_string (dw_die_ref die, enum dwarf_attribute attr_kind,
+                        const char *str)
+{
+  dw_attr_node attr;
+  struct indirect_string_node *node;
+
+  if (! skeleton_debug_str_hash)
+    skeleton_debug_str_hash = htab_create_ggc (10, debug_str_do_hash,
+                                               debug_str_eq, NULL);
+
+  node = find_AT_string_in_table (str, skeleton_debug_str_hash);
+  find_string_form (node);
+  if (node->form == DW_FORM_GNU_str_index)
+    node->form = DW_FORM_strp;
+
+  attr.dw_attr = attr_kind;
+  attr.dw_attr_val.val_class = dw_val_class_str;
+  attr.dw_attr_val.val_entry = NULL;
+  attr.dw_attr_val.v.val_str = node;
+  add_dwarf_attr (die, &attr);
+}
+
 /* Helper function to generate top-level dies for skeleton debug_info and
    debug_types.  */
 
@@ -8671,18 +8898,11 @@ static void
 add_top_level_skeleton_die_attrs (dw_die_ref die)
 {
   const char *dwo_file_name = concat (aux_base_name, ".dwo", NULL);
-  dw_attr_ref attr;
-
-  add_comp_dir_attribute (die);
-  add_AT_string (die, DW_AT_GNU_dwo_name, dwo_file_name);
-  /* The specification suggests that these attributes be inline to avoid
-     having a .debug_str section.  We know that they exist in the die because
-     we just added them.  */
-  attr = get_AT (die, DW_AT_GNU_dwo_name);
-  attr->dw_attr_val.v.val_str->form = DW_FORM_string;
-  attr = get_AT (die, DW_AT_comp_dir);
-  attr->dw_attr_val.v.val_str->form = DW_FORM_string;
+  const char *comp_dir = comp_dir_string ();
 
+  add_skeleton_AT_string (die, DW_AT_GNU_dwo_name, dwo_file_name);
+  if (comp_dir != NULL)
+    add_skeleton_AT_string (die, DW_AT_comp_dir, comp_dir);
   add_AT_pubnames (die);
   add_AT_lineptr (die, DW_AT_GNU_addr_base, debug_addr_section_label);
 }
@@ -8716,9 +8936,6 @@ output_skeleton_debug_sections (dw_die_ref comp_unit)
   remove_AT (comp_unit, DW_AT_producer);
   remove_AT (comp_unit, DW_AT_language);
 
-  /* Add attributes common to skeleton compile_units and type_units.  */
-  add_top_level_skeleton_die_attrs (comp_unit);
-
   switch_to_section (debug_skeleton_info_section);
   ASM_OUTPUT_LABEL (asm_out_file, debug_skeleton_info_section_label);
 
@@ -8959,6 +9176,75 @@ add_pubtype (tree decl, dw_die_ref die)
     }
 }
 
+/* Output a single entry in the pubnames table.  */
+
+static void
+output_pubname (dw_offset die_offset, pubname_entry *entry)
+{
+  dw_die_ref die = entry->die;
+  int is_static = get_AT_flag (die, DW_AT_external) ? 1 : 0;
+
+  dw2_asm_output_data (DWARF_OFFSET_SIZE, die_offset, "DIE offset");
+
+  if (debug_generate_pub_sections == 2)
+    {
+      /* This logic follows gdb's method for determining the value of the flag
+         byte.  */
+      uint32_t flags = GDB_INDEX_SYMBOL_KIND_NONE;
+      switch (die->die_tag)
+      {
+        case DW_TAG_typedef:
+        case DW_TAG_base_type:
+        case DW_TAG_subrange_type:
+          GDB_INDEX_SYMBOL_KIND_SET_VALUE(flags, GDB_INDEX_SYMBOL_KIND_TYPE);
+          GDB_INDEX_SYMBOL_STATIC_SET_VALUE(flags, 1);
+          break;
+        case DW_TAG_enumerator:
+          GDB_INDEX_SYMBOL_KIND_SET_VALUE(flags,
+                                          GDB_INDEX_SYMBOL_KIND_VARIABLE);
+          if (!is_cxx () && !is_java ())
+            GDB_INDEX_SYMBOL_STATIC_SET_VALUE(flags, 1);
+          break;
+        case DW_TAG_subprogram:
+          GDB_INDEX_SYMBOL_KIND_SET_VALUE(flags,
+                                          GDB_INDEX_SYMBOL_KIND_FUNCTION);
+          if (!is_ada ())
+            GDB_INDEX_SYMBOL_STATIC_SET_VALUE(flags, is_static);
+          break;
+        case DW_TAG_constant:
+          GDB_INDEX_SYMBOL_KIND_SET_VALUE(flags,
+                                          GDB_INDEX_SYMBOL_KIND_VARIABLE);
+          GDB_INDEX_SYMBOL_STATIC_SET_VALUE(flags, is_static);
+          break;
+        case DW_TAG_variable:
+          GDB_INDEX_SYMBOL_KIND_SET_VALUE(flags,
+                                          GDB_INDEX_SYMBOL_KIND_VARIABLE);
+          GDB_INDEX_SYMBOL_STATIC_SET_VALUE(flags, is_static);
+          break;
+        case DW_TAG_namespace:
+        case DW_TAG_imported_declaration:
+          GDB_INDEX_SYMBOL_KIND_SET_VALUE(flags, GDB_INDEX_SYMBOL_KIND_TYPE);
+          break;
+        case DW_TAG_class_type:
+        case DW_TAG_interface_type:
+        case DW_TAG_structure_type:
+        case DW_TAG_union_type:
+        case DW_TAG_enumeration_type:
+          GDB_INDEX_SYMBOL_KIND_SET_VALUE(flags, GDB_INDEX_SYMBOL_KIND_TYPE);
+          if (!is_cxx () && !is_java ())
+	    GDB_INDEX_SYMBOL_STATIC_SET_VALUE(flags, 1);
+          break;
+        default:
+          gcc_unreachable ();
+      }
+      dw2_asm_output_data (1, flags >> GDB_INDEX_CU_BITSIZE,
+                           "GDB-index flags");
+    }
+
+  dw2_asm_output_nstring (entry->name, -1, "external name");
+}
+
+
 /* Output the public names table used to speed up access to externally
    visible names; or the public types table used to find type definitions.  */
 
@@ -8969,23 +9255,14 @@ output_pubnames (vec<pubname_entry, va_gc> *names)
   unsigned long pubnames_length = size_of_pubnames (names);
   pubname_ref pub;
 
-  if (!want_pubnames () || !info_section_emitted)
-    return;
-  if (names == pubname_table)
-    switch_to_section (debug_pubnames_section);
-  else
-    switch_to_section (debug_pubtypes_section);
   if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)
     dw2_asm_output_data (4, 0xffffffff,
       "Initial length escape value indicating 64-bit DWARF extension");
-  if (names == pubname_table)
-    dw2_asm_output_data (DWARF_OFFSET_SIZE, pubnames_length,
-			 "Length of Public Names Info");
-  else
-    dw2_asm_output_data (DWARF_OFFSET_SIZE, pubnames_length,
-			 "Length of Public Type Names Info");
-  /* Version number for pubnames/pubtypes is still 2, even in DWARF3.  */
+  dw2_asm_output_data (DWARF_OFFSET_SIZE, pubnames_length, "Pub Info Length");
+
+  /* Version number for pubnames/pubtypes is independent of dwarf version.  */
   dw2_asm_output_data (2, 2, "DWARF Version");
+
   if (dwarf_split_debug_info)
     dw2_asm_output_offset (DWARF_OFFSET_SIZE, debug_skeleton_info_section_label,
                            debug_skeleton_info_section,
@@ -8999,22 +9276,14 @@ output_pubnames (vec<pubname_entry, va_gc> *names)
 
   FOR_EACH_VEC_ELT (*names, i, pub)
     {
-      /* Enumerator names are part of the pubname table, but the parent
-         DW_TAG_enumeration_type die may have been pruned.  Don't output
-         them if that is the case.  */
-      if (pub->die->die_tag == DW_TAG_enumerator && !pub->die->die_mark)
-        continue;
-
-      /* We shouldn't see pubnames for DIEs outside of the main CU.  */
-      if (names == pubname_table)
-	gcc_assert (pub->die->die_mark);
-
-      if (names != pubtype_table
-	  || pub->die->die_offset != 0
-	  || !flag_eliminate_unused_debug_types)
+      if (include_pubname_in_output (names, pub))
 	{
 	  dw_offset die_offset = pub->die->die_offset;
 
+          /* We shouldn't see pubnames for DIEs outside of the main CU.  */
+          if (names == pubname_table && pub->die->die_tag != DW_TAG_enumerator)
+            gcc_assert (pub->die->die_mark);
+
 	  /* If we're putting types in their own .debug_types sections,
 	     the .debug_pubtypes table will still point to the compile
 	     unit (not the type unit), so we want to use the offset of
@@ -9029,15 +9298,31 @@ output_pubnames (vec<pubname_entry, va_gc> *names)
 			      : 0);
 	    }
 
-	  dw2_asm_output_data (DWARF_OFFSET_SIZE, die_offset, "DIE offset");
-
-	  dw2_asm_output_nstring (pub->name, -1, "external name");
+          output_pubname (die_offset, pub);
 	}
     }
 
   dw2_asm_output_data (DWARF_OFFSET_SIZE, 0, NULL);
 }
 
+/* Output public names and types tables if necessary.  */
+
+static void
+output_pubtables (void)
+{
+  if (!want_pubnames () || !info_section_emitted)
+    return;
+
+  switch_to_section (debug_pubnames_section);
+  output_pubnames (pubname_table);
+  /* ??? Only defined by DWARF3, but emitted by Darwin for DWARF2.
+     It shouldn't hurt to emit it always, since pure DWARF2 consumers
+     simply won't look for the section.  */
+  switch_to_section (debug_pubtypes_section);
+  output_pubnames (pubtype_table);
+}
+
+
 /* Output the information that goes into the .debug_aranges table.
    Namely, define the beginning and ending address range of the
    text section generated for this compilation unit.  */
@@ -13460,7 +13745,7 @@ dw_loc_list (var_loc_list *loc_list, tree decl, int want_address)
 	    else
 	      {
 		ASM_GENERATE_INTERNAL_LABEL (label_id, FUNC_END_LABEL,
-					     current_function_funcdef_no);
+					     FUNC_LABEL_ID (cfun));
 		endname = ggc_strdup (label_id);
 	      }
 
@@ -15760,16 +16045,21 @@ add_gnat_descriptive_type_attribute (dw_die_ref die, tree type,
   add_AT_die_ref (die, DW_AT_GNAT_descriptive_type, dtype_die);
 }
 
-/* Generate a DW_AT_comp_dir attribute for DIE.  */
+/* Retrieve the comp_dir string suitable for use with DW_AT_comp_dir.  */
 
-static void
-add_comp_dir_attribute (dw_die_ref die)
+static const char *
+comp_dir_string (void)
 {
-  const char *wd = get_src_pwd ();
+  const char *wd;
   char *wd1;
+  static const char *cached_wd = NULL;
+
+  if (cached_wd != NULL)
+    return cached_wd;
 
+  wd = get_src_pwd ();
   if (wd == NULL)
-    return;
+    return NULL;
 
   if (DWARF2_DIR_SHOULD_END_WITH_SEPARATOR)
     {
@@ -15783,7 +16073,18 @@ add_comp_dir_attribute (dw_die_ref die)
       wd = wd1;
     }
 
-    add_AT_string (die, DW_AT_comp_dir, remap_debug_filename (wd));
+  cached_wd = remap_debug_filename (wd);
+  return cached_wd;
+}
+
+/* Generate a DW_AT_comp_dir attribute for DIE.  */
+
+static void
+add_comp_dir_attribute (dw_die_ref die)
+{
+  const char * wd = comp_dir_string ();
+  if (wd != NULL)
+    add_AT_string (die, DW_AT_comp_dir, wd);
 }
 
 /* Return the default for DW_AT_lower_bound, or -1 if there is not any
@@ -16236,11 +16537,12 @@ add_src_coords_attributes (dw_die_ref die, tree decl)
 static void
 add_linkage_name (dw_die_ref die, tree decl)
 {
-  if ((TREE_CODE (decl) == FUNCTION_DECL || TREE_CODE (decl) == VAR_DECL)
-       && TREE_PUBLIC (decl)
-       && !DECL_ABSTRACT (decl)
-       && !(TREE_CODE (decl) == VAR_DECL && DECL_REGISTER (decl))
-       && die->die_tag != DW_TAG_member)
+  if (debug_info_level > DINFO_LEVEL_TERSE
+      && (TREE_CODE (decl) == FUNCTION_DECL || TREE_CODE (decl) == VAR_DECL)
+      && TREE_PUBLIC (decl)
+      && !DECL_ABSTRACT (decl)
+      && !(TREE_CODE (decl) == VAR_DECL && DECL_REGISTER (decl))
+      && die->die_tag != DW_TAG_member)
     {
       /* Defer until we have an assembler name set.  */
       if (!DECL_ASSEMBLER_NAME_SET_P (decl))
@@ -16304,7 +16606,7 @@ dwarf2out_vms_debug_main_pointer (void)
   die->die_tag = DW_TAG_subprogram;
   add_name_attribute (die, VMS_DEBUG_MAIN_POINTER);
   ASM_GENERATE_INTERNAL_LABEL (label, PROLOGUE_END_LABEL,
-			       current_function_funcdef_no);
+			       FUNC_LABEL_ID (cfun));
   add_AT_lbl_id (die, DW_AT_entry_pc, label);
 
   /* Make it the first child of comp_unit_die ().  */
@@ -17754,9 +18056,9 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)
 	      char label_id_low[MAX_ARTIFICIAL_LABEL_BYTES];
 	      char label_id_high[MAX_ARTIFICIAL_LABEL_BYTES];
 	      ASM_GENERATE_INTERNAL_LABEL (label_id_low, FUNC_BEGIN_LABEL,
-					   current_function_funcdef_no);
+					   FUNC_LABEL_ID (cfun));
 	      ASM_GENERATE_INTERNAL_LABEL (label_id_high, FUNC_END_LABEL,
-					   current_function_funcdef_no);
+					   FUNC_LABEL_ID (cfun));
              add_AT_low_high_pc (subr_die, label_id_low, label_id_high,
                                  false);
 	    }
@@ -19623,16 +19925,19 @@ decls_for_scope (tree stmt, dw_die_ref context_die, int depth)
   /* Output the DIEs to represent all of the data objects and typedefs
      declared directly within this block but not within any nested
      sub-blocks.  Also, nested function and tag DIEs have been
-     generated with a parent of NULL; fix that up now.  */
-  for (decl = BLOCK_VARS (stmt); decl != NULL; decl = DECL_CHAIN (decl))
-    process_scope_var (stmt, decl, NULL_TREE, context_die);
-  for (i = 0; i < BLOCK_NUM_NONLOCALIZED_VARS (stmt); i++)
-    process_scope_var (stmt, NULL, BLOCK_NONLOCALIZED_VAR (stmt, i),
-    		       context_die);
+     generated with a parent of NULL; fix that up now.  We don't
+     have to do this if we're at -g1.  */
+  if (debug_info_level > DINFO_LEVEL_TERSE)
+    {
+      for (decl = BLOCK_VARS (stmt); decl != NULL; decl = DECL_CHAIN (decl))
+	process_scope_var (stmt, decl, NULL_TREE, context_die);
+      for (i = 0; i < BLOCK_NUM_NONLOCALIZED_VARS (stmt); i++)
+	process_scope_var (stmt, NULL, BLOCK_NONLOCALIZED_VAR (stmt, i),
+			   context_die);
+    }
 
-  /* If we're at -g1, we're not interested in subblocks.  */
-  if (debug_info_level <= DINFO_LEVEL_TERSE)
-    return;
+  /* Even if we're at -g1, we need to process the subblocks in order to get
+     inlined call information.  */
 
   /* Output the DIEs to represent all sub-blocks (and the items declared
      therein) of this block.  */
@@ -20255,7 +20560,48 @@ dwarf2out_imported_module_or_decl (tree decl, tree name, tree context,
 void
 dwarf2out_decl (tree decl)
 {
-  dw_die_ref context_die = comp_unit_die ();
+  dw_die_ref context_die;
+
+  /* In LIPO mode, we may output some functions whose type is defined
+     in another function that will not be output. This can result in
+     undefined location list symbols in the debug type info.
+     Here we disable the output of the type info for this case.
+     It is safe since this function and its debug info should never
+     be referenced.  */
+  if (L_IPO_COMP_MODE)
+    {
+      tree decl_context, orig_decl;
+
+      decl_context = DECL_CONTEXT (decl);
+      while (decl_context &&
+          TREE_CODE (decl_context) != TRANSLATION_UNIT_DECL)
+      {
+        struct cgraph_node *node;
+
+        /* Refer to cgraph_mark_functions_to_output() in cgraphunit.c,
+           if cgraph_is_aux_decl_external() is true,
+           this function will not be output in LIPO mode.  */
+        if (TREE_CODE (decl_context) == FUNCTION_DECL &&
+            TREE_PUBLIC (decl_context) &&
+            (node = cgraph_get_node (decl_context)) &&
+            cgraph_is_aux_decl_external (node))
+          return;
+
+        if (TYPE_P (decl_context))
+          {
+            decl_context = TYPE_CONTEXT (decl_context);
+            continue;
+          }
+
+        orig_decl = DECL_ORIGIN (decl_context);
+        while (orig_decl != DECL_ORIGIN (orig_decl))
+          orig_decl = DECL_ORIGIN (orig_decl);
+
+        decl_context = DECL_CONTEXT (orig_decl);
+      }
+    }
+
+  context_die = comp_unit_die ();
 
   switch (TREE_CODE (decl))
     {
@@ -20916,7 +21262,7 @@ set_cur_line_info_table (section *sec)
 	{
 	  char label[MAX_ARTIFICIAL_LABEL_BYTES];
 	  ASM_GENERATE_INTERNAL_LABEL (label, FUNC_END_LABEL,
-				       current_function_funcdef_no);
+				       FUNC_LABEL_ID (cfun));
 	  end_label = ggc_strdup (label);
 	}
 
@@ -21040,7 +21386,7 @@ dwarf2out_source_line (unsigned int line, const char *filename,
   unsigned int file_num;
   dw_line_info_table *table;
 
-  if (debug_info_level < DINFO_LEVEL_NORMAL || line == 0)
+  if (debug_info_level < DINFO_LEVEL_TERSE || line == 0)
     return;
 
   /* The discriminator column was added in dwarf4.  Simplify the below
@@ -21691,6 +22037,8 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)
                                    DEBUG_SKELETON_INFO_SECTION_LABEL, 0);
       debug_loc_section = get_section (DEBUG_DWO_LOC_SECTION,
                                        SECTION_DEBUG | SECTION_EXCLUDE, NULL);
+      debug_str_dwo_section = get_section (DEBUG_STR_DWO_SECTION,
+                                           DEBUG_STR_DWO_SECTION_FLAGS, NULL);
     }
   debug_aranges_section = get_section (DEBUG_ARANGES_SECTION,
 				       SECTION_DEBUG, NULL);
@@ -21815,7 +22163,6 @@ output_index_string (void **h, void *v)
       /* Assert that the strings are output in the same order as their
          indexes were assigned.  */
       gcc_assert (*cur_idx == node->index);
-      ASM_OUTPUT_LABEL (asm_out_file, node->label);
       assemble_string (node->str, strlen (node->str) + 1);
       *cur_idx += 1;
     }
@@ -21830,6 +22177,7 @@ output_indirect_string (void **h, void *v ATTRIBUTE_UNUSED)
 {
   struct indirect_string_node *node = (struct indirect_string_node *) *h;
 
+  node->form = find_string_form (node);
   if (node->form == DW_FORM_strp && node->refcount > 0)
     {
       ASM_OUTPUT_LABEL (asm_out_file, node->label);
@@ -21844,21 +22192,21 @@ output_indirect_string (void **h, void *v ATTRIBUTE_UNUSED)
 static void
 output_indirect_strings (void)
 {
+  switch_to_section (debug_str_section);
   if (!dwarf_split_debug_info)
-    {
-      switch_to_section (debug_str_section);
-      htab_traverse (debug_str_hash, output_indirect_string, NULL);
-    }
+    htab_traverse (debug_str_hash, output_indirect_string, NULL);
   else
     {
       unsigned int offset = 0;
       unsigned int cur_idx = 0;
 
+      htab_traverse (skeleton_debug_str_hash, output_indirect_string, NULL);
+
       switch_to_section (debug_str_offsets_section);
       htab_traverse_noresize (debug_str_hash,
                               output_index_string_offset,
                               &offset);
-      switch_to_section (debug_str_section);
+      switch_to_section (debug_str_dwo_section);
       htab_traverse_noresize (debug_str_hash,
                               output_index_string,
                               &cur_idx);
@@ -21985,17 +22333,8 @@ prune_unused_types_mark_generic_parms_dies (dw_die_ref die)
   c = die->die_child;
   do
     {
-      switch (c->die_tag)
-	{
-	case DW_TAG_template_type_param:
-	case DW_TAG_template_value_param:
-	case DW_TAG_GNU_template_template_param:
-	case DW_TAG_GNU_template_parameter_pack:
-	  prune_unused_types_mark (c, 1);
-	  break;
-	default:
-	  break;
-	}
+      if (is_template_parameter (c))
+	prune_unused_types_mark (c, 1);
       c = c->die_sib;
     } while (c && c != die->die_child);
 }
@@ -22273,6 +22612,8 @@ prune_unused_types (void)
 
   if (debug_str_hash)
     htab_empty (debug_str_hash);
+  if (skeleton_debug_str_hash)
+    htab_empty (skeleton_debug_str_hash);
   prune_unused_types_prune (comp_unit_die ());
   for (node = limbo_die_list; node; node = node->next)
     prune_unused_types_prune (node->die);
@@ -22776,7 +23117,7 @@ resolve_addr (dw_die_ref die)
 
 /* Iteratively hash operands of LOC opcode.  */
 
-static inline hashval_t
+static hashval_t
 hash_loc_operands (dw_loc_descr_ref loc, hashval_t hash)
 {
   dw_val_ref val1 = &loc->dw_loc_oprnd1;
@@ -23521,7 +23862,7 @@ dwarf2out_finish (const char *filename)
 	}
     }
 
-  if (debug_info_level >= DINFO_LEVEL_NORMAL)
+  if (debug_info_level >= DINFO_LEVEL_TERSE)
     add_AT_lineptr (main_comp_unit_die, DW_AT_stmt_list,
 		    debug_line_section_label);
 
@@ -23546,9 +23887,18 @@ dwarf2out_finish (const char *filename)
     optimize_location_lists (comp_unit_die ());
 
   save_macinfo_strings ();
+
   if (dwarf_split_debug_info)
     {
       unsigned int index = 0;
+
+      /* Add attributes common to skeleton compile_units and
+         type_units.  Because these attributes include strings, it
+         must be done before freezing the string table.  Top-level
+         skeleton die attrs are added when the skeleton type unit is
+         created, so ensure it is created by this point.  */
+      add_top_level_skeleton_die_attrs (main_comp_unit_die);
+      (void) get_skeleton_type_unit ();
       htab_traverse_noresize (debug_str_hash, index_string, &index);
     }
 
@@ -23569,7 +23919,7 @@ dwarf2out_finish (const char *filename)
       /* Add a pointer to the line table for the main compilation unit
          so that the debugger can make sense of DW_AT_decl_file
          attributes.  */
-      if (debug_info_level >= DINFO_LEVEL_NORMAL)
+      if (debug_info_level >= DINFO_LEVEL_TERSE)
         add_AT_lineptr (ctnode->root_die, DW_AT_stmt_list,
                         (!dwarf_split_debug_info
                          ? debug_line_section_label
@@ -23640,12 +23990,7 @@ dwarf2out_finish (const char *filename)
       output_location_lists (comp_unit_die ());
     }
 
-  /* Output public names and types tables if necessary.  */
-  output_pubnames (pubname_table);
-  /* ??? Only defined by DWARF3, but emitted by Darwin for DWARF2.
-     It shouldn't hurt to emit it always, since pure DWARF2 consumers
-     simply won't look for the section.  */
-  output_pubnames (pubtype_table);
+  output_pubtables ();
 
   /* Output the address range information if a CU (.debug_info section)
      was emitted.  We output an empty table even if we had no functions
@@ -23696,7 +24041,7 @@ dwarf2out_finish (const char *filename)
     }
 
   /* If we emitted any indirect strings, output the string table too.  */
-  if (debug_str_hash)
+  if (debug_str_hash || skeleton_debug_str_hash)
     output_indirect_strings ();
 }
 
diff --git a/gcc/dwarf2out.h b/gcc/dwarf2out.h
index f68d0e4..07cd373 100644
--- a/gcc/dwarf2out.h
+++ b/gcc/dwarf2out.h
@@ -85,8 +85,8 @@ typedef struct GTY(()) dw_fde_struct {
   int dw_fde_switch_cfi_index; /* Last CFI before switching sections.  */
   HOST_WIDE_INT stack_realignment;
 
-  unsigned funcdef_number;
-  unsigned fde_index;
+  unsigned long funcdef_number;
+  unsigned long fde_index;
 
   /* Dynamic realign argument pointer register.  */
   unsigned int drap_reg;
diff --git a/gcc/except.c b/gcc/except.c
index 4e85f73..45a9c91 100644
--- a/gcc/except.c
+++ b/gcc/except.c
@@ -1139,7 +1139,7 @@ sjlj_emit_function_enter (rtx dispatch_label)
       char buf[20];
       rtx sym;
 
-      ASM_GENERATE_INTERNAL_LABEL (buf, "LLSDA", current_function_funcdef_no);
+      ASM_GENERATE_INTERNAL_LABEL (buf, "LLSDA", FUNC_LABEL_ID (cfun));
       sym = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (buf));
       SYMBOL_REF_FLAGS (sym) = SYMBOL_FLAG_LOCAL;
       emit_move_insn (mem, sym);
@@ -2899,7 +2899,7 @@ output_one_function_exception_table (int section)
 #ifdef HAVE_AS_LEB128
       ASM_GENERATE_INTERNAL_LABEL (ttype_label,
 				   section ? "LLSDATTC" : "LLSDATT",
-				   current_function_funcdef_no);
+                                   FUNC_LABEL_ID (cfun));
 #endif
       tt_format_size = size_of_encoded_value (tt_format);
 
@@ -2907,7 +2907,7 @@ output_one_function_exception_table (int section)
     }
 
   targetm.asm_out.internal_label (asm_out_file, section ? "LLSDAC" : "LLSDA",
-				  current_function_funcdef_no);
+                                  FUNC_LABEL_ID (cfun));
 
   /* The LSDA header.  */
 
@@ -2940,7 +2940,7 @@ output_one_function_exception_table (int section)
       char ttype_after_disp_label[32];
       ASM_GENERATE_INTERNAL_LABEL (ttype_after_disp_label,
 				   section ? "LLSDATTDC" : "LLSDATTD",
-				   current_function_funcdef_no);
+                                   FUNC_LABEL_ID (cfun));
       dw2_asm_output_delta_uleb128 (ttype_label, ttype_after_disp_label,
 				    "@TType base offset");
       ASM_OUTPUT_LABEL (asm_out_file, ttype_after_disp_label);
@@ -2987,10 +2987,10 @@ output_one_function_exception_table (int section)
 #ifdef HAVE_AS_LEB128
   ASM_GENERATE_INTERNAL_LABEL (cs_after_size_label,
 			       section ? "LLSDACSBC" : "LLSDACSB",
-			       current_function_funcdef_no);
+                               FUNC_LABEL_ID (cfun));
   ASM_GENERATE_INTERNAL_LABEL (cs_end_label,
 			       section ? "LLSDACSEC" : "LLSDACSE",
-			       current_function_funcdef_no);
+                               FUNC_LABEL_ID (cfun));
   dw2_asm_output_delta_uleb128 (cs_end_label, cs_after_size_label,
 				"Call-site table length");
   ASM_OUTPUT_LABEL (asm_out_file, cs_after_size_label);
diff --git a/gcc/final.c b/gcc/final.c
index d25b8e0..0bdd3ac 100644
--- a/gcc/final.c
+++ b/gcc/final.c
@@ -124,9 +124,6 @@ static int last_linenum;
 /* Last discriminator written to assembly.  */
 static int last_discriminator;
 
-/* Discriminator of current block.  */
-static int discriminator;
-
 /* Highest line number in current block.  */
 static int high_block_linenum;
 
@@ -136,9 +133,10 @@ static int high_function_linenum;
 /* Filename of last NOTE.  */
 static const char *last_filename;
 
-/* Override filename and line number.  */
+/* Override filename, line number, and discriminator.  */
 static const char *override_filename;
 static int override_linenum;
+static int override_discriminator;
 
 /* Whether to force emission of a line note before the next insn.  */
 static bool force_source_line = false;
@@ -203,6 +201,9 @@ bool final_insns_dump_p;
 /* True if profile_function should be called, but hasn't been called yet.  */
 static bool need_profile_function;
 
+/* True if the function has a split cold section.  */
+static bool has_cold_section_p;
+
 static int asm_insn_count (rtx);
 static void profile_function (FILE *);
 static void profile_after_prologue (FILE *);
@@ -1682,7 +1683,7 @@ final_start_function (rtx first, FILE *file,
 
   last_filename = LOCATION_FILE (prologue_location);
   last_linenum = LOCATION_LINE (prologue_location);
-  last_discriminator = discriminator = 0;
+  last_discriminator = 0;
 
   high_block_linenum = high_function_linenum = last_linenum;
 
@@ -1751,9 +1752,13 @@ final_start_function (rtx first, FILE *file,
   if (warn_frame_larger_than
     && get_frame_size () > frame_larger_than_size)
   {
-      /* Issue a warning */
+      /* Issue a warning.  (WARN_FRAME_LARGER_THAN_EXTRA_TEXT is
+         provided by configuration.  The way extra text is added
+         here may prevent localization from working properly.
+         It's totally broken.)  */
       warning (OPT_Wframe_larger_than_,
-               "the frame size of %wd bytes is larger than %wd bytes",
+               "the frame size of %wd bytes is larger than %wd bytes"
+               WARN_FRAME_LARGER_THAN_EXTRA_TEXT,
                get_frame_size (), frame_larger_than_size);
   }
 
@@ -1796,7 +1801,7 @@ profile_function (FILE *file ATTRIBUTE_UNUSED)
       int align = MIN (BIGGEST_ALIGNMENT, LONG_TYPE_SIZE);
       switch_to_section (data_section);
       ASM_OUTPUT_ALIGN (file, floor_log2 (align / BITS_PER_UNIT));
-      targetm.asm_out.internal_label (file, "LP", current_function_funcdef_no);
+      targetm.asm_out.internal_label (file, "LP", FUNC_LABEL_ID (cfun));
       assemble_integer (const0_rtx, LONG_TYPE_SIZE / BITS_PER_UNIT, align, 1);
     }
 
@@ -1809,7 +1814,7 @@ profile_function (FILE *file ATTRIBUTE_UNUSED)
     ASM_OUTPUT_REG_PUSH (file, REGNO (chain));
 #endif
 
-  FUNCTION_PROFILER (file, current_function_funcdef_no);
+  FUNCTION_PROFILER (file, FUNC_LABEL_ID (cfun));
 
 #ifdef ASM_OUTPUT_REG_PUSH
   if (chain && REG_P (chain))
@@ -2111,6 +2116,7 @@ final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,
 	  targetm.asm_out.function_switched_text_sections (asm_out_file,
 							   current_function_decl,
 							   in_cold_section_p);
+	  has_cold_section_p = true;
 	  break;
 
 	case NOTE_INSN_BASIC_BLOCK:
@@ -2131,8 +2137,6 @@ final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,
 	  else
 	    *seen |= SEEN_BB;
 
-          discriminator = NOTE_BASIC_BLOCK (insn)->discriminator;
-
 	  break;
 
 	case NOTE_INSN_EH_REGION_BEG:
@@ -2225,6 +2229,8 @@ final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,
 		{
 		  override_filename = LOCATION_FILE (*locus_ptr);
 		  override_linenum = LOCATION_LINE (*locus_ptr);
+		  override_discriminator =
+		      get_discriminator_from_locus (*locus_ptr);
 		}
 	    }
 	  break;
@@ -2258,11 +2264,14 @@ final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,
 		{
 		  override_filename = LOCATION_FILE (*locus_ptr);
 		  override_linenum = LOCATION_LINE (*locus_ptr);
+		  override_discriminator =
+		      get_discriminator_from_locus (*locus_ptr);
 		}
 	      else
 		{
 		  override_filename = NULL;
 		  override_linenum = 0;
+		  override_discriminator = 0;
 		}
 	    }
 	  break;
@@ -2945,6 +2954,17 @@ final_scan_insn (rtx insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,
     }
   return NEXT_INSN (insn);
 }
+
+/* Return discriminator of the statement that produced this insn.  */
+int
+insn_discriminator (const_rtx insn)
+{
+  location_t loc = INSN_LOCATION (insn);
+  if (!loc)
+    return 0;
+  return get_discriminator_from_locus (loc);
+}
+
 
 /* Return whether a source line note needs to be emitted before INSN.
    Sets IS_STMT to TRUE if the line should be marked as a possible
@@ -2955,16 +2975,19 @@ notice_source_line (rtx insn, bool *is_stmt)
 {
   const char *filename;
   int linenum;
+  int discriminator;
 
   if (override_filename)
     {
       filename = override_filename;
       linenum = override_linenum;
+      discriminator = override_discriminator;
     }
   else
     {
       filename = insn_file (insn);
       linenum = insn_line (insn);
+      discriminator = insn_discriminator (insn);
     }
 
   if (filename == NULL)
@@ -4320,13 +4343,55 @@ leaf_renumber_regs_insn (rtx in_rtx)
       }
 }
 #endif
-
+
+/* List the call graph profiled edges whise value is greater than
+   PARAM_NOTE_CGRAPH_SECTION_EDGE_THRESHOLD in the
+   "gnu.callgraph.text" section. */
+static void
+dump_cgraph_profiles (void)
+{
+  struct cgraph_node *node = cgraph_get_node (current_function_decl);
+  struct cgraph_edge *e;
+  struct cgraph_node *callee;
+
+  for (e = node->callees; e != NULL; e = e->next_callee)
+    {
+      if (e->count <= PARAM_VALUE (PARAM_GNU_CGRAPH_SECTION_EDGE_THRESHOLD))
+        continue;
+      callee = e->callee;
+      fprintf (asm_out_file, "\t.string \"%s\"\n",
+               IDENTIFIER_POINTER (decl_assembler_name (callee->symbol.decl)));
+      fprintf (asm_out_file, "\t.string \"" HOST_WIDEST_INT_PRINT_DEC "\"\n",
+               e->count);
+    }
+}
+
+/* Iterate through the basic blocks in DECL and get the max count.
+   If COLD is true, find the max count of the cold part of the split.  */
+static gcov_type
+get_max_count (tree decl, bool cold)
+{
+  basic_block bb;
+  gcov_type max_count = cold ? 0 :(cgraph_get_node (decl))->count;
+
+  FOR_EACH_BB (bb)
+    {
+      if (cold && BB_PARTITION (bb) != BB_COLD_PARTITION)
+        continue;
+      if (bb->count > max_count)
+        max_count = bb->count;
+    }
+  return max_count;
+}
+
 /* Turn the RTL into assembly.  */
 static unsigned int
 rest_of_handle_final (void)
 {
   rtx x;
   const char *fnname;
+  char *profile_fnname;
+  unsigned int flags;
 
   /* Get the function's name, as described by its RTL.  This may be
      different from the DECL_NAME name used in the source file.  */
@@ -4337,6 +4402,8 @@ rest_of_handle_final (void)
   gcc_assert (GET_CODE (x) == SYMBOL_REF);
   fnname = XSTR (x, 0);
 
+  has_cold_section_p = false;
+
   assemble_start_function (current_function_decl, fnname);
   final_start_function (get_insns (), asm_out_file, optimize);
   final (get_insns (), asm_out_file, optimize);
@@ -4386,6 +4453,36 @@ rest_of_handle_final (void)
     targetm.asm_out.destructor (XEXP (DECL_RTL (current_function_decl), 0),
 				decl_fini_priority_lookup
 				  (current_function_decl));
+
+  /* With -fcallgraph-profiles-sections and -freorder-functions=,
+     add ".gnu.callgraph.text" section for storing profiling information. */
+  if ((flag_reorder_functions > 1)
+      && flag_profile_use
+      && cgraph_get_node (current_function_decl) != NULL
+      && ((cgraph_get_node (current_function_decl))->callees != NULL
+	  || (cgraph_get_node (current_function_decl))->count > 0))
+    {
+      flags = SECTION_DEBUG | SECTION_EXCLUDE;
+      asprintf (&profile_fnname, ".gnu.callgraph.text.%s", fnname);
+      switch_to_section (get_section (profile_fnname, flags, NULL));
+      fprintf (asm_out_file, "\t.string \"Function %s\"\n", fnname);
+      fprintf (asm_out_file, "\t.string \"Weight "
+                            HOST_WIDEST_INT_PRINT_DEC
+                            " "
+                            HOST_WIDEST_INT_PRINT_DEC
+                            "\"\n",
+              (cgraph_get_node (current_function_decl))->count,
+              get_max_count (current_function_decl, false));
+      /* If this function is split into a cold section, record that weight
+        here.  */
+      if (has_cold_section_p)
+        fprintf (asm_out_file, "\t.string \"ColdWeight "
+                 HOST_WIDEST_INT_PRINT_DEC
+                 "\"\n",
+                 get_max_count (current_function_decl, true));
+      dump_cgraph_profiles ();
+      free (profile_fnname);
+    }
   return 0;
 }
 
diff --git a/gcc/fold-const.c b/gcc/fold-const.c
index 5e34863..f7bb8403 100644
--- a/gcc/fold-const.c
+++ b/gcc/fold-const.c
@@ -2396,11 +2396,27 @@ combine_comparisons (location_t loc,
 
    If OEP_PURE_SAME is set, then pure functions with identical arguments
    are considered the same.  It is used when the caller has other ways
-   to ensure that global memory is unchanged in between.  */
+   to ensure that global memory is unchanged in between.
+
+   If OEP_ALLOW_NULL is set, this routine will not crash on NULL operands,
+   and two NULL operands are considered equal. This flag is usually set
+   in the context of frontend when ARG0 and/or ARG1 may be NULL mostly due
+   to recursion on partially built expressions (e.g. a CAST_EXPR on a NULL
+   tree.) In this case, we certainly don't want the compiler to crash and
+   it's OK to consider two NULL operands equal. On the other hand, when
+   called in the context of code generation and optimization, if NULL
+   operands are not expected, silently ignoring them could be dangerous
+   and might cause problems downstream that are hard to find/debug. In that
+   case, the flag should probably not be set.  */
 
 int
 operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)
 {
+  /* If either is NULL, they must be both NULL to be equal. We only do this
+     check when OEP_ALLOW_NULL is set.  */
+  if ((flags & OEP_ALLOW_NULL) && (!arg0 || !arg1))
+    return arg0 == arg1;
+
   /* If either is ERROR_MARK, they aren't equal.  */
   if (TREE_CODE (arg0) == ERROR_MARK || TREE_CODE (arg1) == ERROR_MARK
       || TREE_TYPE (arg0) == error_mark_node
@@ -2410,7 +2426,13 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)
   /* Similar, if either does not have a type (like a released SSA name), 
      they aren't equal.  */
   if (!TREE_TYPE (arg0) || !TREE_TYPE (arg1))
-    return 0;
+    {
+      /* If the caller chooses to allow the comparison of operands without
+         types, we will continue the comparison only when both of them don't
+         have a type.  */
+      if (!(flags & OEP_ALLOW_NO_TYPE) || TREE_TYPE (arg0) || TREE_TYPE (arg1))
+        return 0;
+    }
 
   /* Check equality of integer constants before bailing out due to
      precision differences.  */
@@ -2422,19 +2444,24 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)
      because they may change the signedness of the arguments.  As pointers
      strictly don't have a signedness, require either two pointers or
      two non-pointers as well.  */
-  if (TYPE_UNSIGNED (TREE_TYPE (arg0)) != TYPE_UNSIGNED (TREE_TYPE (arg1))
-      || POINTER_TYPE_P (TREE_TYPE (arg0)) != POINTER_TYPE_P (TREE_TYPE (arg1)))
+  if (TREE_TYPE (arg0)
+      && (TYPE_UNSIGNED (TREE_TYPE (arg0)) != TYPE_UNSIGNED (TREE_TYPE (arg1))
+          || POINTER_TYPE_P (TREE_TYPE (arg0))
+             != POINTER_TYPE_P (TREE_TYPE (arg1))))
     return 0;
 
   /* We cannot consider pointers to different address space equal.  */
-  if (POINTER_TYPE_P (TREE_TYPE (arg0)) && POINTER_TYPE_P (TREE_TYPE (arg1))
-      && (TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (arg0)))
-	  != TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (arg1)))))
+  if (TREE_TYPE (arg0)
+      && (POINTER_TYPE_P (TREE_TYPE (arg0)) && POINTER_TYPE_P (TREE_TYPE (arg1))
+          && (TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (arg0)))
+              != TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (arg1))))))
     return 0;
 
   /* If both types don't have the same precision, then it is not safe
      to strip NOPs.  */
-  if (TYPE_PRECISION (TREE_TYPE (arg0)) != TYPE_PRECISION (TREE_TYPE (arg1)))
+  if (TREE_TYPE (arg0)
+      && (TYPE_PRECISION (TREE_TYPE (arg0))
+          != TYPE_PRECISION (TREE_TYPE (arg1))))
     return 0;
 
   STRIP_NOPS (arg0);
@@ -2459,9 +2486,10 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)
   if (TREE_CODE (arg0) != TREE_CODE (arg1)
       /* This is needed for conversions and for COMPONENT_REF.
 	 Might as well play it safe and always test this.  */
-      || TREE_CODE (TREE_TYPE (arg0)) == ERROR_MARK
-      || TREE_CODE (TREE_TYPE (arg1)) == ERROR_MARK
-      || TYPE_MODE (TREE_TYPE (arg0)) != TYPE_MODE (TREE_TYPE (arg1)))
+      || (TREE_TYPE (arg0)
+          && (TREE_CODE (TREE_TYPE (arg0)) == ERROR_MARK
+              || TREE_CODE (TREE_TYPE (arg1)) == ERROR_MARK
+              || TYPE_MODE (TREE_TYPE (arg0)) != TYPE_MODE (TREE_TYPE (arg1)))))
     return 0;
 
   /* If ARG0 and ARG1 are the same SAVE_EXPR, they are necessarily equal.
@@ -2497,7 +2525,8 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)
 	  return 1;
 
 
-	if (!HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg0))))
+	if (TREE_TYPE (arg0)
+            && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg0))))
 	  {
 	    /* If we do not distinguish between signed and unsigned zero,
 	       consider them equal.  */
@@ -2564,8 +2593,9 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)
         {
 	CASE_CONVERT:
         case FIX_TRUNC_EXPR:
-	  if (TYPE_UNSIGNED (TREE_TYPE (arg0))
-	      != TYPE_UNSIGNED (TREE_TYPE (arg1)))
+	  if (TREE_TYPE (arg0)
+              && (TYPE_UNSIGNED (TREE_TYPE (arg0))
+                  != TYPE_UNSIGNED (TREE_TYPE (arg1))))
 	    return 0;
 	  break;
 	default:
@@ -2621,11 +2651,14 @@ operand_equal_p (const_tree arg0, const_tree arg1, unsigned int flags)
 	     We can have incomplete types for array references of
 	     variable-sized arrays from the Fortran frontent
 	     though.  */
-	  return ((TYPE_SIZE (TREE_TYPE (arg0)) == TYPE_SIZE (TREE_TYPE (arg1))
-		   || (TYPE_SIZE (TREE_TYPE (arg0))
-		       && TYPE_SIZE (TREE_TYPE (arg1))
-		       && operand_equal_p (TYPE_SIZE (TREE_TYPE (arg0)),
-					   TYPE_SIZE (TREE_TYPE (arg1)), flags)))
+	  return (TREE_TYPE (arg0)
+                  && (TYPE_SIZE (TREE_TYPE (arg0))
+                      == TYPE_SIZE (TREE_TYPE (arg1))
+                      || (TYPE_SIZE (TREE_TYPE (arg0))
+                          && TYPE_SIZE (TREE_TYPE (arg1))
+                          && operand_equal_p (TYPE_SIZE (TREE_TYPE (arg0)),
+                                              TYPE_SIZE (TREE_TYPE (arg1)),
+                                              flags)))
 		  && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (arg0, 1)))
 		      == TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (arg1, 1))))
 		  && OP_SAME (0) && OP_SAME (1));
@@ -7743,8 +7776,8 @@ static bool vec_cst_ctor_to_array (tree, tree *);
    OP0.  Return the folded expression if folding is successful.
    Otherwise, return NULL_TREE.  */
 
-tree
-fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)
+static tree
+fold_unary_loc_1 (location_t loc, enum tree_code code, tree type, tree op0)
 {
   tree tem;
   tree arg0;
@@ -8457,6 +8490,49 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)
     } /* switch (code) */
 }
 
+/* Given an expression tree EXP, set the EXPR_FOLDED flag, and if it is
+   a nop, recursively set the EXPR_FOLDED flag of its operand.  */
+
+static void
+set_expr_folded_flag (tree exp)
+{
+  /* FIXME -- can not set the flag on SSA_NAME, the flag overlaps
+     with the version member.  */
+  if (TREE_CODE (exp) == SSA_NAME)
+    return;
+
+  EXPR_FOLDED (exp) = 1;
+
+  /* If EXP is a nop (i.e. NON_LVALUE_EXPRs and NOP_EXPRs), we need to
+     recursively set the EXPR_FOLDED flag of its operand because the 
+     expression will be stripped later.  */
+  while ((CONVERT_EXPR_P (exp)
+          || TREE_CODE (exp) == NON_LVALUE_EXPR)
+	 && TREE_OPERAND (exp, 0) != error_mark_node)
+    {
+      exp = TREE_OPERAND (exp, 0);
+      /* FIXME -- can not set the flag on SSA_NAME, the flag overlaps
+         with the version member.  */
+      if (TREE_CODE (exp) != SSA_NAME)
+        EXPR_FOLDED (exp) = 1;
+    }
+}
+
+/* Fold a unary expression of code CODE and type TYPE with operand
+   OP0.  Return the folded expression if folding is successful.
+   Otherwise, return NULL_TREE.
+   This is a wrapper around fold_unary_1 function (which does the
+   actual folding). Set the EXPR_FOLDED flag of the folded expression
+   if folding is successful.  */
+
+tree
+fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)
+{
+  tree tem = fold_unary_loc_1 (loc, code, type, op0);
+  if (tem)
+    set_expr_folded_flag (tem);
+  return tem;
+}
 
 /* If the operation was a conversion do _not_ mark a resulting constant
    with TREE_OVERFLOW if the original constant was not.  These conversions
@@ -9856,8 +9932,8 @@ exact_inverse (tree type, tree cst)
    Return the folded expression if folding is successful.  Otherwise,
    return NULL_TREE.  */
 
-tree
-fold_binary_loc (location_t loc,
+static tree
+fold_binary_loc_1 (location_t loc,
 	     enum tree_code code, tree type, tree op0, tree op1)
 {
   enum tree_code_class kind = TREE_CODE_CLASS (code);
@@ -13858,6 +13934,22 @@ fold_binary_loc (location_t loc,
     } /* switch (code) */
 }
 
+/* Fold a binary expression of code CODE and type TYPE with operands
+   OP0 and OP1.  Return the folded expression if folding is
+   successful.  Otherwise, return NULL_TREE.
+   This is a wrapper around fold_binary_1 function (which does the
+   actual folding). Set the EXPR_FOLDED flag of the folded expression
+   if folding is successful.  */
+tree
+fold_binary_loc (location_t loc,
+                 enum tree_code code, tree type, tree op0, tree op1)
+{
+  tree tem = fold_binary_loc_1 (loc, code, type, op0, op1);
+  if (tem)
+    set_expr_folded_flag (tem);
+  return tem;
+}
+
 /* Callback for walk_tree, looking for LABEL_EXPR.  Return *TP if it is
    a LABEL_EXPR; otherwise return NULL_TREE.  Do not check the subtrees
    of GOTO_EXPR.  */
@@ -13894,9 +13986,9 @@ contains_label_p (tree st)
    OP0, OP1, and OP2.  Return the folded expression if folding is
    successful.  Otherwise, return NULL_TREE.  */
 
-tree
-fold_ternary_loc (location_t loc, enum tree_code code, tree type,
-		  tree op0, tree op1, tree op2)
+static tree
+fold_ternary_loc_1 (location_t loc, enum tree_code code, tree type,
+                    tree op0, tree op1, tree op2)
 {
   tree tem;
   tree arg0 = NULL_TREE, arg1 = NULL_TREE, arg2 = NULL_TREE;
@@ -14422,6 +14514,23 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,
     } /* switch (code) */
 }
 
+/* Fold a ternary expression of code CODE and type TYPE with operands
+   OP0, OP1, and OP2.  Return the folded expression if folding is
+   successful.  Otherwise, return NULL_TREE.
+   This is a wrapper around fold_ternary_1 function (which does the
+   actual folding). Set the EXPR_FOLDED flag of the folded expression
+   if folding is successful.  */
+
+tree
+fold_ternary_loc (location_t loc, enum tree_code code, tree type,
+		  tree op0, tree op1, tree op2)
+{
+  tree tem = fold_ternary_loc_1 (loc, code, type, op0, op1, op2);
+  if (tem)
+    set_expr_folded_flag (tem);
+  return tem;
+}
+
 /* Perform constant folding and related simplification of EXPR.
    The related simplifications include x*1 => x, x*0 => 0, etc.,
    and application of the associative law.
diff --git a/gcc/function.c b/gcc/function.c
index e673f21..fdfb25a 100644
--- a/gcc/function.c
+++ b/gcc/function.c
@@ -59,6 +59,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "tree-pass.h"
 #include "predict.h"
 #include "df.h"
+#include "l-ipo.h"
 #include "params.h"
 #include "bb-reorder.h"
 
@@ -4459,12 +4460,29 @@ pop_cfun (void)
 }
 
 /* Return value of funcdef and increase it.  */
+
 int
 get_next_funcdef_no (void)
 {
   return funcdef_no++;
 }
 
+/* Restore funcdef_no to FN.  */
+
+void
+set_funcdef_no (int fn)
+{
+  funcdef_no = fn;
+}
+
+/* Reset the funcdef number.  */
+
+void
+reset_funcdef_no (void)
+{
+  funcdef_no = 0;
+}
+
 /* Return value of funcdef.  */
 int
 get_last_funcdef_no (void)
@@ -4506,6 +4524,7 @@ allocate_struct_function (tree fndecl, bool abstract_p)
       DECL_STRUCT_FUNCTION (fndecl) = cfun;
       cfun->decl = fndecl;
       current_function_funcdef_no = get_next_funcdef_no ();
+      cfun->module_id = current_module_id;
     }
 
   invoke_set_current_function_hook (fndecl);
diff --git a/gcc/function.h b/gcc/function.h
index 89d71e5..46fe95b 100644
--- a/gcc/function.h
+++ b/gcc/function.h
@@ -562,6 +562,9 @@ struct GTY(()) function {
   /* Last statement uid.  */
   int last_stmt_uid;
 
+  /* Function's module id.  */
+  unsigned module_id;
+
   /* Function sequence number for profiling, debugging, etc.  */
   int funcdef_no;
 
@@ -643,6 +646,46 @@ struct GTY(()) function {
   unsigned int is_thunk : 1;
 };
 
+#if 0
+#define EXTRACT_MODULE_ID_FROM_GLOBAL_ID(gid) (unsigned)(((gid) >> FUNC_ID_WIDTH) & FUNC_ID_MASK)
+#define EXTRACT_FUNC_ID_FROM_GLOBAL_ID(gid) (unsigned)((gid) & FUNC_ID_MASK)
+#define FUNC_DECL_MODULE_ID(func) EXTRACT_MODULE_ID_FROM_GLOBAL_ID ((func)->funcdef_no + 1)
+#define FUNC_DECL_FUNC_ID(func) EXTRACT_FUNC_ID_FROM_GLOBAL_ID ((func)->funcdef_no + 1)
+#define FUNC_DECL_GLOBAL_ID(func) ((func)->funcdef_no + 1)
+#define GEN_FUNC_GLOBAL_ID(m,f) ((((HOST_WIDE_INT) (m)) << FUNC_ID_WIDTH) | (f))
+#endif
+
+/* The bit width of function id in the global function id used
+   in LIPO.  */
+#define FUNC_ID_WIDTH HOST_BITS_PER_WIDEST_INT / 2
+/* The mask to extract function id from the global function id.  */
+#define FUNC_ID_MASK ((1ll << FUNC_ID_WIDTH) - 1)
+/* Macro to extract module id from global function id GID.  */
+#define EXTRACT_MODULE_ID_FROM_GLOBAL_ID(gid) (unsigned)(((gid) >>\
+                                        FUNC_ID_WIDTH) & FUNC_ID_MASK)
+/* Macro to extract function id from global function id GID.  */
+#define EXTRACT_FUNC_ID_FROM_GLOBAL_ID(gid) (unsigned)((gid) & FUNC_ID_MASK)
+/* Macro to generate a global function id from module id M and
+   function id F.  */
+#define GEN_FUNC_GLOBAL_ID(m,f) ((((HOST_WIDEST_INT) (m)) << FUNC_ID_WIDTH)\
+                                 | (f))
+/* Access macro for module_id field of function FUNC.  */
+#define FUNC_DECL_MODULE_ID(func) ((func)->module_id)
+/* Access macro for funcdef_no field of function FUNC.  */
+#define FUNC_DECL_FUNC_ID(func)   ((func)->funcdef_no + 1)
+/* Macro to compute global function id for FUNC.  */
+#define FUNC_DECL_GLOBAL_ID(func) \
+  GEN_FUNC_GLOBAL_ID (FUNC_DECL_MODULE_ID (func), FUNC_DECL_FUNC_ID (func))
+#if FUNC_ID_WIDTH == 16
+/* 32 bit wide unique id used for asm label (limit: 30k modules,
+   128k funcs per module.  */
+#define FUNC_LABEL_ID(func) ((FUNC_DECL_MODULE_ID (func) << 18) +\
+                             (func)->funcdef_no)
+#else
+#define FUNC_LABEL_ID(func) (((unsigned long)(FUNC_DECL_MODULE_ID (func)) << 32) +\
+                             (func)->funcdef_no)
+#endif
+
 /* Add the decl D to the local_decls list of FUN.  */
 
 static inline void
@@ -763,6 +806,9 @@ extern void used_types_insert (tree);
 extern int get_next_funcdef_no (void);
 extern int get_last_funcdef_no (void);
 
+extern void reset_funcdef_no (void);
+extern void set_funcdef_no (int);
+
 #ifdef HAVE_simple_return
 extern bool requires_stack_frame_p (rtx, HARD_REG_SET, HARD_REG_SET);
 #endif                        
diff --git a/gcc/gcc.c b/gcc/gcc.c
index e16f72e..059b22b 100644
--- a/gcc/gcc.c
+++ b/gcc/gcc.c
@@ -736,6 +736,9 @@ proper position among the other output files.  */
 %{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\
     %(linker) " \
     LINK_PLUGIN_SPEC \
+   "%{freorder-functions=*: \
+    -plugin %(func_reorder_linker_plugin_file) \
+    -plugin-opt=%(func_reorder_linker_plugin_opt)}" \
    "%{flto|flto=*:%<fcompare-debug*} \
     %{flto} %{flto=*} %l " LINK_PIE_SPEC \
    "%{fuse-ld=*:-fuse-ld=%*}\
@@ -789,6 +792,8 @@ static const char *endfile_spec = ENDFILE_SPEC;
 static const char *startfile_spec = STARTFILE_SPEC;
 static const char *linker_name_spec = LINKER_NAME;
 static const char *linker_plugin_file_spec = "";
+static const char *func_reorder_linker_plugin_file_spec = "";
+static const char *func_reorder_linker_plugin_opt = "";
 static const char *lto_wrapper_spec = "";
 static const char *lto_gcc_spec = "";
 static const char *link_command_spec = LINK_COMMAND_SPEC;
@@ -857,14 +862,18 @@ static const char *cc1_options =
  %{!fsyntax-only:%{S:%W{o*}%{!o*:-o %b.s}}}\
  %{fsyntax-only:-o %j} %{-param*}\
  %{fmudflap|fmudflapth:-fno-builtin -fno-merge-constants}\
- %{coverage:-fprofile-arcs -ftest-coverage}";
+ %{coverage:-fprofile-arcs -ftest-coverage -fno-early-inlining}";
 
+/* If an assembler wrapper is used to invoke post-assembly tools
+   like MAO, --save-temps need to be passed to save the output of
+   such post-processing tools. This is not compatible with vanilla
+   binutils gas which does not recognize --save-temps.  */
 static const char *asm_options =
 "%{-target-help:%:print-asm-header()} "
 #if HAVE_GNU_AS
 /* If GNU AS is used, then convert -w (no warnings), -I, and -v
    to the assembler equivalents.  */
-"%{v} %{w:-W} %{I*} "
+"%{v} %{w:-W} %{I*} %{save-temps*:--save-temps} "
 #endif
 "%a %Y %{c:%W{o*}%{!o*:-o %w%b%O}}%{!c:-o %d%w%u%O}";
 
@@ -1286,6 +1295,10 @@ static struct spec_list static_specs[] =
   INIT_STATIC_SPEC ("multilib_reuse",		&multilib_reuse),
   INIT_STATIC_SPEC ("linker",			&linker_name_spec),
   INIT_STATIC_SPEC ("linker_plugin_file",	&linker_plugin_file_spec),
+  INIT_STATIC_SPEC ("func_reorder_linker_plugin_file",
+                    &func_reorder_linker_plugin_file_spec),
+  INIT_STATIC_SPEC ("func_reorder_linker_plugin_opt",
+                    &func_reorder_linker_plugin_opt),
   INIT_STATIC_SPEC ("lto_wrapper",		&lto_wrapper_spec),
   INIT_STATIC_SPEC ("lto_gcc",			&lto_gcc_spec),
   INIT_STATIC_SPEC ("link_libgcc",		&link_libgcc_spec),
@@ -3080,10 +3093,11 @@ display_help (void)
   fputs (_("  -Xassembler <arg>        Pass <arg> on to the assembler\n"), stdout);
   fputs (_("  -Xpreprocessor <arg>     Pass <arg> on to the preprocessor\n"), stdout);
   fputs (_("  -Xlinker <arg>           Pass <arg> on to the linker\n"), stdout);
+  fputs (_("  -Xclang-only=<arg>       Ignore <arg>\n"), stdout);
   fputs (_("  -save-temps              Do not delete intermediate files\n"), stdout);
   fputs (_("  -save-temps=<arg>        Do not delete intermediate files\n"), stdout);
   fputs (_("\
-  -no-canonical-prefixes   Do not canonicalize paths when building relative\n\
+  -[no-]canonical-prefixes Specify the path canonicalization for relative\n\
                            prefixes to other gcc components\n"), stdout);
   fputs (_("  -pipe                    Use pipes rather than intermediate files\n"), stdout);
   fputs (_("  -time                    Time the execution of each subprocess\n"), stdout);
@@ -3509,6 +3523,7 @@ driver_handle_option (struct gcc_options *opts,
 		     decoded->orig_option_with_args_text);
       break;
 
+    case OPT_canonical_prefixes:
     case OPT_no_canonical_prefixes:
       /* Already handled as a special case, so ignored here.  */
       do_save = false;
@@ -3689,20 +3704,25 @@ process_command (unsigned int decoded_options_count,
 	}
     }
 
-  /* Handle any -no-canonical-prefixes flag early, to assign the function
+  /* Handle any -[no-]canonical-prefixes flags early, to assign the function
      that builds relative prefixes.  This function creates default search
      paths that are needed later in normal option handling.  */
 
   for (j = 1; j < decoded_options_count; j++)
     {
-      if (decoded_options[j].opt_index == OPT_no_canonical_prefixes)
-	{
-	  get_relative_prefix = make_relative_prefix_ignore_links;
-	  break;
-	}
+      if (decoded_options[j].opt_index == OPT_canonical_prefixes)
+	get_relative_prefix = make_relative_prefix;
+      else if (decoded_options[j].opt_index == OPT_no_canonical_prefixes)
+	get_relative_prefix = make_relative_prefix_ignore_links;
     }
   if (! get_relative_prefix)
-    get_relative_prefix = make_relative_prefix;
+    {
+#ifdef ENABLE_CANONICAL_PREFIXES
+      get_relative_prefix = make_relative_prefix;
+#else
+      get_relative_prefix = make_relative_prefix_ignore_links;
+#endif
+    }
 
   /* Set up the default search paths.  If there is no GCC_EXEC_PREFIX,
      see if we can create it from the pathname specified in
@@ -6247,6 +6267,51 @@ compare_files (char *cmpfile[])
   return ret;
 }
 
+/* Set func_reorder_linker_plugin_file_spec and func_reorder_linker_plugin_opt
+   here.  This is the linker plugin to do global function reordering and is
+   enabled with -freorder-functions=*. */
+
+static void
+set_func_reorder_linker_plugin_spec (void)
+{
+  int i;
+  const char *plugin_opt_none = "group=none";
+  const char *plugin_opt_callgraph = "group=callgraph";
+  
+  /* Find the linker plugin that does function ordering.  */
+  func_reorder_linker_plugin_file_spec = find_a_file (&exec_prefixes,
+					    FRPLUGINSONAME, R_OK, false);
+
+  if (!func_reorder_linker_plugin_file_spec)
+      fatal_error ("-freorder-functions=*, but "
+		   FRPLUGINSONAME " file not found");
+
+  func_reorder_linker_plugin_opt = plugin_opt_none;
+
+  /* Set linker plugin options here.  Option ordering is also checked here.
+     -fno-reorder-functions or -freorder-functions should disable any
+     previous -freorder-functions=*. */
+  for (i = 0; (int) i < n_switches; i++)
+    {
+      /* Check for match with "-freorder-functions=callgraph".  */
+      if (func_reorder_linker_plugin_opt != plugin_opt_callgraph
+	  && !strcmp (switches[i].part1, "freorder-functions=callgraph"))
+	{
+	  func_reorder_linker_plugin_opt = plugin_opt_callgraph;
+	  continue;
+	}
+      /* Set option to none if it matches -fno-reorder-functions
+	 or -freorder-functions  */
+      if (func_reorder_linker_plugin_opt != plugin_opt_none
+	  && (!strcmp (switches[i].part1, "fno-reorder-functions")
+	      || !strcmp (switches[i].part1, "freorder-functions")))
+	{
+	  func_reorder_linker_plugin_opt = plugin_opt_none;
+	  continue;
+	}
+    }
+}
+
 extern int main (int, char **);
 
 int
@@ -7021,6 +7086,8 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n"
 #endif
 #endif
 
+          const char *freorder_functions_ = "freorder-functions=";
+
 	  /* We'll use ld if we can't find collect2.  */
 	  if (! strcmp (linker_name_spec, "collect2"))
 	    {
@@ -7050,6 +7117,12 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n"
 	    }
 #endif
 	  lto_gcc_spec = argv[0];
+
+	  /* The function reordering linker plugin will be loaded if the option
+	     -freorder-functions= is present in the command-line.  */ 
+	  if (switch_matches (freorder_functions_,
+		freorder_functions_ + strlen (freorder_functions_), 1))
+	    set_func_reorder_linker_plugin_spec ();
 	}
 
       /* Rebuild the COMPILER_PATH and LIBRARY_PATH environment variables
diff --git a/gcc/gcov-dump.c b/gcc/gcov-dump.c
index 3f3d455..97de629 100644
--- a/gcc/gcov-dump.c
+++ b/gcc/gcov-dump.c
@@ -29,6 +29,7 @@ along with Gcov; see the file COPYING3.  If not see
 #include "gcov-io.c"
 
 static void dump_gcov_file (const char *);
+static int dump_aux_modules (const char *);
 static void print_prefix (const char *, unsigned, gcov_position_t);
 static void print_usage (void);
 static void print_version (void);
@@ -38,6 +39,7 @@ static void tag_arcs (const char *, unsigned, unsigned);
 static void tag_lines (const char *, unsigned, unsigned);
 static void tag_counters (const char *, unsigned, unsigned);
 static void tag_summary (const char *, unsigned, unsigned);
+static void tag_module_info (const char *, unsigned, unsigned);
 extern int main (int, char **);
 
 typedef struct tag_format
@@ -49,6 +51,7 @@ typedef struct tag_format
 
 static int flag_dump_contents = 0;
 static int flag_dump_positions = 0;
+static int flag_dump_aux_modules_only = 0;
 
 static const struct option options[] =
 {
@@ -70,6 +73,7 @@ static const tag_format_t tag_table[] =
   {GCOV_TAG_LINES, "LINES", tag_lines},
   {GCOV_TAG_OBJECT_SUMMARY, "OBJECT_SUMMARY", tag_summary},
   {GCOV_TAG_PROGRAM_SUMMARY, "PROGRAM_SUMMARY", tag_summary},
+  {GCOV_TAG_MODULE_INFO, "MODULE INFO", tag_module_info},
   {0, NULL, NULL}
 };
 
@@ -93,7 +97,7 @@ main (int argc ATTRIBUTE_UNUSED, char **argv)
 
   diagnostic_initialize (global_dc, 0);
 
-  while ((opt = getopt_long (argc, argv, "hlpv", options, NULL)) != -1)
+  while ((opt = getopt_long (argc, argv, "hlpvx", options, NULL)) != -1)
     {
       switch (opt)
 	{
@@ -109,11 +113,21 @@ main (int argc ATTRIBUTE_UNUSED, char **argv)
 	case 'p':
 	  flag_dump_positions = 1;
 	  break;
+	case 'x':
+	  flag_dump_aux_modules_only = 1;
+	  break;
 	default:
 	  fprintf (stderr, "unknown flag `%c'\n", opt);
 	}
     }
 
+  if (flag_dump_aux_modules_only)
+    {
+      while (argv[optind])
+	if (dump_aux_modules (argv[optind++]))
+	  return 1;
+    }
+  else
   while (argv[optind])
     dump_gcov_file (argv[optind++]);
   return 0;
@@ -128,6 +142,7 @@ print_usage (void)
   printf ("  -v, --version        Print version number\n");
   printf ("  -l, --long           Dump record contents too\n");
   printf ("  -p, --positions      Dump record positions\n");
+  printf ("  -x                   Dump names of auxiliary modules only\n");
 }
 
 static void
@@ -151,6 +166,52 @@ print_prefix (const char *filename, unsigned depth, gcov_position_t position)
   printf ("%.*s", (int) depth, prefix);
 }
 
+/* Dump auxiliary module information for gcda file with
+   name FILENAME.  */
+
+static int
+dump_aux_modules (const char *filename)
+{
+  if (!gcov_open (filename, 1))
+    {
+      fprintf (stderr, "%s:cannot open\n", filename);
+      return 1;
+    }
+
+  /* magic */
+  gcov_read_unsigned ();
+  /* version */
+  gcov_read_unsigned ();
+  /* stamp */
+  gcov_read_unsigned ();
+
+  while (1)
+    {
+      gcov_position_t base;
+      unsigned tag, length;
+      int error;
+
+      tag = gcov_read_unsigned ();
+      if (!tag)
+	break;
+      length = gcov_read_unsigned ();
+      base = gcov_position ();
+      if (tag == GCOV_TAG_MODULE_INFO)
+	tag_module_info (filename, tag, length);
+      gcov_sync (base, length);
+      if ((error = gcov_is_error ()))
+	{
+	  printf (error < 0 ? "%s:counter overflow at %lu\n" :
+		  "%s:read error at %lu\n", filename,
+		  (long unsigned) gcov_position ());
+	  return 1;
+	}
+    }
+
+  gcov_close ();
+  return 0;
+}
+
 static void
 dump_gcov_file (const char *filename)
 {
@@ -486,3 +547,38 @@ tag_summary (const char *filename ATTRIBUTE_UNUSED,
         }
     }
 }
+
+static void
+tag_module_info (const char *filename ATTRIBUTE_UNUSED,
+		 unsigned tag ATTRIBUTE_UNUSED, unsigned length)
+{
+  struct gcov_module_info* mod_info;
+
+  mod_info = (struct gcov_module_info *) 
+      alloca ((length + 2) * sizeof (gcov_unsigned_t));
+  gcov_read_module_info (mod_info, length);
+  if (flag_dump_aux_modules_only)
+    {
+      if (!mod_info->is_primary)
+	printf ("%s\n", mod_info->source_filename);
+    }
+  else
+    {
+      const char *primary_suffix =
+               mod_info->is_primary ? "primary" : "auxiliary";
+      const char *export_suffix = "";
+      const char *include_all_suffix = "";
+
+      if (mod_info->is_primary)
+        {
+          if (MODULE_EXPORTED_FLAG (mod_info))
+            export_suffix = ",exported";
+          if (MODULE_INCLUDE_ALL_AUX_FLAG (mod_info))
+            include_all_suffix =",include_all";
+        }
+
+      printf (": %s (ident=%u) [%s%s%s]", mod_info->source_filename,
+              mod_info->ident, primary_suffix, export_suffix,
+              include_all_suffix);
+    }
+}
diff --git a/gcc/gcov-io.c b/gcc/gcov-io.c
index 116cc03..5473d2e 100644
--- a/gcc/gcov-io.c
+++ b/gcc/gcov-io.c
@@ -580,6 +580,56 @@ gcov_read_summary (struct gcov_summary *summary)
     }
 }
 
+#if !IN_LIBGCOV && IN_GCOV != 1
+/* Read LEN words (unsigned type) and construct MOD_INFO.  */
+
+GCOV_LINKAGE void
+gcov_read_module_info (struct gcov_module_info *mod_info,
+                       gcov_unsigned_t len)
+{
+  gcov_unsigned_t src_filename_len, filename_len, i, j, num_strings;
+  mod_info->ident = gcov_read_unsigned ();
+  mod_info->is_primary = gcov_read_unsigned ();
+  mod_info->flags = gcov_read_unsigned ();
+  mod_info->lang  = gcov_read_unsigned ();
+  mod_info->num_quote_paths = gcov_read_unsigned ();
+  mod_info->num_bracket_paths = gcov_read_unsigned ();
+  mod_info->num_cpp_defines = gcov_read_unsigned ();
+  mod_info->num_cpp_includes = gcov_read_unsigned ();
+  mod_info->num_cl_args = gcov_read_unsigned ();
+  len -= 9;
+
+  filename_len = gcov_read_unsigned ();
+  mod_info->da_filename = (char *) xmalloc (filename_len *
+                                            sizeof (gcov_unsigned_t));
+  for (i = 0; i < filename_len; i++)
+    ((gcov_unsigned_t *) mod_info->da_filename)[i] = gcov_read_unsigned ();
+  len -= (filename_len + 1);
+
+  src_filename_len = gcov_read_unsigned ();
+  mod_info->source_filename = (char *) xmalloc (src_filename_len *
+						sizeof (gcov_unsigned_t));
+  for (i = 0; i < src_filename_len; i++)
+    ((gcov_unsigned_t *) mod_info->source_filename)[i] = gcov_read_unsigned ();
+  len -= (src_filename_len + 1);
+
+  num_strings = mod_info->num_quote_paths + mod_info->num_bracket_paths +
+    mod_info->num_cpp_defines + mod_info->num_cpp_includes +
+    mod_info->num_cl_args;
+  for (j = 0; j < num_strings; j++)
+   {
+     gcov_unsigned_t string_len = gcov_read_unsigned ();
+     mod_info->string_array[j] =
+       (char *) xmalloc (string_len * sizeof (gcov_unsigned_t));
+     for (i = 0; i < string_len; i++)
+       ((gcov_unsigned_t *) mod_info->string_array[j])[i] =
+	 gcov_read_unsigned ();
+     len -= (string_len + 1);
+   }
+  gcc_assert (!len);
+}
+#endif
+
 #if !IN_LIBGCOV
 /* Reset to a known position.  BASE should have been obtained from
    gcov_position, LENGTH should be a record length.  */
@@ -612,6 +662,22 @@ gcov_seek (gcov_position_t base)
   fseek (gcov_var.file, base << 2, SEEK_SET);
   gcov_var.start = ftell (gcov_var.file) >> 2;
 }
+
+/* Truncate the gcov file at the current position.  */
+
+GCOV_LINKAGE void
+gcov_truncate (void)
+{
+  long offs;
+  int filenum;
+  gcc_assert (gcov_var.mode < 0);
+  if (gcov_var.offset)
+    gcov_write_block (gcov_var.offset);
+  offs = ftell (gcov_var.file);
+  filenum = fileno (gcov_var.file);
+  if (offs == -1 || filenum == -1 || ftruncate (filenum, offs))
+    gcov_var.error = 1;
+}
 #endif
 
 #if IN_GCOV > 0
diff --git a/gcc/gcov-io.h b/gcc/gcov-io.h
index 98efa76..51d629e 100644
--- a/gcc/gcov-io.h
+++ b/gcc/gcov-io.h
@@ -165,6 +165,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #define GCC_GCOV_IO_H
 
 #if IN_LIBGCOV
+
+#undef FUNC_ID_WIDTH
+#undef FUNC_ID_MASK
 /* About the target */
 
 #if BITS_PER_UNIT == 8
@@ -172,34 +175,64 @@ typedef unsigned gcov_unsigned_t __attribute__ ((mode (SI)));
 typedef unsigned gcov_position_t __attribute__ ((mode (SI)));
 #if LONG_LONG_TYPE_SIZE > 32
 typedef signed gcov_type __attribute__ ((mode (DI)));
+#define FUNC_ID_WIDTH 32
+#define FUNC_ID_MASK ((1ll << FUNC_ID_WIDTH) - 1)
 typedef unsigned gcov_type_unsigned __attribute__ ((mode (DI)));
 #else
 typedef signed gcov_type __attribute__ ((mode (SI)));
+#define FUNC_ID_WIDTH 16
+#define FUNC_ID_MASK ((1 << FUNC_ID_WIDTH) - 1)
 typedef unsigned gcov_type_unsigned __attribute__ ((mode (SI)));
 #endif
-#else
+#else   /* BITS_PER_UNIT != 8  */
 #if BITS_PER_UNIT == 16
 typedef unsigned gcov_unsigned_t __attribute__ ((mode (HI)));
 typedef unsigned gcov_position_t __attribute__ ((mode (HI)));
 #if LONG_LONG_TYPE_SIZE > 32
 typedef signed gcov_type __attribute__ ((mode (SI)));
+#define FUNC_ID_WIDTH 32
+#define FUNC_ID_MASK ((1ll << FUNC_ID_WIDTH) - 1)
 typedef unsigned gcov_type_unsigned __attribute__ ((mode (SI)));
 #else
 typedef signed gcov_type __attribute__ ((mode (HI)));
+#define FUNC_ID_WIDTH 16
+#define FUNC_ID_MASK ((1 << FUNC_ID_WIDTH) - 1)
 typedef unsigned gcov_type_unsigned __attribute__ ((mode (HI)));
 #endif
-#else
+#else  /* BITS_PER_UNIT != 16  */
 typedef unsigned gcov_unsigned_t __attribute__ ((mode (QI)));
 typedef unsigned gcov_position_t __attribute__ ((mode (QI)));
 #if LONG_LONG_TYPE_SIZE > 32
 typedef signed gcov_type __attribute__ ((mode (HI)));
+#define FUNC_ID_WIDTH 32
+#define FUNC_ID_MASK ((1ll << FUNC_ID_WIDTH) - 1)
 typedef unsigned gcov_type_unsigned __attribute__ ((mode (HI)));
 #else
 typedef signed gcov_type __attribute__ ((mode (QI)));
+#define FUNC_ID_WIDTH 16
+#define FUNC_ID_MASK ((1 << FUNC_ID_WIDTH) - 1)
 typedef unsigned gcov_type_unsigned __attribute__ ((mode (QI)));
 #endif
+#endif /* BITS_PER_UNIT == 16  */ 
+
+#endif  /* BITS_PER_UNIT == 8  */
+
+#if LONG_LONG_TYPE_SIZE > 32
+#define GCOV_TYPE_ATOMIC_FETCH_ADD_FN __atomic_fetch_add_8
+#define GCOV_TYPE_ATOMIC_FETCH_ADD BUILT_IN_ATOMIC_FETCH_ADD_8
+#else
+#define GCOV_TYPE_ATOMIC_FETCH_ADD_FN __atomic_fetch_add_4
+#define GCOV_TYPE_ATOMIC_FETCH_ADD BUILT_IN_ATOMIC_FETCH_ADD_4
 #endif
-#endif
+
+#undef EXTRACT_MODULE_ID_FROM_GLOBAL_ID
+#undef EXTRACT_FUNC_ID_FROM_GLOBAL_ID
+#undef GEN_FUNC_GLOBAL_ID
+#define EXTRACT_MODULE_ID_FROM_GLOBAL_ID(gid) \
+                (gcov_unsigned_t)(((gid) >> FUNC_ID_WIDTH) & FUNC_ID_MASK)
+#define EXTRACT_FUNC_ID_FROM_GLOBAL_ID(gid) \
+                (gcov_unsigned_t)((gid) & FUNC_ID_MASK)
+#define GEN_FUNC_GLOBAL_ID(m,f) ((((gcov_type) (m)) << FUNC_ID_WIDTH) | (f))
 
 
 #if defined (TARGET_POSIX_IO)
@@ -213,6 +246,19 @@ typedef unsigned gcov_type_unsigned __attribute__ ((mode (QI)));
 
 typedef unsigned gcov_unsigned_t;
 typedef unsigned gcov_position_t;
+
+#if LONG_LONG_TYPE_SIZE > 32
+#define GCOV_TYPE_ATOMIC_FETCH_ADD_FN __atomic_fetch_add_8
+#define GCOV_TYPE_ATOMIC_FETCH_ADD BUILT_IN_ATOMIC_FETCH_ADD_8
+#else
+#define GCOV_TYPE_ATOMIC_FETCH_ADD_FN __atomic_fetch_add_4
+#define GCOV_TYPE_ATOMIC_FETCH_ADD BUILT_IN_ATOMIC_FETCH_ADD_4
+#endif
+#define PROFILE_GEN_EDGE_ATOMIC (flag_profile_gen_atomic == 1 || \
+                                 flag_profile_gen_atomic == 3)
+#define PROFILE_GEN_VALUE_ATOMIC (flag_profile_gen_atomic == 2 || \
+                                  flag_profile_gen_atomic == 3)
+
 /* gcov_type is typedef'd elsewhere for the compiler */
 #if IN_GCOV
 #define GCOV_LINKAGE static
@@ -221,6 +267,13 @@ typedef unsigned HOST_WIDEST_INT gcov_type_unsigned;
 #if IN_GCOV > 0
 #include <sys/types.h>
 #endif
+
+#define FUNC_ID_WIDTH HOST_BITS_PER_WIDE_INT/2
+#define FUNC_ID_MASK ((1L << FUNC_ID_WIDTH) - 1)
+#define EXTRACT_MODULE_ID_FROM_GLOBAL_ID(gid) (unsigned)(((gid) >> FUNC_ID_WIDTH) & FUNC_ID_MASK)
+#define EXTRACT_FUNC_ID_FROM_GLOBAL_ID(gid) (unsigned)((gid) & FUNC_ID_MASK)
+#define FUNC_GLOBAL_ID(m,f) ((((HOST_WIDE_INT) (m)) << FUNC_ID_WIDTH) | (f)
+
 #else /*!IN_GCOV */
 #define GCOV_TYPE_SIZE (LONG_LONG_TYPE_SIZE > 32 ? 64 : 32)
 #endif
@@ -249,13 +302,17 @@ typedef unsigned HOST_WIDEST_INT gcov_type_unsigned;
 #define gcov_position __gcov_position
 #define gcov_seek __gcov_seek
 #define gcov_rewrite __gcov_rewrite
+#define gcov_truncate __gcov_truncate
 #define gcov_is_error __gcov_is_error
 #define gcov_write_unsigned __gcov_write_unsigned
 #define gcov_write_counter __gcov_write_counter
 #define gcov_write_summary __gcov_write_summary
+#define gcov_write_module_info __gcov_write_module_info
 #define gcov_read_unsigned __gcov_read_unsigned
 #define gcov_read_counter __gcov_read_counter
 #define gcov_read_summary __gcov_read_summary
+#define gcov_read_module_info __gcov_read_module_info
+#define gcov_sort_n_vals __gcov_sort_n_vals
 
 /* Poison these, so they don't accidentally slip in.  */
 #pragma GCC poison gcov_write_string gcov_write_tag gcov_write_length
@@ -319,7 +376,11 @@ typedef unsigned HOST_WIDEST_INT gcov_type_unsigned;
 #define GCOV_TAG_PROGRAM_SUMMARY ((gcov_unsigned_t)0xa3000000)
 #define GCOV_TAG_SUMMARY_LENGTH(NUM)  \
         (1 + GCOV_COUNTERS_SUMMABLE * (10 + 3 * 2) + (NUM) * 5)
-
+#define GCOV_TAG_MODULE_INFO ((gcov_unsigned_t)0xab000000)
+#define GCOV_TAG_AFDO_FILE_NAMES ((gcov_unsigned_t)0xaa000000)
+#define GCOV_TAG_AFDO_FUNCTION ((gcov_unsigned_t)0xac000000)
+#define GCOV_TAG_AFDO_MODULE_GROUPING ((gcov_unsigned_t)0xae000000)
+#define GCOV_TAG_AFDO_WORKING_SET ((gcov_unsigned_t)0xaf000000)
 
 /* Counters that are collected.  */
 #define GCOV_COUNTER_ARCS 	0  /* Arc transitions.  */
@@ -342,9 +403,11 @@ typedef unsigned HOST_WIDEST_INT gcov_type_unsigned;
 				      counter.  */
 #define GCOV_COUNTER_IOR	7  /* IOR of the all values passed to
 				      counter.  */
-#define GCOV_LAST_VALUE_COUNTER 7  /* The last of counters used for value
+#define GCOV_COUNTER_ICALL_TOPNV 8 /* Top N value tracking for indirect calls */
+#define GCOV_LAST_VALUE_COUNTER 8  /* The last of counters used for value
 				      profiling.  */
-#define GCOV_COUNTERS		8
+#define GCOV_COUNTER_DIRECT_CALL 9 /* Direct call counts.  */
+#define GCOV_COUNTERS		10
 
 /* Number of counters used for value profiling.  */
 #define GCOV_N_VALUE_COUNTERS \
@@ -352,8 +415,11 @@ typedef unsigned HOST_WIDEST_INT gcov_type_unsigned;
 
   /* A list of human readable names of the counters */
 #define GCOV_COUNTER_NAMES	{"arcs", "interval", "pow2", "single", \
-      				 "delta", "indirect_call", "average", "ior"}
+				 "delta","indirect_call", "average", "ior", \
+				 "indirect_call_topn", "direct_call"}
 
+#define GCOV_ICALL_TOPN_VAL  2   /* Track two hottest callees */
+#define GCOV_ICALL_TOPN_NCOUNTS  9 /* The number of counter entries per icall callsite */
   /* Names of merge functions for counters.  */
 #define GCOV_MERGE_FUNCTIONS	{"__gcov_merge_add",	\
 				 "__gcov_merge_add",	\
@@ -362,7 +428,9 @@ typedef unsigned HOST_WIDEST_INT gcov_type_unsigned;
 				 "__gcov_merge_delta",  \
 				 "__gcov_merge_single", \
 				 "__gcov_merge_add",	\
-				 "__gcov_merge_ior"}
+				 "__gcov_merge_ior",	\
+				 "__gcov_merge_icall_topn",\
+                                 "__gcov_merge_dc" }
 
 /* Convert a counter index to a tag.  */
 #define GCOV_TAG_FOR_COUNTER(COUNT)				\
@@ -440,6 +508,52 @@ struct gcov_summary
   struct gcov_ctr_summary ctrs[GCOV_COUNTERS_SUMMABLE];
 };
 
+#define GCOV_MODULE_UNKNOWN_LANG  0
+#define GCOV_MODULE_C_LANG    1
+#define GCOV_MODULE_CPP_LANG  2
+#define GCOV_MODULE_FORT_LANG 3
+
+#define GCOV_MODULE_ASM_STMTS (1 << 16)
+#define GCOV_MODULE_LANG_MASK 0xffff
+
+/* Source module info. The data structure is used in
+   both runtime and profile-use phase. Make sure to allocate
+   enough space for the variable length member.  */
+struct gcov_module_info
+{
+  gcov_unsigned_t ident;
+  gcov_unsigned_t is_primary; /* this is overloaded to mean two things:
+				 (1) means FDO/LIPO in instrumented binary.
+				 (2) means IS_PRIMARY in persistent file or
+				     memory copy used in profile-use.  */
+  gcov_unsigned_t flags;      /* bit 0: is_exported,
+                                 bit 1: need to include all the auxiliary 
+                                 modules in use compilation.  */
+  gcov_unsigned_t lang; /* lower 16 bits encode the language, and the upper
+			   16 bits enocde other attributes, such as whether
+			   any assembler is present in the source, etc.  */
+  gcov_unsigned_t ggc_memory; /* memory needed for parsing in kb  */
+  char *da_filename;
+  char *source_filename;
+  gcov_unsigned_t num_quote_paths;
+  gcov_unsigned_t num_bracket_paths;
+  gcov_unsigned_t num_cpp_defines;
+  gcov_unsigned_t num_cpp_includes;
+  gcov_unsigned_t num_cl_args;
+  char *string_array[1];
+};
+
+extern struct gcov_module_info **module_infos;
+extern unsigned primary_module_id;
+#define SET_MODULE_INCLUDE_ALL_AUX(modu) ((modu->flags |= 0x2))
+#define MODULE_INCLUDE_ALL_AUX_FLAG(modu) ((modu->flags & 0x2))
+#define SET_MODULE_EXPORTED(modu) ((modu->flags |= 0x1))
+#define MODULE_EXPORTED_FLAG(modu) ((modu->flags & 0x1))
+#define PRIMARY_MODULE_EXPORTED                                         \
+  (MODULE_EXPORTED_FLAG (module_infos[0])				\
+   && !((module_infos[0]->lang & GCOV_MODULE_ASM_STMTS)			\
+	&& flag_ripa_disallow_asm_modules))
+
 /* Structures embedded in coveraged program.  The structures generated
    by write_profile must match these.  */
 
@@ -462,7 +576,7 @@ struct gcov_fn_info
   const struct gcov_info *key;		/* comdat key */
   gcov_unsigned_t ident;		/* unique ident of function */
   gcov_unsigned_t lineno_checksum;	/* function lineo_checksum */
-  gcov_unsigned_t cfg_checksum;		/* function cfg checksum */
+  gcov_unsigned_t cfg_checksum;	/* function cfg checksum */
   struct gcov_ctr_info ctrs[0];		/* instrumented counters */
 };
 
@@ -473,11 +587,12 @@ typedef void (*gcov_merge_fn) (gcov_type *, gcov_unsigned_t);
 struct gcov_info
 {
   gcov_unsigned_t version;	/* expected version number */
+  struct gcov_module_info *mod_info; /* addtional module info.  */
   struct gcov_info *next;	/* link to next, used by libgcov */
 
   gcov_unsigned_t stamp;	/* uniquifying time stamp */
   const char *filename;		/* output file name */
-
+  gcov_unsigned_t eof_pos;      /* end position of profile data */
   gcov_merge_fn merge[GCOV_COUNTERS];  /* merge functions (null for
 					  unused) */
   
@@ -486,9 +601,19 @@ struct gcov_info
 					          to function information  */
 };
 
+/* Information about a single imported module.  */
+struct dyn_imp_mod
+{
+  const struct gcov_info *imp_mod;
+  double weight;
+};
+
 /* Register a new object file module.  */
 extern void __gcov_init (struct gcov_info *) ATTRIBUTE_HIDDEN;
 
+/* Set sampling rate to RATE.  */
+extern void __gcov_set_sampling_rate (unsigned int rate);
+
 /* Called before fork, to avoid double counting.  */
 extern void __gcov_flush (void) ATTRIBUTE_HIDDEN;
 
@@ -511,13 +636,22 @@ extern void __gcov_merge_delta (gcov_type *, unsigned) ATTRIBUTE_HIDDEN;
 /* The merge function that just ors the counters together.  */
 extern void __gcov_merge_ior (gcov_type *, unsigned) ATTRIBUTE_HIDDEN;
 
+/* The merge function used for direct call counters.  */
+extern void __gcov_merge_dc (gcov_type *, unsigned) ATTRIBUTE_HIDDEN;
+
+/* The merge function used for indirect call counters.  */
+extern void __gcov_merge_icall_topn (gcov_type *, unsigned) ATTRIBUTE_HIDDEN;
+
 /* The profiler functions.  */
 extern void __gcov_interval_profiler (gcov_type *, gcov_type, int, unsigned);
 extern void __gcov_pow2_profiler (gcov_type *, gcov_type);
 extern void __gcov_one_value_profiler (gcov_type *, gcov_type);
 extern void __gcov_indirect_call_profiler (gcov_type *, gcov_type, void *, void *);
+extern void __gcov_indirect_call_topn_profiler (void *, void *, gcov_unsigned_t) ATTRIBUTE_HIDDEN;
+extern void __gcov_direct_call_profiler (void *, void *, gcov_unsigned_t) ATTRIBUTE_HIDDEN;
 extern void __gcov_average_profiler (gcov_type *, gcov_type);
 extern void __gcov_ior_profiler (gcov_type *, gcov_type);
+extern void __gcov_sort_n_vals (gcov_type *value_array, int n);
 
 #ifndef inhibit_libc
 /* The wrappers around some library functions..  */
@@ -586,6 +720,10 @@ static int gcov_is_error (void);
 GCOV_LINKAGE gcov_unsigned_t gcov_read_unsigned (void) ATTRIBUTE_HIDDEN;
 GCOV_LINKAGE gcov_type gcov_read_counter (void) ATTRIBUTE_HIDDEN;
 GCOV_LINKAGE void gcov_read_summary (struct gcov_summary *) ATTRIBUTE_HIDDEN;
+#if !IN_LIBGCOV && IN_GCOV != 1
+GCOV_LINKAGE void gcov_read_module_info (struct gcov_module_info *mod_info,
+					 gcov_unsigned_t len) ATTRIBUTE_HIDDEN;
+#endif
 
 #if IN_LIBGCOV
 /* Available only in libgcov */
@@ -595,8 +733,15 @@ GCOV_LINKAGE void gcov_write_tag_length (gcov_unsigned_t, gcov_unsigned_t)
 GCOV_LINKAGE void gcov_write_summary (gcov_unsigned_t /*tag*/,
 				      const struct gcov_summary *)
     ATTRIBUTE_HIDDEN;
+
+GCOV_LINKAGE void gcov_write_module_infos (struct gcov_info *mod_info)
+    ATTRIBUTE_HIDDEN;
+GCOV_LINKAGE const struct dyn_imp_mod **
+gcov_get_sorted_import_module_array (struct gcov_info *mod_info, unsigned *len)
+    ATTRIBUTE_HIDDEN;
 static void gcov_rewrite (void);
 GCOV_LINKAGE void gcov_seek (gcov_position_t /*position*/) ATTRIBUTE_HIDDEN;
+GCOV_LINKAGE void gcov_truncate (void) ATTRIBUTE_HIDDEN;
 #else
 /* Available outside libgcov */
 GCOV_LINKAGE const char *gcov_read_string (void);
@@ -627,7 +772,6 @@ GCOV_LINKAGE time_t gcov_time (void);
 static inline gcov_position_t
 gcov_position (void)
 {
-  gcc_assert (gcov_var.mode > 0);
   return gcov_var.start + gcov_var.offset;
 }
 
diff --git a/gcc/gcov.c b/gcc/gcov.c
index 7084bd0..6aa48fd 100644
--- a/gcc/gcov.c
+++ b/gcc/gcov.c
@@ -37,6 +37,7 @@ along with Gcov; see the file COPYING3.  If not see
 #include "intl.h"
 #include "diagnostic.h"
 #include "version.h"
+#include "demangle.h"
 
 #include <getopt.h>
 
@@ -168,6 +169,7 @@ typedef struct function_info
 {
   /* Name of function.  */
   char *name;
+  char *demangled_name;
   unsigned ident;
   unsigned lineno_checksum;
   unsigned cfg_checksum;
@@ -325,6 +327,14 @@ static int flag_gcov_file = 1;
 
 static int flag_display_progress = 0;
 
+/* Output *.gcov file in intermediate format used by 'lcov'.  */
+
+static int flag_intermediate_format = 0;
+
+/* Output demangled function names.  */
+
+static int flag_demangled_names = 0;
+
 /* For included files, make the gcov output file name include the name
    of the input source file.  For example, if x.h is included in a.c,
    then the output file name is a.c##x.h.gcov instead of x.h.gcov.  */
@@ -388,6 +398,7 @@ static void executed_summary (unsigned, unsigned);
 static void function_summary (const coverage_t *, const char *);
 static const char *format_gcov (gcov_type, gcov_type, int);
 static void accumulate_line_counts (source_t *);
+static void output_gcov_file(const char *, source_t *);
 static int output_branch_count (FILE *, int, const arc_t *);
 static void output_lines (FILE *, const source_t *);
 static char *make_gcov_file_name (const char *, const char *);
@@ -461,21 +472,23 @@ print_usage (int error_p)
   fnotice (file, "Usage: gcov [OPTION]... SOURCE|OBJ...\n\n");
   fnotice (file, "Print code coverage information.\n\n");
   fnotice (file, "  -h, --help                      Print this help, then exit\n");
-  fnotice (file, "  -v, --version                   Print version number, then exit\n");
   fnotice (file, "  -a, --all-blocks                Show information for every basic block\n");
   fnotice (file, "  -b, --branch-probabilities      Include branch probabilities in output\n");
-  fnotice (file, "  -c, --branch-counts             Given counts of branches taken\n\
+  fnotice (file, "  -c, --branch-counts             Output counts of branches taken\n\
                                     rather than percentages\n");
-  fnotice (file, "  -n, --no-output                 Do not create an output file\n");
+  fnotice (file, "  -d, --display-progress          Display progress information\n");
+  fnotice (file, "  -f, --function-summaries        Output summaries for each function\n");
+  fnotice (file, "  -i, --intermediate-format       Output .gcov file in intermediate text format\n");
   fnotice (file, "  -l, --long-file-names           Use long output file names for included\n\
                                     source files\n");
-  fnotice (file, "  -f, --function-summaries        Output summaries for each function\n");
+  fnotice (file, "  -m, --demangled-names           Output demangled function names\n");
+  fnotice (file, "  -n, --no-output                 Do not create an output file\n");
   fnotice (file, "  -o, --object-directory DIR|FILE Search for object files in DIR or called FILE\n");
-  fnotice (file, "  -s, --source-prefix DIR         Source prefix to elide\n");
-  fnotice (file, "  -r, --relative-only             Only show data for relative sources\n");
   fnotice (file, "  -p, --preserve-paths            Preserve all pathname components\n");
+  fnotice (file, "  -r, --relative-only             Only show data for relative sources\n");
+  fnotice (file, "  -s, --source-prefix DIR         Source prefix to elide\n");
   fnotice (file, "  -u, --unconditional-branches    Show unconditional branch counts too\n");
-  fnotice (file, "  -d, --display-progress          Display progress information\n");
+  fnotice (file, "  -v, --version                   Print version number, then exit\n");
   fnotice (file, "\nFor bug reporting instructions, please see:\n%s.\n",
 	   bug_report_url);
   exit (status);
@@ -503,9 +516,11 @@ static const struct option options[] =
   { "all-blocks",           no_argument,       NULL, 'a' },
   { "branch-probabilities", no_argument,       NULL, 'b' },
   { "branch-counts",        no_argument,       NULL, 'c' },
+  { "intermediate-format",  no_argument,       NULL, 'i' },
   { "no-output",            no_argument,       NULL, 'n' },
   { "long-file-names",      no_argument,       NULL, 'l' },
   { "function-summaries",   no_argument,       NULL, 'f' },
+  { "demangled-names",      no_argument,       NULL, 'm' },
   { "preserve-paths",       no_argument,       NULL, 'p' },
   { "relative-only",        no_argument,       NULL, 'r' },
   { "object-directory",     required_argument, NULL, 'o' },
@@ -523,7 +538,8 @@ process_args (int argc, char **argv)
 {
   int opt;
 
-  while ((opt = getopt_long (argc, argv, "abcdfhlno:s:pruv", options, NULL)) != -1)
+  while ((opt = getopt_long (argc, argv, "abcdfhilmno:s:pruv", options, NULL)) !=
+         -1)
     {
       switch (opt)
 	{
@@ -545,6 +561,9 @@ process_args (int argc, char **argv)
 	case 'l':
 	  flag_long_names = 1;
 	  break;
+	case 'm':
+	  flag_demangled_names = 1;
+	  break;
 	case 'n':
 	  flag_gcov_file = 0;
 	  break;
@@ -564,6 +583,10 @@ process_args (int argc, char **argv)
 	case 'u':
 	  flag_unconditional = 1;
 	  break;
+	case 'i':
+          flag_intermediate_format = 1;
+          flag_gcov_file = 1;
+          break;
         case 'd':
           flag_display_progress = 1;
           break;
@@ -579,6 +602,110 @@ process_args (int argc, char **argv)
   return optind;
 }
 
+/* Get the name of the gcov file.  The return value must be free'd.
+
+   It appends the '.gcov' extension to the *basename* of the file.
+   The resulting file name will be in PWD.
+
+   e.g.,
+   input: foo.da,       output: foo.da.gcov
+   input: a/b/foo.cc,   output: foo.cc.gcov  */
+
+static char *
+get_gcov_intermediate_filename (const char *file_name)
+{
+  const char *gcov = ".gcov";
+  char *result;
+  const char *cptr;
+
+  /* Find the 'basename'.  */
+  cptr = lbasename (file_name);
+
+  result = XNEWVEC(char, strlen (cptr) + strlen (gcov) + 1);
+  sprintf (result, "%s%s", cptr, gcov);
+
+  return result;
+}
+
+/* Output the result in intermediate format used by 'lcov'.
+
+The intermediate format contains a single file named 'foo.cc.gcov',
+with no source code included. A sample output is
+
+file:foo.cc
+function:5,1,_Z3foov
+function:13,1,main
+function:19,1,_GLOBAL__sub_I__Z3foov
+function:19,1,_Z41__static_initialization_and_destruction_0ii
+lcount:5,1
+lcount:7,9
+lcount:9,8
+lcount:11,1
+file:/.../iostream
+lcount:74,1
+file:/.../basic_ios.h
+file:/.../ostream
+file:/.../ios_base.h
+function:157,0,_ZStorSt12_Ios_IostateS_
+lcount:157,0
+file:/.../char_traits.h
+function:258,0,_ZNSt11char_traitsIcE6lengthEPKc
+lcount:258,0
+...
+
+The default gcov outputs multiple files: 'foo.cc.gcov',
+'iostream.gcov', 'ios_base.h.gcov', etc. with source code
+included. Instead the intermediate format here outputs only a single
+file 'foo.cc.gcov' similar to the above example. */
+
+static void
+output_intermediate_file (FILE *gcov_file, source_t *src)
+{
+  unsigned line_num;    /* current line number.  */
+  const line_t *line;   /* current line info ptr.  */
+  function_t *fn;       /* current function info ptr. */
+
+  fprintf (gcov_file, "file:%s\n", src->name);    /* source file name */
+
+  for (fn = src->functions; fn; fn = fn->line_next)
+    {
+      /* function:<name>,<line_number>,<execution_count> */
+      fprintf (gcov_file, "function:%d,%s,%s\n", fn->line,
+               format_gcov (fn->blocks[0].count, 0, -1),
+               flag_demangled_names ? fn->demangled_name : fn->name);
+    }
+
+  for (line_num = 1, line = &src->lines[line_num];
+       line_num < src->num_lines;
+       line_num++, line++)
+    {
+      arc_t *arc;
+      if (line->exists)
+        fprintf (gcov_file, "lcount:%u,%s\n", line_num,
+                 format_gcov (line->count, 0, -1));
+      if (flag_branches)
+        for (arc = line->u.branches; arc; arc = arc->line_next)
+          {
+            if (!arc->is_unconditional && !arc->is_call_non_return)
+              {
+                const char *branch_type;
+                /* branch:<line_num>,<branch_coverage_type>
+                   branch_coverage_type
+                     : notexec (Branch not executed)
+                     : taken (Branch executed and taken)
+                     : nottaken (Branch executed, but not taken)
+                */
+                if (arc->src->count)
+                  branch_type = (arc->count > 0) ? "taken" : "nottaken";
+                else
+                  branch_type = "notexec";
+                fprintf(gcov_file, "branch:%d,%s\n", line_num, branch_type);
+              }
+          }
+    }
+}
+
+
 /* Process a single input file.  */
 
 static void
@@ -655,11 +782,40 @@ process_file (const char *file_name)
 }
 
 static void
+output_gcov_file(const char *file_name, source_t *src)
+{
+  char *gcov_file_name = make_gcov_file_name (file_name, src->coverage.name);
+
+  if (src->coverage.lines)
+    {
+      FILE *gcov_file = fopen (gcov_file_name, "w");
+      if (gcov_file)
+        {
+          fnotice (stdout, "Creating '%s'\n", gcov_file_name);
+          output_lines (gcov_file, src);
+          if (ferror (gcov_file))
+            fnotice (stderr, "Error writing output file '%s'\n", gcov_file_name);
+          fclose (gcov_file);
+        }
+      else
+        fnotice (stderr, "Could not open output file '%s'\n", gcov_file_name);
+    }
+  else
+    {
+      unlink (gcov_file_name);
+      fnotice (stdout, "Removing '%s'\n", gcov_file_name);
+    }
+  free (gcov_file_name);
+}
+
+static void
 generate_results (const char *file_name)
 {
   unsigned ix;
   source_t *src;
   function_t *fn;
+  FILE *gcov_intermediate_file = NULL;
+  char *gcov_intermediate_filename = NULL;
 
   for (ix = n_sources, src = sources; ix--; src++)
     if (src->num_lines)
@@ -670,7 +826,7 @@ generate_results (const char *file_name)
       coverage_t coverage;
 
       memset (&coverage, 0, sizeof (coverage));
-      coverage.name = fn->name;
+      coverage.name = flag_demangled_names ? fn->demangled_name : fn->name;
       add_line_counts (flag_function_summary ? &coverage : NULL, fn);
       if (flag_function_summary)
 	{
@@ -688,7 +844,21 @@ generate_results (const char *file_name)
       else
 	file_name = canonicalize_name (file_name);
     }
-  
+
+  if (flag_gcov_file && flag_intermediate_format)
+    {
+      /* Open the intermediate file.  */
+      gcov_intermediate_filename =
+        get_gcov_intermediate_filename (file_name);
+      gcov_intermediate_file = fopen (gcov_intermediate_filename, "w");
+      if (!gcov_intermediate_file)
+        {
+          fnotice (stderr, "Cannot open intermediate output file %s\n",
+                   gcov_intermediate_filename);
+          return;
+        }
+    }
+
   for (ix = n_sources, src = sources; ix--; src++)
     {
       if (flag_relative_only)
@@ -711,34 +881,21 @@ generate_results (const char *file_name)
       total_executed += src->coverage.lines_executed;
       if (flag_gcov_file)
 	{
-	  char *gcov_file_name
-	    = make_gcov_file_name (file_name, src->coverage.name);
-
-	  if (src->coverage.lines)
-	    {
-	      FILE *gcov_file = fopen (gcov_file_name, "w");
+          if (flag_intermediate_format)
+            /* Output the intermediate format without requiring source
+               files.  This outputs a section to a *single* file.  */
+            output_intermediate_file (gcov_intermediate_file, src);
+          else
+            output_gcov_file (file_name, src);
+          fnotice (stdout, "\n");
+        }
+    }
 
-	      if (gcov_file)
-		{
-		  fnotice (stdout, "Creating '%s'\n", gcov_file_name);
-		  output_lines (gcov_file, src);
-		  if (ferror (gcov_file))
-		    fnotice (stderr, "Error writing output file '%s'\n",
-			     gcov_file_name);
-		  fclose (gcov_file);
-		}
-	      else
-		fnotice (stderr, "Could not open output file '%s'\n",
-			 gcov_file_name);
-	    }
-	  else
-	    {
-	      unlink (gcov_file_name);
-	      fnotice (stdout, "Removing '%s'\n", gcov_file_name);
-	    }
-	  free (gcov_file_name);
-	}
-      fnotice (stdout, "\n");
+  if (flag_gcov_file && flag_intermediate_format)
+    {
+      /* Now we've finished writing the intermediate file.  */
+      fclose (gcov_intermediate_file);
+      XDELETEVEC (gcov_intermediate_filename);
     }
 
   if (!file_name)
@@ -765,6 +922,9 @@ release_function (function_t *fn)
     }
   free (fn->blocks);
   free (fn->counts);
+  if (flag_demangled_names && fn->demangled_name != fn->name)
+    free (fn->demangled_name);
+  free (fn->name);
 }
 
 /* Release all memory used.  */
@@ -1050,6 +1210,12 @@ read_graph_file (void)
 
 	  fn = XCNEW (function_t);
 	  fn->name = function_name;
+          if (flag_demangled_names)
+            {
+              fn->demangled_name = cplus_demangle (fn->name, DMGL_PARAMS);
+              if (!fn->demangled_name)
+                fn->demangled_name = fn->name;
+            }
 	  fn->ident = ident;
 	  fn->lineno_checksum = lineno_checksum;
 	  fn->cfg_checksum = cfg_checksum;
@@ -2277,7 +2443,8 @@ output_lines (FILE *gcov_file, const source_t *src)
 	    if (arc->fake)
 	      return_count -= arc->count;
 
-	  fprintf (gcov_file, "function %s", fn->name);
+	  fprintf (gcov_file, "function %s", flag_demangled_names ?
+                   fn->demangled_name : fn->name);
 	  fprintf (gcov_file, " called %s",
 		   format_gcov (called_count, 0, -1));
 	  fprintf (gcov_file, " returned %s",
diff --git a/gcc/ggc-page.c b/gcc/ggc-page.c
index 5b18468..f2b148d 100644
--- a/gcc/ggc-page.c
+++ b/gcc/ggc-page.c
@@ -2496,3 +2496,18 @@ ggc_pch_read (FILE *f, void *addr)
   /* Update the statistics.  */
   G.allocated = G.allocated_last_gc = offs - (char *)addr;
 }
+
+struct alloc_zone
+{
+  int dummy;
+};
+
+struct alloc_zone rtl_zone;
+struct alloc_zone tree_zone;
+struct alloc_zone tree_id_zone;
+
+size_t
+ggc_total_allocated (void)
+{
+  return G.bytes_mapped;
+}
diff --git a/gcc/ggc.h b/gcc/ggc.h
index b31bc80..bd73fcb 100644
--- a/gcc/ggc.h
+++ b/gcc/ggc.h
@@ -249,6 +249,9 @@ extern void init_ggc_heuristics (void);
   ggc_alloc_rtvec_def (sizeof (struct rtvec_def)		\
 		       + ((NELT) - 1) * sizeof (rtx))		\
 
+
+extern size_t ggc_total_allocated (void);
+
 /* Memory statistics passing versions of some allocators.  Too few of them to
    make gengtype produce them, so just define the needed ones here.  */
 static inline struct rtx_def *
diff --git a/gcc/gimple-fold.c b/gcc/gimple-fold.c
index b9211a9..06edced 100644
--- a/gcc/gimple-fold.c
+++ b/gcc/gimple-fold.c
@@ -178,7 +178,7 @@ canonicalize_constructor_val (tree cval, tree from_decl)
 	  /* Make sure we create a cgraph node for functions we'll reference.
 	     They can be non-existent if the reference comes from an entry
 	     of an external vtable for example.  */
-	  cgraph_get_create_node (base);
+	  cgraph_get_create_real_symbol_node (base);
 	}
       /* Fixup types in global initializers.  */
       if (TREE_TYPE (TREE_TYPE (cval)) != TREE_TYPE (TREE_OPERAND (cval, 0)))
diff --git a/gcc/gimple-low.c b/gcc/gimple-low.c
index b06d194..64cc031 100644
--- a/gcc/gimple-low.c
+++ b/gcc/gimple-low.c
@@ -204,7 +204,7 @@ struct gimple_opt_pass pass_lower_cf =
    return false.  */
 
 static bool
-gimple_check_call_args (gimple stmt, tree fndecl)
+gimple_check_call_args (gimple stmt, tree fndecl, bool args_count_match)
 {
   tree parms, p;
   unsigned int i, nargs;
@@ -243,6 +243,8 @@ gimple_check_call_args (gimple stmt, tree fndecl)
 		  && !fold_convertible_p (DECL_ARG_TYPE (p), arg)))
             return false;
 	}
+      if (args_count_match && p)
+	return false;
     }
   else if (parms)
     {
@@ -271,11 +273,13 @@ gimple_check_call_args (gimple stmt, tree fndecl)
 }
 
 /* Verify if the type of the argument and lhs of CALL_STMT matches
-   that of the function declaration CALLEE.
+   that of the function declaration CALLEE. If ARGS_COUNT_MATCH is
+   true, the arg count needs to be the same.
    If we cannot verify this or there is a mismatch, return false.  */
 
 bool
-gimple_check_call_matching_types (gimple call_stmt, tree callee)
+gimple_check_call_matching_types (gimple call_stmt, tree callee,
+				  bool args_count_match)
 {
   tree lhs;
 
@@ -285,7 +289,7 @@ gimple_check_call_matching_types (gimple call_stmt, tree callee)
        && !useless_type_conversion_p (TREE_TYPE (DECL_RESULT (callee)),
                                       TREE_TYPE (lhs))
        && !fold_convertible_p (TREE_TYPE (DECL_RESULT (callee)), lhs))
-      || !gimple_check_call_args (call_stmt, callee))
+      || !gimple_check_call_args (call_stmt, callee, args_count_match))
     return false;
   return true;
 }
diff --git a/gcc/gimple-pretty-print.c b/gcc/gimple-pretty-print.c
index 8c24a57..2a83751 100644
--- a/gcc/gimple-pretty-print.c
+++ b/gcc/gimple-pretty-print.c
@@ -1859,7 +1859,9 @@ pp_gimple_stmt_1 (pretty_printer *buffer, gimple gs, int spc, int flags)
 
   if ((flags & TDF_LINENO) && gimple_has_location (gs))
     {
-      expanded_location xloc = expand_location (gimple_location (gs));
+      location_t loc = gimple_location (gs);
+      expanded_location xloc = expand_location (loc);
+      int discriminator = get_discriminator_from_locus (loc);
       pp_character (buffer, '[');
       if (xloc.file)
 	{
@@ -1869,6 +1871,11 @@ pp_gimple_stmt_1 (pretty_printer *buffer, gimple gs, int spc, int flags)
       pp_decimal_int (buffer, xloc.line);
       pp_string (buffer, ":");
       pp_decimal_int (buffer, xloc.column);
+      if (discriminator)
+	{
+	  pp_string (buffer, " discrim ");
+	  pp_decimal_int (buffer, discriminator);
+	}
       pp_string (buffer, "] ");
     }
 
@@ -2079,8 +2086,6 @@ dump_gimple_bb_header (FILE *outf, basic_block bb, int indent, int flags)
 			 indent, "", get_lineno (gsi_stmt (gsi)));
 		break;
 	      }
-	  if (bb->discriminator)
-	    fprintf (outf, ", discriminator %i", bb->discriminator);
 	  fputc ('\n', outf);
 	}
     }
diff --git a/gcc/gimplify.c b/gcc/gimplify.c
index 9416963..05324de 100644
--- a/gcc/gimplify.c
+++ b/gcc/gimplify.c
@@ -5218,19 +5218,29 @@ gimplify_addr_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)
 
       mark_addressable (TREE_OPERAND (expr, 0));
 
-      /* The FEs may end up building ADDR_EXPRs early on a decl with
-	 an incomplete type.  Re-build ADDR_EXPRs in canonical form
-	 here.  */
-      if (!types_compatible_p (TREE_TYPE (op0), TREE_TYPE (TREE_TYPE (expr))))
-	*expr_p = build_fold_addr_expr (op0);
+      /* Fix to PR/41163 (r151122) broke LIPO. Calls to builtin functions
+         were 'canonicized' in profile-use pass, but not in profile-gen. */
+      if (!flag_dyn_ipa)
+        {
+          /* The FEs may end up building ADDR_EXPRs early on a decl with
+             an incomplete type.  Re-build ADDR_EXPRs in canonical form
+             here.  */
+          if (!types_compatible_p (TREE_TYPE (op0), TREE_TYPE (TREE_TYPE (expr))))
+            *expr_p = build_fold_addr_expr (op0);
+        }
 
       /* Make sure TREE_CONSTANT and TREE_SIDE_EFFECTS are set properly.  */
       recompute_tree_invariant_for_addr_expr (*expr_p);
 
-      /* If we re-built the ADDR_EXPR add a conversion to the original type
-         if required.  */
-      if (!useless_type_conversion_p (TREE_TYPE (expr), TREE_TYPE (*expr_p)))
-	*expr_p = fold_convert (TREE_TYPE (expr), *expr_p);
+      /* Fix to PR/41163 (r151122) broke LIPO. Calls to builtin functions
+         were 'canonicized' in profile-use pass, but not in profile-gen. */
+      if (!flag_dyn_ipa)
+        {
+          /* If we re-built the ADDR_EXPR add a conversion to the original type
+             if required.  */
+          if (!useless_type_conversion_p (TREE_TYPE (expr), TREE_TYPE (*expr_p)))
+            *expr_p = fold_convert (TREE_TYPE (expr), *expr_p);
+        }
 
       break;
     }
diff --git a/gcc/go/gofrontend/expressions.cc b/gcc/go/gofrontend/expressions.cc
index 2b60d90..28eab4f 100644
--- a/gcc/go/gofrontend/expressions.cc
+++ b/gcc/go/gofrontend/expressions.cc
@@ -1251,6 +1251,24 @@ Func_expression::do_traverse(Traverse* traverse)
 	  : Expression::traverse(&this->closure_, traverse));
 }
 
+// Lower a function reference.  If this reference is not called
+// directly, make sure there is a function descriptor.
+
+Expression*
+Func_expression::do_lower(Gogo* gogo, Named_object*, Statement_inserter*, int)
+{
+  // Make sure that the descriptor exists.  FIXME: If the function is
+  // only ever called, and is never referenced otherwise, then we
+  // don't need the descriptor.  We could do that with another pass
+  // over the tree.
+  if (this->closure_ == NULL
+      && this->function_->is_function()
+      && !this->function_->func_value()->is_method())
+    this->function_->func_value()->descriptor(gogo, this->function_);
+
+  return this;
+}
+
 // Return the type of a function expression.
 
 Type*
diff --git a/gcc/go/gofrontend/expressions.h b/gcc/go/gofrontend/expressions.h
index 67a4bb9..1fe4060 100644
--- a/gcc/go/gofrontend/expressions.h
+++ b/gcc/go/gofrontend/expressions.h
@@ -1526,6 +1526,9 @@ class Func_expression : public Expression
   int
   do_traverse(Traverse*);
 
+  Expression*
+  do_lower(Gogo*, Named_object*, Statement_inserter*, int);
+
   Type*
   do_type();
 
diff --git a/gcc/go/gofrontend/gogo.cc b/gcc/go/gofrontend/gogo.cc
index 6ae72b6..3182d63 100644
--- a/gcc/go/gofrontend/gogo.cc
+++ b/gcc/go/gofrontend/gogo.cc
@@ -1617,6 +1617,14 @@ Lower_parse_tree::function(Named_object* no)
 {
   no->func_value()->set_closure_type();
 
+  // Make sure that every externally visible function has a
+  // descriptor, so that packages that import this one can refer to
+  // it.
+  if (!Gogo::is_hidden_name(no->name())
+      && !no->func_value()->is_method()
+      && !no->func_value()->is_descriptor_wrapper())
+    no->func_value()->descriptor(this->gogo_, no);
+
   go_assert(this->function_ == NULL);
   this->function_ = no;
   int t = no->func_value()->traverse(this);
@@ -1704,6 +1712,28 @@ Lower_parse_tree::expression(Expression** pexpr)
 void
 Gogo::lower_parse_tree()
 {
+  // Create a function descriptor for any function that is declared in
+  // this package.  This is so that we have a descriptor for functions
+  // written in assembly.  Gather the descriptors first so that we
+  // don't add declarations while looping over them.
+  std::vector<Named_object*> fndecls;
+  Bindings* b = this->package_->bindings();
+  for (Bindings::const_declarations_iterator p = b->begin_declarations();
+       p != b->end_declarations();
+       ++p)
+    {
+      Named_object* no = p->second;
+      if (no->is_function_declaration()
+	  && !no->func_declaration_value()->type()->is_method()
+	  && !Linemap::is_predeclared_location(no->location()))
+	fndecls.push_back(no);
+    }
+  for (std::vector<Named_object*>::const_iterator p = fndecls.begin();
+       p != fndecls.end();
+       ++p)
+    (*p)->func_declaration_value()->descriptor(this, *p);
+  fndecls.clear();
+
   Lower_parse_tree lower_parse_tree(this, NULL);
   this->traverse(&lower_parse_tree);
 }
diff --git a/gcc/graph.c b/gcc/graph.c
index 5183730..91ce293 100644
--- a/gcc/graph.c
+++ b/gcc/graph.c
@@ -155,11 +155,12 @@ draw_cfg_node_succ_edges (pretty_printer *pp, int funcdef_no, basic_block bb)
 
       pp_printf (pp,
 		 "\tfn_%d_basic_block_%d:s -> fn_%d_basic_block_%d:n "
-		 "[style=%s,color=%s,weight=%d,constraint=%s];\n",
+		 "[style=%s,color=%s,weight=%d,constraint=%s, label=\"[%i%%]\"];\n",
 		 funcdef_no, e->src->index,
 		 funcdef_no, e->dest->index,
 		 style, color, weight,
-		 (e->flags & (EDGE_FAKE | EDGE_DFS_BACK)) ? "false" : "true");
+		 (e->flags & (EDGE_FAKE | EDGE_DFS_BACK)) ? "false" : "true",
+		 e->probability * 100 / REG_BR_PROB_BASE);
     }
   pp_flush (pp);
 }
diff --git a/gcc/incpath.c b/gcc/incpath.c
index 018da98..eb65f01 100644
--- a/gcc/incpath.c
+++ b/gcc/incpath.c
@@ -453,6 +453,28 @@ add_path (char *path, int chain, int cxx_aware, bool user_supplied_p)
   add_cpp_dir_path (p, chain);
 }
 
+/* Return the bracket and quote include search paths
+   in *BRACKETS and *QUOTES respectively.  */
+
+void
+get_include_chains (cpp_dir **quotes, cpp_dir **brackets)
+{
+  *quotes = heads[QUOTE];
+  *brackets = heads[BRACKET];
+}
+
+/* Make HEAD and TAIL pointers to include paths resynchronized
+   after appending new paths.  */
+
+void
+clear_include_chains (void)
+{
+  heads[QUOTE] = tails[QUOTE] = NULL;
+  heads[BRACKET] = tails[BRACKET] = NULL;
+  heads[SYSTEM] = tails[SYSTEM] = NULL;
+  heads[AFTER] = tails[AFTER] = NULL;
+}
+
 /* Exported function to handle include chain merging, duplicate
    removal, and registration with cpplib.  */
 void
@@ -514,4 +536,3 @@ static void hook_void_charptr_charptr_int (const char *sysroot ATTRIBUTE_UNUSED,
 #endif
 
 struct target_c_incpath_s target_c_incpath = { TARGET_EXTRA_PRE_INCLUDES, TARGET_EXTRA_INCLUDES };
-
diff --git a/gcc/incpath.h b/gcc/incpath.h
index bac0d7f..05138c8 100644
--- a/gcc/incpath.h
+++ b/gcc/incpath.h
@@ -21,6 +21,8 @@ extern void register_include_chains (cpp_reader *, const char *,
 				     const char *, const char *,
 				     int, int, int);
 extern void add_cpp_dir_path (struct cpp_dir *, int);
+extern void get_include_chains (cpp_dir **quotes, cpp_dir **brackets);
+extern void clear_include_chains (void);
 extern struct cpp_dir *get_added_cpp_dirs (int);
 
 struct target_c_incpath_s {
diff --git a/gcc/input.c b/gcc/input.c
index a141a92..dab2ab9 100644
--- a/gcc/input.c
+++ b/gcc/input.c
@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "coretypes.h"
 #include "intl.h"
 #include "input.h"
+#include "vec.h"
 
 /* Current position in real source file.  */
 
@@ -29,6 +30,16 @@ location_t input_location;
 
 struct line_maps *line_table;
 
+static vec<location_t> discriminator_location_locations;
+static vec<int> discriminator_location_discriminators;
+static location_t next_discriminator_location = UNKNOWN_LOCATION;
+static location_t min_discriminator_location = UNKNOWN_LOCATION;
+
+/* Expand the source location LOC into a human readable location.  If
+   LOC resolves to a builtin location, the file name of the readable
+   location is set to the string "<built-in>".  */
+
+
 /* Expand the source location LOC into a human readable location.  If
    LOC resolves to a builtin location, the file name of the readable
    location is set to the string "<built-in>". If EXPANSION_POINT_P is
@@ -58,6 +69,13 @@ expand_location_1 (source_location loc,
       loc = LOCATION_LOCUS (loc);
     }
 
+  /* If LOC describes a location with a discriminator, extract the
+     discriminator and map it to the real location.  */
+  if (min_discriminator_location != UNKNOWN_LOCATION
+      && loc >= min_discriminator_location
+      && loc < next_discriminator_location)
+    loc = map_discriminator_location (loc);
+
   memset (&xloc, 0, sizeof (xloc));
 
   if (loc >= RESERVED_LOCATION_COUNT)
@@ -278,3 +296,84 @@ dump_line_table_statistics (void)
            STAT_LABEL (total_used_map_size));
   fprintf (stderr, "\n");
 }
+
+/* Associate the DISCRIMINATOR with LOCUS, and return a new locus.
+   We associate discriminators with a locus by allocating location_t
+   values beyond those assigned by libcpp.  Each new value is mapped
+   directly to a real location_t value, and separately to the
+   discriminator.  */
+
+location_t
+location_with_discriminator (location_t locus, int discriminator)
+{
+  tree block = LOCATION_BLOCK (locus);
+  location_t ret;
+  int i;
+  locus = map_discriminator_location (locus);
+
+  if (locus == UNKNOWN_LOCATION)
+    return block ? COMBINE_LOCATION_DATA (line_table, locus, block)
+		 : locus;
+
+  if (min_discriminator_location == UNKNOWN_LOCATION)
+    {
+      min_discriminator_location = line_table->highest_location + 1;
+      next_discriminator_location = min_discriminator_location;
+    }
+
+  /* Traverse the last few discriminator_locations to see if we can reuse
+     the entry.  */
+  for (i = next_discriminator_location - min_discriminator_location - 1;
+       (i >= 0 && LOCATION_LINE (discriminator_location_locations[i]) ==
+				 LOCATION_LINE (locus)
+        && discriminator_location_discriminators[i] == discriminator);
+       i--)
+    if (discriminator_location_locations[i] == locus)
+      return (block
+	  ? COMBINE_LOCATION_DATA (line_table, min_discriminator_location + i,
+				   block)
+	  : min_discriminator_location + i);
+
+  discriminator_location_locations.safe_push(locus);
+  discriminator_location_discriminators.safe_push(discriminator);
+
+  ret = (block
+      ? COMBINE_LOCATION_DATA (line_table, next_discriminator_location, block)
+      : next_discriminator_location);
+
+  next_discriminator_location++;
+  return ret;
+}
+
+/* Return TRUE if LOCUS represents a location with a discriminator.  */
+
+bool
+has_discriminator (location_t locus)
+{
+  locus = LOCATION_LOCUS (locus);
+  return (min_discriminator_location != UNKNOWN_LOCATION
+	  && locus >= min_discriminator_location
+	  && locus < next_discriminator_location);
+}
+
+/* Return the real location_t value for LOCUS.  */
+
+location_t
+map_discriminator_location (location_t locus)
+{
+  locus = LOCATION_LOCUS (locus);
+  if (! has_discriminator (locus))
+    return locus;
+  return (location_t) discriminator_location_locations[locus - min_discriminator_location];
+}
+
+/* Return the discriminator for LOCUS.  */
+
+int
+get_discriminator_from_locus (location_t locus)
+{
+  locus = LOCATION_LOCUS (locus);
+  if (! has_discriminator (locus))
+    return 0;
+  return discriminator_location_discriminators[locus - min_discriminator_location];
+}
diff --git a/gcc/input.h b/gcc/input.h
index 56f6de0..e28cc74 100644
--- a/gcc/input.h
+++ b/gcc/input.h
@@ -47,6 +47,11 @@ typedef source_location location_t;
 
 extern location_t input_location;
 
+extern location_t location_with_discriminator (location_t, int);
+extern bool has_discriminator (location_t);
+extern location_t map_discriminator_location (location_t);
+extern int get_discriminator_from_locus (location_t);
+
 #define LOCATION_FILE(LOC) ((expand_location (LOC)).file)
 #define LOCATION_LINE(LOC) ((expand_location (LOC)).line)
 #define LOCATION_COLUMN(LOC)((expand_location (LOC)).column)
@@ -59,7 +64,8 @@ extern location_t input_location;
 #define input_line LOCATION_LINE (input_location)
 #define input_filename LOCATION_FILE (input_location)
 #define in_system_header_at(LOC) \
-  ((linemap_location_in_system_header_p (line_table, LOC)))
+  ((linemap_location_in_system_header_p (line_table, \
+					 map_discriminator_location (LOC))))
 #define in_system_header (in_system_header_at (input_location))
 
 void dump_line_table_statistics (void);
diff --git a/gcc/ipa-cp.c b/gcc/ipa-cp.c
index 7ea66f8..8763c9f 100644
--- a/gcc/ipa-cp.c
+++ b/gcc/ipa-cp.c
@@ -115,8 +115,10 @@ along with GCC; see the file COPYING3.  If not see
 #include "tree-pretty-print.h"
 #include "tree-inline.h"
 #include "params.h"
+#include "dbgcnt.h"
 #include "ipa-inline.h"
 #include "ipa-utils.h"
+#include "l-ipo.h"
 
 struct ipcp_value;
 
@@ -1535,6 +1537,8 @@ ipa_get_indirect_edge_target (struct cgraph_edge *ie,
 	  TREE_CODE (t) == ADDR_EXPR
 	  && TREE_CODE (TREE_OPERAND (t, 0)) == FUNCTION_DECL)
 	return TREE_OPERAND (t, 0);
+      else if (L_IPO_COMP_MODE && t && TREE_CODE (t) == FUNCTION_DECL)
+        return t;
       else
 	return NULL_TREE;
     }
diff --git a/gcc/ipa-inline-analysis.c b/gcc/ipa-inline-analysis.c
index 5343933..f4cb7a8 100644
--- a/gcc/ipa-inline-analysis.c
+++ b/gcc/ipa-inline-analysis.c
@@ -977,7 +977,6 @@ reset_inline_summary (struct cgraph_node *node)
   info->self_size = info->self_time = 0;
   info->estimated_stack_size = 0;
   info->estimated_self_stack_size = 0;
-  info->stack_frame_offset = 0;
   info->size = 0;
   info->time = 0;
   info->growth = 0;
@@ -1320,10 +1319,9 @@ dump_inline_edge_summary (FILE *f, int indent, struct cgraph_node *node,
 	  }
       if (!edge->inline_failed)
 	{
-	  fprintf (f, "%*sStack frame offset %i, callee self size %i,"
+	  fprintf (f, "%*sCallee self size %i,"
 		   " callee size %i\n",
 		   indent + 2, "",
-		   (int) inline_summary (callee)->stack_frame_offset,
 		   (int) inline_summary (callee)->estimated_self_stack_size,
 		   (int) inline_summary (callee)->estimated_stack_size);
 	  dump_inline_edge_summary (f, indent + 2, callee, info);
@@ -2266,7 +2264,8 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)
 {
   gcov_type time = 0;
   /* Estimate static overhead for function prologue/epilogue and alignment. */
-  int size = 2;
+  int overhead = PARAM_VALUE (PARAM_INLINE_FUNCTION_OVERHEAD_SIZE);
+  int size = overhead;
   /* Benefits are scaled by probability of elimination that is in range
      <0,2>.  */
   basic_block bb;
@@ -2307,7 +2306,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)
   account_size_time (info, 0, 0, &bb_predicate);
 
   bb_predicate = not_inlined_predicate ();
-  account_size_time (info, 2 * INLINE_SIZE_SCALE, 0, &bb_predicate);
+  account_size_time (info, overhead * INLINE_SIZE_SCALE, 0, &bb_predicate);
 
   gcc_assert (my_function && my_function->cfg);
   if (parms_info)
@@ -2661,7 +2660,6 @@ compute_inline_parameters (struct cgraph_node *node, bool early)
   self_stack_size = optimize ? estimated_stack_frame_size (node) : 0;
   info->estimated_self_stack_size = self_stack_size;
   info->estimated_stack_size = self_stack_size;
-  info->stack_frame_offset = 0;
 
   /* Can this function be inlined at all?  */
   info->inlinable = tree_inlinable_function_p (node->symbol.decl);
@@ -2694,7 +2692,6 @@ compute_inline_parameters (struct cgraph_node *node, bool early)
   /* Inlining characteristics are maintained by the cgraph_mark_inline.  */
   info->time = info->self_time;
   info->size = info->self_size;
-  info->stack_frame_offset = 0;
   info->estimated_stack_size = info->estimated_self_stack_size;
 #ifdef ENABLE_CHECKING
   inline_update_overall_summary (node);
@@ -3071,16 +3068,12 @@ inline_update_callee_summaries (struct cgraph_node *node, int depth)
 {
   struct cgraph_edge *e;
   struct inline_summary *callee_info = inline_summary (node);
-  struct inline_summary *caller_info = inline_summary (node->callers->caller);
-  HOST_WIDE_INT peak;
-
-  callee_info->stack_frame_offset
-    = caller_info->stack_frame_offset
-    + caller_info->estimated_self_stack_size;
-  peak = callee_info->stack_frame_offset
-    + callee_info->estimated_self_stack_size;
-  if (inline_summary (node->global.inlined_to)->estimated_stack_size < peak)
-      inline_summary (node->global.inlined_to)->estimated_stack_size = peak;
+
+  /* Pessimistically assume no sharing of stack space.  That is, the
+    frame size of a function is estimated as the original frame size
+    plus the sum of the frame sizes of all inlined callees.  */
+  inline_summary (node->global.inlined_to)->estimated_stack_size +=
+      callee_info->estimated_self_stack_size;
   cgraph_propagate_frequency (node);
   for (e = node->callees; e; e = e->next_callee)
     {
diff --git a/gcc/ipa-inline-transform.c b/gcc/ipa-inline-transform.c
index cac20fe..62c6a23 100644
--- a/gcc/ipa-inline-transform.c
+++ b/gcc/ipa-inline-transform.c
@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
+#include "dumpfile.h"
 #include "tm.h"
 #include "tree.h"
 #include "langhooks.h"
@@ -43,6 +44,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "ipa-inline.h"
 #include "tree-inline.h"
 #include "tree-pass.h"
+#include "l-ipo.h"
+#include "params.h"
 
 int ncalls_inlined;
 int nfunctions_inlined;
@@ -186,6 +189,134 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,
       clone_inlined_nodes (e, duplicate, update_original, overall_size);
 }
 
+#define MAX_INT_LENGTH 16
+
+/* Return NODE's name and aux info. The output is controled by OPT_INFO
+   level.  */
+
+static const char *
+cgraph_node_opt_info (struct cgraph_node *node, bool emit_mod_info)
+{
+  char *buf;
+  size_t buf_size;
+  const char *bfd_name = lang_hooks.dwarf_name (node->symbol.decl, 0);
+  const char *mod_name = 0;
+  unsigned int mod_id = 0;
+  int funcdef_no = -1;
+  const char *primary_tag = 0;
+
+  if (!bfd_name)
+    bfd_name = "unknown";
+
+  buf_size = strlen (bfd_name) + 1;
+  if (profile_info)
+    buf_size += (MAX_INT_LENGTH + 3);
+
+  if (L_IPO_COMP_MODE && emit_mod_info)
+    {
+      mod_id = cgraph_get_module_id (node->symbol.decl);
+      gcc_assert (mod_id);
+      mod_name = get_module_name (mod_id);
+      primary_tag = (mod_id == primary_module_id ? "*" :"");
+      buf_size += (4 + strlen (mod_name));
+      if (PARAM_VALUE (PARAM_INLINE_DUMP_MODULE_ID))
+        {
+          struct function *func = DECL_STRUCT_FUNCTION (node->symbol.decl);
+          if (func)
+            funcdef_no = func->funcdef_no; 
+          buf_size += (2 * MAX_INT_LENGTH + 1);
+	}
+    }
+
+  buf = (char *) xmalloc (buf_size);
+
+  strcpy (buf, bfd_name);
+
+  if (L_IPO_COMP_MODE && emit_mod_info)
+    {
+      if (PARAM_VALUE (PARAM_INLINE_DUMP_MODULE_ID))
+         sprintf (buf, "%s [%d:%d %s%s]", buf, mod_id, funcdef_no,
+	     primary_tag, mod_name);
+      else
+         sprintf (buf, "%s [%s%s]", buf, primary_tag, mod_name);
+    }
+
+  if (profile_info)
+    sprintf (buf, "%s ("HOST_WIDEST_INT_PRINT_DEC")", buf, node->count);
+  return buf;
+}
+
+/* Return CALLER's inlined call chain. Save the cgraph_node of the ultimate
+   function that the caller is inlined to in FINAL_CALLER.  */
+
+static const char *
+cgraph_node_call_chain (struct cgraph_node *caller,
+		        struct cgraph_node **final_caller)
+{
+  struct cgraph_node *node;
+  const char *via_str = " (via inline instance";
+  size_t current_string_len = strlen (via_str) + 1;
+  size_t buf_size = current_string_len;
+  char *buf = (char *) xmalloc (buf_size);
+
+  buf[0] = 0;
+  gcc_assert (caller->global.inlined_to != NULL);
+  strcat (buf, via_str);
+  for (node = caller; node->global.inlined_to != NULL;
+       node = node->callers->caller)
+    {
+      const char *name = cgraph_node_opt_info (node, false);
+      current_string_len += (strlen (name) + 1);
+      if (current_string_len >= buf_size)
+	{
+	  buf_size = current_string_len * 2;
+	  buf = (char *) xrealloc (buf, buf_size);
+	}
+      strcat (buf, " ");
+      strcat (buf, name);
+    }
+  strcat (buf, ")");
+  *final_caller = node;
+  return buf;
+}
+
+/* Dump the inline decision of EDGE to stderr.  */
+
+static void
+dump_inline_decision (struct cgraph_edge *edge)
+{
+  location_t locus;
+  const char *inline_chain_text;
+  const char *call_count_text;
+  struct cgraph_node *final_caller = edge->caller;
+
+  if (final_caller->global.inlined_to != NULL)
+    inline_chain_text = cgraph_node_call_chain (final_caller, &final_caller);
+  else
+    inline_chain_text = "";
+
+  if (edge->count > 0)
+    {
+      const char *call_count_str = " with call count ";
+      char *buf = (char *) xmalloc (strlen (call_count_str) + MAX_INT_LENGTH);
+      sprintf (buf, "%s"HOST_WIDEST_INT_PRINT_DEC, call_count_str,
+	       edge->count);
+      call_count_text = buf;
+    }
+  else
+    {
+      call_count_text = "";
+    }
+ 
+  locus = gimple_location (edge->call_stmt);
+  dump_printf_loc (is_in_ipa_inline ? MSG_OPTIMIZED_LOCATIONS : MSG_NOTE,
+                   locus,
+                   "%s inlined into %s%s%s\n",
+                   cgraph_node_opt_info (edge->callee, true),
+                   cgraph_node_opt_info (final_caller, true),
+                   call_count_text,
+                   inline_chain_text);
+}
 
 /* Mark edge E as inlined and update callgraph accordingly.  UPDATE_ORIGINAL
    specify whether profile of original function should be updated.  If any new
@@ -206,13 +337,21 @@ inline_call (struct cgraph_edge *e, bool update_original,
   struct cgraph_node *to = NULL;
   struct cgraph_edge *curr = e;
   struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);
+  struct cgraph_node *resolved_target = callee;
   bool new_edges_found = false;
 
+  /* Skip fake edge.  */
+  if (L_IPO_COMP_MODE && !e->call_stmt)
+    return false;
+
 #ifdef ENABLE_CHECKING
   int estimated_growth = estimate_edge_growth (e);
   bool predicated = inline_edge_summary (e)->predicate != NULL;
 #endif
 
+  if (dump_enabled_p ())
+    dump_inline_decision (e);
+
   /* Don't inline inlined edges.  */
   gcc_assert (e->inline_failed);
   /* Don't even think of inlining inline clone.  */
@@ -230,7 +369,10 @@ inline_call (struct cgraph_edge *e, bool update_original,
   if (e->callee != callee)
     {
       struct cgraph_node *alias = e->callee, *next_alias;
-      cgraph_redirect_edge_callee (e, callee);
+
+      if (L_IPO_COMP_MODE && cgraph_pre_profiling_inlining_done)
+        resolved_target = cgraph_lipo_get_resolved_node (callee->symbol.decl);
+      cgraph_redirect_edge_callee (e, resolved_target);
       while (alias && alias != callee)
 	{
 	  if (!alias->callers
@@ -256,12 +398,15 @@ inline_call (struct cgraph_edge *e, bool update_original,
   if (update_overall_summary)
    inline_update_overall_summary (to);
   new_size = inline_summary (to)->size;
+  if (to->max_bb_count < e->callee->max_bb_count)
+    to->max_bb_count = e->callee->max_bb_count;
 
 #ifdef ENABLE_CHECKING
   /* Verify that estimated growth match real growth.  Allow off-by-one
      error due to INLINE_SIZE_SCALE roudoff errors.  */
   gcc_assert (!update_overall_summary || !overall_size
 	      || abs (estimated_growth - (new_size - old_size)) <= 1
+              || resolved_target != callee
 	      /* FIXME: a hack.  Edges with false predicate are accounted
 		 wrong, we should remove them from callgraph.  */
 	      || predicated);
@@ -270,7 +415,11 @@ inline_call (struct cgraph_edge *e, bool update_original,
   /* Account the change of overall unit size; external functions will be
      removed and are thus not accounted.  */
   if (overall_size
-      && !DECL_EXTERNAL (to->symbol.decl))
+      && !DECL_EXTERNAL (to->symbol.decl)
+      && ((L_IPO_COMP_MODE
+           && cgraph_get_module_id (to->symbol.decl)
+           == primary_module_id)
+          || !L_IPO_COMP_MODE))
     *overall_size += new_size - old_size;
   ncalls_inlined++;
 
diff --git a/gcc/ipa-inline.c b/gcc/ipa-inline.c
index 90b2a13..c0584ed 100644
--- a/gcc/ipa-inline.c
+++ b/gcc/ipa-inline.c
@@ -109,14 +109,24 @@ along with GCC; see the file COPYING3.  If not see
 #include "rtl.h"
 #include "tree-flow.h"
 #include "ipa-prop.h"
+#include "basic-block.h"
+#include "toplev.h"
+#include "dbgcnt.h"
 #include "except.h"
+#include "l-ipo.h"
 #include "target.h"
 #include "ipa-inline.h"
 #include "ipa-utils.h"
+#include "auto-profile.h"
+#include "sreal.h"
 
 /* Statistics we collect about inlining algorithm.  */
 static int overall_size;
 static gcov_type max_count;
+static sreal max_count_real, max_relbenefit_real, half_int_min_real;
+
+/* Global variable to denote if it is in ipa-inline pass. */
+bool is_in_ipa_inline = false;
 
 /* Return false when inlining edge E would lead to violating
    limits on function unit growth or stack usage growth.  
@@ -191,8 +201,7 @@ caller_growth_limits (struct cgraph_edge *e)
   stack_size_limit += ((gcov_type)stack_size_limit
 		       * PARAM_VALUE (PARAM_STACK_FRAME_GROWTH) / 100);
 
-  inlined_stack = (outer_info->stack_frame_offset
-		   + outer_info->estimated_self_stack_size
+  inlined_stack = (outer_info->estimated_stack_size
 		   + what_info->estimated_stack_size);
   /* Check new stack consumption with stack consumption at the place
      stack is used.  */
@@ -362,6 +371,11 @@ can_early_inline_edge_p (struct cgraph_edge *e)
       e->inline_failed = CIF_BODY_NOT_AVAILABLE;
       return false;
     }
+
+  /* Skip fake edges  */
+  if (L_IPO_COMP_MODE && !e->call_stmt)
+    return false;
+
   /* In early inliner some of callees may not be in SSA form yet
      (i.e. the callgraph is cyclic and we did not process
      the callee by early inliner, yet).  We don't have CIF code for this
@@ -385,15 +399,16 @@ static int
 num_calls (struct cgraph_node *n)
 {
   struct cgraph_edge *e;
+  /* The following is buggy -- indirect call is not considered.  */
   int num = 0;
 
   for (e = n->callees; e; e = e->next_callee)
-    if (!is_inexpensive_builtin (e->callee->symbol.decl))
+    if (e->call_stmt /* Only exist in profile use pass in LIPO  */
+        && !is_inexpensive_builtin (e->callee->symbol.decl))
       num++;
   return num;
 }
 
-
 /* Return true if we are interested in inlining small function.  */
 
 static bool
@@ -404,6 +419,8 @@ want_early_inline_function_p (struct cgraph_edge *e)
 
   if (DECL_DISREGARD_INLINE_LIMITS (callee->symbol.decl))
     ;
+  else if (flag_auto_profile && afdo_callsite_hot_enough_for_early_inline (e))
+    ;
   else if (!DECL_DECLARED_INLINE_P (callee->symbol.decl)
 	   && !flag_inline_small_functions)
     {
@@ -414,12 +431,12 @@ want_early_inline_function_p (struct cgraph_edge *e)
   else
     {
       int growth = estimate_edge_growth (e);
+      struct cgraph_node *callee = e->callee;
       int n;
 
-      if (growth <= 0)
+      if (growth <= PARAM_VALUE (PARAM_EARLY_INLINING_INSNS_ANY))
 	;
-      else if (!cgraph_maybe_hot_edge_p (e)
-	       && growth > 0)
+      else if (!cgraph_maybe_hot_edge_p (e))
 	{
 	  if (dump_file)
 	    fprintf (dump_file, "  will not early inline: %s/%i->%s/%i, "
@@ -439,6 +456,9 @@ want_early_inline_function_p (struct cgraph_edge *e)
 		     growth);
 	  want_inline = false;
 	}
+      else if (DECL_COMDAT (callee->symbol.decl)
+               && growth <= PARAM_VALUE (PARAM_EARLY_INLINING_INSNS_COMDAT))
+        ;
       else if ((n = num_calls (callee)) != 0
 	       && growth * (n + 1) > PARAM_VALUE (PARAM_EARLY_INLINING_INSNS))
 	{
@@ -508,6 +528,27 @@ big_speedup_p (struct cgraph_edge *e)
   return false;
 }
 
+/* Returns true if an edge or its caller are hot enough to
+   be considered for inlining.  */
+
+static bool
+edge_hot_enough_p (struct cgraph_edge *edge)
+{
+  if (cgraph_maybe_hot_edge_p (edge))
+    return true;
+
+  /* We disable hot-caller heuristic if the callee's entry count is
+     0 because in this case we do not have enough information to
+     calculate the scaling factor.  */
+  if (flag_auto_profile && edge->callee->count == 0
+      && edge->callee->max_bb_count > 0)
+    return false;
+  if (PARAM_VALUE (PARAM_INLINE_HOT_CALLER)
+      && maybe_hot_count_p (NULL, edge->caller->max_bb_count))
+    return true;
+  return false;
+}
+
 /* Return true if we are interested in inlining small function.
    When REPORT is true, report reason to dump file.  */
 
@@ -605,7 +646,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)
 	  want_inline = false;
 	}
       /* If call is cold, do not inline when function body would grow. */
-      else if (!cgraph_maybe_hot_edge_p (e))
+      else if (!edge_hot_enough_p (e))
 	{
           e->inline_failed = CIF_UNLIKELY_CALL;
 	  want_inline = false;
@@ -783,6 +824,49 @@ want_inline_function_to_all_callers_p (struct cgraph_node *node, bool cold)
 
 #define RELATIVE_TIME_BENEFIT_RANGE (INT_MAX / 64)
 
+/* Return true if FUNCDECL is a function with fixed
+   argument list.  */
+
+static bool
+fixed_arg_function_p (tree fndecl)
+{
+  tree fntype = TREE_TYPE (fndecl);
+  return (TYPE_ARG_TYPES (fntype) == 0
+          || (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))
+              == void_type_node));
+}
+
+/* For profile collection with flag_dyn_ipa (LIPO), we always
+   want to inline comdat functions for the following reasons:
+   1) Functions in comdat may be actually defined in a different
+   module (depending on how linker picks). This results in a edge
+   from one module to another module in the dynamic callgraph.
+   The edge is false and result in unnecessary module grouping.
+   2) The profile counters in comdat functions are not 'comdated'
+   -- which means each copy of the same comdat function has its
+   own set of counters. With inlining, we are actually splitting
+   the counters and make the profile information 'context sensitive',
+   which is a good thing.
+   3) During profile-use pass of LIPO (flag_dyn_ipa == 1),
+   the pre-tree_profile inline decisions have to be the same as the
+   profile-gen pass (otherwise coverage mismatch will occur). Due to
+   this reason, it is better for each module to 'use' the comdat copy
+   of its own. The only way to get profile data for the copy is to
+   inline the copy in profile-gen phase.
+   TODO: For indirectly called comdat functions, the above issues
+   still exist. */
+
+static bool
+better_inline_comdat_function_p (struct cgraph_node *node)
+{
+  return (profile_arc_flag && flag_dyn_ipa
+          && DECL_COMDAT (node->symbol.decl)
+          && inline_summary (node)->size
+	     <= PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SINGLE)
+          && fixed_arg_function_p (node->symbol.decl));
+}
+
+
 /* Return relative time improvement for inlining EDGE in range
    1...RELATIVE_TIME_BENEFIT_RANGE  */
 
@@ -884,12 +968,26 @@ edge_badness (struct cgraph_edge *edge, bool dump)
 
   else if (max_count)
     {
+      sreal tmp, relbenefit_real, growth_real;
       int relbenefit = relative_time_benefit (callee_info, edge, edge_time);
-      badness =
-	((int)
-	 ((double) edge->count * INT_MIN / 2 / max_count / RELATIVE_TIME_BENEFIT_RANGE) *
-	 relbenefit) / growth;
-      
+
+      sreal_init(&relbenefit_real, relbenefit, 0);
+      sreal_init(&growth_real, growth, 0);
+
+      /* relative_edge_count.  */
+      sreal_init (&tmp, edge->count, 0);
+      sreal_div (&tmp, &tmp, &max_count_real);
+
+      /* relative_time_benefit.  */
+      sreal_mul (&tmp, &tmp, &relbenefit_real);
+      sreal_div (&tmp, &tmp, &max_relbenefit_real);
+
+      /* growth_f_caller.  */
+      sreal_mul (&tmp, &tmp, &half_int_min_real);
+      sreal_div (&tmp, &tmp, &growth_real);
+
+      badness = -sreal_to_int (&tmp);
+ 
       /* Be sure that insanity of the profile won't lead to increasing counts
 	 in the scalling and thus to overflow in the computation above.  */
       gcc_assert (max_count >= edge->count);
@@ -978,7 +1076,12 @@ edge_badness (struct cgraph_edge *edge, bool dump)
   if (cgraph_edge_recursive_p (edge))
     return badness + 1;
   else
-    return badness;
+    {
+      if (better_inline_comdat_function_p (edge->callee))
+        return INT_MIN  + 1;
+      else
+        return badness;
+    }
 }
 
 /* Recompute badness of EDGE and update its key in HEAP if needed.  */
@@ -1119,7 +1222,8 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,
 	    || check_inlinablity_for == edge)
 	  {
 	    if (can_inline_edge_p (edge, false)
-		&& want_inline_small_function_p (edge, false))
+		&& (want_inline_small_function_p (edge, false)
+                    || better_inline_comdat_function_p (node)))
 	      update_edge_key (heap, edge);
 	    else if (edge->aux)
 	      {
@@ -1225,6 +1329,7 @@ recursive_inlining (struct cgraph_edge *edge,
 		    vec<cgraph_edge_p> *new_edges)
 {
   int limit = PARAM_VALUE (PARAM_MAX_INLINE_INSNS_RECURSIVE_AUTO);
+  int probability = PARAM_VALUE (PARAM_MIN_INLINE_RECURSIVE_PROBABILITY);
   fibheap_t heap;
   struct cgraph_node *node;
   struct cgraph_edge *e;
@@ -1289,6 +1394,29 @@ recursive_inlining (struct cgraph_edge *edge,
 	    == cgraph_function_or_thunk_node (curr->callee, NULL)->symbol.decl)
           depth++;
 
+      if (max_count)
+	{
+          if (!cgraph_maybe_hot_edge_p (curr))
+	    {
+	      if (dump_file)
+		fprintf (dump_file, "   Not inlining cold call\n");
+
+              cgraph_redirect_edge_callee (curr, dest);
+              reset_edge_growth_cache (curr);
+	      continue;
+	    }
+          if (node->count == 0 || curr->count * 100 / node->count < probability)
+	    {
+	      if (dump_file)
+		fprintf (dump_file,
+			 "   Probability of edge is too small\n");
+
+              cgraph_redirect_edge_callee (curr, dest);
+              reset_edge_growth_cache (curr);
+	      continue;
+	    }
+	}
+
       if (!want_inline_self_recursive_call_p (curr, node, false, depth))
 	{
 	  cgraph_redirect_edge_callee (curr, dest);
@@ -1296,6 +1424,9 @@ recursive_inlining (struct cgraph_edge *edge,
 	  continue;
 	}
 
+      if (!dbg_cnt (inl))
+        continue;
+
       if (dump_file)
 	{
 	  fprintf (dump_file,
@@ -1405,6 +1536,8 @@ inline_small_functions (void)
   int initial_size = 0;
   struct cgraph_node **order = XCNEWVEC (struct cgraph_node *, cgraph_n_nodes);
 
+  is_in_ipa_inline = true;
+
   if (flag_indirect_inlining)
     new_indirect_edges.create (8);
 
@@ -1445,7 +1578,13 @@ inline_small_functions (void)
 	for (edge = node->callers; edge; edge = edge->next_caller)
 	  if (max_count < edge->count)
 	    max_count = edge->count;
+        for (edge = node->indirect_calls; edge; edge = edge->next_callee)
+          if (max_count < edge->count)
+            max_count = edge->count;
       }
+  sreal_init (&max_count_real, max_count, 0);
+  sreal_init (&max_relbenefit_real, RELATIVE_TIME_BENEFIT_RANGE, 0);
+  sreal_init (&half_int_min_real, INT_MAX / 2, 0);
   ipa_free_postorder_info ();
   initialize_growth_caches ();
 
@@ -1470,7 +1609,8 @@ inline_small_functions (void)
 	for (edge = node->callers; edge; edge = edge->next_caller)
 	  if (edge->inline_failed
 	      && can_inline_edge_p (edge, true)
-	      && want_inline_small_function_p (edge, true)
+	      && (want_inline_small_function_p (edge, true)
+                  || better_inline_comdat_function_p (node))
 	      && edge->inline_failed)
 	    {
 	      gcc_assert (!edge->aux);
@@ -1497,6 +1637,9 @@ inline_small_functions (void)
       if (!edge->inline_failed)
 	continue;
 
+      if (L_IPO_COMP_MODE && !edge->call_stmt)
+        continue;
+
       /* Be sure that caches are maintained consistent.  
          We can not make this ENABLE_CHECKING only because it cause different
          updates of the fibheap queue.  */
@@ -1518,7 +1661,7 @@ inline_small_functions (void)
 
       if (!can_inline_edge_p (edge, true))
 	continue;
-      
+ 
       callee = cgraph_function_or_thunk_node (edge->callee, NULL);
       growth = estimate_edge_growth (edge);
       if (dump_file)
@@ -1554,9 +1697,13 @@ inline_small_functions (void)
 	  continue;
 	}
 
-      if (!want_inline_small_function_p (edge, true))
+      if (!want_inline_small_function_p (edge, true)
+          && !better_inline_comdat_function_p (edge->callee))
 	continue;
 
+      if (!dbg_cnt (inl))
+         continue;
+
       /* Heuristics for inlining small functions works poorly for
 	 recursive calls where we do efect similar to loop unrolling.
 	 When inliing such edge seems profitable, leave decision on
@@ -1635,8 +1782,9 @@ inline_small_functions (void)
       if (dump_file)
 	{
 	  fprintf (dump_file,
-		   " Inlined into %s which now has time %i and size %i,"
+		   "INFO: %s Inlined into %s which now has time %i and size %i,"
 		   "net change of %+i.\n",
+		   cgraph_node_name (edge->callee),
 		   cgraph_node_name (edge->caller),
 		   inline_summary (edge->caller)->time,
 		   inline_summary (edge->caller)->size,
@@ -1906,7 +2054,15 @@ inline_always_inline_functions (struct cgraph_node *node)
 	}
 
       if (!can_early_inline_edge_p (e))
-	continue;
+	{
+	  /* Set inlined to true if the callee is marked "always_inline" but
+	     is not inlinable.  This will allow flagging an error later in
+	     expand_call_inline in tree-inline.c.  */
+	  if (lookup_attribute ("always_inline",
+				 DECL_ATTRIBUTES (callee->symbol.decl)) != NULL)
+	    inlined = true;
+	  continue;
+	}
 
       if (dump_file)
 	fprintf (dump_file, "  Inlining %s into %s (always_inline).\n",
@@ -1952,6 +2108,7 @@ early_inline_small_functions (struct cgraph_node *node)
 
       if (cgraph_edge_recursive_p (e))
 	{
+
 	  if (dump_file)
 	    fprintf (dump_file, "  Not inlining: recursive call.\n");
 	  continue;
@@ -2044,13 +2201,16 @@ early_inliner (void)
 	  for (edge = node->callees; edge; edge = edge->next_callee)
 	    {
 	      struct inline_edge_summary *es = inline_edge_summary (edge);
+
+	      if (!edge->call_stmt)
+	        continue;
 	      es->call_stmt_size
 		= estimate_num_insns (edge->call_stmt, &eni_size_weights);
 	      es->call_stmt_time
 		= estimate_num_insns (edge->call_stmt, &eni_time_weights);
 	      if (edge->callee->symbol.decl
-		  && !gimple_check_call_matching_types (edge->call_stmt,
-							edge->callee->symbol.decl))
+		  && !gimple_check_call_matching_types (
+		      edge->call_stmt, edge->callee->symbol.decl, false))
 		edge->call_stmt_cannot_inline_p = true;
 	    }
 	  timevar_pop (TV_INTEGRATION);
@@ -2093,7 +2253,6 @@ struct gimple_opt_pass pass_early_inline =
  }
 };
 
-
 /* When to run IPA inlining.  Inlining of always-inline functions
    happens during early inlining.
 
diff --git a/gcc/ipa-inline.h b/gcc/ipa-inline.h
index 8a72601..3988b3b 100644
--- a/gcc/ipa-inline.h
+++ b/gcc/ipa-inline.h
@@ -234,6 +234,7 @@ void clone_inlined_nodes (struct cgraph_edge *e, bool, bool, int *);
 
 extern int ncalls_inlined;
 extern int nfunctions_inlined;
+extern bool is_in_ipa_inline;
 
 static inline struct inline_summary *
 inline_summary (struct cgraph_node *node)
diff --git a/gcc/ipa-prop.c b/gcc/ipa-prop.c
index c62dc68..7b2792f 100644
--- a/gcc/ipa-prop.c
+++ b/gcc/ipa-prop.c
@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "data-streamer.h"
 #include "tree-streamer.h"
 #include "params.h"
+#include "l-ipo.h"
 
 /* Intermediate information about a parameter that is only useful during the
    run of ipa_analyze_node and is not kept afterwards.  */
@@ -1399,7 +1400,20 @@ ipa_compute_jump_functions_for_edge (struct param_analysis_info *parms_ainfo,
       tree arg = gimple_call_arg (call, n);
 
       if (is_gimple_ip_invariant (arg))
-	ipa_set_jf_constant (jfunc, arg);
+        {
+          if (L_IPO_COMP_MODE && TREE_CODE (arg) == ADDR_EXPR
+              && TREE_CODE (TREE_OPERAND (arg, 0)) == FUNCTION_DECL)
+            {
+              tree fdecl = TREE_OPERAND (arg, 0);
+	      fdecl = cgraph_lipo_get_resolved_node (fdecl)->symbol.decl;
+              if (fdecl != TREE_OPERAND (arg, 0))
+                {
+                  arg = unshare_expr (arg);
+                  TREE_OPERAND (arg, 0) = fdecl;
+                }
+            }
+          ipa_set_jf_constant (jfunc, arg);
+        }
       else if (!is_gimple_reg_type (TREE_TYPE (arg))
 	       && TREE_CODE (arg) == PARM_DECL)
 	{
@@ -2126,7 +2140,6 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)
      we may create the first reference to the object in the unit.  */
   if (!callee || callee->global.inlined_to)
     {
-      struct cgraph_node *first_clone = callee;
 
       /* We are better to ensure we can refer to it.
 	 In the case of static functions we are out of luck, since we already	
@@ -2142,31 +2155,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)
 		     xstrdup (cgraph_node_name (ie->callee)), ie->callee->uid);
 	  return NULL;
 	}
-
-      /* Create symbol table node.  Even if inline clone exists, we can not take
-	 it as a target of non-inlined call.  */
-      callee = cgraph_create_node (target);
-
-      /* OK, we previously inlined the function, then removed the offline copy and
-	 now we want it back for external call.  This can happen when devirtualizing
-	 while inlining function called once that happens after extern inlined and
-	 virtuals are already removed.  In this case introduce the external node
-	 and make it available for call.  */
-      if (first_clone)
-	{
-	  first_clone->clone_of = callee;
-	  callee->clones = first_clone;
-	  symtab_prevail_in_asm_name_hash ((symtab_node)callee);
-	  symtab_insert_node_to_hashtable ((symtab_node)callee);
-	  if (dump_file)
-	    fprintf (dump_file, "ipa-prop: Introduced new external node "
-		     "(%s/%i) and turned into root of the clone tree.\n",
-		     xstrdup (cgraph_node_name (callee)), callee->uid);
-	}
-      else if (dump_file)
-	fprintf (dump_file, "ipa-prop: Introduced new external node "
-		 "(%s/%i).\n",
-		 xstrdup (cgraph_node_name (callee)), callee->uid);
+      callee = cgraph_get_create_real_symbol_node (target);
     }
   ipa_check_create_node_params ();
 
@@ -2341,8 +2330,9 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,
 	  new_direct_edge->indirect_inlining_edge = 1;
 	  if (new_direct_edge->call_stmt)
 	    new_direct_edge->call_stmt_cannot_inline_p
-	      = !gimple_check_call_matching_types (new_direct_edge->call_stmt,
-						   new_direct_edge->callee->symbol.decl);
+	      = !gimple_check_call_matching_types (
+		  new_direct_edge->call_stmt,
+		  new_direct_edge->callee->symbol.decl, false);
 	  if (new_edges)
 	    {
 	      new_edges->safe_push (new_direct_edge);
diff --git a/gcc/ipa-pure-const.c b/gcc/ipa-pure-const.c
index 94c7315..a94faf0 100644
--- a/gcc/ipa-pure-const.c
+++ b/gcc/ipa-pure-const.c
@@ -1491,6 +1491,12 @@ static bool
 gate_pure_const (void)
 {
   return (flag_ipa_pure_const
+           /* Due to the traverse order difference between profile-use
+          and profile-gen, pure/const analysis result can be different
+          resulting in differnt CFG in the caller (e.g, different VOPS,
+          --> different MEMOP PHI --> different CFG cleanups) function,
+          thus causing profile mismatch problem.  */
+           && (!flag_dyn_ipa || cgraph_pre_profiling_inlining_done)
 	  /* Don't bother doing anything if the program has errors.  */
 	  && !seen_error ());
 }
diff --git a/gcc/ipa-utils.c b/gcc/ipa-utils.c
index f2ff95a..761cc48 100644
--- a/gcc/ipa-utils.c
+++ b/gcc/ipa-utils.c
@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "flags.h"
 #include "diagnostic.h"
 #include "langhooks.h"
+#include "l-ipo.h"
 
 /* Debugging function for postorder and inorder code. NOTE is a string
    that is printed before the nodes are printed.  ORDER is an array of
@@ -312,6 +313,9 @@ ipa_reverse_postorder (struct cgraph_node **order)
 			  && !DECL_DISREGARD_INLINE_LIMITS
 			    (cgraph_function_node (edge->callee, NULL)->symbol.decl))
 			node2 = NULL;
+                      if (L_IPO_COMP_MODE
+		          && cgraph_is_fake_indirect_call_edge (edge))
+			node2 = NULL;
 		    }
 		  for (;ipa_ref_list_referring_iterate (&stack[stack_size].node->symbol.ref_list,
 						       stack[stack_size].ref,
diff --git a/gcc/ipa-utils.h b/gcc/ipa-utils.h
index f388598..7ece7b8 100644
--- a/gcc/ipa-utils.h
+++ b/gcc/ipa-utils.h
@@ -23,6 +23,10 @@ along with GCC; see the file COPYING3.  If not see
 #include "tree.h"
 #include "cgraph.h"
 
+/* Used for parsing attributes of asm code.  */
+extern tree memory_identifier_string;
+extern tree get_memory_identifier_string (void);
+
 struct ipa_dfs_info {
   int dfn_number;
   int low_link;
@@ -48,5 +52,3 @@ tree get_base_var (tree);
 
 
 #endif  /* GCC_IPA_UTILS_H  */
-
-
diff --git a/gcc/ipa.c b/gcc/ipa.c
index a9b8fb4..3885e66 100644
--- a/gcc/ipa.c
+++ b/gcc/ipa.c
@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "coretypes.h"
 #include "tm.h"
 #include "cgraph.h"
+#include "toplev.h"
 #include "tree-pass.h"
 #include "gimple.h"
 #include "ggc.h"
@@ -29,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "pointer-set.h"
 #include "target.h"
 #include "tree-iterator.h"
+#include "l-ipo.h"
 #include "ipa-utils.h"
 #include "pointer-set.h"
 #include "ipa-inline.h"
@@ -88,7 +90,8 @@ process_references (struct ipa_ref_list *list,
 	  struct cgraph_node *node = ipa_ref_node (ref);
 
 	  if (node->analyzed
-	      && (!DECL_EXTERNAL (node->symbol.decl)
+	      && (!(DECL_EXTERNAL (node->symbol.decl)
+	            || cgraph_is_aux_decl_external (node))
 		  || node->alias
 	          || before_inlining_p))
 	    pointer_set_insert (reachable, node);
@@ -221,6 +224,14 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)
   struct pointer_set_t *reachable = pointer_set_create ();
   struct pointer_set_t *body_needed_for_clonning = pointer_set_create ();
 
+  /* In LIPO mode, do not remove functions until after global linking
+     is performed. Otherwise functions needed for cross module inlining
+     may get eliminated. Global linking will be done just before tree
+     profiling.  */
+  if (L_IPO_COMP_MODE
+     && !cgraph_pre_profiling_inlining_done)
+    return false;
+
 #ifdef ENABLE_CHECKING
   verify_symtab ();
 #endif
@@ -299,7 +310,8 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)
 		{
 		  if (e->callee->analyzed
 		      && (!e->inline_failed
-			  || !DECL_EXTERNAL (e->callee->symbol.decl)
+			  || !(DECL_EXTERNAL (e->callee->symbol.decl)
+			       || cgraph_is_aux_decl_external (e->callee))
 			  || cnode->alias
 			  || before_inlining_p))
 		    pointer_set_insert (reachable, e->callee);
@@ -359,8 +371,14 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)
 	    {
 	      if (file)
 		fprintf (file, " %s", cgraph_node_name (node));
-	      cgraph_node_remove_callees (node);
-	      ipa_remove_all_references (&node->symbol.ref_list);
+#ifdef FIXME_LIPO
+error " Check the following code "
+#endif
+              if (!cgraph_is_aux_decl_external (node))
+                {
+	          cgraph_node_remove_callees (node);
+	          ipa_remove_all_references (&node->symbol.ref_list);
+                }
 	      changed = true;
 	    }
 	  if (!pointer_set_contains (body_needed_for_clonning, node->symbol.decl)
@@ -378,6 +396,20 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)
       if (node->global.inlined_to
 	  && !node->callers)
 	{
+          /* Clean up dangling references from callees as well.
+             TODO -- should be done recursively.  */
+          if (L_IPO_COMP_MODE)
+            {
+	      struct cgraph_edge *e;
+              for (e = node->callees; e; e = e->next_callee)
+                {
+                  struct cgraph_node *callee_node;
+
+                  callee_node = e->callee;
+                  if (callee_node->global.inlined_to)
+                    callee_node->global.inlined_to = node;
+                }
+            }
 	  gcc_assert (node->clones);
 	  node->global.inlined_to = NULL;
 	  update_inlined_to_pointer (node, node);
@@ -387,30 +419,33 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)
 
   /* Remove unreachable variables.  */
   if (file)
-    fprintf (file, "\nReclaiming variables:");
+    fprintf (file, "\n");
+
+  if (file)
+    fprintf (file, "Reclaiming variables:");
   for (vnode = varpool_first_variable (); vnode; vnode = vnext)
     {
       vnext = varpool_next_variable (vnode);
       if (!vnode->symbol.aux)
-	{
-	  if (file)
-	    fprintf (file, " %s", varpool_node_name (vnode));
-	  varpool_remove_node (vnode);
-	  changed = true;
-	}
+        {
+          if (file)
+            fprintf (file, " %s", varpool_node_name (vnode));
+          varpool_remove_node (vnode);
+          changed = true;
+        }
       else if (!pointer_set_contains (reachable, vnode))
         {
-	  if (vnode->analyzed)
-	    {
-	      if (file)
-		fprintf (file, " %s", varpool_node_name (vnode));
-	      changed = true;
-	    }
-	  vnode->analyzed = false;
-	  vnode->symbol.aux = NULL;
-	}
+          if (vnode->analyzed)
+            {
+              if (file)
+                fprintf (file, " %s", varpool_node_name (vnode));
+              changed = true;
+            }
+          vnode->analyzed = false;
+          vnode->symbol.aux = NULL;
+        }
       else
-	vnode->symbol.aux = NULL;
+        vnode->symbol.aux = NULL;
     }
 
   pointer_set_destroy (reachable);
@@ -892,6 +927,7 @@ function_and_variable_visibility (bool whole_program)
     {
       if (!vnode->finalized)
         continue;
+
       if (varpool_externally_visible_p
 	    (vnode, 
 	     pointer_set_contains (aliased_vnodes, vnode)))
@@ -906,6 +942,10 @@ function_and_variable_visibility (bool whole_program)
 	    symtab_dissolve_same_comdat_group_list ((symtab_node) vnode);
 	  vnode->symbol.resolution = LDPR_PREVAILING_DEF_IRONLY;
 	}
+      /* Static variables defined in auxiliary modules are externalized to
+         allow cross module inlining.  */
+      gcc_assert (TREE_STATIC (vnode->symbol.decl)
+                  || varpool_is_auxiliary (vnode));
     }
   pointer_set_destroy (aliased_nodes);
   pointer_set_destroy (aliased_vnodes);
diff --git a/gcc/ira-int.h b/gcc/ira-int.h
index 096f330..eb4ef9f 100644
--- a/gcc/ira-int.h
+++ b/gcc/ira-int.h
@@ -41,9 +41,11 @@ along with GCC; see the file COPYING3.  If not see
    analogous to REG_FREQ_FROM_BB.  When optimizing for size, or
    profile driven feedback is available and the function is never
    executed, frequency is always equivalent.  Otherwise rescale the
-   edge frequency.  */
+   edge frequency.  For AutoFDO, even if a function is not sampled,
+   it can still be executed, thus frequency rescale is still used.  */
 #define REG_FREQ_FROM_EDGE_FREQ(freq)					   \
-  (optimize_size || (flag_branch_probabilities && !ENTRY_BLOCK_PTR->count) \
+  (optimize_size || (flag_branch_probabilities				   \
+   && !flag_auto_profile && !ENTRY_BLOCK_PTR->count) 			   \
    ? REG_FREQ_MAX : (freq * REG_FREQ_MAX / BB_FREQ_MAX)			   \
    ? (freq * REG_FREQ_MAX / BB_FREQ_MAX) : 1)
 
diff --git a/gcc/java/Make-lang.in b/gcc/java/Make-lang.in
index 7ed3220..f143888 100644
--- a/gcc/java/Make-lang.in
+++ b/gcc/java/Make-lang.in
@@ -87,7 +87,7 @@ JAVA_OBJS = java/class.o java/decl.o java/expr.o \
 JCFDUMP_OBJS = java/jcf-dump.o java/jcf-io.o java/jcf-depend.o java/jcf-path.o \
 		java/win32-host.o java/zextract.o ggc-none.o hash-table.o
 
-JVGENMAIN_OBJS = java/jvgenmain.o java/mangle_name.o
+JVGENMAIN_OBJS = java/jvgenmain.o java/mangle_name.o vec.o ggc-none.o
 
 java_OBJS = $(sort $(JAVA_OBJS) $(JCFDUMP_OBJS) $(JVGENMAIN_OBJS)) jvspec.o
 
diff --git a/gcc/l-ipo.c b/gcc/l-ipo.c
new file mode 100644
index 0000000..f8b795a
--- /dev/null
+++ b/gcc/l-ipo.c
@@ -0,0 +1,2287 @@
+/* Copyright (C) 2009. Free Software Foundation, Inc.
+   Contributed by Xinliang David Li (davidxl@google.com) and
+                  Raksit Ashok  (raksit@google.com)
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tree.h"
+#include "c-family/c-common.h"
+#include "toplev.h"
+#include "langhooks.h"
+#include "langhooks-def.h"
+#include "diagnostic.h"
+#include "debug.h"
+#include "gimple.h"
+#include "cgraph.h"
+#include "l-ipo.h"
+#include "coverage.h"
+#include "gcov-io.h"
+#include "timevar.h"
+#include "vec.h"
+
+unsigned ggc_total_memory; /* in KB */
+
+struct GTY(()) saved_module_scope
+{
+  vec<tree, va_gc> *module_decls;
+  unsigned module_id;
+};
+
+static GTY (()) struct saved_module_scope *current_module_scope;
+static GTY ((param_is (struct saved_module_scope))) htab_t saved_module_scope_map;
+static int primary_module_last_funcdef_no = 0;
+/* Function id space for each module are qualified by the module id. After all the files
+   are parsed, we need to reset the funcdef_no to the max value from all module so that
+   the function clones do not assigned with ids colliding with some other orignal function
+   in the same module.  */
+static int max_funcdef_no = 0;
+static location_t primary_module_last_loc;
+/* Primary module pending templates.  */
+/* Referenced asm ids in primary module.  */
+static GTY (()) vec<tree, va_gc> *referenced_asm_ids = NULL;
+bool parser_parsing_start = false;
+/* Nonzero if we're done parsing and into end-of-file activities.  */
+int at_eof;
+
+static int aggr_has_equiv_id (tree t1, tree t2);
+
+/* Module scope hash function.  */
+
+static hashval_t
+htab_module_scope_hash (const void *ent)
+{
+  const struct saved_module_scope *const entry
+      = (const struct saved_module_scope *) ent;
+  return (hashval_t) entry->module_id;
+}
+
+/* Module scope equality function.  */
+
+static int
+htab_module_scope_eq (const void *ent1, const void *ent2)
+{
+  const struct saved_module_scope *const entry1
+      = (const struct saved_module_scope *) ent1;
+  const struct saved_module_scope *const entry2
+      = (const struct saved_module_scope *) ent2;
+
+  return entry1->module_id == entry2->module_id;
+}
+
+/* Returns the module scope given a module id MOD_ID.  */
+
+static struct saved_module_scope *
+get_module_scope (unsigned mod_id)
+{
+  struct saved_module_scope **slot, key, *module_scope;
+
+  gcc_assert (mod_id);
+
+  if (saved_module_scope_map == NULL)
+    saved_module_scope_map = htab_create_ggc (10, htab_module_scope_hash,
+                                              htab_module_scope_eq, NULL);
+  key.module_id = mod_id;
+  slot = (struct saved_module_scope **)
+      htab_find_slot (saved_module_scope_map, &key, INSERT);
+  module_scope = *slot;
+  if (!module_scope)
+    {
+      module_scope = ggc_alloc_cleared_saved_module_scope ();
+      module_scope->module_id = mod_id;
+      *slot = module_scope;
+    }
+  return module_scope;
+}
+
+/* Allocate memory for struct lang_decl for tree T.  */
+
+static struct lang_decl *
+alloc_lang_decl (tree t)
+{
+  size_t size;
+  size = lang_hooks.l_ipo.get_lang_decl_size (t);
+  return ggc_alloc_cleared_lang_decl (size);
+}
+
+/* Return a cloned copy of tree SRC.  */
+
+tree
+lipo_save_decl (tree src)
+{
+  tree saved = copy_node (src);
+  enum tree_code tc = TREE_CODE (src);
+  if (TREE_CODE_CLASS (tc) == tcc_declaration)
+    {
+      struct lang_decl *ls = NULL;
+      struct function *func = NULL;
+      DECL_CONTEXT (saved) = DECL_CONTEXT (src);
+      if (DECL_LANG_SPECIFIC (src))
+        {
+          ls = alloc_lang_decl (src);
+          memcpy (ls, DECL_LANG_SPECIFIC (src),
+                  lang_hooks.l_ipo.get_lang_decl_size (src));
+        }
+      DECL_LANG_SPECIFIC (saved) = ls;
+      if (tc == FUNCTION_DECL && DECL_STRUCT_FUNCTION (src))
+        {
+          func = ggc_alloc_cleared_function ();
+          *func = *(DECL_STRUCT_FUNCTION (src));
+          DECL_STRUCT_FUNCTION (saved) = func;
+        }
+    }
+  else
+    {
+      gcc_assert (TREE_CODE_CLASS (tc) == tcc_type &&
+                  TYPE_MAIN_VARIANT (src) == src);
+      TYPE_CONTEXT (saved) = TYPE_CONTEXT (src);
+      lang_hooks.l_ipo.dup_lang_type (src, saved);
+    }
+
+  return saved;
+}
+
+/* Copy tree SAVED to tree DEST.  */
+
+void
+lipo_restore_decl (tree dest, tree saved)
+{
+  enum tree_code tc;
+  unsigned old_uid;
+  struct lang_decl *oldls;
+
+  tc = TREE_CODE (saved);
+  if (TREE_CODE_CLASS (tc) == tcc_declaration)
+    {
+      struct function *oldfunc = NULL;
+      old_uid = DECL_UID (dest);
+      oldls = DECL_LANG_SPECIFIC (dest);
+      oldfunc
+          = (tc == FUNCTION_DECL ? DECL_STRUCT_FUNCTION (dest) : NULL);
+
+      memcpy ((char *) dest + sizeof (struct tree_common),
+              (char *) saved + sizeof (struct tree_common),
+              sizeof (struct tree_decl_common) - sizeof (struct tree_common));
+
+      if (tc == FUNCTION_DECL)
+        memcpy ((char *) dest + sizeof (struct tree_decl_common),
+                (char *) saved + sizeof (struct tree_decl_common),
+                sizeof (struct tree_function_decl)
+                - sizeof (struct tree_decl_common));
+
+      DECL_UID (dest) = old_uid;
+      if (DECL_LANG_SPECIFIC (saved))
+        {
+          if (!oldls)
+            oldls = alloc_lang_decl (dest);
+          memcpy (oldls, DECL_LANG_SPECIFIC (saved),
+                  lang_hooks.l_ipo.get_lang_decl_size (saved));
+          DECL_LANG_SPECIFIC (dest) = oldls;
+        }
+      else
+        DECL_LANG_SPECIFIC (dest) = NULL;
+
+      if (tc == FUNCTION_DECL)
+        {
+          if (DECL_STRUCT_FUNCTION (saved))
+            {
+              if (!oldfunc)
+                oldfunc = ggc_alloc_cleared_function ();
+              *oldfunc = *(DECL_STRUCT_FUNCTION (saved));
+              DECL_STRUCT_FUNCTION (dest) = oldfunc;
+            }
+          else
+            DECL_STRUCT_FUNCTION (dest) = NULL;
+        }
+    }
+  else
+    {
+      gcc_assert (TREE_CODE_CLASS (tc) == tcc_type);
+      lang_hooks.l_ipo.copy_lang_type (saved, dest);
+    }
+}
+
+
+/* Return the name for tree TD which is either a decl or type.  */
+
+tree
+get_type_or_decl_name (tree td)
+{
+  tree id;
+
+  if (DECL_P (td))
+    id = DECL_NAME (td);
+  else
+    {
+      id = TYPE_NAME (td);
+      if (DECL_P (id))
+        id = DECL_NAME (id);
+    }
+  return id;
+}
+
+/* For a DECL (a type or a decl) in SCOPE, check to see if it is in
+   global or namespace scope. If yes, add it to the current module scope.  */
+
+void
+add_decl_to_current_module_scope (tree decl, void *scope)
+{
+  struct saved_module_scope *module_scope;
+  tree id;
+
+  if (!flag_dyn_ipa)
+    return;
+
+  if (!parser_parsing_start)
+    {
+      /* The source file may contains only global variable declations
+         -- there is no module grouping data associated with it, so
+         neither primary_module_id nor current_module_id is set.  */
+      lang_hooks.l_ipo.add_built_in_decl (decl);
+      return;
+    }
+
+  if (!L_IPO_COMP_MODE)
+    return;
+
+  if (!lang_hooks.l_ipo.has_global_name (decl, scope))
+    return;
+
+  /* Unlike C++ where names are attached to type decls, for C, the type name
+     is identifier node. Thus we need to track type names as well.  */
+  id = get_type_or_decl_name (decl);
+  if (!id)
+    return;
+
+  module_scope = current_module_scope;
+  gcc_assert (module_scope && module_scope->module_id == current_module_id);
+  vec_safe_push (module_scope->module_decls, decl);
+}
+
+/* Clear name bindings for all decls created in MODULE_SCOPE.  */
+
+static void
+clear_module_scope_bindings (struct saved_module_scope *module_scope)
+{
+  size_t i;
+  tree decl;
+
+  for (i = 0;
+       vec_safe_iterate (module_scope->module_decls, i, &decl);
+       ++i)
+    {
+      lang_hooks.l_ipo.clear_global_name_bindings (
+        get_type_or_decl_name (decl));
+      /* Now force creating assembly name. */
+      if (VAR_OR_FUNCTION_DECL_P (decl))
+        {
+          tree assembler_name;
+
+          if (HAS_DECL_ASSEMBLER_NAME_P (decl)
+              && DECL_ASSEMBLER_NAME_SET_P (decl))
+            {
+              assembler_name = DECL_ASSEMBLER_NAME (decl);
+              lang_hooks.l_ipo.clear_global_name_bindings (assembler_name);
+            }
+        }
+    }
+}
+
+/* The referenced attribute of a decl is not associated with the
+   decl itself but with the assembler name. Remember the referenced
+   bits before clearing them.  */
+
+static void
+save_assembler_name_reference_bit (void)
+{
+  varpool_get_referenced_asm_ids (&referenced_asm_ids);
+}
+
+/* Clear the reference bits for assembler names before closing the
+   module scope.  */
+
+static void
+clear_assembler_name_reference_bit (void)
+{
+  varpool_clear_asm_id_reference_bit ();
+}
+
+/* Restore the reference bits for assembler names.  */
+
+static void
+restore_assembler_name_reference_bit (void)
+{
+  size_t i;
+  tree nm;
+  for (i = 0;
+       vec_safe_iterate (referenced_asm_ids, i, &nm);
+       ++i)
+    TREE_SYMBOL_REFERENCED (nm) = 1;
+}
+
+/* Set up the module scope before the parsing of the
+   associated source file.  */
+
+void
+push_module_scope (void)
+{
+  struct saved_module_scope *prev_module_scope;
+
+  if (!flag_dyn_ipa || !L_IPO_COMP_MODE)
+    {
+      parser_parsing_start = true;
+      return;
+    }
+
+  prev_module_scope = current_module_scope;
+  if (L_IPO_IS_PRIMARY_MODULE)
+    {
+      gcc_assert (!prev_module_scope);
+      lang_hooks.l_ipo.save_built_in_decl_pre_parsing ();
+      parser_parsing_start = true;
+    }
+
+  gcc_assert (current_module_id);
+
+  /* Set up the module scope.  */
+  current_module_scope = get_module_scope (current_module_id);
+  return;
+}
+
+/* Restore the shared decls to their post parsing states.  */
+
+static void
+restore_post_parsing_states (void)
+{
+  current_module_id = primary_module_id;
+  current_module_scope = get_module_scope (primary_module_id);
+  set_funcdef_no (max_funcdef_no);
+  input_location = primary_module_last_loc;
+
+  restore_assembler_name_reference_bit ();
+  lang_hooks.l_ipo.restore_built_in_decl_post_module_parsing ();
+}
+
+/* Pop the current module scope (by clearing name bindings etc.)
+   and prepare for parsing of the next module.  In particular,
+   built-in decls need to be restored to the state before file
+   parsing starts.  */
+
+void
+pop_module_scope (void)
+{
+  bool is_last = false;
+  int  last_funcdef_no;
+
+  if (!flag_dyn_ipa || !L_IPO_COMP_MODE)
+    return;
+
+  gcc_assert (current_module_id && current_module_scope);
+
+  if (L_IPO_IS_PRIMARY_MODULE)
+    primary_module_last_loc = input_location;
+
+  at_eof = 1;
+  cgraph_process_same_body_aliases ();
+  lang_hooks.l_ipo.process_pending_decls (input_location);
+  lang_hooks.l_ipo.clear_deferred_fns ();
+  at_eof = 0;
+
+  is_last = is_last_module (current_module_id);
+
+  last_funcdef_no = get_last_funcdef_no ();
+  if (last_funcdef_no > max_funcdef_no)
+    max_funcdef_no = last_funcdef_no;
+
+  lang_hooks.l_ipo.save_built_in_decl_post_module_parsing ();
+  /* Save primary module state if needed (when module group
+     size > 1)  */
+  if (L_IPO_IS_PRIMARY_MODULE && num_in_fnames > 1)
+    {
+      save_assembler_name_reference_bit ();
+      primary_module_last_funcdef_no = last_funcdef_no;
+    }
+
+  if (!is_last)
+    {
+      /* More aux modules are anticipated, clear
+         the parsing state.  */
+      gcc_assert (num_in_fnames > 1);
+      clear_assembler_name_reference_bit ();
+      clear_module_scope_bindings (current_module_scope);
+      /* Restore symtab bindings for builtins  */
+      lang_hooks.l_ipo.restore_built_in_decl_pre_parsing ();
+      /* The map can not be cleared because the names of operator
+         decls are used to store the information about the conversion
+         target type. This forces the coversion operator ids to be
+         incremented across different modules, and assember id must
+         be used for checksum computation.  */
+      /* cp_clear_conv_type_map (); */
+    }
+  else if (num_in_fnames > 1)
+   {
+     clear_module_scope_bindings (current_module_scope);
+     restore_post_parsing_states ();
+   }
+  else
+    gcc_assert (L_IPO_IS_PRIMARY_MODULE && num_in_fnames == 1);
+}
+
+
+/* Type merging support for LIPO  */
+
+struct type_ec
+{
+  tree rep_type;
+  vec<tree> *eq_types;
+};
+
+static vec<tree> *pending_types = NULL;
+static struct pointer_set_t *type_set = NULL;
+static htab_t type_hash_tab = NULL;
+
+/* Hash function for the type table.  */
+
+static hashval_t
+type_hash_hash (const void *ent)
+{
+  tree type, name;
+  const struct type_ec *const entry
+      = (const struct type_ec *) ent;
+
+  type = entry->rep_type;
+  name = TYPE_NAME (type);
+  if (DECL_P (name))
+    name = DECL_NAME (name);
+
+  return htab_hash_string (IDENTIFIER_POINTER (name));
+}
+
+/* Equality function for type hash table.  */
+
+static int
+type_hash_eq (const void *ent1, const void *ent2)
+{
+  tree type1, type2;
+  const struct type_ec *const entry1
+      = (const struct type_ec *) ent1;
+  const struct type_ec *const entry2
+      = (const struct type_ec *) ent2;
+
+  type1 = entry1->rep_type;
+  type2 = entry2->rep_type;
+
+  return aggr_has_equiv_id (type1, type2);
+}
+
+/* Function to delete type hash entries.  */
+
+static void
+type_hash_del (void *ent)
+{
+  struct type_ec *const entry
+      = (struct type_ec *) ent;
+
+  vec_free (entry->eq_types);
+  free (entry);
+}
+
+struct GTY(()) type_ent
+{
+  tree type;
+  unsigned eq_id;
+};
+
+static GTY ((param_is (struct type_ent))) htab_t l_ipo_type_tab = 0;
+static unsigned l_ipo_eq_id = 0;
+
+/* Address hash function for struct type_ent.  */
+
+static hashval_t
+type_addr_hash (const void *ent)
+{
+  const struct type_ent *const entry
+      = (const struct type_ent *) ent;
+  return (hashval_t) (long) entry->type;
+}
+
+/* Address equality function for type_ent.  */
+
+static int
+type_addr_eq (const void *ent1, const void *ent2)
+{
+  const struct type_ent *const entry1
+      = (const struct type_ent *) ent1;
+  const struct type_ent *const entry2
+      = (const struct type_ent *) ent2;
+  return entry1->type == entry2->type;
+}
+
+/* Returns 1 if NS1 and NS2 refer to the same namespace.  */
+
+static int
+is_ns_equiv (tree ns1, tree ns2)
+{
+  tree n1, n2;
+  if (ns1 == NULL && ns2 == NULL)
+    return 1;
+
+  if ((!ns1 && ns2) || (ns1 && !ns2))
+    return 0;
+
+  gcc_assert (DECL_P (ns1) && DECL_P (ns2));
+
+  if (!is_ns_equiv (DECL_CONTEXT (ns1),
+                    DECL_CONTEXT (ns2)))
+      return 0;
+
+  n1 = DECL_NAME (ns1);
+  n2 = DECL_NAME (ns2);
+  if (n1 == 0 && n2 == 0)
+    /* Conservative (which can happen when two NSes are from
+       different modules but with same UID) quivalence is allowed.  */
+    return DECL_UID (ns1) == DECL_UID (ns2);
+  if (!n1 || !n2)
+    return 0;
+
+  if (!strcmp (IDENTIFIER_POINTER (n1),
+               IDENTIFIER_POINTER (n2)))
+    return 1;
+
+  return 0;
+}
+
+/* Returns 1 if aggregate type T1 and T2 have equivalent qualified
+   ids.  */
+
+static int
+aggr_has_equiv_id (tree t1, tree t2)
+{
+  int ctx_match;
+  tree ctx1, ctx2, tn1, tn2;
+  gcc_assert (TYPE_P (t1) && TYPE_P (t2));
+
+  ctx1 = TYPE_CONTEXT (t1);
+  ctx2 = TYPE_CONTEXT (t2);
+
+  if ((ctx1 && !ctx2) || (!ctx1 && ctx2))
+    return 0;
+
+  if (ctx1 && TREE_CODE (ctx1) != TREE_CODE (ctx2))
+    return 0;
+
+  if (ctx1 && (TREE_CODE (ctx1) == FUNCTION_DECL
+               || TREE_CODE (ctx1) == BLOCK))
+    return 0;
+
+  if (!ctx1)
+    {
+      ctx_match = 1;
+      gcc_assert (!ctx2);
+    }
+  else if (TREE_CODE (ctx1) == NAMESPACE_DECL)
+    ctx_match = is_ns_equiv (ctx1, ctx2);
+  else if (TYPE_P (ctx1))
+    ctx_match = aggr_has_equiv_id (ctx1, ctx2);
+  else
+    {
+      gcc_assert (TREE_CODE (ctx1) == TRANSLATION_UNIT_DECL);
+      ctx_match = 1;
+    }
+
+  if (!ctx_match)
+    return 0;
+
+  /* Now compare the name of the types.  */
+  tn1 = TYPE_NAME (t1);
+  tn2 = TYPE_NAME (t2);
+  if ((tn1 && !tn2) || !(tn1 && tn2))
+    return 0;
+  else if (!tn1 && !tn2)
+    /* Be conservative on unamed types.  */
+    return 1;
+
+  if (DECL_P (tn1))
+    tn1 = DECL_NAME (tn1);
+  if (DECL_P (tn2))
+    tn2 = DECL_NAME (tn2);
+  if (strcmp (IDENTIFIER_POINTER (tn1),
+              IDENTIFIER_POINTER (tn2)))
+    return 0;
+
+  return lang_hooks.l_ipo.cmp_lang_type (t1, t2);
+}
+
+/* Return the canonical type of the type's main variant.  */
+static inline tree
+get_norm_type (const_tree type)
+{
+  tree cano_type = TYPE_MAIN_VARIANT (type);
+  if (TYPE_CANONICAL (cano_type))
+    cano_type = TYPE_CANONICAL (cano_type);
+
+  return cano_type;
+}
+
+/* Return 1 if type T1 and T2 are equivalent. Struct/union/class
+   types are compared using qualified name ids.  Alias sets of
+   equivalent types will be merged. Client code may choose to do
+   structural equivalence check for sanity.  Note the difference
+   between the types_compatible_p (and its langhooks subroutines)
+   and this interface. The former is mainly used to remove useless
+   type conversion and value numbering computation. It returns 1
+   only when it is sure and should not be used in contexts where
+   erroneously returning 0 causes problems. This interface
+   lipo_cmp_type behaves differently - it returns 1 when it is not
+   sure -- as the primary purpose of the interface is for alias
+   set computation.  */
+
+int
+lipo_cmp_type (tree t1, tree t2)
+{
+  if (TREE_CODE (t1) != TREE_CODE (t2))
+    return 0;
+  if (TYPE_READONLY (t1) != TYPE_READONLY (t2))
+    return 0;
+  if (TYPE_VOLATILE (t1) != TYPE_VOLATILE (t2))
+    return 0;
+
+  t1 = get_norm_type (t1);
+  t2 = get_norm_type (t2);
+
+  switch (TREE_CODE (t1))
+    {
+    case RECORD_TYPE:
+    case UNION_TYPE:
+    case QUAL_UNION_TYPE:
+      return aggr_has_equiv_id (t1, t2);
+
+    case POINTER_TYPE:
+    case REFERENCE_TYPE:
+    case COMPLEX_TYPE:
+      return lipo_cmp_type (TREE_TYPE (t1), TREE_TYPE (t2));
+    case ARRAY_TYPE:
+      return (TYPE_DOMAIN (t1) == NULL || TYPE_DOMAIN (t2) == NULL
+              || (lipo_cmp_type (TYPE_DOMAIN (t1), TYPE_DOMAIN (t2))
+                  && lipo_cmp_type (TREE_TYPE (t1), TREE_TYPE (t2))));
+    case METHOD_TYPE:
+      return lipo_cmp_type (TYPE_METHOD_BASETYPE (t1),
+                            TYPE_METHOD_BASETYPE (t2));
+    case FUNCTION_TYPE:
+      {
+        tree arg1, arg2;
+        for (arg1 = TYPE_ARG_TYPES (t1), arg2 = TYPE_ARG_TYPES (t2);
+             arg1 && arg2;
+             arg1 = TREE_CHAIN (arg1), arg2 = TREE_CHAIN (arg2))
+          if (!lipo_cmp_type (TREE_VALUE (arg1),
+                              TREE_VALUE (arg2)))
+            return 0;
+        if (arg1 || arg2)
+          return 0;
+        return 1;
+      }
+    case OFFSET_TYPE:
+      return lipo_cmp_type (TYPE_OFFSET_BASETYPE (t1),
+                            TYPE_OFFSET_BASETYPE (t2));
+    case ENUMERAL_TYPE:
+      return lipo_cmp_type (TREE_TYPE (t1), TREE_TYPE (t2));
+    case REAL_TYPE:
+    case FIXED_POINT_TYPE:
+    case INTEGER_TYPE:
+      return (TYPE_PRECISION (t1) == TYPE_PRECISION (t2)
+              && TYPE_MODE (t1) == TYPE_MODE (t2)
+              && TYPE_MIN_VALUE (t1) == TYPE_MIN_VALUE (t2)
+              && TYPE_MAX_VALUE (t1) == TYPE_MAX_VALUE (t2));
+    case VECTOR_TYPE:
+      return (TYPE_VECTOR_SUBPARTS (t1) == TYPE_VECTOR_SUBPARTS (t2)
+              && lipo_cmp_type (TREE_TYPE (t1), TREE_TYPE (t2)));
+    case VOID_TYPE:
+    case BOOLEAN_TYPE:
+      return 1;
+    case TEMPLATE_TYPE_PARM:
+      return 1;
+    default:
+      gcc_unreachable ();
+    }
+}
+
+#ifndef ANON_AGGRNAME_PREFIX
+#define ANON_AGGRNAME_PREFIX "__anon_"
+#endif
+#ifndef ANON_AGGRNAME_P
+#define ANON_AGGRNAME_P(ID_NODE) \
+  (!strncmp (IDENTIFIER_POINTER (ID_NODE), ANON_AGGRNAME_PREFIX, \
+	     sizeof (ANON_AGGRNAME_PREFIX) - 1))
+#endif
+
+/* Callback function used in tree walk to find referenced struct types.  */
+
+static tree
+find_struct_types (tree *tp,
+                   int *walk_subtrees ATTRIBUTE_UNUSED,
+                   void *data ATTRIBUTE_UNUSED)
+{
+  if (!(*tp))
+    return NULL_TREE;
+
+  if (TYPE_P (*tp))
+    {
+      if (lang_hooks.l_ipo.is_compiler_generated_type (*tp))
+        return NULL_TREE;
+
+      switch (TREE_CODE (*tp))
+        {
+        case RECORD_TYPE:
+        case UNION_TYPE:
+        case QUAL_UNION_TYPE:
+          {
+            tree cano_type, name;
+            tree context;
+            tree field;
+
+            cano_type = get_norm_type (*tp);
+            name = TYPE_NAME (cano_type);
+            if (!name)
+              {
+                /* the main variant of typedef of unnamed struct
+                   has no name, use the orignal type for equivalence.  */
+                cano_type = *tp;
+                name = TYPE_NAME (cano_type);
+              }
+            if (!name)
+              return NULL_TREE;
+            if (DECL_P (name)
+                && (DECL_IGNORED_P (name)
+                    || ANON_AGGRNAME_P (DECL_NAME (name))))
+              return NULL_TREE;
+
+            if (!pointer_set_insert (type_set, cano_type))
+              pending_types->safe_push (cano_type);
+            else
+              return NULL_TREE; /* Or use walk tree without dups.  */
+
+            context = TYPE_CONTEXT (cano_type);
+            if (context && TYPE_P (context))
+              walk_tree (&context, find_struct_types, NULL, NULL);
+
+            /* Instantiate a nested work as the tree walker does not
+               get to the fields.  */
+            if (TYPE_BINFO (cano_type))
+	      {
+                int i;
+                tree binfo, base_binfo;
+
+                for (binfo = TYPE_BINFO (cano_type), i = 0;
+                     BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)
+                  walk_tree (&BINFO_TYPE (base_binfo), find_struct_types,
+                             NULL, NULL);
+              }
+            for (field = TYPE_FIELDS (cano_type);
+                 field != 0;
+                 field = TREE_CHAIN (field))
+              walk_tree (&TREE_TYPE (field), find_struct_types,
+                         NULL, NULL);
+            return NULL_TREE;
+          }
+        default:
+          return NULL_TREE;
+        }
+    }
+  else if (DECL_P (*tp))
+    /* walk tree does not walk down decls, so do a nested walk here.  */
+    walk_tree (&(TREE_TYPE (*tp)), find_struct_types, NULL, NULL);
+
+  return NULL_TREE;
+}
+
+/* Collect referenced struct types.  */
+
+static void
+cgraph_collect_type_referenced (void)
+{
+  basic_block bb;
+  gimple_stmt_iterator gi;
+
+  FOR_EACH_BB (bb)
+    {
+      for (gi = gsi_start_bb (bb); !gsi_end_p (gi); gsi_next (&gi))
+        {
+          unsigned i;
+	  gimple stmt = gsi_stmt (gi);
+	  for (i = 0; i < gimple_num_ops (stmt); i++)
+	    walk_tree (gimple_op_ptr (stmt, i), find_struct_types, NULL, NULL);
+	}
+    }
+}
+
+/* Check type equivalence. Returns 1 if T1 and T2 are equivalent
+   for tbaa; return 0 if not. -1 is returned if it is unknown.  */
+
+int
+equivalent_struct_types_for_tbaa (const_tree t1, const_tree t2)
+{
+  struct type_ent key, *tent1, *tent2,  **slot;
+
+  if (!l_ipo_type_tab)
+    return -1;
+
+  t1 = get_norm_type (t1);
+  t2 = get_norm_type (t2);
+
+  key.type = (tree) (long) t1;
+  slot = (struct type_ent **)
+      htab_find_slot (l_ipo_type_tab, &key, NO_INSERT);
+  if (!slot || !*slot)
+    return -1;
+  tent1 = *slot;
+
+  key.type = (tree) (long) t2;
+  slot = (struct type_ent **)
+      htab_find_slot (l_ipo_type_tab, &key, NO_INSERT);
+  if (!slot || !*slot)
+    return -1;
+  tent2 = *slot;
+
+  return tent1->eq_id == tent2->eq_id;
+}
+
+/* Build type hash table.  */
+
+static void
+cgraph_build_type_equivalent_classes (void)
+{
+  unsigned n, i;
+  n = pending_types->length ();
+  for (i = 0; i < n; i++)
+    {
+      struct type_ec **slot;
+      struct type_ec te;
+      te.rep_type  = (*pending_types)[i];
+      te.eq_types = NULL;
+      slot = (struct type_ec **) htab_find_slot (type_hash_tab,
+                                                 &te, INSERT);
+      if (!*slot)
+        {
+          *slot = XCNEW (struct type_ec);
+          (*slot)->rep_type = te.rep_type;
+          vec_alloc ((*slot)->eq_types, 10);
+        }
+      (*slot)->eq_types->safe_push (te.rep_type);
+    }
+}
+
+/* Re-propagate component types's alias set to that of TYPE. PROCESSED
+   is the pointer set of processed types.  */
+
+static void
+re_record_component_aliases (tree type,
+                             struct pointer_set_t *processed)
+{
+  alias_set_type superset = get_alias_set (type);
+  tree field;
+
+  if (superset == 0)
+    return;
+
+  if (pointer_set_insert (processed, type))
+    return;
+
+  switch (TREE_CODE (type))
+    {
+    case RECORD_TYPE:
+    case UNION_TYPE:
+    case QUAL_UNION_TYPE:
+      /* Recursively record aliases for the base classes, if there are any.  */
+      if (TYPE_BINFO (type))
+	{
+	  int i;
+	  tree binfo, base_binfo;
+
+	  for (binfo = TYPE_BINFO (type), i = 0;
+	       BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)
+            {
+              re_record_component_aliases (BINFO_TYPE (base_binfo),
+                                           processed);
+              record_alias_subset (superset,
+                                   get_alias_set (BINFO_TYPE (base_binfo)));
+            }
+	}
+      for (field = TYPE_FIELDS (type); field != 0; field = TREE_CHAIN (field))
+	if (TREE_CODE (field) == FIELD_DECL && !DECL_NONADDRESSABLE_P (field))
+          {
+            re_record_component_aliases (TREE_TYPE (field), processed);
+            record_alias_subset (superset, get_alias_set (TREE_TYPE (field)));
+          }
+      break;
+
+    case COMPLEX_TYPE:
+      re_record_component_aliases (TREE_TYPE (type), processed);
+      record_alias_subset (superset, get_alias_set (TREE_TYPE (type)));
+      break;
+
+    /* VECTOR_TYPE and ARRAY_TYPE share the alias set with their
+       element type.  */
+
+    default:
+      break;
+    }
+}
+
+/* The callback function to merge alias sets of equivalent types.  */
+
+static int
+type_eq_process (void **slot, void *data ATTRIBUTE_UNUSED)
+{
+  unsigned i;
+  alias_set_type alias_set, ptr_alias_set = -1;
+  tree rep_type, type;
+  vec<tree> *eq_types;
+  struct type_ec ** te = (struct type_ec **)slot;
+  bool zero_set = false, ptr_zero_set = false;
+  struct type_ent **slot2, key, *tent;
+
+
+  rep_type = (*te)->rep_type;
+  eq_types = (*te)->eq_types;
+  alias_set = get_alias_set (rep_type);
+
+  for (i = 0; eq_types->iterate (i, &type); ++i)
+    {
+      alias_set_type als, ptr_als = -1;
+      tree type_ptr = TYPE_POINTER_TO (type);;
+
+      als = get_alias_set (type);
+      if (als == 0)
+        zero_set = true;
+
+      if (alias_set && als && alias_set != als)
+        record_alias_subset (alias_set, als);
+
+      if (type_ptr)
+        {
+          ptr_als = get_alias_set (type_ptr);
+          if (ptr_als == 0)
+            ptr_zero_set = true;
+
+          if (ptr_alias_set == -1)
+            ptr_alias_set = ptr_als;
+          else
+            {
+              if (!ptr_zero_set && ptr_alias_set != ptr_als)
+                record_alias_subset (ptr_alias_set, ptr_als);
+            }
+        }
+    }
+
+  /* Now propagate back.  */
+  for (i = 0; eq_types->iterate (i, &type); ++i)
+    {
+      alias_set_type als, ptr_als;
+      tree ptr_type = TYPE_POINTER_TO (type);
+
+      als = get_alias_set (type);
+
+      if (zero_set)
+        TYPE_ALIAS_SET (type) = 0;
+      else if (alias_set != als)
+        record_alias_subset (als, alias_set);
+
+      if (ptr_type)
+        {
+          ptr_als = get_alias_set (ptr_type);
+          if (ptr_zero_set)
+            TYPE_ALIAS_SET (ptr_type) = 0;
+          else if (ptr_alias_set != ptr_als)
+            record_alias_subset (ptr_als, ptr_alias_set);
+        }
+    }
+
+
+  /* Now populate the type table.  */
+  l_ipo_eq_id++;
+  for (i = 0; eq_types->iterate (i, &type); ++i)
+    {
+      key.type = type;
+      slot2 = (struct type_ent **)
+          htab_find_slot (l_ipo_type_tab, &key, INSERT);
+      tent = *slot2;
+      gcc_assert (!tent);
+      tent = ggc_alloc_cleared_type_ent ();
+      tent->type = key.type;
+      tent->eq_id = l_ipo_eq_id;
+      *slot2 = tent;
+    }
+
+  return 1;
+}
+
+/* Regenerate alias set for aggregate types.  */
+
+static void
+record_components_for_parent_types (void)
+{
+  unsigned n, i;
+  struct pointer_set_t *processed_types;
+
+  processed_types = pointer_set_create ();
+  n = pending_types->length ();
+  for (i = 0; i < n; i++)
+    {
+      tree type = (*pending_types)[i];
+      re_record_component_aliases (type, processed_types);
+    }
+
+  pointer_set_destroy (processed_types);
+}
+
+/* Unify type alias sets for equivalent types.  */
+
+void
+cgraph_unify_type_alias_sets (void)
+{
+  struct cgraph_node *node;
+  struct varpool_node *pv;
+
+  if (!L_IPO_COMP_MODE)
+    return;
+
+  vec_alloc (pending_types, 100);
+  type_set = pointer_set_create ();
+  type_hash_tab = htab_create (10, type_hash_hash,
+                               type_hash_eq, type_hash_del);
+  l_ipo_type_tab = htab_create_ggc (10, type_addr_hash,
+                                    type_addr_eq, NULL);
+
+  FOR_EACH_DEFINED_FUNCTION (node)
+    {
+      if (!gimple_has_body_p (node->symbol.decl))
+	continue;
+      push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));
+      current_function_decl = node->symbol.decl;
+      if (gimple_has_body_p (current_function_decl))
+        cgraph_collect_type_referenced ();
+      current_function_decl = NULL;
+      set_cfun (NULL);
+      pop_cfun ();
+    }
+
+  FOR_EACH_VARIABLE (pv)
+    walk_tree (&pv->symbol.decl, find_struct_types, NULL, NULL);
+
+  /* Compute type equivalent classes.  */
+  cgraph_build_type_equivalent_classes ();
+  /* Now unify alias sets of equivelent types.  */
+  htab_traverse (type_hash_tab, type_eq_process, NULL);
+  /* Finally re-populating parent's alias set.  */
+  record_components_for_parent_types ();
+
+  pointer_set_destroy (type_set);
+  vec_free (pending_types);
+  htab_delete (type_hash_tab);
+}
+
+/* Return true if NODE->decl from an auxiliary module has external
+   definition (and therefore is not needed for expansion).  */
+
+bool
+cgraph_is_aux_decl_external (struct cgraph_node *node)
+{
+  tree decl = node->symbol.decl;
+
+  if (!L_IPO_COMP_MODE)
+    return false;
+
+  if (!cgraph_is_auxiliary (decl))
+    return false;
+
+  /* Versioned clones from auxiliary moduels are not external.  */
+  if (node->is_versioned_clone)
+    return false;
+
+  /* Comdat or weak functions in aux modules are not external --
+     there is no guarantee that the definitition will be emitted
+     in the primary compilation of this auxiliary module.  */
+  if (DECL_COMDAT (decl) || DECL_WEAK (decl))
+    return false;
+
+  /* virtual functions won't be deleted in the primary module.  */
+  if (DECL_VIRTUAL_P (decl))
+    return true;
+
+  if (!TREE_PUBLIC (decl))
+    return false;
+
+  /* The others from aux modules are external. */
+  return true;
+}
+
+/* Linked function symbol (cgraph node)  table.  */
+static GTY((param_is (struct cgraph_sym))) htab_t cgraph_symtab;
+
+/* This is true when global linking is needed and performed (for C++).
+   For C, symbol linking is performed on the fly during parsing, and
+   the cgraph_symtab is used only for keeping additional information
+   for any already merged symbol if needed.  */
+
+static bool global_link_performed = 0;
+
+/* For an external (non-defined) function DECL, return the primary
+   module id (even though when the declaration is declared in an aux
+   module). For a defined function DECL, return the module id in which
+   it is defined.  */
+
+unsigned
+cgraph_get_module_id (tree decl)
+{
+  struct function *func = DECL_STRUCT_FUNCTION (decl);
+  /* Not defined.  */
+  if (!func)
+    return primary_module_id;
+  return FUNC_DECL_MODULE_ID (func);
+}
+
+/* Return true if function decl is defined in an auxiliary module.  */
+
+bool
+cgraph_is_auxiliary (tree decl)
+{
+  return (cgraph_get_module_id (decl) != primary_module_id);
+}
+
+/* Return the hash value for cgraph_sym pointed to by P. The
+   hash value is computed using function's assembler name.  */
+
+static hashval_t
+hash_sym_by_assembler_name (const void *p)
+{
+  const struct cgraph_sym *n = (const struct cgraph_sym *) p;
+  return (hashval_t) decl_assembler_name_hash (n->assembler_name);
+}
+
+/* Return nonzero if P1 and P2 are equal.  */
+
+static int
+eq_assembler_name (const void *p1, const void *p2)
+{
+  const struct cgraph_sym *n1 = (const struct cgraph_sym *) p1;
+  const_tree name = (const_tree) p2;
+  return (decl_assembler_name_equal (n1->rep_decl, name));
+}
+
+/* Return the cgraph_sym for function declaration DECL.  */
+
+static struct cgraph_sym **
+cgraph_sym (tree decl)
+{
+  struct cgraph_sym **slot;
+  tree name;
+
+  if (!cgraph_symtab)
+    {
+      gcc_assert (!global_link_performed);
+      return NULL;
+    }
+
+  name = DECL_ASSEMBLER_NAME (decl);
+  slot = (struct cgraph_sym **)
+      htab_find_slot_with_hash (cgraph_symtab, name,
+                                decl_assembler_name_hash (name),
+                                NO_INSERT);
+  return slot;
+}
+
+/* Return the representative declaration for assembler name
+   ASM_NAME.  */
+
+tree
+cgraph_find_decl (tree asm_name)
+{
+  struct cgraph_sym **slot;
+  if (!L_IPO_COMP_MODE)
+    return NULL;
+  if (!cgraph_symtab || !global_link_performed)
+    return NULL;
+
+  slot = (struct cgraph_sym **)
+      htab_find_slot_with_hash (cgraph_symtab, asm_name,
+                                decl_assembler_name_hash (asm_name),
+                                NO_INSERT);
+  if (!slot || !*slot)
+    return NULL;
+
+  return (*slot)->rep_node->symbol.decl;
+}
+
+/* Return true if function declaration DECL is originally file scope
+   static, which is promoted to global scope.  */
+
+bool
+cgraph_is_promoted_static_func (tree decl)
+{
+  struct cgraph_sym ** sym;
+  gcc_assert (L_IPO_COMP_MODE);
+
+  /* cgraph_symtab will be created when any symbol got
+     promoted.  */
+  if (!cgraph_symtab)
+    return false;
+
+  sym = cgraph_sym (decl);
+  if (!sym)
+    return false;
+  return (*sym)->is_promoted_static;
+}
+
+/* Hash function for module information table. ENT
+   is a pointer to a cgraph_module_info.  */
+
+static hashval_t
+htab_sym_hash (const void *ent)
+{
+  const struct cgraph_mod_info * const mi
+      = (const struct cgraph_mod_info * const ) ent;
+  return (hashval_t) mi->module_id;
+}
+
+/* Hash equality function for module information table.  */
+
+static int
+htab_sym_eq (const void *ent1, const void *ent2)
+{
+  const struct cgraph_mod_info * const mi1
+      = (const struct cgraph_mod_info * const ) ent1;
+  const struct cgraph_mod_info * const mi2
+      = (const struct cgraph_mod_info * const ) ent2;
+  return (mi1->module_id == mi2->module_id);
+}
+
+/* cgraph_sym SYM may be defined in more than one source modules.
+   Add declaration DECL's definiting module to SYM.  */
+
+static void
+add_define_module (struct cgraph_sym *sym, tree decl)
+{
+  unsigned module_id;
+  struct cgraph_mod_info **slot;
+  struct cgraph_mod_info mi;
+
+  struct function *f = DECL_STRUCT_FUNCTION (decl);
+  if (!f)
+    return;
+  module_id = FUNC_DECL_MODULE_ID (f);
+
+  if (!sym->def_module_hash)
+    sym->def_module_hash
+        = htab_create_ggc (10, htab_sym_hash, htab_sym_eq, NULL);
+
+  mi.module_id = module_id;
+  slot = (struct cgraph_mod_info **)htab_find_slot (sym->def_module_hash,
+                                                    &mi, INSERT);
+  if (!*slot)
+    {
+      *slot = ggc_alloc_cleared_cgraph_mod_info ();
+      (*slot)->module_id = module_id;
+    }
+  else
+    gcc_assert ((*slot)->module_id == module_id);
+}
+
+static int
+add_def_module (void **slot, void *data)
+{
+  struct cgraph_mod_info **m = (struct cgraph_mod_info **)slot;
+  htab_t mod_set = (htab_t) data;
+  struct cgraph_mod_info **new_slot;
+
+  new_slot = (struct cgraph_mod_info **)htab_find_slot (mod_set, *m, INSERT);
+  if (!*new_slot)
+    {
+      *new_slot = ggc_alloc_cleared_cgraph_mod_info ();
+      (*new_slot)->module_id = (*m)->module_id;
+    }
+  else
+    gcc_assert ((*new_slot)->module_id == (*m)->module_id);
+  return 1;
+}
+
+/* Clone defined module hash table from ORIG to CLONE.  */
+
+void
+copy_defined_module_set (tree clone, tree orig)
+{
+  struct cgraph_sym **orig_sym, **clone_sym;
+
+  orig_sym = cgraph_sym (orig);
+  clone_sym = cgraph_sym (clone);
+  if (!orig_sym || !(*orig_sym)->def_module_hash)
+    return;
+  if (!(*clone_sym)->def_module_hash)
+    (*clone_sym)->def_module_hash
+      = htab_create_ggc (10, htab_sym_hash, htab_sym_eq, NULL);
+  htab_traverse ((*orig_sym)->def_module_hash, add_def_module, (*clone_sym)->def_module_hash);
+}
+
+/* Return true if the symbol associated with DECL is defined in module
+   MODULE_ID.  This interface is used by the inliner to make sure profile-gen
+   and profile-use pass (L-IPO mode) make consistent inline decision.  */
+
+bool
+cgraph_is_inline_body_available_in_module (tree decl, unsigned module_id)
+{
+  struct cgraph_sym **sym;
+  void **slot;
+  struct cgraph_mod_info mi;
+
+  gcc_assert (L_IPO_COMP_MODE);
+
+  if (DECL_BUILT_IN (decl))
+    return true;
+
+  /* TODO: revisit this.  */
+  if (DECL_IN_SYSTEM_HEADER (decl) && DECL_DECLARED_INLINE_P (decl))
+    return true;
+
+  gcc_assert (TREE_STATIC (decl) || DECL_DECLARED_INLINE_P (decl));
+
+  if (cgraph_get_module_id (decl) == module_id)
+    return true;
+
+  sym = cgraph_sym (decl);
+  if (!sym || !(*sym)->def_module_hash)
+    return false;
+
+  mi.module_id = module_id;
+  slot = htab_find_slot ((*sym)->def_module_hash, &mi, NO_INSERT);
+  if (slot)
+    {
+      gcc_assert (((struct cgraph_mod_info*)*slot)->module_id == module_id);
+      return true;
+    }
+  return false;
+}
+
+/* Return the linked cgraph node using DECL's assembler name.  DO_ASSERT
+   is a flag indicating that a non null link target must be returned.  */
+
+struct cgraph_node *
+cgraph_lipo_get_resolved_node_1 (tree decl, bool do_assert)
+{
+  struct cgraph_sym **slot;
+
+  /* Handle alias decl. */
+  slot = cgraph_sym (decl);
+
+  if (!slot || !*slot)
+    {
+      if (!do_assert)
+        return NULL;
+      else
+        {
+          /* Nodes that are indirectly called are not 'reachable' in
+             the callgraph. If they are not needed (comdat, inline
+             extern etc), they may be removed from the link table
+             before direct calls to them are exposed (via indirect
+             call promtion by const folding etc). When this happens,
+             the node will need to be relinked. A probably better fix
+             is to modify the callgraph so that they are not eliminated
+             in the first place -- this will allow inlining to happen.  */
+
+          struct cgraph_node *n = cgraph_get_create_node (decl);
+          if (!n->analyzed)
+            {
+              gcc_assert (DECL_EXTERNAL (decl)
+                          || cgraph_is_aux_decl_external (n)
+                          || DECL_VIRTUAL_P (decl));
+              gcc_assert (/* This is the case for explicit extern instantiation,
+                             when cgraph node is not created before link.  */
+                          DECL_EXTERNAL (decl));
+              cgraph_link_node (n);
+              return n;
+            }
+          else
+            gcc_unreachable ();
+        }
+    }
+  else
+    {
+      struct cgraph_sym *sym = *slot;
+      return sym->rep_node;
+    }
+}
+
+/* Return the cgraph_node of DECL if decl has definition; otherwise return
+   the cgraph node of the representative decl, which is the declaration DECL
+   is resolved to after linking/symbol resolution.  */
+
+struct cgraph_node *
+cgraph_lipo_get_resolved_node (tree decl)
+{
+  struct cgraph_node *node = NULL;
+
+  gcc_assert (L_IPO_COMP_MODE && global_link_performed);
+  gcc_assert (cgraph_symtab);
+
+  /* Never merged.  */
+  if (!TREE_PUBLIC (decl) || DECL_ARTIFICIAL (decl)
+      /* builtin function decls are shared across modules, but 'linking'
+         is still performed for them to keep track of the set of defining
+         modules. Skip the real resolution here to avoid merging '__builtin_xxx'
+         with 'xxx'.  */
+      || DECL_BUILT_IN (decl))
+    return cgraph_get_create_node (decl);
+
+  node = cgraph_lipo_get_resolved_node_1 (decl, true);
+  return node;
+}
+
+/* When NODE->decl is dead function eliminated,
+   remove the entry in the link table.  */
+
+void
+cgraph_remove_link_node (struct cgraph_node *node)
+{
+  tree name, decl;
+
+  if (!L_IPO_COMP_MODE || !cgraph_symtab)
+    return;
+
+  decl = node->symbol.decl;
+
+  /* Skip nodes that are not in the link table.  */
+  if (!TREE_PUBLIC (decl) || DECL_ARTIFICIAL (decl))
+    return;
+
+  /* Skip if node is an inline clone or if the node has
+     defintion that is not really resolved to the merged node.  */
+  if (cgraph_lipo_get_resolved_node_1 (decl, false) != node)
+    return;
+
+  name = DECL_ASSEMBLER_NAME (decl);
+  htab_remove_elt_with_hash (cgraph_symtab, name,
+                             decl_assembler_name_hash (name));
+}
+
+/* Return true if the function body for DECL has profile information.  */
+
+static bool
+has_profile_info (tree decl)
+{
+  gcov_type *ctrs = NULL;
+  unsigned n;
+  struct function* f = DECL_STRUCT_FUNCTION (decl);
+
+  ctrs = get_coverage_counts_no_warn (f, GCOV_COUNTER_ARCS, &n);
+  if (ctrs)
+    {
+      unsigned i;
+      for (i = 0; i < n; i++)
+        if (ctrs[i])
+          return true;
+    }
+
+  return false;
+}
+
+/* Resolve delaration NODE->decl for function symbol *SLOT.  */
+
+static void
+resolve_cgraph_node (struct cgraph_sym **slot, struct cgraph_node *node)
+{
+  tree decl1, decl2;
+  int decl1_defined = 0;
+  int decl2_defined = 0;
+
+  decl1 = (*slot)->rep_decl;
+  decl2 = node->symbol.decl;
+
+  decl1_defined = gimple_has_body_p (decl1);
+  decl2_defined = gimple_has_body_p (decl2);
+
+  if (decl1_defined && !decl2_defined)
+    return;
+
+  if (!decl1_defined && decl2_defined)
+    {
+      (*slot)->rep_node = node;
+      (*slot)->rep_decl = decl2;
+      add_define_module (*slot, decl2);
+      return;
+    }
+
+  if (decl2_defined)
+    {
+      bool has_prof1 = false;
+      bool has_prof2 = false;
+      gcc_assert (decl1_defined);
+      add_define_module (*slot, decl2);
+
+      has_prof1 = has_profile_info (decl1);
+      if (has_prof1)
+        return;
+      has_prof2 = has_profile_info (decl2);
+      if (has_prof2)
+        {
+          (*slot)->rep_node = node;
+          (*slot)->rep_decl = decl2;
+        }
+      return;
+    }
+  return;
+}
+
+
+/* Resolve NODE->decl in the function symbol table.  */
+
+struct cgraph_sym *
+cgraph_link_node (struct cgraph_node *node)
+{
+  void **slot;
+  tree name;
+
+  if (!L_IPO_COMP_MODE)
+    return NULL;
+
+  if (!cgraph_symtab)
+    return NULL;
+
+  /* Skip the cases when the  defintion can be locally resolved, and
+     when we do not need to keep track of defining modules.  */
+  if (!TREE_PUBLIC (node->symbol.decl) || DECL_ARTIFICIAL (node->symbol.decl))
+    return NULL;
+
+  name = DECL_ASSEMBLER_NAME (node->symbol.decl);
+  slot = htab_find_slot_with_hash (cgraph_symtab, name,
+                                   decl_assembler_name_hash (name),
+                                   INSERT);
+  if (*slot)
+    resolve_cgraph_node ((struct cgraph_sym **) slot, node);
+  else
+    {
+      struct cgraph_sym *sym = ggc_alloc_cleared_cgraph_sym ();
+      sym->rep_node = node;
+      sym->rep_decl = node->symbol.decl;
+      sym->assembler_name = name;
+      add_define_module (sym, node->symbol.decl);
+      *slot = sym;
+    }
+  return (struct cgraph_sym *) *slot;
+}
+
+/* Perform cross module linking of function declarations.  */
+
+void
+cgraph_do_link (void)
+{
+  struct cgraph_node *node;
+
+  if (!L_IPO_COMP_MODE)
+    return;
+
+  global_link_performed = 1;
+  gcc_assert (cgraph_pre_profiling_inlining_done);
+
+  if (!cgraph_symtab)
+    cgraph_symtab
+        = htab_create_ggc (10, hash_sym_by_assembler_name,
+                           eq_assembler_name, NULL);
+
+  FOR_EACH_FUNCTION (node)
+    {
+      gcc_assert (!node->global.inlined_to);
+      cgraph_link_node (node);
+    }
+}
+
+struct promo_ent
+{
+  char* assemb_name;
+  int seq;
+};
+
+/* Hash function for promo_ent table.  */
+
+static hashval_t
+promo_ent_hash (const void *ent)
+{
+  const struct promo_ent *const entry
+      = (const struct promo_ent *) ent;
+
+  return htab_hash_string (entry->assemb_name);
+}
+
+/* Hash_eq function for promo_ent table.  */
+
+static int
+promo_ent_eq (const void *ent1, const void *ent2)
+{
+  const struct promo_ent *const entry1
+      = (const struct promo_ent *) ent1;
+  const struct promo_ent *const entry2
+      = (const struct promo_ent *) ent2;
+  if (!strcmp (entry1->assemb_name, entry2->assemb_name))
+    return 1;
+  return 0;
+}
+
+/* Delete function for promo_ent hash table.  */
+
+static void
+promo_ent_del (void *ent)
+{
+  struct promo_ent *const entry
+      = (struct promo_ent *) ent;
+
+  free (entry->assemb_name);
+  free (entry);
+}
+
+static htab_t promo_ent_hash_tab = NULL;
+
+/* Return a unique sequence number for NAME. This is needed to avoid
+   name conflict -- function scope statics may have identical names.
+
+   This function returns a zero sequence number if it is called with
+   a particular NAME for the first time, and non-zero otherwise.
+   This fact is used to keep track of unseen weak variables.  */
+
+static int
+get_name_seq_num (const char *name)
+{
+  struct promo_ent **slot;
+  struct promo_ent ent;
+  ent.assemb_name = xstrdup (name);
+  ent.seq = 0;
+
+  slot = (struct promo_ent **)
+      htab_find_slot (promo_ent_hash_tab, &ent, INSERT);
+
+  if (!*slot)
+    {
+      *slot = XCNEW (struct promo_ent);
+      (*slot)->assemb_name = ent.assemb_name;
+    }
+  else
+    {
+      (*slot)->seq++;
+      free (ent.assemb_name);
+    }
+  return (*slot)->seq;
+}
+
+/* Returns a unique assembler name for DECL.  */
+
+static tree
+create_unique_name (tree decl, unsigned module_id)
+{
+  tree id, assemb_id;
+  char *assembler_name;
+  const char *name;
+  struct  function *context = NULL;
+  int seq = 0;
+
+  if (TREE_CODE (decl) == FUNCTION_DECL)
+    {
+      if (!DECL_CONTEXT (decl)
+          || TREE_CODE (DECL_CONTEXT (decl)) == TRANSLATION_UNIT_DECL)
+        {
+          id = DECL_NAME (decl);
+          /* if (IDENTIFIER_OPNAME_P (id))  */
+          if (TREE_LANG_FLAG_2 (id))
+            id = DECL_ASSEMBLER_NAME (decl);
+        }
+      else
+        id = DECL_ASSEMBLER_NAME (decl);
+    }
+  else
+    {
+      if (!DECL_CONTEXT (decl))
+        id = DECL_NAME (decl);
+      else if (TREE_CODE (DECL_CONTEXT (decl)) == NAMESPACE_DECL)
+        id = DECL_ASSEMBLER_NAME (decl);
+      else if (TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL)
+        {
+          id = DECL_NAME (decl);
+          context = DECL_STRUCT_FUNCTION (DECL_CONTEXT (decl));
+        }
+      else
+        /* file scope context */
+        id = DECL_NAME (decl);
+    }
+
+  name = IDENTIFIER_POINTER (id);
+  if (context)
+    {
+      char *n;
+      unsigned fno =  FUNC_DECL_FUNC_ID (context);
+      n = (char *)alloca (strlen (name) + 15);
+      sprintf (n, "%s.%u", name, fno);
+      name = n;
+    }
+
+  assembler_name = (char*) alloca (strlen (name) + 30);
+  sprintf (assembler_name, "%s.cmo.%u", name, module_id);
+  seq = get_name_seq_num (assembler_name);
+  if (seq)
+    sprintf (assembler_name, "%s.%d", assembler_name, seq);
+
+  assemb_id = get_identifier (assembler_name);
+
+  return assemb_id;
+}
+
+/* Promote DECL to be global. MODULE_ID is the id of the module where
+   DECL is defined. IS_EXTERN is a flag indicating if externalization
+   is needed.  */
+
+static void
+promote_static_var_func (unsigned module_id, tree decl, bool is_extern)
+{
+  tree assemb_id;
+  tree alias;
+
+  /* No need to promote symbol alias.  */
+  alias = lookup_attribute ("alias", DECL_ATTRIBUTES (decl));
+  if (alias)
+    return;
+
+  /* Function decls in C++ may contain characters not taken by assembler.
+     Similarly, function scope static variable has UID as the assembler name
+     suffix which is not consistent across modules.  */
+  assemb_id = create_unique_name (decl, module_id);
+
+  if (DECL_ASSEMBLER_NAME_SET_P (decl))
+    {
+      if (TREE_CODE (decl) == FUNCTION_DECL)
+        unlink_from_assembler_name_hash ((symtab_node) cgraph_get_create_node (decl));
+      else
+        unlink_from_assembler_name_hash ((symtab_node) varpool_get_node (decl));
+    }
+
+  SET_DECL_ASSEMBLER_NAME (decl, assemb_id);
+  TREE_PUBLIC (decl) = 1;
+  DECL_VISIBILITY (decl) = VISIBILITY_HIDDEN;
+  DECL_VISIBILITY_SPECIFIED (decl) = 1;
+
+  if (TREE_CODE (decl) == FUNCTION_DECL)
+    {
+      struct cgraph_node *node = cgraph_get_create_node (decl);
+
+      node->symbol.resolution = LDPR_UNKNOWN;
+      insert_to_assembler_name_hash ((symtab_node) node);
+    }
+  else
+    {
+      struct varpool_node *node = varpool_get_node (decl);
+      node->symbol.resolution = LDPR_UNKNOWN;
+      /* Statics from exported primary module are very likely
+         referenced by other modules, so they should be made
+         externally visible (to be avoided to be localized again).
+         Another way to do this is to set force_output bit or
+         change the logic in varpool_externally_visible in ipa.c.  */
+      if (!is_extern)
+        {
+          node->symbol.resolution = LDPR_PREVAILING_DEF;
+          node->symbol.externally_visible = true;
+        }
+      varpool_link_node (node);
+      insert_to_assembler_name_hash ((symtab_node) node);
+    }
+
+  if (is_extern)
+    {
+      if (TREE_CODE (decl) == VAR_DECL)
+        {
+          TREE_STATIC (decl) = 0;
+          DECL_EXTERNAL (decl) = 1;
+          /* Keep the initializer to allow const prop.  */
+          /* DECL_INITIAL (decl) = 0; */
+          DECL_CONTEXT (decl) = 0;
+        }
+      /* else
+         Function body will be deleted later before expansion.  */
+    }
+  else
+    TREE_STATIC (decl) = 1;
+}
+
+/* Externalize global variables from aux modules and promote
+   static variables.
+   WEAK variables are treated especially in
+   varpool_remove_duplicate_weak_decls.  */
+
+static void
+process_module_scope_static_var (struct varpool_node *vnode)
+{
+  tree decl = vnode->symbol.decl;
+
+  if (varpool_is_auxiliary (vnode))
+    {
+      gcc_assert (vnode->module_id != primary_module_id);
+      if (TREE_PUBLIC (decl))
+        {
+          /* Externalize non-weak variables.  */
+	  if (!DECL_WEAK (decl))
+	    {
+	      DECL_EXTERNAL (decl) = 1;
+	      TREE_STATIC (decl) = 0;
+              /* Keep the initializer to allow const prop.  */
+	      /* DECL_INITIAL (decl) = NULL; */
+	      if (DECL_CONTEXT (decl))
+                {
+                  DECL_ASSEMBLER_NAME (decl);
+                }
+	      DECL_CONTEXT (decl) = NULL;
+	    }
+        }
+      else
+        {
+          /* Promote static vars to global.  */
+          if (vnode->module_id)
+            promote_static_var_func (vnode->module_id, decl,
+                                     varpool_is_auxiliary (vnode));
+        }
+    }
+  else
+    {
+      if (PRIMARY_MODULE_EXPORTED && !TREE_PUBLIC (decl))
+        promote_static_var_func (vnode->module_id, decl,
+                                 varpool_is_auxiliary (vnode));
+    }
+}
+
+/* Promote all aliases of CNODE.  */
+
+static void
+promote_function_aliases (struct cgraph_node *cnode, unsigned mod_id,
+                          bool is_extern)
+{
+  int i;
+  struct ipa_ref *ref;
+
+  for (i = 0; ipa_ref_list_referring_iterate (&cnode->symbol.ref_list, i, ref);
+      i++)
+    {
+      if (ref->use == IPA_REF_ALIAS)
+        {
+          struct cgraph_node *alias = ipa_ref_referring_node (ref);
+          tree alias_decl = alias->symbol.decl;
+          /* Should assert  */
+          if (cgraph_get_module_id (alias_decl) == mod_id)
+            promote_static_var_func (mod_id, alias_decl, is_extern);
+        }
+    }
+}
+
+/* Promote static function CNODE->decl to be global.  */
+
+static void
+process_module_scope_static_func (struct cgraph_node *cnode)
+{
+  tree decl = cnode->symbol.decl;
+  bool addr_taken;
+  unsigned mod_id;
+  struct ipa_ref *ref;
+  int i;
+
+  if (TREE_PUBLIC (decl)
+      || !TREE_STATIC (decl)
+      || DECL_EXTERNAL (decl)
+      || DECL_ARTIFICIAL (decl))
+    return;
+
+  if (flag_ripa_no_promote_always_inline
+      && lookup_attribute ("always_inline", DECL_ATTRIBUTES (decl)) != NULL)
+    return;
+
+  /* Can be local -- the promotion pass need to be done after
+     callgraph build when address taken bit is set.  */
+  addr_taken = cnode->symbol.address_taken;
+  if (!addr_taken)
+    {
+      for (i = 0; ipa_ref_list_referring_iterate (&cnode->symbol.ref_list, i, ref);
+          i++)
+        if (ref->use == IPA_REF_ALIAS)
+          {
+	    struct cgraph_node *alias = ipa_ref_referring_node (ref);
+	    if (alias->symbol.address_taken)
+	      addr_taken = true;
+          }
+    }
+  if (!addr_taken)
+    {
+      tree assemb_id = create_unique_name (decl, cgraph_get_module_id (decl));
+
+      if (DECL_ASSEMBLER_NAME_SET_P (decl))
+        unlink_from_assembler_name_hash ((symtab_node) cnode);
+      SET_DECL_ASSEMBLER_NAME (decl, assemb_id);
+      insert_to_assembler_name_hash ((symtab_node) cnode);
+      return;
+    }
+
+  mod_id = cgraph_get_module_id (decl);
+  if (cgraph_is_auxiliary (decl))
+    {
+      gcc_assert (mod_id != primary_module_id);
+      /* Promote static function to global.  */
+      if (mod_id)
+        {
+          promote_static_var_func (mod_id, decl, 1);
+          promote_function_aliases (cnode, mod_id, 1);
+        }
+    }
+  else
+    {
+      if (PRIMARY_MODULE_EXPORTED
+          /* skip static_init routines.  */
+          && !DECL_ARTIFICIAL (decl))
+        {
+          promote_static_var_func (mod_id, decl, 0);
+
+          promote_function_aliases (cnode, mod_id, 0);
+        }
+    }
+}
+
+/* Process var_decls, func_decls with static storage.  */
+
+void
+cgraph_process_module_scope_statics (void)
+{
+  struct cgraph_node *pf;
+  struct varpool_node *pv;
+
+  if (!L_IPO_COMP_MODE)
+    return;
+
+  promo_ent_hash_tab = htab_create (10, promo_ent_hash,
+                                    promo_ent_eq, promo_ent_del);
+
+  /* Process variable first.  */
+  FOR_EACH_DEFINED_VARIABLE (pv)
+    process_module_scope_static_var (pv);
+
+  FOR_EACH_FUNCTION (pf)
+    process_module_scope_static_func (pf);
+
+  htab_delete (promo_ent_hash_tab);
+}
+
+/* There could be duplicate non-extern WEAK decls in the varpool queue,
+   coming from different modules. All but one of these need to be externalized
+   and removed from the varpool queue.
+   Duplicate WEAK decls can be added to varpool queue as late as
+   cgraph_expand_function, when a WEAK decl is marked referenced as assembler
+   is being output. Therefore, a call to this function should be made after
+   cgraph_expand_function.  */
+
+void
+varpool_remove_duplicate_weak_decls (void)
+{
+  struct varpool_node *node = NULL;
+
+  if (!L_IPO_COMP_MODE)
+    return;
+
+  promo_ent_hash_tab = htab_create (10, promo_ent_hash,
+                                    promo_ent_eq, promo_ent_del);
+
+  FOR_EACH_VARIABLE (node)
+    {
+      tree decl = node->symbol.decl;
+
+      if (TREE_PUBLIC (decl) && DECL_WEAK (decl) && !DECL_EXTERNAL (decl)
+	  && get_name_seq_num (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl))))
+        {
+	  DECL_EXTERNAL (decl) = 1;
+	  TREE_STATIC (decl) = 0;
+	  DECL_INITIAL (decl) = NULL;
+	  DECL_CONTEXT (decl) = NULL;
+	}
+    }
+
+  htab_delete (promo_ent_hash_tab);
+}
+
+static GTY((param_is (struct varpool_node))) htab_t varpool_symtab;
+
+/* Hash function for varpool node.  */
+
+static hashval_t
+hash_node_by_assembler_name (const void *p)
+{
+  const struct varpool_node *n = (const struct varpool_node *) p;
+  return (hashval_t) decl_assembler_name_hash (
+        DECL_ASSEMBLER_NAME (n->symbol.decl));
+}
+
+/* Returns nonzero if P1 and P2 are equal.  */
+
+static int
+eq_node_assembler_name (const void *p1, const void *p2)
+{
+  const struct varpool_node *n1 = (const struct varpool_node *) p1;
+  const_tree name = (const_tree)p2;
+  return (decl_assembler_name_equal (n1->symbol.decl, name));
+}
+
+/* Return true if NODE's decl is declared in an auxiliary module.  */
+
+bool
+varpool_is_auxiliary (struct varpool_node *node)
+{
+  return (node->module_id
+          && node->module_id != primary_module_id);
+}
+
+/* Return the varpool_node to which DECL is resolved to during linking.
+   This method can not be used after static to global promotion happens.  */
+
+static struct varpool_node *
+real_varpool_node_1 (tree decl, bool assert)
+{
+  void **slot;
+  tree name;
+
+  if (!L_IPO_COMP_MODE || !varpool_symtab)
+    return varpool_get_node (decl);
+
+  if (!TREE_PUBLIC (decl) || DECL_ARTIFICIAL (decl))
+    return varpool_get_node (decl);
+
+  name = DECL_ASSEMBLER_NAME (decl);
+  slot = htab_find_slot_with_hash (varpool_symtab, name,
+                                   decl_assembler_name_hash (name),
+                                   NO_INSERT);
+  if (!slot)
+    {
+      gcc_assert (!assert);
+      return NULL;
+    }
+
+  gcc_assert (slot && *slot);
+  return (struct varpool_node *)*slot;
+}
+
+struct varpool_node *
+real_varpool_node (tree decl)
+{
+  return real_varpool_node_1 (decl, true);
+}
+
+/* Remove NODE from the link table.  */
+
+void
+varpool_remove_link_node (struct varpool_node *node)
+{
+  tree name;
+  tree decl;
+
+  if (!L_IPO_COMP_MODE || !varpool_symtab)
+    return;
+
+  decl = node->symbol.decl;
+
+  if (!TREE_PUBLIC (decl) || DECL_ARTIFICIAL (decl))
+    return;
+
+  if (real_varpool_node_1 (decl, false) != node)
+    return;
+
+  name = DECL_ASSEMBLER_NAME (decl);
+  htab_remove_elt_with_hash (varpool_symtab, name,
+                             decl_assembler_name_hash (name));
+}
+
+/* Merge the addressable attribute from DECL2 to DECL1.  */
+
+static inline void
+merge_addressable_attr (tree decl1, tree decl2)
+{
+  if (TREE_ADDRESSABLE (decl2))
+    TREE_ADDRESSABLE (decl1) = 1;
+}
+
+/* Resolve NODE->decl to symbol table entry *SLOT.  */
+
+static void
+resolve_varpool_node (struct varpool_node **slot, struct varpool_node *node)
+{
+  tree decl1, decl2;
+
+  decl1 = (*slot)->symbol.decl;
+  decl2 = node->symbol.decl;
+
+  /* Take the decl with the complete type. */
+  if (COMPLETE_TYPE_P (TREE_TYPE (decl1))
+      && !COMPLETE_TYPE_P (TREE_TYPE (decl2)))
+    {
+      merge_addressable_attr (decl1, decl2);
+      return;
+    }
+  if (!COMPLETE_TYPE_P (TREE_TYPE (decl1))
+      && COMPLETE_TYPE_P (TREE_TYPE (decl2)))
+    {
+      *slot = node;
+      merge_addressable_attr (decl2, decl1);
+      return;
+    }
+
+  /* Either all complete or neither's type is complete. Just
+     pick the primary module's decl.  */
+  if (!varpool_is_auxiliary (*slot))
+    {
+      merge_addressable_attr (decl1, decl2);
+      return;
+    }
+
+  if (!varpool_is_auxiliary (node))
+    {
+      *slot = node;
+      merge_addressable_attr (decl2, decl1);
+      return;
+    }
+
+  merge_addressable_attr (decl1, decl2);
+  return;
+}
+
+/* Link NODE into var_decl symbol table.  */
+
+void
+varpool_link_node (struct varpool_node *node)
+{
+  tree name;
+  void **slot;
+
+  if (!L_IPO_COMP_MODE || !varpool_symtab)
+    return;
+
+  if (!TREE_PUBLIC (node->symbol.decl) || DECL_ARTIFICIAL (node->symbol.decl))
+    return;
+
+  name = DECL_ASSEMBLER_NAME (node->symbol.decl);
+  slot = htab_find_slot_with_hash (varpool_symtab, name,
+                                   decl_assembler_name_hash (name),
+                                   INSERT);
+  if (*slot)
+    resolve_varpool_node ((struct varpool_node **) slot, node);
+  else
+    *slot = node;
+}
+
+/* Fixup references of VNODE.  */
+
+static void
+fixup_reference_list (struct varpool_node *node)
+{
+  int i;
+  struct ipa_ref *ref;
+  struct ipa_ref_list *list = &node->symbol.ref_list;
+  vec<cgraph_node_ptr> new_refered;
+  vec<int> new_refered_type;
+  struct cgraph_node *c;
+  enum ipa_ref_use use_type = IPA_REF_LOAD;
+
+  new_refered.create (10);
+  new_refered_type.create (10);
+  for (i = 0; ipa_ref_list_reference_iterate (list, i, ref); i++)
+    {
+      if (!is_a <cgraph_node> (ref->referred))
+        continue;
+
+      struct cgraph_node *cnode = ipa_ref_node (ref);
+      struct cgraph_node *r_cnode
+        = cgraph_lipo_get_resolved_node (cnode->symbol.decl);
+      if (r_cnode != cnode)
+        {
+          new_refered.safe_push (r_cnode);
+          use_type = ref->use;
+          new_refered_type.safe_push ((int) use_type);
+        }
+    }
+  for (i = 0; new_refered.iterate (i, &c); ++i)
+    {
+      ipa_record_reference ((symtab_node)node, (symtab_node)c,
+                            (enum ipa_ref_use) new_refered_type[i], NULL);
+    }
+}
+
+/* Perform cross module linking for var_decls.  */
+
+void
+varpool_do_link (void)
+{
+  struct varpool_node *node;
+
+  if (!L_IPO_COMP_MODE)
+    return;
+
+  varpool_symtab
+      = htab_create_ggc (10, hash_node_by_assembler_name,
+                         eq_node_assembler_name, NULL);
+  FOR_EACH_VARIABLE (node)
+    varpool_link_node (node);
+
+  /* Merge the externally visible attribute.  */
+  FOR_EACH_VARIABLE (node)
+    {
+      if (node->symbol.externally_visible)
+        (real_varpool_node (node->symbol.decl))->symbol.externally_visible = true;
+      fixup_reference_list (node);
+    }
+}
+
+/* Get the list of assembler name ids with reference bit set.  */
+
+void
+varpool_get_referenced_asm_ids (vec<tree,va_gc> **ids)
+{
+  struct varpool_node *node;
+  FOR_EACH_VARIABLE (node)
+    {
+      tree asm_id = NULL;
+      tree decl = node->symbol.decl;
+      if (DECL_ASSEMBLER_NAME_SET_P (decl))
+        {
+          asm_id = DECL_ASSEMBLER_NAME (decl);
+          vec_safe_push (*ids, asm_id);
+        }
+    }
+}
+
+/* Clear the referenced bit in all assembler ids.  */
+
+void
+varpool_clear_asm_id_reference_bit (void)
+{
+  struct varpool_node *node;
+  FOR_EACH_VARIABLE (node)
+    {
+      tree asm_id = NULL;
+      tree decl = node->symbol.decl;
+      if (DECL_ASSEMBLER_NAME_SET_P (decl))
+        {
+          asm_id = DECL_ASSEMBLER_NAME (decl);
+          TREE_SYMBOL_REFERENCED (asm_id) = 0;
+        }
+    }
+}
+
+
+#include "gt-l-ipo.h"
diff --git a/gcc/l-ipo.h b/gcc/l-ipo.h
new file mode 100644
index 0000000..bbcdde8
--- /dev/null
+++ b/gcc/l-ipo.h
@@ -0,0 +1,67 @@
+/* Copyright (C) 2009. Free Software Foundation, Inc.
+   Contributed by Xinliang David Li (davidxl@google.com) and
+                  Raksit Ashok  (raksit@google.com)
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef GCC_L_IPO_H
+#define GCC_L_IPO_H
+
+/* Used in profile-gen  */
+extern unsigned ggc_total_memory; /* in KB */
+
+/* Primary module's id (non-zero). If no module-info was read in, this will
+   be zero.  */
+extern unsigned primary_module_id;
+
+/* The macro to test if the compilation is in light weight IPO mode.
+   In this mode, the source module being compiled will be compiled
+   together with 0 or more auxiliary modules.  */
+#define L_IPO_COMP_MODE (primary_module_id != 0)
+
+/* The macro to test if the current module being parsed is the
+   primary source module.  */
+#define L_IPO_IS_PRIMARY_MODULE (current_module_id == primary_module_id)
+
+/* The macro to test if the current module being parsed is an
+   auxiliary source module.  */
+#define L_IPO_IS_AUXILIARY_MODULE (L_IPO_COMP_MODE && current_module_id \
+                             && current_module_id != primary_module_id)
+
+/* Current module id.  */
+extern unsigned current_module_id;
+extern unsigned include_all_aux;
+extern struct gcov_module_info **module_infos;
+extern int is_last_module (unsigned mod_id);
+
+extern unsigned num_in_fnames;
+extern int at_eof;
+extern bool parser_parsing_start;
+
+void push_module_scope (void);
+void pop_module_scope (void);
+tree lipo_save_decl (tree src);
+void lipo_restore_decl (tree, tree);
+void add_decl_to_current_module_scope (tree decl, void *b);
+int lipo_cmp_type (tree t1, tree t2);
+tree get_type_or_decl_name (tree);
+int equivalent_struct_types_for_tbaa (const_tree t1, const_tree t2);
+extern void copy_defined_module_set (tree, tree);
+extern bool is_parsing_done_p (void);
+extern const char* get_module_name (unsigned int);
+
+#endif
diff --git a/gcc/langhooks-def.h b/gcc/langhooks-def.h
index 7bd2e99..03f3b70 100644
--- a/gcc/langhooks-def.h
+++ b/gcc/langhooks-def.h
@@ -36,6 +36,12 @@ struct diagnostic_info;
 
 extern void lhd_do_nothing (void);
 extern void lhd_do_nothing_t (tree);
+extern void lhd_do_nothing_u (unsigned);
+extern void lhd_do_nothing_t_t (tree, tree);
+extern int lhd_do_nothing_t_return_int (tree);
+extern bool lhd_do_nothing_t_return_bool (tree);
+extern int lhd_do_nothing_t_t_return_int (tree, tree);
+extern bool lhd_do_nothing_t_vp_return_bool (tree, void *);
 extern void lhd_do_nothing_f (struct function *);
 extern tree lhd_pass_through_t (tree);
 extern bool lhd_post_options (const char **);
@@ -60,6 +66,7 @@ extern size_t lhd_tree_size (enum tree_code);
 extern HOST_WIDE_INT lhd_to_target_charset (HOST_WIDE_INT);
 extern tree lhd_expr_to_decl (tree, bool *, bool *);
 extern tree lhd_builtin_function (tree);
+extern bool lhd_user_conv_function_p (tree decl);
 
 /* Declarations of default tree inlining hooks.  */
 extern void lhd_initialize_diagnostics (diagnostic_context *);
@@ -108,6 +115,7 @@ extern void lhd_omp_firstprivatize_type_sizes (struct gimplify_omp_ctx *,
 #define LANG_HOOKS_TYPES_COMPATIBLE_P	lhd_types_compatible_p
 #define LANG_HOOKS_BUILTIN_FUNCTION	lhd_builtin_function
 #define LANG_HOOKS_BUILTIN_FUNCTION_EXT_SCOPE	LANG_HOOKS_BUILTIN_FUNCTION
+#define LANG_HOOKS_USER_CONV_FUNCTION	lhd_user_conv_function_p
 #define LANG_HOOKS_EXPR_TO_DECL		lhd_expr_to_decl
 #define LANG_HOOKS_TO_TARGET_CHARSET	lhd_to_target_charset
 #define LANG_HOOKS_INIT_TS		lhd_do_nothing
@@ -191,6 +199,39 @@ extern tree lhd_make_node (enum tree_code);
   LANG_HOOKS_RECONSTRUCT_COMPLEX_TYPE \
 }
 
+#define LANG_HOOKS_ADD_BUILT_IN_DECL lhd_do_nothing_t
+#define LANG_HOOKS_SAVE_BUILT_IN_PRE lhd_do_nothing
+#define LANG_HOOKS_RESTORE_BUILT_IN_PRE lhd_do_nothing
+#define LANG_HOOKS_SAVE_BUILT_IN_POST lhd_do_nothing
+#define LANG_HOOKS_RESTORE_BUILT_IN_POST lhd_do_nothing
+#define LANG_HOOKS_CLEAR_NAME_BINDINGS lhd_do_nothing_t
+#define LANG_HOOKS_HAS_GLOBAL_NAME lhd_do_nothing_t_vp_return_bool
+#define LANG_HOOKS_GET_LANG_DECL_SIZE lhd_do_nothing_t_return_int
+#define LANG_HOOKS_DUP_LANG_TYPE lhd_do_nothing_t_t
+#define LANG_HOOKS_COPY_LANG_TYPE lhd_do_nothing_t_t
+#define LANG_HOOKS_PROCESS_PENDING_DECLS lhd_do_nothing_u
+#define LANG_HOOKS_CLEAR_DEFFERED_FNS lhd_do_nothing
+#define LANG_HOOKS_IS_GENERATED_TYPE lhd_do_nothing_t_return_bool
+#define LANG_HOOKS_CMP_LANG_TYPE lhd_do_nothing_t_t_return_int
+
+
+#define LANG_HOOKS_FOR_LIPO_INITIALIZER { \
+  LANG_HOOKS_ADD_BUILT_IN_DECL, \
+  LANG_HOOKS_SAVE_BUILT_IN_PRE, \
+  LANG_HOOKS_RESTORE_BUILT_IN_PRE, \
+  LANG_HOOKS_SAVE_BUILT_IN_POST, \
+  LANG_HOOKS_RESTORE_BUILT_IN_POST, \
+  LANG_HOOKS_CLEAR_NAME_BINDINGS, \
+  LANG_HOOKS_HAS_GLOBAL_NAME, \
+  LANG_HOOKS_GET_LANG_DECL_SIZE, \
+  LANG_HOOKS_DUP_LANG_TYPE, \
+  LANG_HOOKS_COPY_LANG_TYPE, \
+  LANG_HOOKS_PROCESS_PENDING_DECLS, \
+  LANG_HOOKS_CLEAR_DEFFERED_FNS, \
+  LANG_HOOKS_IS_GENERATED_TYPE, \
+  LANG_HOOKS_CMP_LANG_TYPE,  \
+}
+
 /* Declaration hooks.  */
 #define LANG_HOOKS_GLOBAL_BINDINGS_P global_bindings_p
 #define LANG_HOOKS_PUSHDECL	pushdecl
@@ -288,6 +329,7 @@ extern void lhd_end_section (void);
   LANG_HOOKS_TREE_DUMP_INITIALIZER, \
   LANG_HOOKS_DECLS, \
   LANG_HOOKS_FOR_TYPES_INITIALIZER, \
+  LANG_HOOKS_FOR_LIPO_INITIALIZER, \
   LANG_HOOKS_LTO, \
   LANG_HOOKS_GET_INNERMOST_GENERIC_PARMS, \
   LANG_HOOKS_GET_INNERMOST_GENERIC_ARGS, \
@@ -295,6 +337,7 @@ extern void lhd_end_section (void);
   LANG_HOOKS_GIMPLIFY_EXPR, \
   LANG_HOOKS_BUILTIN_FUNCTION, \
   LANG_HOOKS_BUILTIN_FUNCTION_EXT_SCOPE, \
+  LANG_HOOKS_USER_CONV_FUNCTION, \
   LANG_HOOKS_INIT_TS,          \
   LANG_HOOKS_EXPR_TO_DECL, \
   LANG_HOOKS_EH_PERSONALITY, \
diff --git a/gcc/langhooks.c b/gcc/langhooks.c
index 70af8da..f36bdeb 100644
--- a/gcc/langhooks.c
+++ b/gcc/langhooks.c
@@ -102,6 +102,48 @@ lhd_return_null_const_tree (const_tree ARG_UNUSED (t))
   return NULL_TREE;
 }
 
+void
+lhd_do_nothing_u (unsigned ARG_UNUSED (t))
+{
+}
+
+int
+lhd_do_nothing_t_return_int (tree ARG_UNUSED (t))
+{
+  return false;
+}
+
+bool
+lhd_do_nothing_t_return_bool (tree ARG_UNUSED (t))
+{
+  return false;
+}
+
+
+void
+lhd_do_nothing_t_t (tree ARG_UNUSED (t), tree ARG_UNUSED (t2))
+{
+}
+
+int
+lhd_do_nothing_t_t_return_int (tree ARG_UNUSED (t), tree ARG_UNUSED (t2))
+{
+  return 1;
+}
+
+bool
+lhd_do_nothing_t_vp_return_bool (tree ARG_UNUSED (t), void * ARG_UNUSED (t2))
+{
+  return true;
+}
+
+/* Do nothing (tree, tree). Return NULL_TREE.  */
+tree
+lhd_do_nothing_t_t_return_null_tree (tree ARG_UNUSED (t), tree ARG_UNUSED (t2))
+{
+  return NULL_TREE;
+}
+
 /* The default post options hook.  */
 
 bool
@@ -604,6 +646,12 @@ lhd_builtin_function (tree decl)
   return decl;
 }
 
+bool
+lhd_user_conv_function_p (tree decl ATTRIBUTE_UNUSED)
+{
+  return false;
+}
+
 /* Create a builtin type.  */
 
 tree
diff --git a/gcc/langhooks.h b/gcc/langhooks.h
index 4bc1bd5..8f9e785 100644
--- a/gcc/langhooks.h
+++ b/gcc/langhooks.h
@@ -224,6 +224,61 @@ struct lang_hooks_for_decls
   void (*omp_finish_clause) (tree clause);
 };
 
+/* Lang hooks for LIPO.  */
+
+struct lang_hooks_for_lipo
+{
+  /* Add DECL to the list of predefined builtins.  */
+  void (*add_built_in_decl) (tree decl);
+
+  /* Save the tree (by making a copy) and binding values
+     for builtins before parsing start.  */
+  void (*save_built_in_decl_pre_parsing) (void);
+
+  /* Restore builtins and their bindings to their values
+     before parsing. */
+  void (*restore_built_in_decl_pre_parsing) (void);
+
+  /* Save the tree (by making a copy) and binding values for
+     builtins after parsing of a file.  */
+  void (*save_built_in_decl_post_module_parsing) (void);
+
+  /* Restore builtins and their bindings to their post
+     parsing values.  */
+  void (*restore_built_in_decl_post_module_parsing) (void);
+
+  /* Clear symbol binding for name ID. */
+  void (*clear_global_name_bindings) (tree id);
+
+  /* Return true if DECL in SCOPE is scoped in global/namespace scope,
+     otherwise return false. */
+  bool (*has_global_name) (tree decl, void *scope);
+
+  /* Return the actual size of the lang_decl struct for
+     decl T.  */
+  int (*get_lang_decl_size) (tree t);
+
+  /* Duplicate language specific type information from SRC
+   to DEST.  */
+  void (*dup_lang_type) (tree src, tree dest);
+
+  /* Copy DEST into SRC.  */
+  void (*copy_lang_type) (tree src, tree dest);
+
+  /* Process decls after parsing of a source module.  */
+  void (*process_pending_decls) (unsigned);
+
+  /* Clear the list of deferred functions.  */
+  void (*clear_deferred_fns) (void);
+
+  /* Return true if T is compiler generated.  */
+  bool (*is_compiler_generated_type) (tree t);
+
+  /* Compare language specific types T1 and T2.
+     Return 1 if they are compatible.  */
+  int (*cmp_lang_type) (tree t1, tree t2);
+};
+
 /* Language hooks related to LTO serialization.  */
 
 struct lang_hooks_for_lto
@@ -405,6 +460,8 @@ struct lang_hooks
 
   struct lang_hooks_for_types types;
 
+  struct lang_hooks_for_lipo l_ipo;
+
   struct lang_hooks_for_lto lto;
 
   /* Returns the generic parameters of an instantiation of
@@ -433,6 +490,9 @@ struct lang_hooks
      backend must add all of the builtins at program initialization time.  */
   tree (*builtin_function_ext_scope) (tree decl);
 
+  /* Returns true if DECL is a user defined conversion operator (C++) */
+  bool (*user_conv_function_p) (tree decl);
+
   /* Used to set up the tree_contains_structure array for a frontend. */
   void (*init_ts) (void);
 
diff --git a/gcc/loop-iv.c b/gcc/loop-iv.c
index be2e0f4..3142cad 100644
--- a/gcc/loop-iv.c
+++ b/gcc/loop-iv.c
@@ -3017,8 +3017,12 @@ get_simple_loop_desc (struct loop *loop)
   /* At least desc->infinite is not always initialized by
      find_simple_loop_exit.  */
   desc = XCNEW (struct niter_desc);
-  iv_analysis_loop_init (loop);
-  find_simple_exit (loop, desc);
+  if (loop->latch != EXIT_BLOCK_PTR)
+    {
+      iv_analysis_loop_init (loop);
+      find_simple_exit (loop, desc);
+    }
+  analyze_loop_insns (loop, desc);
   loop->aux = desc;
 
   if (desc->simple_p && (desc->assumptions || desc->infinite))
diff --git a/gcc/loop-unroll.c b/gcc/loop-unroll.c
index 1eb904b..cce184e 100644
--- a/gcc/loop-unroll.c
+++ b/gcc/loop-unroll.c
@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "recog.h"
 #include "target.h"
 #include "dumpfile.h"
+#include "gcov-io.h"
 
 /* This pass performs loop unrolling and peeling.  We only perform these
    optimizations on innermost loops (with single exception) because
@@ -147,6 +148,99 @@ static void combine_var_copies_in_loop_exit (struct var_to_expand *,
 					     basic_block);
 static rtx get_expansion (struct var_to_expand *);
 
+/* Compute the maximum number of times LOOP can be unrolled without exceeding
+   a branch budget, which can increase branch mispredictions. The number of
+   branches is computed by weighting each branch with its expected execution
+   probability through the loop based on profile data. If no profile feedback
+   data exists, simply return the current NUNROLL factor.  */
+
+static unsigned
+max_unroll_with_branches(struct loop *loop, unsigned nunroll)
+{
+  struct loop *outer;
+  struct niter_desc *outer_desc = 0;
+  int outer_niters = 1;
+  int frequent_iteration_threshold;
+  unsigned branch_budget;
+  struct niter_desc *desc = get_simple_loop_desc (loop);
+
+  /* Ignore loops with FP computation as these tend to benefit much more
+     consistently from unrolling.  */
+  if (desc->has_fp)
+    return nunroll;
+
+  frequent_iteration_threshold = PARAM_VALUE (PARAM_MIN_ITER_UNROLL_WITH_BRANCHES);
+  if (expected_loop_iterations (loop) >= (unsigned) frequent_iteration_threshold)
+    return nunroll;
+
+  /* If there was no profile feedback data, av_num_branches will be 0
+     and we won't limit unrolling. If the av_num_branches is at most 1,
+     also don't limit unrolling as the back-edge branch will not be duplicated.  */
+  if (desc->av_num_branches <= 1)
+    return nunroll;
+
+  /* Walk up the loop tree until we find a hot outer loop in which the current
+     loop is nested. At that point we will compute the number of times the
+     current loop can be unrolled based on the number of branches in the hot
+     outer loop.  */
+  outer = loop_outer (loop);
+  /* The loop structure contains a fake outermost loop, so this should always
+     be non-NULL for our current loop.  */
+  gcc_assert (outer);
+
+  /* Walk up the loop tree until we either find a hot outer loop or hit the
+     fake outermost loop at the root.  */
+  while (true)
+    {
+      outer_desc = get_simple_loop_desc (outer);
+
+      /* Stop if we hit the fake outermost loop at the root of the tree,
+         which includes the whole procedure.  */
+      if (!loop_outer (outer))
+        break;
+
+      if (outer_desc->const_iter)
+        outer_niters *= outer_desc->niter;
+      else if (outer->header->count)
+        outer_niters *= expected_loop_iterations (outer);
+
+      /* If the outer loop has enough iterations to be considered hot, then
+         we can stop our upwards loop tree traversal and examine the current
+         outer loop.  */
+      if (outer_niters >= frequent_iteration_threshold)
+        break;
+
+      outer = loop_outer (outer);
+    }
+
+  gcc_assert(outer);
+
+  /* Assume that any call will cause the branch budget to be exceeded,
+     and that we can't unroll the current loop without increasing
+     mispredicts.  */
+  if (outer_desc->has_call)
+    return 0;
+
+  /* Otherwise, compute the maximum number of times current loop can be
+     unrolled without exceeding our branch budget. First we subtract
+     off the outer loop's average branch count from the budget. Note
+     that this includes the branches in the current loop. This yields
+     the number of branches left in the budget for the unrolled copies.
+     We divide this by the number of branches in the current loop that
+     must be duplicated when we unroll, which is the total average
+     number of branches minus the back-edge branch. This yields the
+     number of new loop body copies that can be created by unrolling
+     without exceeding the budget, to which we add 1 to get the unroll
+     factor. Note that the "outermost loop" may be the whole procedure
+     if we did not find a hot enough enclosing loop.  */
+  branch_budget = PARAM_VALUE (PARAM_UNROLL_OUTER_LOOP_BRANCH_BUDGET);
+  if (outer_desc->av_num_branches > branch_budget)
+    return 0;
+  /* We already returned early if desc->av_num_branches <= 1.  */
+  return (branch_budget - outer_desc->av_num_branches)
+      / (desc->av_num_branches - 1) + 1;
+}
+
 /* Emit a message summarizing the unroll or peel that will be
    performed for LOOP, along with the loop's location LOCUS, if
    appropriate given the dump or -fopt-info settings.  */
@@ -158,6 +252,9 @@ report_unroll_peel (struct loop *loop, location_t locus)
   int niters = 0;
   int report_flags = MSG_OPTIMIZED_LOCATIONS | TDF_RTL | TDF_DETAILS;
 
+  if (loop->lpt_decision.decision == LPT_NONE)
+    return;
+
   if (!dump_enabled_p ())
     return;
 
@@ -202,6 +299,82 @@ report_unroll_peel (struct loop *loop, location_t locus)
   dump_printf (report_flags, "\n");
 }
 
+/* Determine whether and how much LOOP unrolling/peeling should be constrained
+   based on code footprint estimates. Returns the codesize-based factor to be
+   divided into the max instructions in an unrolled or peeled loop:
+   1) For size <= threshold, do not limit (by returning 1).
+   2) For threshold < size < 2*threshold, reduce maximum allowed peeled or
+      unrolled instructions according to loop hotness.
+   3) For threshold >= 2*threshold, disable unrolling/peeling (by returning
+      INT_MAX).  */
+
+static int
+code_size_limit_factor(struct loop *loop)
+{
+  unsigned size_threshold, num_hot_counters;
+  struct niter_desc *desc = get_simple_loop_desc (loop);
+  gcov_type sum_to_header_ratio;
+  int hotness_ratio_threshold;
+  int limit_factor;
+  gcov_working_set_t *ws;
+
+  ws = find_working_set(999);
+  if (! ws)
+    return 1;
+  num_hot_counters = ws->num_counters;
+
+  /* First check if the application has a large codesize footprint.
+     This is estimated from FDO profile summary information for the
+     program, where the num_hot_counters indicates the number of hottest
+     counters (blocks) that compose most of the execution time of
+     the program. A large value would indicate a large flat execution
+     profile where icache misses may be a concern.  */
+  size_threshold = PARAM_VALUE (PARAM_UNROLLPEEL_CODESIZE_THRESHOLD);
+  if (!profile_info
+      || num_hot_counters <= size_threshold
+      || !profile_info->sum_all)
+    return 1;
+
+  /* Next, exclude some loops where unrolling/peeling may be more
+     important to overall performance.  */
+
+  /* Ignore FP loops, which are more likely to benefit heavily from
+     unrolling. */
+  if (desc->has_fp)
+    return 1;
+
+  /* Next, set the value of the codesize-based unroll factor divisor which in
+     most loops will need to be set to a value that will reduce or eliminate
+     unrolling/peeling.  */
+  if (num_hot_counters < size_threshold * 2
+      && loop->header->count > 0)
+    {
+      /* For applications that are less than twice the codesize limit, allow
+         limited unrolling for very hot loops.  */
+      sum_to_header_ratio = profile_info->sum_all / loop->header->count;
+      hotness_ratio_threshold = PARAM_VALUE (PARAM_UNROLLPEEL_HOTNESS_THRESHOLD);
+      /* When the profile count sum to loop entry header ratio is smaller than
+         the threshold (i.e. the loop entry is hot enough), the divisor is set
+         to 1 so the unroll/peel factor is not reduced. When it is bigger
+         than the ratio, increase the divisor by the amount this ratio
+         is over the threshold, which will quickly reduce the unroll/peel
+         factor to zero as the loop's hotness reduces.  */
+      if (sum_to_header_ratio > hotness_ratio_threshold)
+        {
+          limit_factor = sum_to_header_ratio / hotness_ratio_threshold;
+          gcc_assert (limit_factor >= 1);
+        }
+      else
+        limit_factor = 1;
+    }
+  else
+    /* For appliations that are at least twice the codesize limit, set
+       the divisor to a large value that will force the unroll factor to 0.  */
+    limit_factor = INT_MAX;
+
+  return limit_factor;
+}
+
 /* Unroll and/or peel (depending on FLAGS) LOOPS.  */
 void
 unroll_and_peel_loops (int flags)
@@ -585,6 +758,7 @@ static void
 decide_unroll_constant_iterations (struct loop *loop, int flags)
 {
   unsigned nunroll, nunroll_by_av, best_copies, best_unroll = 0, n_copies, i;
+  unsigned nunroll_branches;
   struct niter_desc *desc;
   double_int iterations;
 
@@ -629,6 +803,21 @@ decide_unroll_constant_iterations (struct loop *loop, int flags)
       return;
     }
 
+  /* Be careful when unrolling loops with branches inside -- it can increase
+     the number of mispredicts.  */
+  if (desc->num_branches > 1)
+    {
+      nunroll_branches = max_unroll_with_branches (loop, nunroll);
+      if (nunroll > nunroll_branches)
+        nunroll = nunroll_branches;
+      if (nunroll <= 1)
+        {
+          if (dump_file)
+	    fprintf (dump_file, ";; Not unrolling, contains branches\n");
+          return;
+        }
+    }
+
   /* Check whether the loop rolls enough to consider.  
      Consult also loop bounds and profile; in the case the loop has more
      than one exit it may well loop less than determined maximal number
@@ -883,9 +1072,10 @@ unroll_loop_constant_iterations (struct loop *loop)
 static void
 decide_unroll_runtime_iterations (struct loop *loop, int flags)
 {
-  unsigned nunroll, nunroll_by_av, i;
+  unsigned nunroll, nunroll_by_av, nunroll_branches, i;
   struct niter_desc *desc;
   double_int iterations;
+  int limit_factor = 1;
 
   if (!(flags & UAP_UNROLL))
     {
@@ -898,10 +1088,26 @@ decide_unroll_runtime_iterations (struct loop *loop, int flags)
 	     "\n;; Considering unrolling loop with runtime "
 	     "computable number of iterations\n");
 
+  if (flag_unroll_codesize_limit)
+    {
+      /* Determine whether to limit code size growth from unrolling,
+         using FDO profile summary information that gives an
+         estimated number of executed blocks.  */
+      limit_factor = code_size_limit_factor (loop);
+      if (dump_file && limit_factor > 1)
+	{
+          fprintf (dump_file,
+                   ";; Due to large code size footprint estimate, limit "
+                   "max unrolled insns by divisor %d\n", limit_factor);
+	}
+    }
+
   /* nunroll = total number of copies of the original loop body in
      unrolled loop (i.e. if it is 2, we have to duplicate loop body once.  */
-  nunroll = PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS) / loop->ninsns;
-  nunroll_by_av = PARAM_VALUE (PARAM_MAX_AVERAGE_UNROLLED_INSNS) / loop->av_ninsns;
+  nunroll = PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS) / limit_factor
+            / loop->ninsns;
+  nunroll_by_av = PARAM_VALUE (PARAM_MAX_AVERAGE_UNROLLED_INSNS)
+                  / limit_factor / loop->av_ninsns;
   if (nunroll > nunroll_by_av)
     nunroll = nunroll_by_av;
   if (nunroll > (unsigned) PARAM_VALUE (PARAM_MAX_UNROLL_TIMES))
@@ -938,6 +1144,21 @@ decide_unroll_runtime_iterations (struct loop *loop, int flags)
       return;
     }
 
+  /* Be careful when unrolling loops with branches inside -- it can increase
+     the number of mispredicts.  */
+  if (desc->num_branches > 1)
+    {
+      nunroll_branches = max_unroll_with_branches (loop, nunroll);
+      if (nunroll > nunroll_branches)
+        nunroll = nunroll_branches;
+      if (nunroll <= 1)
+        {
+          if (dump_file)
+            fprintf (dump_file, ";; Not unrolling, contains branches\n");
+          return;
+        }
+    }
+
   /* Check whether the loop rolls.  */
   if ((estimated_loop_iterations (loop, &iterations)
        || max_loop_iterations (loop, &iterations))
@@ -948,6 +1169,13 @@ decide_unroll_runtime_iterations (struct loop *loop, int flags)
       return;
     }
 
+  /* In AutoFDO, the profile is not accurate. If the calculated trip count
+     is larger than the header count, then the profile is not accurate
+     enough to make correct unroll decisions. */
+  if (flag_auto_profile
+      && expected_loop_iterations (loop) > loop->header->count)
+    return;
+
   /* Success; now force nunroll to be power of 2, as we are unable to
      cope with overflows in computation of number of iterations.  */
   for (i = 1; 2 * i <= nunroll; i *= 2)
@@ -1288,6 +1516,7 @@ decide_peel_simple (struct loop *loop, int flags)
 {
   unsigned npeel;
   double_int iterations;
+  int limit_factor = 1;
 
   if (!(flags & UAP_PEEL))
     {
@@ -1298,8 +1527,23 @@ decide_peel_simple (struct loop *loop, int flags)
   if (dump_file)
     fprintf (dump_file, "\n;; Considering simply peeling loop\n");
 
+  if (flag_peel_codesize_limit)
+    {
+      /* Determine whether to limit code size growth from peeling,
+         using FDO profile summary information that gives an
+         estimated number of executed blocks.  */
+      limit_factor = code_size_limit_factor (loop);
+      if (dump_file && limit_factor > 1)
+	{
+          fprintf (dump_file,
+                   ";; Due to large code size footprint estimate, limit "
+                   "max peeled insns by divisor %d\n", limit_factor);
+	}
+    }
+
   /* npeel = number of iterations to peel.  */
-  npeel = PARAM_VALUE (PARAM_MAX_PEELED_INSNS) / loop->ninsns;
+  npeel = PARAM_VALUE (PARAM_MAX_PEELED_INSNS) / limit_factor
+          / loop->ninsns;
   if (npeel > (unsigned) PARAM_VALUE (PARAM_MAX_PEEL_TIMES))
     npeel = PARAM_VALUE (PARAM_MAX_PEEL_TIMES);
 
@@ -1311,16 +1555,26 @@ decide_peel_simple (struct loop *loop, int flags)
       return;
     }
 
+  struct niter_desc *desc = get_simple_loop_desc (loop);
+
+  /* Check number of iterations.  */
+  if (desc->simple_p && !desc->assumptions && desc->const_iter)
+    {
+      if (dump_file)
+        fprintf (dump_file, ";; Loop iterates constant times\n");
+      return;
+    }
+
   /* Do not simply peel loops with branches inside -- it increases number
      of mispredicts.  
      Exception is when we do have profile and we however have good chance
      to peel proper number of iterations loop will iterate in practice.
-     TODO: this heuristic needs tunning; while for complette unrolling
+     TODO: this heuristic needs tunning; while for complete unrolling
      the branch inside loop mostly eliminates any improvements, for
      peeling it is not the case.  Also a function call inside loop is
      also branch from branch prediction POV (and probably better reason
      to not unroll/peel).  */
-  if (num_loop_branches (loop) > 1
+  if (desc->num_branches > 1
       && profile_status != PROFILE_READ)
     {
       if (dump_file)
@@ -1443,6 +1697,7 @@ decide_unroll_stupid (struct loop *loop, int flags)
   unsigned nunroll, nunroll_by_av, i;
   struct niter_desc *desc;
   double_int iterations;
+  int limit_factor = 1;
 
   if (!(flags & UAP_UNROLL_ALL))
     {
@@ -1453,11 +1708,26 @@ decide_unroll_stupid (struct loop *loop, int flags)
   if (dump_file)
     fprintf (dump_file, "\n;; Considering unrolling loop stupidly\n");
 
+  if (flag_unroll_codesize_limit)
+    {
+      /* Determine whether to limit code size growth from unrolling,
+         using FDO profile summary information that gives an
+         estimated number of executed blocks.  */
+      limit_factor = code_size_limit_factor (loop);
+      if (dump_file && limit_factor > 1)
+	{
+          fprintf (dump_file,
+                   ";; Due to large code size footprint estimate, limit "
+                   "max unrolled insns by divisor %d\n", limit_factor);
+	}
+    }
+
   /* nunroll = total number of copies of the original loop body in
      unrolled loop (i.e. if it is 2, we have to duplicate loop body once.  */
-  nunroll = PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS) / loop->ninsns;
-  nunroll_by_av
-    = PARAM_VALUE (PARAM_MAX_AVERAGE_UNROLLED_INSNS) / loop->av_ninsns;
+  nunroll = PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS) / limit_factor
+            / loop->ninsns;
+  nunroll_by_av = PARAM_VALUE (PARAM_MAX_AVERAGE_UNROLLED_INSNS)
+                  / limit_factor / loop->av_ninsns;
   if (nunroll > nunroll_by_av)
     nunroll = nunroll_by_av;
   if (nunroll > (unsigned) PARAM_VALUE (PARAM_MAX_UNROLL_TIMES))
@@ -1489,7 +1759,7 @@ decide_unroll_stupid (struct loop *loop, int flags)
      of mispredicts. 
      TODO: this heuristic needs tunning; call inside the loop body
      is also relatively good reason to not unroll.  */
-  if (num_loop_branches (loop) > 1)
+  if (desc->num_branches > 1)
     {
       if (dump_file)
 	fprintf (dump_file, ";; Not unrolling, contains branches\n");
diff --git a/gcc/lra-constraints.c b/gcc/lra-constraints.c
index dfbe93a..2d8aa81 100644
--- a/gcc/lra-constraints.c
+++ b/gcc/lra-constraints.c
@@ -4396,7 +4396,7 @@ update_ebb_live_info (rtx head, rtx tail)
 	  bitmap_clear_bit (&live_regs, reg->regno);
       /* Mark each used value as live.  */
       for (reg = curr_id->regs; reg != NULL; reg = reg->next)
-	if (reg->type == OP_IN
+	if (reg->type != OP_OUT
 	    && bitmap_bit_p (&check_only_regs, reg->regno))
 	  bitmap_set_bit (&live_regs, reg->regno);
       /* It is quite important to remove dead move insns because it
diff --git a/gcc/mcf.c b/gcc/mcf.c
index 7a716f5..dd681da 100644
--- a/gcc/mcf.c
+++ b/gcc/mcf.c
@@ -47,6 +47,10 @@ along with GCC; see the file COPYING3.  If not see
 #include "coretypes.h"
 #include "basic-block.h"
 #include "gcov-io.h"
+#include "params.h"
+#include "diagnostic-core.h"
+
+#include "tree.h"
 #include "profile.h"
 #include "dumpfile.h"
 
@@ -59,15 +63,18 @@ along with GCC; see the file COPYING3.  If not see
 #define COST(k, w)      ((k) / mcf_ln ((w) + 2))
 /* Limit the number of iterations for cancel_negative_cycles() to ensure
    reasonable compile time.  */
-#define MAX_ITER(n, e)  10 + (1000000 / ((n) * (e)))
+#define MAX_ITER(n, e)  (PARAM_VALUE (PARAM_MIN_MCF_CANCEL_ITERS) + \
+			 (1000000 / ((n) * (e))))
+
 typedef enum
 {
-  INVALID_EDGE,
+  INVALID_EDGE = 0,
   VERTEX_SPLIT_EDGE,	    /* Edge to represent vertex with w(e) = w(v).  */
   REDIRECT_EDGE,	    /* Edge after vertex transformation.  */
   REVERSE_EDGE,
   SOURCE_CONNECT_EDGE,	    /* Single edge connecting to single source.  */
   SINK_CONNECT_EDGE,	    /* Single edge connecting to single sink.  */
+  SINK_SOURCE_EDGE,	    /* Single edge connecting sink to source.  */
   BALANCE_EDGE,		    /* Edge connecting with source/sink: cp(e) = 0.  */
   REDIRECT_NORMALIZED_EDGE, /* Normalized edge for a redirect edge.  */
   REVERSE_NORMALIZED_EDGE   /* Normalized edge for a reverse edge.  */
@@ -243,6 +250,10 @@ dump_fixup_edge (FILE *file, fixup_graph_type *fixup_graph, fixup_edge_p fedge)
 	  fputs (" @SINK_CONNECT_EDGE", file);
 	  break;
 
+	case SINK_SOURCE_EDGE:
+	  fputs (" @SINK_SOURCE_EDGE", file);
+	  break;
+
 	case REVERSE_EDGE:
 	  fputs (" @REVERSE_EDGE", file);
 	  break;
@@ -458,7 +469,7 @@ create_fixup_graph (fixup_graph_type *fixup_graph)
   double k_neg = 0;
   /* Vector to hold D(v) = sum_out_edges(v) - sum_in_edges(v).  */
   gcov_type *diff_out_in = NULL;
-  gcov_type supply_value = 1, demand_value = 0;
+  gcov_type supply_value = 0, demand_value = 0;
   gcov_type fcost = 0;
   int new_entry_index = 0, new_exit_index = 0;
   int i = 0, j = 0;
@@ -479,14 +490,15 @@ create_fixup_graph (fixup_graph_type *fixup_graph)
     fnum_vertices_after_transform + n_edges + n_basic_blocks + 2;
 
   /* In create_fixup_graph: Each basic block and edge can be split into 3
-     edges. Number of balance edges = n_basic_blocks. So after
-     create_fixup_graph:
-     max_edges = 4 * n_basic_blocks + 3 * n_edges
+     edges. Number of balance edges = n_basic_blocks - 1. And there is 1 edge
+     connecting new_entry and new_exit, and 2 edges connecting new_entry to
+     entry, and exit to new_exit. So after create_fixup_graph:
+     max_edges = 4 * n_basic_blocks + 3 * n_edges + 2
      Accounting for residual flow edges
-     max_edges = 2 * (4 * n_basic_blocks + 3 * n_edges)
-     = 8 * n_basic_blocks + 6 * n_edges
-     < 8 * n_basic_blocks + 8 * n_edges.  */
-  int fmax_num_edges = 8 * (n_basic_blocks + n_edges);
+     max_edges = 2 * (4 * n_basic_blocks + 3 * n_edges + 2)
+     = 8 * n_basic_blocks + 6 * n_edges + 4
+     < 8 * n_basic_blocks + 8 * n_edges + 8.  */
+  int fmax_num_edges = 8 * (n_basic_blocks + n_edges + 1);
 
   /* Initial num of vertices in the fixup graph.  */
   fixup_graph->num_vertices = n_basic_blocks;
@@ -505,7 +517,7 @@ create_fixup_graph (fixup_graph_type *fixup_graph)
 
   /* Compute constants b, k_pos, k_neg used in the cost function calculation.
      b = sqrt(avg_vertex_weight(cfg)); k_pos = b; k_neg = 50b.  */
-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)
+  FOR_ALL_BB (bb)
     total_vertex_weight += bb->count;
 
   sqrt_avg_vertex_weight = mcf_sqrt (total_vertex_weight / n_basic_blocks);
@@ -519,10 +531,11 @@ create_fixup_graph (fixup_graph_type *fixup_graph)
   if (dump_file)
     fprintf (dump_file, "\nVertex transformation:\n");
 
-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)
+  FOR_ALL_BB (bb)
   {
     /* v'->v'': index1->(index1+1).  */
     i = 2 * bb->index;
+
     fcost = (gcov_type) COST (k_pos, bb->count);
     add_fixup_edge (fixup_graph, i, i + 1, VERTEX_SPLIT_EDGE, bb->count,
                     fcost, CAP_INFINITY);
@@ -586,23 +599,45 @@ create_fixup_graph (fixup_graph_type *fixup_graph)
 
   new_entry_index = fixup_graph->new_entry_index = fixup_graph->num_vertices;
   fixup_graph->num_vertices++;
-  /* Set supply_value to 1 to avoid zero count function ENTRY.  */
-  add_fixup_edge (fixup_graph, new_entry_index, ENTRY_BLOCK, SOURCE_CONNECT_EDGE,
-		  1 /* supply_value */, 0, 1 /* supply_value */);
-
-  /* Create new exit with EXIT_BLOCK as single pred.  */
+  /* Set capacity to 0 initially, it will be updated after
+     supply_value is computed. */
+  add_fixup_edge (fixup_graph, new_entry_index, ENTRY_BLOCK,
+		  SOURCE_CONNECT_EDGE, 0 /* supply_value */, 0,
+		  0 /* supply_value */);
+  add_fixup_edge (fixup_graph, ENTRY_BLOCK, new_entry_index,
+                  SOURCE_CONNECT_EDGE, 0 /* supply_value */, 0,
+                  0 /* supply_value */);
+
+
+  /* Set capacity to 0 initially, it will be updated after
+     demand_value is computed. */
   new_exit_index = fixup_graph->new_exit_index = fixup_graph->num_vertices;
   fixup_graph->num_vertices++;
   add_fixup_edge (fixup_graph, 2 * EXIT_BLOCK + 1, new_exit_index,
                   SINK_CONNECT_EDGE,
                   0 /* demand_value */, 0, 0 /* demand_value */);
+  add_fixup_edge (fixup_graph, new_exit_index, 2 * EXIT_BLOCK + 1,
+                  SINK_CONNECT_EDGE,
+                  0 /* demand_value */, 0, 0 /* demand_value */);
+
+
+  /* Create a back edge from the new_exit to the new_entry.
+     Initially, its capacity will be set to 0 so that it does not
+     affect max flow, but later its capacity will be changed to
+     infinity to cancel negative cycles. */
+  add_fixup_edge (fixup_graph, new_exit_index, new_entry_index,
+		  SINK_SOURCE_EDGE, 0, 0, 0);
+
+
 
   /* Connect vertices with unbalanced D(v) to source/sink.  */
   if (dump_file)
     fprintf (dump_file, "\nD(v) balance:\n");
-  /* Skip vertices for ENTRY (0, 1) and EXIT (2,3) blocks, so start with i = 4.
-     diff_out_in[v''] will be 0, so skip v'' vertices, hence i += 2.  */
-  for (i = 4; i < new_entry_index; i += 2)
+
+  /* Skip vertices for ENTRY (0, 1) and EXIT (2,3) blocks, so start
+     with i = 4.  diff_out_in[v''] should be 0, but may not be due to
+     rounding error.  So here we consider all vertices.  */
+  for (i = 4; i < new_entry_index; i += 1)
     {
       if (diff_out_in[i] > 0)
 	{
@@ -667,7 +702,6 @@ create_fixup_graph (fixup_graph_type *fixup_graph)
 	      fprintf (dump_file, "------------------\n");
 	    }
 
-	  pfedge->cost /= 2;
 	  pfedge->norm_vertex_index = new_index;
 	  if (dump_file)
 	    {
@@ -677,7 +711,7 @@ create_fixup_graph (fixup_graph_type *fixup_graph)
 
 	  /* Add a new fixup edge: new_index->src.  */
 	  add_fixup_edge (fixup_graph, new_index, pfedge->src,
-			  REVERSE_NORMALIZED_EDGE, 0, r_pfedge->cost,
+			  REVERSE_NORMALIZED_EDGE, 0, 0,
 			  r_pfedge->max_capacity);
 	  gcc_assert (fixup_graph->num_vertices <= fmax_num_vertices);
 
@@ -685,7 +719,6 @@ create_fixup_graph (fixup_graph_type *fixup_graph)
              ==> r_pfedge->src -> new_index.  */
 	  r_pfedge->dest = new_index;
 	  r_pfedge->type = REVERSE_NORMALIZED_EDGE;
-	  r_pfedge->cost = pfedge->cost;
 	  r_pfedge->max_capacity = pfedge->max_capacity;
 	  if (dump_file)
 	    dump_fixup_edge (dump_file, fixup_graph, r_pfedge);
@@ -787,14 +820,12 @@ cancel_negative_cycle (fixup_graph_type *fixup_graph,
   bool found_cycle = false;
   int cycle_start = 0, cycle_end = 0;
   gcov_type sum_cost = 0, cycle_flow = 0;
-  int new_entry_index;
   bool propagated = false;
 
   gcc_assert (fixup_graph);
   fnum_vertices = fixup_graph->num_vertices;
   fnum_edges = fixup_graph->num_edges;
   fedge_list = fixup_graph->edge_list;
-  new_entry_index = fixup_graph->new_entry_index;
 
   /* Initialize.  */
   /* Skip ENTRY.  */
@@ -813,8 +844,6 @@ cancel_negative_cycle (fixup_graph_type *fixup_graph,
     for (i = 0; i < fnum_edges; i++)
       {
 	pfedge = fedge_list + i;
-	if (pfedge->src == new_entry_index)
-	  continue;
 	if (pfedge->is_rflow_valid && pfedge->rflow
             && d[pfedge->src] != CAP_INFINITY
 	    && (d[pfedge->dest] > d[pfedge->src] + pfedge->cost))
@@ -836,8 +865,6 @@ cancel_negative_cycle (fixup_graph_type *fixup_graph,
   for (i = 0; i < fnum_edges; i++)
     {
       pfedge = fedge_list + i;
-      if (pfedge->src == new_entry_index)
-	continue;
       if (pfedge->is_rflow_valid && pfedge->rflow
           && d[pfedge->src] != CAP_INFINITY
 	  && (d[pfedge->dest] > d[pfedge->src] + pfedge->cost))
@@ -905,10 +932,12 @@ cancel_negative_cycle (fixup_graph_type *fixup_graph,
     {
       pfedge = find_fixup_edge (fixup_graph, cycle[k + 1], cycle[k]);
       r_pfedge = find_fixup_edge (fixup_graph, cycle[k], cycle[k + 1]);
-      pfedge->rflow -= cycle_flow;
+      if (pfedge->rflow != CAP_INFINITY)
+        pfedge->rflow -= cycle_flow;
       if (pfedge->type)
 	pfedge->flow += cycle_flow;
-      r_pfedge->rflow += cycle_flow;
+      if (r_pfedge->rflow != CAP_INFINITY)
+        r_pfedge->rflow += cycle_flow;
       if (r_pfedge->type)
 	r_pfedge->flow -= cycle_flow;
     }
@@ -938,7 +967,8 @@ compute_residual_flow (fixup_graph_type *fixup_graph)
   for (i = 0; i < fnum_edges; i++)
     {
       pfedge = fedge_list + i;
-      pfedge->rflow = pfedge->max_capacity - pfedge->flow;
+      pfedge->rflow = pfedge->max_capacity == CAP_INFINITY ?
+                      CAP_INFINITY : pfedge->max_capacity - pfedge->flow;
       pfedge->is_rflow_valid = true;
       add_rfixup_edge (fixup_graph, pfedge->dest, pfedge->src, pfedge->flow,
 		       -pfedge->cost);
@@ -1063,20 +1093,22 @@ find_max_flow (fixup_graph_type *fixup_graph, int source, int sink)
 	{
 	  pfedge = find_fixup_edge (fixup_graph, bb_pred[u], u);
 	  r_pfedge = find_fixup_edge (fixup_graph, u, bb_pred[u]);
+
+          if (pfedge->rflow != CAP_INFINITY)
+	    pfedge->rflow -= increment;
+          if (r_pfedge->rflow != CAP_INFINITY)
+	    r_pfedge->rflow += increment;
+
 	  if (pfedge->type)
 	    {
 	      /* forward edge.  */
 	      pfedge->flow += increment;
-	      pfedge->rflow -= increment;
-	      r_pfedge->rflow += increment;
 	    }
 	  else
 	    {
 	      /* backward edge.  */
 	      gcc_assert (r_pfedge->type);
-	      r_pfedge->rflow += increment;
 	      r_pfedge->flow -= increment;
-	      pfedge->rflow -= increment;
 	    }
 	}
 
@@ -1295,6 +1327,60 @@ adjust_cfg_counts (fixup_graph_type *fixup_graph)
 }
 
 
+/* Called before negative_cycle_cancellation, to form a cycle between
+ * new_exit to new_entry in FIXUP_GRAPH with capacity MAX_FLOW. We
+ * don't want the flow in the BALANCE_EDGE to be modified, so we set
+ * the residural flow of those edges to 0 */
+
+static void
+modify_sink_source_capacity (fixup_graph_type *fixup_graph, gcov_type max_flow)
+{
+  fixup_edge_p edge, r_edge;
+  int i;
+  int entry = ENTRY_BLOCK;
+  int exit = 2 * EXIT_BLOCK + 1;
+  int new_entry = fixup_graph->new_entry_index;
+  int new_exit = fixup_graph->new_exit_index;
+
+  edge = find_fixup_edge (fixup_graph, new_entry, entry);
+  edge->max_capacity = CAP_INFINITY;
+  edge->rflow = CAP_INFINITY;
+
+  edge = find_fixup_edge (fixup_graph, entry, new_entry);
+  edge->max_capacity = CAP_INFINITY;
+  edge->rflow = CAP_INFINITY;
+
+  edge = find_fixup_edge (fixup_graph, exit, new_exit);
+  edge->max_capacity = CAP_INFINITY;
+  edge->rflow = CAP_INFINITY;
+
+  edge = find_fixup_edge (fixup_graph, new_exit, exit);
+  edge->max_capacity = CAP_INFINITY;
+  edge->rflow = CAP_INFINITY;
+
+  edge = find_fixup_edge (fixup_graph, new_exit, new_entry);
+  edge->max_capacity = CAP_INFINITY;
+  edge->flow = max_flow;
+  edge->rflow = CAP_INFINITY;
+
+  r_edge = find_fixup_edge (fixup_graph, new_entry, new_exit);
+  r_edge->rflow = max_flow;
+
+  /* Find all the backwards residual edges corresponding to
+     BALANCE_EDGEs and set their residual flow to 0 to enforce a
+     minimum flow constraint on these edges. */
+  for (i = 4; i < new_entry; i += 1)
+    {
+      edge = find_fixup_edge (fixup_graph, i, new_entry);
+      if (edge)
+	edge->rflow = 0;
+      edge = find_fixup_edge (fixup_graph, new_exit, i);
+      if (edge)
+	edge->rflow = 0;
+    }
+}
+
+
 /* Implements the negative cycle canceling algorithm to compute a minimum cost
    flow.
 Algorithm:
@@ -1323,13 +1409,18 @@ find_minimum_cost_flow (fixup_graph_type *fixup_graph)
   int fnum_vertices;
   int new_exit_index;
   int new_entry_index;
+  gcov_type max_flow;
 
   gcc_assert (fixup_graph);
   fnum_vertices = fixup_graph->num_vertices;
   new_exit_index = fixup_graph->new_exit_index;
   new_entry_index = fixup_graph->new_entry_index;
 
-  find_max_flow (fixup_graph, new_entry_index, new_exit_index);
+  max_flow = find_max_flow (fixup_graph, new_entry_index, new_exit_index);
+
+  /* Adjust the fixup graph to translate things into a minimum cost
+     circulation problem. */
+  modify_sink_source_capacity (fixup_graph, max_flow);
 
   /* Initialize the structures for find_negative_cycle().  */
   pred = (int *) xcalloc (fnum_vertices, sizeof (int));
@@ -1345,7 +1436,14 @@ find_minimum_cost_flow (fixup_graph_type *fixup_graph)
       iteration++;
       if (iteration > MAX_ITER (fixup_graph->num_vertices,
                                 fixup_graph->num_edges))
-        break;
+	{
+          if (dump_enabled_p ())
+            dump_printf_loc (MSG_NOTE,
+                             DECL_SOURCE_LOCATION (current_function_decl),
+                             "Exiting profile correction early to avoid "
+                             "excessive compile time");
+          break;
+	}
     }
 
   if (dump_file)
diff --git a/gcc/mversn-dispatch.c b/gcc/mversn-dispatch.c
new file mode 100644
index 0000000..17b2ae8
--- /dev/null
+++ b/gcc/mversn-dispatch.c
@@ -0,0 +1,1769 @@
+/* Mulitversion Dispatch Pass.
+   Copyright (C) 2011 Free Software Foundation, Inc.
+   Contributed by Sriraman Tallam (tmsriram@google.com)
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>. */
+
+
+/* This pass processes __builtin_dispatch calls to call multi-versioned
+   functions. Only two versions are supported now. Example use :
+
+  int popcnt_sse4(unsigned int x) __attribute__((__target__("popcnt")));
+  int popcnt_sse4(unsigned int x)
+  {
+    int count = __builtin_popcount(x);
+    return count;
+  }
+
+  int popcnt(unsigned int x) __attribute__((__target__("no-popcnt")));
+  int popcnt(unsigned int x)
+  {
+    int count = __builtin_popcount(x);
+    return count;
+  }
+
+  int testsse() __attribute__((version_selector));
+  int main ()
+  {
+    ...
+    ret = __builtin_dispatch (testsse,  (void*)popcnt_sse4, (void*)popcnt, 25);
+    ...
+  }
+
+  There are two passes that are run to achieve multi-versioning.
+  "pass_ipa_multiversion_dispatch" is an ipa pass that decides which functions
+  have to be cloned and hoists the feature-test calls appropriately.  This
+  pass can be enabled with the flag "-fclone-hot-version-paths" and disabled
+  with "-fno-clone-hot-version-paths".
+
+  "pass_tree_convert_builtin_dispatch" does the lowering.  It is a
+  function-level pass.  Functions marked with attribute "version_selector" are
+  also handled by this pass.  This pass is always on.
+
+  How to use __builtin_dispatch ?
+  -----------------------------
+
+  __builtin_dispatch takes 3 mandatory arguments :
+
+  __builtin_dispatch (arg1, arg2, arg3, <arg4>, <arg5>, ...);
+
+  arg1 is the pointer to the feature-test function.
+  arg2 is the ( void *) cast pointer to the versioned function that is
+  executed when the feature test returns 1.
+  arg3 is the ( void *) cast pointer to the versioned function that is
+  executed when the feature test returns 0.
+  arg4, arg5, ... are optional. They are the arguments to the versioned
+  functions.  Both versions must accept the same number of arguments.
+  The __builtin_dispatch function returns the value returned by the
+  versioned function that gets executed.  The versioned function arg2
+  is executed when the feature_test function arg1 returns 1 and arg3
+  is executed when the feature_test function arg1 returns 0. arg1
+  could be marked as a "version_selector" function if it is a pure
+  function with no side-effects, returns a constant at run-time and
+  can be evaluated at any point in the execution.
+
+  When to use the "version_selector" attribute ?
+  -----------------------------------------------
+
+  Functions are marked with attribute "version_selector" only if
+  they are run-time constants.  Example of such functions would
+  be those that test if a specific feature is available on a
+  particular architecture.  Such functions must return a positive
+  integer. For two-way functions, those that test if a feature
+  is present or not must return 1 or 0 respectively.
+
+
+  The code is organized into five parts.  The first part has the functionality
+  to detect and handle functions marked with attribute "version_selector".  The
+  second part is the analysis phase where we find calls to __builtin_dispatch
+  and mark all functions that are hot and have a call-graph path to a
+  __builtin_dispatch call.  The third part decides which functions
+  to clone.  This is based on the number of clones that have to be created for
+  the functions marked in the analysis phase. Only two clones are allowed for
+  a function currently.  The fourth part is where the actual cloning happens.
+  The fifth part contains the implementation to lower the __builtin_dispatch
+  calls.
+
+  Flags : -fclone-hot-version-paths does function unswitching via cloning.
+          --param=num-mversn-clones=<num> allows to specify the number of
+          functions that should be cloned.
+	  --param=mversn-clone-depth=<num> allows to specify the length of
+          the call graph path that should be cloned.  num = 0 implies only
+          leaf node that contains the __builtin_dispatch statement must be
+          cloned. */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "tree.h"
+#include "tree-inline.h"
+#include "langhooks.h"
+#include "flags.h"
+#include "cgraph.h"
+#include "diagnostic.h"
+#include "toplev.h"
+#include "timevar.h"
+#include "params.h"
+#include "fibheap.h"
+#include "intl.h"
+#include "tree-pass.h"
+#include "hashtab.h"
+#include "coverage.h"
+#include "ggc.h"
+#include "tree-flow.h"
+#include "rtl.h"
+#include "ipa-prop.h"
+#include "basic-block.h"
+#include "toplev.h"
+#include "dbgcnt.h"
+#include "tree-dump.h"
+#include "output.h"
+#include "vecprim.h"
+#include "gimple-pretty-print.h"
+#include "ipa-inline.h"
+
+typedef struct cgraph_node* NODEPTR;
+DEF_VEC_P (NODEPTR);
+DEF_VEC_ALLOC_P (NODEPTR, heap);
+
+/* Store the decl of __builtin_dispatch */
+static tree builtin_function_decl = NULL;
+
+/* Hash to map name to a decl.  Used for variables and functions. */
+static htab_t name_decl_htab = NULL;
+
+/* Hashtable helpers for name_decl_htab. */
+
+static hashval_t
+name_decl_htab_hash_descriptor (const void *p)
+{
+  const_tree t = (const_tree) p;
+  const char *name
+    = (IDENTIFIER_POINTER (DECL_NAME (t)));
+  return htab_hash_string(name);
+}
+
+/* Hashtable helper for name_decl_htab. */
+
+static int
+name_decl_htab_eq_descriptor (const void *p1, const void *p2)
+{
+  const_tree t1 = (const_tree) p1;
+  const char *c1 = IDENTIFIER_POINTER (DECL_NAME (t1));
+  const char *c2 = (const char *)p2;
+
+  return (strcmp (c1, c2) == 0);
+}
+
+/* Return true if NODE is a hot function.  It is a hot function
+   if its execution frequency is determined to be hot or
+   if any of its incoming or outgoing call-graph edges is hot.  */
+
+static bool
+hot_function_p (struct cgraph_node *node)
+{
+  struct cgraph_edge *edge;
+
+  if (node->frequency == NODE_FREQUENCY_HOT)
+    return true;
+
+  for (edge = node->callees; edge; edge = edge->next_callee)
+    if (cgraph_maybe_hot_edge_p (edge))
+      return true;
+
+  for (edge = node->callers; edge; edge = edge->next_caller)
+    if (cgraph_maybe_hot_edge_p (edge))
+      return true;
+
+  return false;
+}
+
+/* Return the number of arguments that a function has.  */
+
+static int
+function_args_count (tree fntype)
+{
+  function_args_iterator args_iter;
+  tree t;
+  int num = 0;
+
+  if (fntype)
+    {
+      FOREACH_FUNCTION_ARGS(fntype, t, args_iter)
+	{
+	  num++;
+	}
+    }
+
+  return num;
+}
+
+/* Return the variable name (global/constructor) to use for the
+   version_selector function with name of DECL by appending SUFFIX. */
+
+static char *
+make_name (tree decl, const char *suffix)
+{
+  char *global_var_name;
+  int name_len;
+  const char *name;
+
+  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));
+
+  name_len = strlen (name) + strlen (suffix) + 2;
+  global_var_name = (char *) xmalloc (name_len);
+  snprintf (global_var_name, name_len, "%s_%s", name, suffix);
+  return global_var_name;
+}
+
+/* Code for handling version_selector attribute functions.  Such functions are
+   run-time constants and need to be executed only once.  They are hoisted
+   to a static constructor and their result is stored in a global.
+ */
+
+
+/* This function returns the global variable / constructor name created
+   for feature-test functions marked with attribute "version_selector".
+   The name returned is the DECL name appended with
+   "version_selector_global" for the variable and
+   "version_selector_constructor" for the constructor. */
+
+static char*
+make_feature_test_global_name (tree decl, bool is_constructor)
+{
+  if (is_constructor)
+    return make_name (decl, "version_selector_constructor");
+
+  return make_name (decl, "version_selector_global");
+}
+
+/* This function creates a new VAR_DECL with attributes set
+   using the parameters.  PUBLIK corresponds to TREE_PUBLIC,
+   EXTERNAL corresponds to DECL_EXTERNAL and comdat is
+   for DECL_ONE_ONLY.  The global variable will have the
+   same status as the version_selector function.*/
+
+static tree
+allocate_new_var (const char *name, int publik,
+                  int external, int comdat)
+{
+  tree new_global_var;
+  struct varpool_node *vnode;
+
+  new_global_var = build_decl (UNKNOWN_LOCATION,
+			       VAR_DECL,
+	  	               get_identifier (name),
+		               integer_type_node);
+
+  DECL_EXTERNAL (new_global_var) = external;
+  TREE_STATIC (new_global_var) = 1;
+  TREE_PUBLIC (new_global_var) = publik;
+  DECL_INITIAL (new_global_var) = 0;
+  DECL_ARTIFICIAL (new_global_var) = 1;
+  DECL_PRESERVE_P (new_global_var) = 1;
+
+  if (comdat)
+    make_decl_one_only (new_global_var, DECL_ASSEMBLER_NAME (new_global_var));
+  assemble_variable (new_global_var, 0, 0, 0);
+
+  vnode = varpool_node (new_global_var);
+  gcc_assert (vnode != NULL);
+  /* Set finalized to 1, otherwise it asserts in function "write_symbol" in
+     lto-streamer-out.c. */
+  vnode->finalized = 1;
+  
+  return new_global_var;
+}
+
+/* Make a new constructor function here to call a feature-test function
+   and set its body to CONSTRUCTOR_BODY.  Its public and comdat
+   attributes are set from the parameters, PUBLIK, and COMDAT.
+   VERSION_SELECTOR_VAR is the global decl that saves the result of the
+   feature-test function in the constructor. */
+
+static tree
+make_constructor_function (char *name, gimple constructor_body, int publik,
+			   int comdat, tree version_selector_var)
+{
+  tree decl, type, t;
+  gimple_seq seq;
+  basic_block new_bb;
+  tree old_current_function_decl;
+
+  type = build_function_type_list (void_type_node, NULL_TREE);
+
+  if (dump_file)
+    fprintf (dump_file, "Name of new constructor function = %s\n", name);
+
+  decl = build_fn_decl (name, type);
+
+  DECL_NAME (decl) = get_identifier (name);
+  SET_DECL_ASSEMBLER_NAME (decl, DECL_NAME (decl));
+  gcc_assert (cgraph_get_create_node (decl) != NULL);
+
+  TREE_USED (decl) = 1;
+  DECL_ARTIFICIAL (decl) = 1;
+  DECL_IGNORED_P (decl) = 0;
+  TREE_PUBLIC (decl) = publik;
+  DECL_UNINLINABLE (decl) = 1;
+  DECL_EXTERNAL (decl) = 0;
+  DECL_CONTEXT (decl) = NULL_TREE;
+  DECL_INITIAL (decl) = make_node (BLOCK);
+  DECL_STATIC_CONSTRUCTOR (decl) = 1;
+  TREE_READONLY (decl) = 0;
+  DECL_PURE_P (decl) = 0;
+
+  if (comdat)
+    make_decl_one_only (decl, DECL_ASSEMBLER_NAME (decl));
+
+  /* Build result decl and add to function_decl. */
+  t = build_decl (UNKNOWN_LOCATION, RESULT_DECL, NULL_TREE, void_type_node);
+  DECL_ARTIFICIAL (t) = 1;
+  DECL_IGNORED_P (t) = 1;
+  DECL_RESULT (decl) = t;
+
+  gimplify_function_tree (decl);
+
+  /* Build CFG for this function. */
+
+  old_current_function_decl = current_function_decl;
+  push_cfun (DECL_STRUCT_FUNCTION (decl));
+  current_function_decl = decl;
+  init_empty_tree_cfg_for_function (DECL_STRUCT_FUNCTION (decl));
+  cfun->curr_properties |=
+    (PROP_gimple_lcf | PROP_gimple_leh | PROP_cfg | PROP_referenced_vars |
+     PROP_ssa);
+  new_bb = create_empty_bb (ENTRY_BLOCK_PTR);
+  make_edge (ENTRY_BLOCK_PTR, new_bb, EDGE_FALLTHRU);
+
+  /* XXX: Not sure if the edge commented below is necessary.  If I add this
+     edge, it fails in gimple_verify_flow_info in tree-cfg.c in condition :
+     " if (e->flags & EDGE_FALLTHRU)"
+     during -fprofile-generate.
+     Otherwise, it is fine.  Deleting this edge does not break anything.
+     Commenting this so that it is clear I am intentionally not doing this.*/
+  /* make_edge (new_bb, EXIT_BLOCK_PTR, EDGE_FALLTHRU); */
+
+  seq = gimple_seq_alloc_with_stmt (constructor_body);
+
+  set_bb_seq (new_bb, seq);
+  gimple_set_bb (constructor_body, new_bb);
+
+  /* Set the lexical block of the constructor body. Fails the inliner
+     other wise. */
+  gimple_set_block (constructor_body, DECL_INITIAL (decl));
+
+  /* This call is very important if this pass runs when the IR is in
+     SSA form.  It breaks things in strange ways otherwise. */
+  init_tree_ssa (DECL_STRUCT_FUNCTION (decl));
+  add_referenced_var (version_selector_var);
+
+  cgraph_add_new_function (decl, true);
+  cgraph_call_function_insertion_hooks (cgraph_get_create_node (decl));
+  cgraph_mark_needed_node (cgraph_get_create_node (decl));
+
+  if (dump_file)
+    dump_function_to_file (decl, dump_file, TDF_BLOCKS);
+
+  pop_cfun ();
+  current_function_decl = old_current_function_decl;
+  return decl;
+}
+
+/* If  the current function is marked with attribute
+   "version_selector" then it is the predicate (feature-test) function
+   for multi-versioning.  Call this function in a constructor and assign
+   the return value to a global variable.
+   The constructor's name is the decl name suffixed
+   "version_selector_constructor" and the global variable's name is the
+   decl name suffixed with "version_selector_global"
+
+   For example, feature-test function isSSE4 marked with attribute
+   version_selector is converted to
+
+   void isSSE4_version_selector_constructor ()
+   {
+     isSSE4_version_selector_global = isSSE4 ();
+   }
+
+   This function returns the decl of the global variable.
+
+   THIS_DECL is the function decl of the "version_selector" function.
+   */
+
+static tree
+handle_version_selector_attr_function (tree this_decl)
+{
+  char *global_var_name;
+  tree version_selector_var = NULL;
+  void **slot;
+
+  gcc_assert (!flag_lto);
+
+  if (dump_file)
+    fprintf (dump_file, "Creating constructor/global for function %s\n",
+	     IDENTIFIER_POINTER (DECL_NAME (this_decl)));
+
+  global_var_name = make_feature_test_global_name (this_decl,
+                                                   false);
+
+  slot = htab_find_slot_with_hash (name_decl_htab, global_var_name,
+                                   htab_hash_string (global_var_name),
+                                   INSERT);
+  if (*slot == NULL)
+    {
+      if (dump_file)
+        fprintf (dump_file, "Creating global variable %s\n",
+	         global_var_name);
+      *slot = allocate_new_var (global_var_name,
+                                TREE_PUBLIC (this_decl),
+                                DECL_EXTERNAL (this_decl),
+                                DECL_ONE_ONLY (this_decl));
+    }
+  else
+    {
+      free (global_var_name);
+      return (tree) *slot;
+    }
+
+  version_selector_var = (tree) *slot;
+
+  /* If the feature-test function is not external, create a constructor and
+     call this function in the constructor. */
+
+  if (!DECL_EXTERNAL (this_decl))
+    {
+      char *constructor_name;
+      gimple constructor_body;
+      tree constructor_decl;
+
+      constructor_name
+        = make_feature_test_global_name (this_decl, true);
+
+      constructor_body = gimple_build_call (this_decl, 0);
+
+      gimple_call_set_lhs (constructor_body, version_selector_var);
+
+      if (dump_file)
+        print_gimple_stmt (dump_file, constructor_body, 0, TDF_VOPS);
+
+      constructor_decl =
+        make_constructor_function (constructor_name, constructor_body,
+				   TREE_PUBLIC (this_decl),
+				   DECL_ONE_ONLY (this_decl),
+			           version_selector_var);
+
+      gcc_assert (constructor_decl != NULL_TREE);
+      free (constructor_name);
+    }
+
+  free (global_var_name);
+  return version_selector_var;
+}
+
+/* Start Analysis phase.  Mark all functions that are hot and have a call-graph
+   path to a __builtin_dispatch call. */
+
+/* This function returns the address of the feature test function.
+   If the address of the function is saved to a temporary,
+   this function traverses the gimple statements before BUILTIN_STMT
+   and finds an assignment whose rhs is the feature test function.
+   If the feature test function is specified as a function pointer
+   whose function value is unknown, this funcition returns NULL. */
+
+static tree
+find_version_selector_func_addr (gimple builtin_stmt)
+{
+  tree cond_func_addr = NULL;
+  gimple def_stmt = NULL;
+
+  cond_func_addr = gimple_call_arg (builtin_stmt, 0);
+
+  gcc_assert (TREE_CODE (cond_func_addr) == ADDR_EXPR
+	      || TREE_CODE (cond_func_addr) == SSA_NAME);
+
+  if (TREE_CODE (cond_func_addr) == ADDR_EXPR)
+    return cond_func_addr;
+
+  /* TREE_CODE (cond_func_addr) ==  SSA_NAME
+     This means a new function pointer variable is created and assigned the
+     address of the feature-test function. Traverse the statements backwards
+     and find the assignment to get the RHS. */
+
+  def_stmt = SSA_NAME_DEF_STMT (cond_func_addr);
+
+  gcc_assert (def_stmt
+              && gimple_assign_lhs (def_stmt) == cond_func_addr);
+
+  cond_func_addr = gimple_assign_rhs1 (def_stmt);
+
+  /* If the cond_func_addr is still not an ADDR_EXPR, it means that the
+     feature-test function is specified as a pointer.  In this case, we
+     return NULL, since the feature-test function decl is not known. */
+
+  if (cond_func_addr == NULL
+      || TREE_CODE (cond_func_addr) != ADDR_EXPR)
+    return NULL;
+
+  /* If the operand of the ADDR_EXPR is not a function_decl, return NULL
+     as this still means the feature-test function is specified as a
+     function pointer. */
+
+  if (TREE_CODE (TREE_OPERAND (cond_func_addr, 0)) != FUNCTION_DECL)
+    return NULL;
+
+  return cond_func_addr;
+}
+
+/* Finds the gimple calls  to __builtin_dispatch in function pointed
+   to by the call graph NODE and populates the vector VEC.  Returns
+   true if at least one statement was found where the feature test
+   function is marked as "version_selector".  Otherwise, there is no
+   question of hoisting it. */
+
+static bool
+is_builtin_dispatch_stmt_present (struct cgraph_node *node,
+			          VEC (tree,heap) **vec)
+{
+  struct cgraph_edge *edge;
+  bool present = false;
+
+  gcc_assert (!flag_lto);
+
+  for (edge = node->callees; edge; edge = edge->next_callee)
+    {
+      if (edge->callee->decl == builtin_function_decl)
+        {
+	  tree cond_func_decl;
+	  tree cond_func_addr;
+	  gcc_assert (*vec != NULL);
+	  cond_func_addr = find_version_selector_func_addr (edge->call_stmt);
+
+	  if (cond_func_addr == NULL)
+            continue;
+
+	  cond_func_decl = TREE_OPERAND (cond_func_addr, 0);
+
+	  /* Do not consider for hoisting if "version_selector" attribute is
+	     not set. */
+	  if (lookup_attribute ("version_selector",
+			        DECL_ATTRIBUTES (cond_func_decl)) == NULL)
+            {
+              if (dump_file)
+                {
+                  fprintf (dump_file, "Not hoisting builtin_dispatch as "
+                           "feature_test function not version_selector :\n");
+                  print_gimple_stmt (dump_file, edge->call_stmt, 0, TDF_VOPS);
+		}
+              continue;
+            }
+
+	  present = true;
+	  VEC_safe_push (tree, heap, *vec, cond_func_decl);
+        }
+    }
+  return present;
+}
+
+/* Updates the list of feature-test function decls reaching the cgraph
+   function NODE. */
+
+static void
+update_reachable_decls_list (struct cgraph_node *node,
+                             VEC (tree, heap) *predicate_decls)
+{
+  VEC (tree, heap) **decl_list = NULL;
+  tree cond_func_decl;
+  int ix;
+
+  if (node->aux == NULL)
+    {
+      decl_list = (VEC (tree, heap) **) xmalloc (sizeof (VEC (tree, heap) *));
+      *decl_list = VEC_alloc (tree, heap, 1);
+      node->aux = decl_list;
+    }
+  else
+    decl_list = (VEC (tree, heap) **) node->aux;
+
+  for (ix = 0; VEC_iterate (tree, predicate_decls, ix, cond_func_decl); ++ix)
+    VEC_safe_push (tree, heap, *decl_list, cond_func_decl);
+}
+
+/* Propagate the __builtin_dispatch stmt (s) called from node to its
+   callers, PREDICATE_DECLS is the decls list of the predicate functions. */
+
+static unsigned int
+mark_reachable_functions (struct cgraph_node *this_node,
+			  VEC (tree, heap) *predicate_decls)
+{
+  VEC (NODEPTR, heap) *work_list;
+  VEC (int, heap) *depth_list;
+  struct cgraph_edge *e;
+  htab_t node_htab = NULL;
+  void **slot = NULL;
+
+  /* Use a work-list style algorithm to mark functions in any call-graph
+     path to the current function. */
+
+  work_list = VEC_alloc (NODEPTR, heap, 8);
+  depth_list = VEC_alloc (int, heap, 8);
+
+  VEC_safe_push (NODEPTR, heap, work_list, this_node);
+  VEC_safe_push (int, heap, depth_list, 0);
+
+  node_htab = htab_create (10, htab_hash_pointer,
+  			   htab_eq_pointer, NULL);
+
+  slot = htab_find_slot (node_htab, this_node, INSERT);
+
+  gcc_assert (*slot == NULL);
+  *slot = this_node;
+
+  while (!VEC_empty (NODEPTR, work_list))
+    {
+      struct cgraph_node *node = VEC_pop (NODEPTR, work_list);
+      int depth = VEC_pop (int, depth_list);
+
+      if (dump_file)
+        fprintf (dump_file, "%s has a depth = %d callgraph path to %s\n",
+                 cgraph_node_name (node), depth,
+                 cgraph_node_name (this_node));
+
+      update_reachable_decls_list (node, predicate_decls);
+
+      gcc_assert (node->aux != NULL);
+
+      if (depth >= PARAM_VALUE (PARAM_MVERSN_CLONE_CGRAPH_DEPTH))
+        {
+          if (dump_file)
+            fprintf (dump_file, "Not propogating __builtin_dispatch... "
+                     "maximum cloning depth  = %d reached\n",
+		     PARAM_VALUE (PARAM_MVERSN_CLONE_CGRAPH_DEPTH));
+          continue;
+        }
+
+      for (e = node->callers; e; e = e->next_caller)
+        {
+          slot = htab_find_slot (node_htab, e->caller, INSERT);
+	  if (*slot != NULL)
+	    continue;
+          *slot = e->caller;
+          if (!hot_function_p (e->caller))
+            continue;
+
+          VEC_safe_push (NODEPTR, heap, work_list, e->caller);
+          VEC_safe_push (int, heap, depth_list, (depth + 1));
+        }
+    }
+
+  htab_delete (node_htab);
+  VEC_free (NODEPTR, heap, work_list);
+  VEC_free (int, heap, depth_list);
+  return 0;
+}
+
+/* Scan the call graph and detect hot functions that have __builtin_dispatch
+   calls. Then, propogate this information to its callers. Returns true if
+   a suitable __builtin_dispatch was found. */
+
+static bool
+perform_analysis_phase (void)
+{
+  struct cgraph_node *node;
+  VEC(tree, heap) *builtin_predicates_vec = NULL;
+  bool flag = false;
+
+  builtin_predicates_vec = VEC_alloc (tree, heap, 1);
+
+  for (node = cgraph_nodes; node; node = node->next)
+    {
+      /* if the body of this decl is from outside, do nothing. */
+      if (DECL_EXTERNAL (node->decl))
+        continue;
+
+      if (!hot_function_p (node))
+        continue;
+
+      if (!is_builtin_dispatch_stmt_present (node, &builtin_predicates_vec))
+        continue;
+
+      if (dump_file)
+        {
+          fprintf (dump_file, "%s calls __builtin_dispatch atleast once.\n",
+                   cgraph_node_name (node));
+
+          fprintf (dump_file, "%s is a hot function, consider cloning ...\n",
+        	   cgraph_node_name (node));
+        }
+
+      flag = true;
+      mark_reachable_functions (node, builtin_predicates_vec);
+      VEC_truncate (tree, builtin_predicates_vec, 0);
+    }
+
+  VEC_free (tree, heap, builtin_predicates_vec);
+  return flag;
+}
+
+/* End Analysis phase. */
+
+/* Decide Cloning Phase.
+
+   In this phase, we go through each function and decide if it should be
+   cloned or not. */
+
+/* This function counts the number of unique decls in the DECL_LIST.*/
+
+static int
+count_predicate_functions (VEC (tree,heap) *decl_list)
+{
+  int ix;
+  int count = 0;
+  tree cond_func_decl = NULL;
+  htab_t dup_decl_htab = NULL;
+
+  if (VEC_length (tree, decl_list) == 1)
+    return 1;
+
+  dup_decl_htab = htab_create (2, htab_hash_pointer, htab_eq_pointer, NULL);
+
+  for (ix = 0; VEC_iterate (tree, decl_list, ix, cond_func_decl); ++ix)
+    {
+      void **slot = NULL;
+      slot = htab_find_slot (dup_decl_htab, cond_func_decl, INSERT);
+
+      if (*slot != NULL)
+        continue;
+      count++;
+      *slot = cond_func_decl;
+    }
+
+  htab_delete (dup_decl_htab);
+  return count;
+}
+
+/* This function decides which functions to clone based on the number of
+   feature_test decls reaching it.  Currently, only one feature_test decl
+   is allowed. */
+
+static bool
+decide_cloning_phase (void)
+{
+  struct cgraph_node *node;
+  int count;
+  bool run_cloning_phase = false;
+  int num_funcs_cloned = 0;
+
+  for (node = cgraph_nodes; node; node = node->next)
+    {
+      tree cond_func_decl = NULL;
+      VEC (tree, heap) *vec;
+      if (node->aux == NULL)
+        continue;
+
+      if (num_funcs_cloned >= PARAM_VALUE (PARAM_NUMBER_OF_MVERSN_CLONES))
+        {
+          if (dump_file)
+            fprintf (dump_file, "Reached cloning limit specified "
+                     "by \"num-mversn-clones\" for %s\n",
+	             cgraph_node_name (node));
+
+          free (node->aux);
+	  node->aux = NULL;
+	  continue;
+        }
+
+      vec = *(VEC (tree,heap) **) node->aux;
+      count = count_predicate_functions (vec);
+      gcc_assert (count >= 1);
+      cond_func_decl = VEC_index (tree, vec, 0);
+      gcc_assert (cond_func_decl != NULL);
+      VEC_free (tree, heap, vec);
+      free (node->aux);
+      node->aux = NULL;
+
+      if (count > 1)
+        {
+          if (dump_file)
+            fprintf (dump_file, "%s has %d predicates, Not cloning for > 1\n",
+	             cgraph_node_name (node), count);
+	  continue;
+        }
+      /* Set the node's aux value to be that of the predicate decl. */
+      node->aux = cond_func_decl;
+      run_cloning_phase = true;
+      num_funcs_cloned++;
+    }
+  return run_cloning_phase;
+}
+
+/* End Decide Cloning Phase. */
+
+/* Cloning Phase. */
+
+/* Deletes all basic-blocks and leaves function with :
+   ENTRY_BLOCK ---> (new empty basic block) ---> EXIT_BLOCK
+*/
+
+static basic_block
+empty_function_body (tree fndecl)
+{
+  basic_block bb, new_bb;
+  edge e;
+  tree old_current_function_decl;
+
+  old_current_function_decl = current_function_decl;
+  push_cfun (DECL_STRUCT_FUNCTION (fndecl));
+  current_function_decl = fndecl;
+
+  clear_edges ();
+  for (bb = ENTRY_BLOCK_PTR; bb != NULL;)
+    {
+      basic_block bb_next;
+      bb_next = bb->next_bb;
+      if (bb != EXIT_BLOCK_PTR
+          && bb != ENTRY_BLOCK_PTR)
+        {
+          if (bb_seq (bb) != NULL)
+            {
+              gimple_stmt_iterator i;
+              for (i = gsi_start_bb (bb); !gsi_end_p (i);)
+	        {
+		  gimple stmt = gsi_stmt (i);
+		  unlink_stmt_vdef (stmt);
+                  gsi_remove (&i, true);
+		  release_defs (stmt);
+		}
+            }
+          bb->il.gimple = NULL;
+          bb->prev_bb = NULL;
+          bb->next_bb = NULL;
+          SET_BASIC_BLOCK (bb->index, NULL);
+          n_basic_blocks--;
+        }
+      bb = bb_next;
+    }
+  ENTRY_BLOCK_PTR->next_bb = EXIT_BLOCK_PTR;
+  new_bb = create_empty_bb (ENTRY_BLOCK_PTR);
+  e = make_edge (ENTRY_BLOCK_PTR, new_bb, EDGE_FALLTHRU);
+  gcc_assert (e != NULL);
+  /* XXX:Is this edge necessary ? */
+  e = make_edge (new_bb, EXIT_BLOCK_PTR, 0);
+  gcc_assert (e != NULL);
+
+  current_function_decl = old_current_function_decl;
+  pop_cfun ();
+  return new_bb;
+}
+
+/* Takes function with decl ORIG_FNDECL and clones it.  The
+   name of the clone is the original name suffixed with
+   NAME_SUFFIX.  Code is adapted from cgraph_function_versioning
+   in cgraphunit.c */
+
+static tree
+clone_function (tree orig_fndecl, const char *name_suffix)
+{
+  tree new_decl;
+  char *new_name;
+  struct cgraph_node *new_version;
+  struct cgraph_node *old_version;
+  void **slot;
+  tree old_current_function_decl;
+
+  new_name = make_name (orig_fndecl, name_suffix);
+  new_decl = copy_node (orig_fndecl);
+
+
+  slot = htab_find_slot_with_hash (name_decl_htab, new_name,
+                                   htab_hash_string (new_name), INSERT);
+
+  gcc_assert (*slot == NULL);
+  *slot = new_decl;
+
+  /* Code adapted from cgraph_function_versioning in cgraphuinit.c */
+
+  new_version = cgraph_get_create_node (new_decl);
+  old_version = cgraph_get_create_node (orig_fndecl);
+
+  new_version->local = old_version->local;
+  new_version->global = old_version->global;
+  new_version->rtl = old_version->rtl;
+  new_version->reachable = true;
+  new_version->count = old_version->count;
+
+  /* Set the name of the new function. */
+  DECL_NAME (new_decl) = get_identifier (new_name);
+  SET_DECL_ASSEMBLER_NAME (new_decl, DECL_NAME (new_decl));
+  SET_DECL_RTL (new_decl, NULL);
+
+  tree_function_versioning (orig_fndecl, new_decl, NULL /*tree_map*/,
+                            false, NULL /*args_to_skip*/,
+			    false, /* skip return */
+			    NULL /* blocks_to_copy */ ,
+                            NULL /* new_entry */);
+
+
+  old_current_function_decl = current_function_decl;
+  push_cfun (DECL_STRUCT_FUNCTION (new_decl));
+  current_function_decl = new_decl;
+
+  TREE_READONLY (new_decl) = TREE_READONLY (orig_fndecl);
+  TREE_STATIC (new_decl) = TREE_STATIC (orig_fndecl);
+  TREE_USED (new_decl) = TREE_USED (orig_fndecl);
+  DECL_ARTIFICIAL (new_decl) = 1;
+  DECL_IGNORED_P (new_decl) = 0;
+  TREE_PUBLIC (new_decl) = TREE_PUBLIC (orig_fndecl);
+  DECL_CONTEXT (new_decl) = DECL_CONTEXT (orig_fndecl);
+
+  DECL_EXTERNAL (new_decl) = DECL_EXTERNAL (orig_fndecl);
+  DECL_COMDAT (new_decl) = DECL_COMDAT (orig_fndecl);
+  DECL_COMDAT_GROUP (new_decl) = DECL_COMDAT_GROUP (orig_fndecl);
+  DECL_VIRTUAL_P (new_decl) = DECL_VIRTUAL_P (orig_fndecl);
+  DECL_WEAK (new_decl) = DECL_WEAK (orig_fndecl);
+
+  /* Always inline the clones. Why are we cloning otherwise? */
+  DECL_DECLARED_INLINE_P (new_decl) = 1;
+  DECL_UNINLINABLE (new_decl) = 0;
+  new_version->local.externally_visible
+  = old_version->local.externally_visible;
+  new_version->local.local
+  = old_version->local.local;
+
+  new_version->analyzed = true;
+  new_version->lowered = true;
+
+  if (dump_file)
+    dump_function_to_file (new_decl, dump_file, TDF_BLOCKS);
+
+  cgraph_add_new_function (new_decl, true);
+
+  cgraph_call_function_insertion_hooks (new_version);
+  cgraph_mark_needed_node (new_version);
+
+  pop_cfun ();
+  current_function_decl = old_current_function_decl;
+
+  return new_decl;
+}
+
+/* This function populates the vector *VEC with the args in the gimple
+   call statement STMT. SKIP_ARGS is the number of args to skip.*/
+
+static void
+get_function_args (gimple stmt, int num_args, VEC (tree, heap) **vec,
+                   int skip_args)
+{
+  int i;
+
+  if (num_args == 0) return;
+
+  *vec = VEC_alloc (tree, heap, num_args);
+  /* The number of args in a function is 1 plus the actual number of
+     args.  Also, there are 3 special args reserved, so the first arg
+     starts from 3. */
+  for (i = 0; i <= num_args - 2; ++i)
+    VEC_quick_push (tree, *vec, gimple_call_arg (stmt, (skip_args + i)));
+}
+
+/* Given ret = __builtin_dispatch (pred, fn1, fn2, arg1, ....)
+   get ret = fn1 (arg1, ...) or ret = fn2 (arg1, ....)
+   depending on the value of SIDE == 0 or 1. */
+
+static gimple
+make_specialized_call_from_builtin (gimple builtin_stmt, int side)
+{
+  tree func_addr;
+  int num_func_args = 0;
+  VEC (tree, heap) *nargs = NULL;
+  tree lhs_stmt;
+  gimple specialized_call_stmt;
+
+  if (side == 0)
+    func_addr = gimple_call_arg (builtin_stmt, 1);
+  else
+    func_addr = gimple_call_arg (builtin_stmt, 2);
+
+  num_func_args
+    =  function_args_count (TREE_TYPE (TREE_OPERAND (func_addr, 0)));
+
+  get_function_args (builtin_stmt, num_func_args, &nargs, 3);
+
+  specialized_call_stmt = gimple_build_call_vec (func_addr, nargs);
+
+  lhs_stmt = gimple_call_lhs (builtin_stmt);
+
+  if (lhs_stmt != NULL_TREE)
+    gimple_call_set_lhs (specialized_call_stmt, lhs_stmt);
+
+  if (nargs != NULL)
+    VEC_free (tree, heap, nargs);
+
+  return specialized_call_stmt;
+}
+
+/* Given a call (GENERIC_STMT) to a function that is cloned, substitute
+   with a call to the correct clone. */
+
+static gimple
+make_specialized_call_to_clone (gimple generic_stmt, int side)
+{
+  tree new_decl;
+  char *new_name;
+  tree generic_fndecl;
+  gimple specialized_call_stmt;
+  void **slot;
+  int num_func_args;
+  tree lhs_stmt;
+  VEC (tree, heap) *nargs= NULL;
+
+  generic_fndecl = gimple_call_fndecl (generic_stmt);
+  gcc_assert (generic_fndecl != NULL);
+
+  if (side == 0)
+    new_name = make_name (generic_fndecl, "clone_0");
+  else
+    new_name = make_name (generic_fndecl, "clone_1");
+
+  slot = htab_find_slot_with_hash (name_decl_htab, new_name,
+                                   htab_hash_string (new_name), NO_INSERT);
+  gcc_assert (slot != NULL);
+  new_decl = (tree) *slot;
+  gcc_assert (new_decl);
+
+  num_func_args = function_args_count (TREE_TYPE (generic_fndecl));
+  get_function_args (generic_stmt, num_func_args, &nargs, 0);
+  specialized_call_stmt = gimple_build_call_vec (new_decl, nargs);
+
+  lhs_stmt = gimple_call_lhs (generic_stmt);
+
+  if (lhs_stmt != NULL_TREE)
+    gimple_call_set_lhs (specialized_call_stmt, lhs_stmt);
+
+  if (nargs != NULL)
+    VEC_free (tree, heap, nargs);
+
+  return specialized_call_stmt;
+}
+
+/* Returns true if STMT is a call to __builtin_dispatch and its
+   predicate feature-test function is marked with attribute
+   "version_selector". */
+
+static bool
+is_builtin_with_predicate_version_selector (gimple stmt)
+{
+  tree cond_func_addr, cond_func_decl;
+
+  gcc_assert (!flag_lto);
+ 
+  if (gimple_call_fndecl (stmt) != builtin_function_decl)
+    return false;
+
+  cond_func_addr = find_version_selector_func_addr (stmt);
+
+  if (cond_func_addr == NULL)
+    return false;
+
+  cond_func_decl = TREE_OPERAND (cond_func_addr, 0);
+  if (lookup_attribute ("version_selector",
+			DECL_ATTRIBUTES (cond_func_decl)) != NULL)
+    return true;
+
+  return false;
+}
+
+/* Find calls to __builtin_dispatch or to functions that are versioned
+   in CLONE_DECL and substitute the call with the correct version based
+   on the value of SIDE. */
+
+static void
+specialize_call (tree clone_decl, int side)
+{
+  basic_block bb;
+  tree old_current_function_decl;
+
+  old_current_function_decl = current_function_decl;
+  push_cfun (DECL_STRUCT_FUNCTION (clone_decl));
+  current_function_decl = clone_decl;
+
+  /* Iterate over call edges and find out if there is
+     a call to __builtin_dispatch or a cloned function.
+     We cannot iterate over call graph edges as there are
+     no edges for the clones yet. */
+
+  FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (clone_decl))
+    {
+      gimple_stmt_iterator gsi;
+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+        {
+	  tree callee_decl;
+	  struct cgraph_node *callee_node;
+	  gimple specialized_call_stmt;
+	  gimple stmt = gsi_stmt (gsi);
+
+	  if (!is_gimple_call (stmt))
+            continue;
+
+	  callee_decl = gimple_call_fndecl (stmt);
+
+	  if (callee_decl == NULL)
+            continue;
+
+	  callee_node = cgraph_get_create_node (callee_decl);
+
+	  /* For a __builtin_dispatch stmt, only specialize if
+             version_selector attribute is set. Otherwise, it is
+             not hoisted, so no specialization. */
+
+	  if (is_builtin_with_predicate_version_selector (stmt))
+	    {
+	      specialized_call_stmt =
+	        make_specialized_call_from_builtin (stmt, side);
+	    }
+	  else if  (callee_node->aux != NULL)
+            {
+	      specialized_call_stmt =
+	        make_specialized_call_to_clone (stmt, side);
+            }
+	  else
+	    continue;
+
+          if (dump_file)
+            {
+	      fprintf (dump_file, "Specialize stmt : \n");
+              print_gimple_stmt (dump_file, stmt, 0, TDF_VOPS);
+	      fprintf (dump_file, "Specialized stmt : \n");
+              print_gimple_stmt (dump_file, specialized_call_stmt,
+			         0, TDF_VOPS);
+            }
+
+	  gimple_set_block (specialized_call_stmt, gimple_block (stmt));
+	  gsi_insert_before_without_update (&gsi, specialized_call_stmt,
+                                            GSI_SAME_STMT);
+
+	  
+          unlink_stmt_vdef (stmt);
+	  gsi_remove (&gsi, true); 
+	  mark_symbols_for_renaming (specialized_call_stmt);
+
+	  /* After removing make sure gsi is set correctly to not skip
+	     a statememt. */
+          gsi = gsi_for_stmt (specialized_call_stmt);
+	}
+    }
+  current_function_decl = old_current_function_decl;
+  pop_cfun ();
+}
+
+/* When a function is version cloned, its body is replaced to call one
+   of the versions with the feature-test function acting as a predicate.
+   This is done with __builtin_dispatch which is later expanded. */
+
+static gimple
+make_builtin_call_to_clones (tree orig_fndecl, tree clone_0_addr,
+                             tree clone_1_addr, tree cond_func_addr)
+{
+  gimple new_builtin_call;
+  VEC(tree, heap) *vargs = VEC_alloc (tree, heap, 4);
+  tree arg;
+
+  VEC_quick_push (tree, vargs, cond_func_addr);
+  VEC_quick_push (tree, vargs, clone_0_addr);
+  VEC_quick_push (tree, vargs, clone_1_addr);
+
+  for (arg = DECL_ARGUMENTS (orig_fndecl); arg; arg = TREE_CHAIN (arg))
+    {
+      VEC_safe_push (tree, heap, vargs, arg);
+      /* Again, this add_referenced_var is very very important.  It broke
+         a build where a cloned function's arguments where never
+         referenced.  Missing this statement in places asserts at
+         tree-dfa.c:589, in function referenced_var_lookup at
+         "gcc_assert (h || uid == 0);" and is very difficult to triage. */
+      add_referenced_var (arg);
+    }
+
+  new_builtin_call = gimple_build_call_vec (builtin_function_decl, vargs);
+  mark_symbols_for_renaming (new_builtin_call);
+
+
+  if (dump_file)
+    print_gimple_stmt (dump_file, new_builtin_call, 0, TDF_VOPS);
+
+  VEC_free (tree, heap, vargs);
+
+  return new_builtin_call;
+}
+
+/* This clones a dispatch function whose callee-graph path has a function
+   which calls __builtin_dispatch.  This function is cloned and the
+   original function branches to the right clone. */
+
+static int
+clone_and_dispatch_function (struct cgraph_node *orig_node, tree *clone_0,
+			     tree *clone_1)
+{
+  tree clone_0_decl, clone_1_decl;
+  gimple new_builtin_call = NULL;
+  gimple new_return_stmt = NULL;
+  gimple_seq seq = NULL;
+  basic_block new_bb;
+  tree orig_fndecl;
+  tree return_var = NULL;
+  tree return_type;
+  tree old_current_function_decl;
+
+  old_current_function_decl = current_function_decl;
+  orig_fndecl = orig_node->decl;
+  push_cfun (DECL_STRUCT_FUNCTION (orig_fndecl));
+  current_function_decl = orig_fndecl;
+
+  /* Make 2 clones for true and false function. */
+  clone_0_decl = clone_function (orig_fndecl, "clone_0");
+  clone_1_decl = clone_function (orig_fndecl, "clone_1");
+  *clone_0 = clone_0_decl;
+  *clone_1 = clone_1_decl;
+
+  new_bb = empty_function_body (orig_fndecl);
+
+  new_builtin_call = make_builtin_call_to_clones (
+		       orig_fndecl,
+                       build_fold_addr_expr (clone_0_decl),
+		       build_fold_addr_expr (clone_1_decl),
+		       build_fold_addr_expr ((tree)orig_node->aux));
+
+  return_type = TREE_TYPE (TREE_TYPE (orig_fndecl));
+
+  if (!TREE_ADDRESSABLE (return_type) && COMPLETE_TYPE_P (return_type))
+    {
+      tree tmp_var;
+      tmp_var = create_tmp_var (return_type, NULL);
+      add_referenced_var (tmp_var);
+      return_var = make_ssa_name (tmp_var, new_builtin_call);
+      gimple_call_set_lhs (new_builtin_call, return_var);
+    }
+
+  mark_symbols_for_renaming (new_builtin_call);
+  new_return_stmt = gimple_build_return (return_var);
+  mark_symbols_for_renaming (new_return_stmt);
+  gimple_seq_add_stmt (&seq, new_builtin_call);
+  gimple_seq_add_stmt (&seq, new_return_stmt);
+  set_bb_seq (new_bb, seq);
+  gimple_set_bb (new_builtin_call, new_bb);
+  gimple_set_bb (new_return_stmt, new_bb);
+
+  gimple_set_block (new_builtin_call, DECL_INITIAL (orig_fndecl));
+  gimple_set_block (new_return_stmt, DECL_INITIAL (orig_fndecl));
+
+  if (dump_file)
+    dump_function_to_file (orig_fndecl, dump_file, TDF_BLOCKS);
+
+  /* This update_ssa is necessary here for the following reason.  SSA uses
+     a global syms_to_rename bitmap that stores syms that must be renamed.
+     So, if we accumulate the syms from one function in IPA but move to
+     a different function without updating SSA, then we could be
+     accumulating syms from many functions.  This would assert in
+     referenced_var_lookup because the hashtab storing the syms is
+     function local. This is horrible. gcc-4.6 makes this bitmap a
+     global. */
+  update_ssa (TODO_update_ssa);
+
+  compute_inline_parameters (cgraph_get_create_node (orig_fndecl), false);
+  DECL_DECLARED_INLINE_P (orig_fndecl) = 1;
+  DECL_UNINLINABLE (orig_fndecl) = 0;
+  current_function_decl = old_current_function_decl;
+  pop_cfun ();
+  return 0;
+}
+
+/* Clone all functions marked for cloning by the earlier phase. */
+
+static void
+perform_cloning_phase (void)
+{
+  struct cgraph_node *node;
+  int ix;
+  VEC (tree, heap) *cloned_decl_list = NULL;
+  tree cloned_decl = NULL;
+
+  cloned_decl_list = VEC_alloc (tree, heap, 2);
+
+  /* First clone, then specialize the clones. */
+  for (node = cgraph_nodes; node; node = node->next)
+    {
+      tree clone_0_decl, clone_1_decl;
+      if (node->aux == NULL)
+        continue;
+      if (dump_file)
+      {
+        fprintf (dump_file, "%s will be cloned\n", cgraph_node_name (node));
+        dump_function_to_file (node->decl, dump_file, TDF_BLOCKS);
+      }
+      clone_and_dispatch_function (node, &clone_0_decl, &clone_1_decl);
+      VEC_safe_push (tree, heap, cloned_decl_list, clone_0_decl);
+      VEC_safe_push (tree, heap, cloned_decl_list, clone_1_decl);
+      continue;
+    }
+
+  /* Specialize the clones now. */
+  for (ix = 0; VEC_iterate (tree, cloned_decl_list, ix, cloned_decl); ++ix)
+    {
+      int which_clone = ix % 2;
+      specialize_call (cloned_decl, which_clone);
+    }
+
+  VEC_free (tree, heap, cloned_decl_list);
+}
+
+/* End Cloning phase. */
+
+/* Checks if there is atleast one call to __builtin_dispatch. */
+
+static bool
+find_builtin_decl (void)
+{
+  struct cgraph_node *node;
+  for (node = cgraph_nodes; node; node = node->next)
+    {
+      if (strstr (cgraph_node_name (node), "__builtin_dispatch") != NULL)
+        {
+          builtin_function_decl = node->decl;
+          return true;
+        }
+    }
+  return false;
+}
+
+/* Set the aux fields of all nodes and edges in the call graph to be NULL. */
+
+static void
+cleanup_aux_field (void)
+{
+  struct cgraph_node *node;
+  struct cgraph_edge *edge;
+
+  for (node = cgraph_nodes; node; node = node->next)
+    {
+      node->aux = NULL;
+      for (edge = node->callees; edge; edge = edge->next_callee)
+        edge->aux = NULL;
+    }
+}
+
+/* Main driver function. It scans the __builtin_dispatch calls and
+   figures out which functions to clone.  It then clones the functions. */
+
+static unsigned int
+builtin_dispatch_ipa_clone (void)
+{
+  cleanup_aux_field ();
+
+  /* Allocate hashtab mapping name to decl. */
+  name_decl_htab = htab_create (10, name_decl_htab_hash_descriptor,
+			        name_decl_htab_eq_descriptor, NULL);
+
+  /* Turn it on for O1 and above.  At -O0, there is a SSA alias bug
+     with create_tmp_var.  Cloning and hoisting is not necessary at
+     -O0 anyways.  Also, guard it with the flag
+     "-fclone-hot-version-paths". 
+     Disabled for LTO as it needs more work. */
+  if (optimize == 0
+      || profile_arc_flag
+      || !flag_clone_hot_version_paths
+      || flag_lto)
+    return 0;
+
+  if (!find_builtin_decl ())
+    return 0;
+
+  gcc_assert (builtin_function_decl != NULL);
+
+  if (!perform_analysis_phase ())
+    {
+      cleanup_aux_field ();
+      return 0;
+    }
+
+  if (decide_cloning_phase ())
+    perform_cloning_phase ();
+
+  cleanup_aux_field ();
+
+  return 0;
+}
+
+static bool
+gate_handle_builtin_dispatch (void)
+{
+  return true;
+}
+
+struct simple_ipa_opt_pass pass_ipa_multiversion_dispatch =
+{
+ {
+  SIMPLE_IPA_PASS,
+  "multiversion_dispatch",		/* name */
+  gate_handle_builtin_dispatch,		/* gate */
+  builtin_dispatch_ipa_clone,           /* execute */
+  NULL,					/* sub */
+  NULL,					/* next */
+  0,					/* static_pass_number */
+  TV_MVERSN_DISPATCH,			/* tv_id */
+  0,	                                /* properties_required */
+  PROP_cfg,				/* properties_provided */
+  0,					/* properties_destroyed */
+  0,					/* todo_flags_start */
+  TODO_dump_func |			/* todo_flags_finish */
+  TODO_update_ssa
+ }
+};
+
+/* Lowering of the __builtin_dispatch calls. */
+
+
+/* This function converts STMT which is a __builtin_dispatch
+   call of the form :
+   ret = __builtin_dispatch (predicate, foo, bar, arg1, ...)
+   into :
+   var_1 = predicate
+   if  (var_1)
+     var_2 = foo (arg1, ...);
+   else
+     var_3 = bar (arg1, ...);
+   var_4 = phi (var_2, var_3)
+   ret = var_4
+
+   var_? are ssa names for variable var.
+*/
+
+static unsigned int
+convert_builtin_dispatch (gimple stmt)
+{
+  tree cond_func_addr, if_func_addr, else_func_addr;
+  tree cond_func_decl = NULL;
+  gimple if_part, else_part, if_else_stmt;
+  basic_block bb1, bb2, bb3, bb4;
+  gimple bb1end, bb2end, bb3end;
+  edge e12, e13, e23, e24, e34;
+  VEC(tree, heap) *nargs = NULL;
+  int num_func_args = 0, i;
+  tree version_selector_var;
+  tree lhs_result;
+  gimple_stmt_iterator gsi;
+  basic_block bb;
+  gimple feature_test_call = NULL;
+  tree tmp_var = NULL;
+  gimple init_stmt = NULL;
+  tree ssa_if_name, ssa_else_name;
+  gimple phinode = NULL;
+  tree tmp_result_var, ssa_result_var;
+
+  gsi = gsi_for_stmt (stmt);
+  bb = gsi_bb (gsi);
+
+  cond_func_addr = find_version_selector_func_addr (stmt);
+  if (cond_func_addr != NULL)
+    {
+      cond_func_decl = TREE_OPERAND (cond_func_addr, 0);
+      gcc_assert (cond_func_decl);
+    }
+
+  if (dump_file)
+    {
+      fprintf (dump_file, "Before Converting __builtin_dispatch :\n");
+      dump_function_to_file (current_function_decl, dump_file, TDF_BLOCKS);
+    }
+
+  if_func_addr = gimple_call_arg (stmt, 1);
+  else_func_addr = gimple_call_arg (stmt, 2);
+
+  tmp_result_var = create_tmp_var (integer_type_node, NULL);
+  add_referenced_var (tmp_result_var);
+
+  if (flag_lto
+      || cond_func_decl == NULL
+      || lookup_attribute ("version_selector",
+                           DECL_ATTRIBUTES (cond_func_decl)) == NULL)
+    {
+      tree arg = gimple_call_arg (stmt, 0);
+      /* This means the feature-test function is not set with attribute
+         version_selector or it is a function pointer or in LTO. So,
+         explicitly call it. */
+      feature_test_call = gimple_build_call (arg, 0);
+      ssa_result_var = make_ssa_name (tmp_result_var, feature_test_call);
+      gimple_call_set_lhs (feature_test_call, ssa_result_var);
+      mark_symbols_for_renaming (feature_test_call);
+      version_selector_var = ssa_result_var;
+    }
+  else
+    {
+      /* Get the global corresponding to the "version_selector" function. */
+      version_selector_var
+        = handle_version_selector_attr_function (cond_func_decl);
+      gcc_assert (version_selector_var);
+      add_referenced_var (version_selector_var);
+      feature_test_call = gimple_build_assign (tmp_result_var,
+                                               version_selector_var);
+      ssa_result_var = make_ssa_name (tmp_result_var, feature_test_call);
+      gimple_assign_set_lhs (feature_test_call, ssa_result_var);
+      mark_symbols_for_renaming (feature_test_call);
+      version_selector_var = ssa_result_var;
+    }
+
+  if_else_stmt = gimple_build_cond (GT_EXPR,
+                                    version_selector_var,
+                                    integer_zero_node,
+                                    NULL_TREE, NULL_TREE);
+
+  mark_symbols_for_renaming (if_else_stmt);
+
+  num_func_args =  function_args_count (
+    TREE_TYPE (TREE_OPERAND (if_func_addr, 0)));
+
+  nargs = VEC_alloc (tree, heap, num_func_args);
+
+  /* The arguments to the feature test function start from the 4th argument
+     in __builtin_dispatch.  The first 3 arguments are mandatory. */
+
+  for (i = 0; i <= num_func_args - 2; ++i)
+    VEC_quick_push (tree, nargs,
+                    gimple_call_arg (stmt, (3 + i)));
+
+  if_part = gimple_build_call_vec (if_func_addr, nargs);
+  else_part = gimple_build_call_vec (else_func_addr, nargs);
+
+  lhs_result = gimple_call_lhs (stmt);
+
+  if (lhs_result != NULL_TREE)
+    {
+      tree ssa_var;
+      tree return_type;
+      return_type = TREE_TYPE (lhs_result);
+      tmp_var = create_tmp_var (return_type, NULL);
+      add_referenced_var (tmp_var);
+
+      init_stmt = gimple_build_assign (tmp_var, build_zero_cst (return_type));
+      ssa_var = make_ssa_name (tmp_var, init_stmt);
+      gimple_assign_set_lhs (init_stmt, ssa_var);
+      mark_symbols_for_renaming (init_stmt);
+
+      ssa_if_name = make_ssa_name (tmp_var, init_stmt);
+      ssa_else_name = make_ssa_name (tmp_var, init_stmt);
+      gimple_call_set_lhs (if_part, ssa_if_name);
+      gimple_call_set_lhs (else_part, ssa_else_name);
+    }
+  mark_symbols_for_renaming (if_part);
+  mark_symbols_for_renaming (else_part);
+
+  /* Set the lexical block to be the same as the dispatch call. */
+  gcc_assert (feature_test_call);
+  gimple_set_block (feature_test_call, gimple_block (stmt));
+
+  if (init_stmt)
+    gimple_set_block (init_stmt, gimple_block (stmt));
+
+  gimple_set_block (if_else_stmt, gimple_block (stmt));
+  gimple_set_block (if_part, gimple_block (stmt));
+  gimple_set_block (else_part, gimple_block (stmt));
+
+  gsi_insert_before_without_update (&gsi, feature_test_call, GSI_SAME_STMT);
+  gimple_set_bb (feature_test_call, bb);
+
+  if (init_stmt)
+    {
+      gsi_insert_before_without_update (&gsi, init_stmt,
+                                        GSI_SAME_STMT);
+      gimple_set_bb (init_stmt, bb);
+    }
+
+  gsi_insert_before_without_update (&gsi, if_else_stmt, GSI_SAME_STMT);
+  gsi_insert_before_without_update (&gsi, if_part, GSI_SAME_STMT);
+  gsi_insert_before_without_update (&gsi, else_part, GSI_SAME_STMT);
+
+  /* Remove the builtin_dispatch call after the expansion. */
+  unlink_stmt_vdef (stmt);
+  gsi_remove (&gsi, true);
+
+  bb1end = if_else_stmt;
+  bb2end = if_part;
+  bb3end = else_part;
+  bb1 = bb;
+  e12 = split_block (bb1, bb1end);
+  bb2 = e12->dest;
+  e23 = split_block (bb2, bb2end);
+  bb3 = e23->dest;
+  e34 = split_block (bb3, bb3end);
+  bb4 = e34->dest;
+
+  e12->flags &= ~EDGE_FALLTHRU;
+  e12->flags |= EDGE_TRUE_VALUE;
+  e13 = make_edge (bb1, bb3, EDGE_FALSE_VALUE);
+  gcc_assert (e13);
+  e24 = make_edge (bb2, bb4, EDGE_FALLTHRU);
+  gcc_assert (e24);
+  remove_edge (e23);
+
+  if (tmp_var)
+    {
+      gimple assign_stmt;
+      phinode = create_phi_node (tmp_var, bb4);
+      add_phi_arg (phinode, ssa_if_name, e24, UNKNOWN_LOCATION);
+      add_phi_arg (phinode, ssa_else_name, e34, UNKNOWN_LOCATION);
+      mark_symbols_for_renaming (phinode);
+      gcc_assert (lhs_result);
+      assign_stmt
+        = gimple_build_assign (lhs_result, gimple_phi_result (phinode));
+      mark_symbols_for_renaming (assign_stmt);
+      gsi = gsi_start_bb (bb4);
+      gsi_insert_before_without_update (&gsi, assign_stmt, GSI_SAME_STMT);
+      gimple_set_bb (assign_stmt, bb4);
+    }
+
+  if (dump_file)
+    {
+      fprintf (dump_file, "Converted __builtin_dispatch :\n");
+      dump_function_to_file (current_function_decl, dump_file, TDF_BLOCKS);
+    }
+
+  return 0;
+}
+
+/* This function does two things.
+
+   1) For a feature-test function marked with attribute "version_selector",
+      it creates a constructor that calls the feature-test function and a
+      global that holds the result.  The global's result will be used
+      to lower any __builtin_dispatch statement that refers to this feature
+      test function.  The __builtin_dispatch statement and the feature test
+      function can be in different modules.
+
+   2) It lowers __builtin_dispatch statements. */
+
+static unsigned int
+do_convert_builtin_dispatch (void)
+{
+  basic_block bb;
+  gimple_stmt_iterator gsi;
+  VEC (gimple, heap) *builtin_stmt_list = NULL;
+  int ix;
+  gimple builtin_stmt;
+
+  /* Allocate hashtab mapping name to decl. */
+  if (name_decl_htab == NULL)
+    name_decl_htab = htab_create (10, name_decl_htab_hash_descriptor,
+		                  name_decl_htab_eq_descriptor, NULL);
+
+  /* Look for functions with attribute "version_selector" and make a
+     constructor which calls the function and saves the result in a
+     global.  Disabled for LTO as it needs more work. */
+
+  if (!flag_lto
+      && lookup_attribute ("version_selector",
+                           DECL_ATTRIBUTES (current_function_decl)) != NULL)
+    {
+      if (dump_file)
+        fprintf (dump_file, "Function with version_selector attribute found :"
+                 " %s.  Making constructor for it.\n",
+		 current_function_name ());
+
+      handle_version_selector_attr_function (current_function_decl);
+      /* Assume there are no __builtin_dispatch calls in feature test
+	 functions.  So it is safe to return. */
+      return 0;
+    }
+
+  /* Find and lower __builtin_dispatch calls. */
+
+  FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (current_function_decl))
+    {
+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+        {
+          gimple stmt = gsi_stmt (gsi);
+          tree call_decl;
+
+          if (!is_gimple_call (stmt))
+            continue;
+
+          call_decl = gimple_call_fndecl (stmt);
+
+	  if (call_decl == NULL)
+            continue;
+
+	  if (DECL_NAME (call_decl) == NULL_TREE)
+	    continue;
+
+	  if (strstr (IDENTIFIER_POINTER (DECL_NAME (call_decl)),
+                      "__builtin_dispatch") == NULL)
+            continue;
+
+	  if (dump_file)
+            {
+	      fprintf (dump_file, "Converting __builtin_dispatch stmt in:%s\n",
+		       current_function_name ());
+              print_gimple_stmt (dump_file, stmt, 0, TDF_VOPS);
+            }
+
+	  if (builtin_stmt_list == NULL)
+              builtin_stmt_list = VEC_alloc (gimple, heap, 2);
+
+          gcc_assert (builtin_stmt_list != NULL);
+	  VEC_safe_push (gimple, heap, builtin_stmt_list, stmt);
+        }
+    }
+
+  if (!builtin_stmt_list)
+    return 0;
+ 
+  for (ix = 0; VEC_iterate (gimple, builtin_stmt_list, ix, builtin_stmt);
+       ++ix)
+    convert_builtin_dispatch (builtin_stmt);
+
+  compute_inline_parameters (cgraph_get_create_node (current_function_decl),
+			     false);
+ 
+  VEC_free (gimple, heap, builtin_stmt_list); 
+  
+  return 0;
+}
+
+static bool
+gate_convert_builtin_dispatch (void)
+{
+  return true;
+}
+
+struct gimple_opt_pass pass_tree_convert_builtin_dispatch =
+{
+ {
+  GIMPLE_PASS,
+  "convert_builtin_dispatch",	        /* name */
+  gate_convert_builtin_dispatch,	/* gate */
+  do_convert_builtin_dispatch,		/* execute */
+  NULL,					/* sub */
+  NULL,					/* next */
+  0,					/* static_pass_number */
+  TV_MVERSN_DISPATCH,			/* tv_id */
+  PROP_cfg,				/* properties_required */
+  PROP_cfg,				/* properties_provided */
+  0,					/* properties_destroyed */
+  0,					/* todo_flags_start */
+  TODO_dump_func |			/* todo_flags_finish */
+  TODO_cleanup_cfg | TODO_dump_cgraph |
+  TODO_update_ssa | TODO_verify_ssa
+ }
+};
diff --git a/gcc/opts-global.c b/gcc/opts-global.c
index 32ea320..f71b726 100644
--- a/gcc/opts-global.c
+++ b/gcc/opts-global.c
@@ -36,6 +36,9 @@ along with GCC; see the file COPYING3.  If not see
 #include "plugin.h"
 #include "toplev.h"
 #include "tree-pass.h"
+#include "params.h"
+#include "l-ipo.h"
+#include "xregex.h"
 
 typedef const char *const_char_p; /* For DEF_VEC_P.  */
 
@@ -45,6 +48,13 @@ static vec<const_char_p> ignored_options;
 const char **in_fnames;
 unsigned num_in_fnames;
 
+static struct reg_func_attr_patterns
+{
+  regex_t r;
+  const char *attribute;
+  struct reg_func_attr_patterns *next;
+} *reg_func_attr_patterns;
+
 /* Return a malloced slash-separated list of languages in MASK.  */
 
 static char *
@@ -74,6 +84,62 @@ write_langs (unsigned int mask)
   return result;
 }
 
+/* Add strings like attribute_str:pattern... to attribute pattern list.  */
+
+static void
+add_attribute_pattern (const char *arg)
+{
+  char *tmp;
+  char *pattern_str;
+  struct reg_func_attr_patterns *one_pat;
+  int ec;
+  
+  /* We never free this string.  */
+  tmp = xstrdup (arg);
+
+  pattern_str = strchr (tmp, ':');
+  if (!pattern_str)
+    error ("invalid pattern in -ffunction-attribute-list option: %qs", tmp);
+
+  *pattern_str = '\0';
+  pattern_str ++;
+
+  one_pat = XCNEW (struct reg_func_attr_patterns);
+  one_pat->next = reg_func_attr_patterns;
+  one_pat->attribute = tmp;
+  reg_func_attr_patterns = one_pat;
+  if ((ec= regcomp (&one_pat->r, pattern_str, REG_EXTENDED|REG_NOSUB) != 0))
+    {
+      char err[100];
+      regerror (ec, &one_pat->r, err, 99);
+      error ("invalid pattern in -ffunction-attribute-list option: %qs: %qs",
+	     pattern_str, err);
+    }
+}
+
+/* Match FNDECL's name with user specified patterns, and add attributes
+   to FNDECL.  */
+
+void
+pattern_match_function_attributes (tree fndecl)
+{
+  const char *name;
+  struct reg_func_attr_patterns *one_pat;
+
+  if (!fndecl)
+    return;
+
+  if (!reg_func_attr_patterns)
+    return;
+
+  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (fndecl));
+
+  for (one_pat = reg_func_attr_patterns; one_pat; one_pat = one_pat->next)
+    if (regexec (&one_pat->r, name, 0, NULL, 0) == 0)
+      decl_attributes (&fndecl, tree_cons (
+	  get_identifier (one_pat->attribute), NULL, NULL), 0);
+}
+
 /* Complain that switch DECODED does not apply to this front end (mask
    LANG_MASK).  */
 
@@ -179,7 +245,7 @@ lang_handle_option (struct gcc_options *opts,
 
 /* Handle FILENAME from the command line.  */
 
-static void
+void
 add_input_filename (const char *filename)
 {
   num_in_fnames++;
@@ -187,6 +253,40 @@ add_input_filename (const char *filename)
   in_fnames[num_in_fnames - 1] = filename;
 }
 
+/* GCC command-line options saved to the LIPO profile data file.
+   See detailed comment in opts.h.  */
+const char **lipo_cl_args;
+unsigned num_lipo_cl_args;
+
+/* Inspect the given GCC command-line arguments, which are part of one GCC
+   switch, and decide whether or not to store these to the LIPO profile data
+   file.  */
+static void
+lipo_save_cl_args (struct cl_decoded_option *decoded)
+{
+  const char *opt = decoded->orig_option_with_args_text;
+  /* Store the following command-line flags to the lipo profile data file:
+     (1) -f... (except -frandom-seed...)
+     (2) -m...
+     (3) -W...
+     (4) -O...
+     (5) --param...
+     (6) -std=... (-std=c99 for restrict keyword)
+  */
+  if (opt[0] == '-'
+      && (opt[1] == 'f' || opt[1] == 'm' || opt[1] == 'W' || opt[1] == 'O'
+	  || (strstr (opt, "--param") == opt)
+	  || (strstr (opt, "-std=")))
+      && !strstr(opt, "-frandom-seed")
+      && !strstr(opt, "-fripa-disallow-opt-mismatch")
+      && !strstr(opt, "-Wripa-opt-mismatch"))
+    {
+      num_lipo_cl_args++;
+      lipo_cl_args = XRESIZEVEC (const char *, lipo_cl_args, num_lipo_cl_args);
+      lipo_cl_args[num_lipo_cl_args - 1] = opt;
+    }
+}
+
 /* Handle the vector of command line options (located at LOC), storing
    the results of processing DECODED_OPTIONS and DECODED_OPTIONS_COUNT
    in OPTS and OPTS_SET and using DC for diagnostic state.  LANG_MASK
@@ -203,6 +303,10 @@ read_cmdline_options (struct gcc_options *opts, struct gcc_options *opts_set,
 		      diagnostic_context *dc)
 {
   unsigned int i;
+  int force_multi_module = 0;
+  static int cur_mod_id = 0;
+
+  force_multi_module = PARAM_VALUE (PARAM_FORCE_LIPO_MODE);
 
   for (i = 1; i < decoded_options_count; i++)
     {
@@ -221,12 +325,15 @@ read_cmdline_options (struct gcc_options *opts, struct gcc_options *opts_set,
 				&opts->x_main_input_basename);
 	    }
 	  add_input_filename (decoded_options[i].arg);
+          if (force_multi_module)
+            add_module_info (++cur_mod_id, (num_in_fnames == 1), num_in_fnames - 1);
 	  continue;
 	}
 
       read_cmdline_option (opts, opts_set,
 			   decoded_options + i, loc, lang_mask, handlers,
 			   dc);
+      lipo_save_cl_args (decoded_options + i);
     }
 }
 
@@ -434,6 +541,10 @@ handle_common_deferred_options (void)
 	  set_random_seed (opt->arg);
 	  break;
 
+	case OPT_ffunction_attribute_list_:
+	  add_attribute_pattern (opt->arg);
+	  break;
+
 	case OPT_fstack_limit:
 	  /* The real switch is -fno-stack-limit.  */
 	  if (!opt->value)
diff --git a/gcc/opts.c b/gcc/opts.c
index 7ae1e00..99ab20d 100644
--- a/gcc/opts.c
+++ b/gcc/opts.c
@@ -823,15 +823,34 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,
 	}
     }
 
+  if (opts->x_profile_arc_flag
+      || opts->x_flag_branch_probabilities)
+    {
+      /* With profile data, inlining is much more selective and makes
+	 better decisions, so increase the inlining function size
+	 limits.  Changes must be added to both the generate and use
+	 builds to avoid profile mismatches.  */
+      maybe_set_param_value
+	(PARAM_MAX_INLINE_INSNS_SINGLE, 1000,
+	 opts->x_param_values, opts_set->x_param_values);
+      maybe_set_param_value
+	(PARAM_MAX_INLINE_INSNS_AUTO, 1000,
+	 opts->x_param_values, opts_set->x_param_values);
+    }
+
   /* Set PARAM_MAX_STORES_TO_SINK to 0 if either vectorization or if-conversion
      is disabled.  */
   if (!opts->x_flag_tree_vectorize || !opts->x_flag_tree_loop_if_convert)
     maybe_set_param_value (PARAM_MAX_STORES_TO_SINK, 0,
                            opts->x_param_values, opts_set->x_param_values);
 
-  /* The -gsplit-dwarf option requires -gpubnames.  */
+  /* The -gsplit-dwarf option requires -ggnu-pubnames.  */
   if (opts->x_dwarf_split_debug_info)
-    opts->x_debug_generate_pub_sections = 1;
+    opts->x_debug_generate_pub_sections = 2;
+
+  /* Turn on -ffunction-sections when -freorder-functions=* is used.  */
+  if (opts->x_flag_reorder_functions > 1)
+    opts->x_flag_function_sections = 1;
 }
 
 #define LEFT_COLUMN	27
@@ -1213,6 +1232,7 @@ print_specific_help (unsigned int include_flags,
 		       opts->x_help_columns, opts, lang_mask);
 }
 
+
 /* Handle target- and language-independent options.  Return zero to
    generate an "unknown option" message.  Only options that need
    extra handling need to be listed here; if you simply want
@@ -1424,6 +1444,10 @@ common_handle_option (struct gcc_options *opts,
 			       opts, opts_set, loc, dc);
       break;
 
+    case OPT_Wforce_warnings:
+      dc->force_warnings_requested = value;
+      break;
+
     case OPT_Wlarger_than_:
       opts->x_larger_than_size = value;
       opts->x_warn_larger_than = value != -1;
@@ -1443,6 +1467,15 @@ common_handle_option (struct gcc_options *opts,
       opts->x_flag_stack_usage_info = value != -1;
       break;
 
+    case OPT_Wshadow:
+      warn_shadow_local = value;
+      warn_shadow_compatible_local = value;
+      break;
+
+    case OPT_Wshadow_local:
+      warn_shadow_compatible_local = value;
+      break;
+
     case OPT_Wstrict_aliasing:
       set_Wstrict_aliasing (opts, value);
       break;
@@ -1578,8 +1611,41 @@ common_handle_option (struct gcc_options *opts,
 	opts->x_flag_unroll_loops = value;
       if (!opts_set->x_flag_peel_loops)
 	opts->x_flag_peel_loops = value;
-      if (!opts_set->x_flag_tracer)
-	opts->x_flag_tracer = value;
+      if (!opts_set->x_flag_value_profile_transformations)
+	opts->x_flag_value_profile_transformations = value;
+      if (!opts_set->x_flag_inline_functions)
+	opts->x_flag_inline_functions = value;
+      if (!opts_set->x_flag_ipa_cp)
+	opts->x_flag_ipa_cp = value;
+      if (!opts_set->x_flag_ipa_cp_clone
+	  && value && opts->x_flag_ipa_cp)
+	opts->x_flag_ipa_cp_clone = value;
+      if (!opts_set->x_flag_predictive_commoning)
+	opts->x_flag_predictive_commoning = value;
+      if (!opts_set->x_flag_unswitch_loops)
+	opts->x_flag_unswitch_loops = value;
+      if (!opts_set->x_flag_gcse_after_reload)
+	opts->x_flag_gcse_after_reload = value;
+      if (!opts_set->x_flag_tree_vectorize)
+	opts->x_flag_tree_vectorize = value;
+      if (!opts_set->x_flag_vect_cost_model)
+	opts->x_flag_vect_cost_model = value;
+      if (!opts_set->x_flag_tree_loop_distribute_patterns)
+	opts->x_flag_tree_loop_distribute_patterns = value;
+      break;
+
+    case OPT_fauto_profile_:
+      auto_profile_file = xstrdup (arg);
+      opts->x_flag_auto_profile = true;
+      value = true;
+    /* No break here - do -fauto-profile processing. */
+    case OPT_fauto_profile:
+      if (!opts_set->x_flag_branch_probabilities)
+	opts->x_flag_branch_probabilities = value;
+      if (!opts_set->x_flag_unroll_loops)
+	opts->x_flag_unroll_loops = value;
+      if (!opts_set->x_flag_peel_loops)
+	opts->x_flag_peel_loops = value;
       if (!opts_set->x_flag_value_profile_transformations)
 	opts->x_flag_value_profile_transformations = value;
       if (!opts_set->x_flag_inline_functions)
@@ -1621,6 +1687,10 @@ common_handle_option (struct gcc_options *opts,
         opts->x_flag_ipa_reference = false;
       break;
 
+    case OPT_fripa_inc_path_sub_:
+      lipo_inc_path_pattern = xstrdup (arg);
+      break;
+
     case OPT_fshow_column:
       dc->show_column = value;
       break;
@@ -1636,6 +1706,10 @@ common_handle_option (struct gcc_options *opts,
       /* Deferred.  */
       break;
 
+    case OPT_ffunction_attribute_list_:
+      /* Deferred.  */
+      break;
+
     case OPT_fsched_verbose_:
 #ifdef INSN_SCHEDULING
       /* Handled with Var in common.opt.  */
@@ -1697,8 +1771,13 @@ common_handle_option (struct gcc_options *opts,
       break;
 
     case OPT_g:
-      set_debug_level (NO_DEBUG, DEFAULT_GDB_EXTENSIONS, arg, opts, opts_set,
-		       loc);
+      /* -g by itself should force -g2.  */
+      if (*arg == '\0')
+	set_debug_level (NO_DEBUG, DEFAULT_GDB_EXTENSIONS, "2", opts, opts_set,
+			 loc);
+      else
+	set_debug_level (NO_DEBUG, DEFAULT_GDB_EXTENSIONS, arg, opts, opts_set,
+			 loc);
       break;
 
     case OPT_gcoff:
@@ -1728,6 +1807,12 @@ common_handle_option (struct gcc_options *opts,
 		       loc);
       break;
 
+    case OPT_gmlt:
+      /* Synonym for -g1.  */
+      set_debug_level (NO_DEBUG, DEFAULT_GDB_EXTENSIONS, "1", opts, opts_set,
+		       loc);
+      break;
+
     case OPT_gvms:
       set_debug_level (VMS_DEBUG, false, arg, opts, opts_set, loc);
       break;
diff --git a/gcc/opts.h b/gcc/opts.h
index 264f4de..69e214f 100644
--- a/gcc/opts.h
+++ b/gcc/opts.h
@@ -305,6 +305,15 @@ extern const char **in_fnames;
 
 extern unsigned num_in_fnames;
 
+/* GCC command-line arguments used during profile-gen, that are saved to the
+   profile data file. During profile-use, these can be compared to make sure
+   only those auxiliary modules are actually imported that use a compatible
+   set of GCC flags as the primary module.  */
+extern const char **lipo_cl_args;
+
+/* The size of the above mentioned mentioned array.  */
+extern unsigned num_lipo_cl_args;
+
 extern char *opts_concat (const char *first, ...);
 
 /* Obstack for option strings.  */
@@ -369,6 +378,11 @@ extern void control_warning_option (unsigned int opt_index, int kind,
 				    struct gcc_options *opts_set,
 				    diagnostic_context *dc);
 extern void print_ignored_options (void);
+extern void add_input_filename (const char *filename);
+extern void add_module_info (unsigned mod_id, bool is_primary, int index);
+extern void set_lipo_c_parsing_context (struct cpp_reader *parse_in, int i, bool verbose);
+extern void coverage_note_define (const char *cpp_def, bool is_def);
+extern void coverage_note_include (const char *filename);
 extern void handle_common_deferred_options (void);
 extern bool common_handle_option (struct gcc_options *opts,
 				  struct gcc_options *opts_set,
@@ -400,4 +414,7 @@ extern void set_struct_debug_option (struct gcc_options *opts,
 				     const char *value);
 extern bool opt_enum_arg_to_value (size_t opt_index, const char *arg,
 				   int *value, unsigned int lang_mask);
+extern void write_compilation_info_to_asm (void);
+extern void write_compilation_flags_to_asm (void);
+extern void pattern_match_function_attributes (tree);
 #endif
diff --git a/gcc/params.def b/gcc/params.def
index cb25def..40604ce 100644
--- a/gcc/params.def
+++ b/gcc/params.def
@@ -103,13 +103,23 @@ DEFPARAM (PARAM_MIN_INLINE_RECURSIVE_PROBABILITY,
 	  "Inline recursively only when the probability of call being executed exceeds the parameter",
 	  10, 0, 0)
 
+DEFPARAM (PARAM_INLINE_FUNCTION_OVERHEAD_SIZE,
+	  "inline-function-overhead-size",
+	  "Size estimate of function overhead (prologue/epilogue) for inlining purposes",
+	  7, 0, 0)
+
+DEFPARAM (PARAM_INLINE_HOT_CALLER,
+	  "inline-hot-caller",
+	  "Consider cold callsites for inlining if caller contains hot code",
+	  1, 0, 1)
+
 /* Limit of iterations of early inliner.  This basically bounds number of
    nested indirect calls early inliner can resolve.  Deeper chains are still
    handled by late inlining.  */
 DEFPARAM (PARAM_EARLY_INLINER_MAX_ITERATIONS,
 	  "max-early-inliner-iterations",
 	  "The maximum number of nested indirect inlining performed by early inliner",
-	  1, 0, 0)
+	  10, 0, 0)
 
 /* Limit on probability of entry BB.  */
 DEFPARAM (PARAM_COMDAT_SHARING_PROBABILITY,
@@ -199,6 +209,14 @@ DEFPARAM(PARAM_EARLY_INLINING_INSNS,
 	 "early-inlining-insns",
 	 "Maximal estimated growth of function body caused by early inlining of single call",
 	 11, 0, 0)
+DEFPARAM(PARAM_EARLY_INLINING_INSNS_ANY,
+	 "early-inlining-insns-any",
+	 "Early inline calls if growth does not exceed this limit",
+	 0, 0, 0)
+DEFPARAM(PARAM_EARLY_INLINING_INSNS_COMDAT,
+	 "early-inlining-insns-comdat",
+	 "Early inline calls to comdate functions if growth does not exceed this limit",
+	 15, 0, 0)
 DEFPARAM(PARAM_LARGE_STACK_FRAME,
 	 "large-stack-frame",
 	 "The size of stack frame to be considered large",
@@ -288,7 +306,7 @@ DEFPARAM(PARAM_MAX_UNROLL_TIMES,
 DEFPARAM(PARAM_MAX_PEELED_INSNS,
 	"max-peeled-insns",
 	"The maximum number of insns of a peeled loop",
-	100, 0, 0)
+	400, 0, 0)
 /* The maximum number of peelings of a single loop.  */
 DEFPARAM(PARAM_MAX_PEEL_TIMES,
 	"max-peel-times",
@@ -303,7 +321,7 @@ DEFPARAM(PARAM_MAX_PEEL_BRANCHES,
 DEFPARAM(PARAM_MAX_COMPLETELY_PEELED_INSNS,
 	"max-completely-peeled-insns",
 	"The maximum number of insns of a completely peeled loop",
-	100, 0, 0)
+	400, 0, 0)
 /* The maximum number of peelings of a single loop that is peeled completely.  */
 DEFPARAM(PARAM_MAX_COMPLETELY_PEEL_TIMES,
 	"max-completely-peel-times",
@@ -319,6 +337,32 @@ DEFPARAM(PARAM_MAX_UNROLL_ITERATIONS,
 	 "max-completely-peel-loop-nest-depth",
 	 "The maximum depth of a loop nest we completely peel",
 	 8, 0, 0)
+/* The maximum code size estimate under which loop unrolling and peeling
+ * is allowed in a profile feedback compile. This currently applies to loops
+ * with non-constant iteration counts and no floating point computations.  */
+DEFPARAM(PARAM_UNROLLPEEL_CODESIZE_THRESHOLD,
+	"unrollpeel-codesize-threshold",
+	"Maximum profile-based code size footprint estimate for loop unrolling "
+	"and peeling",
+	15000, 0, 0)
+/* The maximum ratio of total profiled execution counts to loop entry block
+   count that must be exceeded to ignore most code size limits when unrolling
+   and peeling.  */
+DEFPARAM(PARAM_UNROLLPEEL_HOTNESS_THRESHOLD,
+        "unrollpeel-hotness-threshold",
+        "Maximum ratio of total profiled execution count to loop entry "
+        "block count under which most codesize limits for unrolling and "
+        "peeling will be ignored",
+        100, 1, 0)
+
+DEFPARAM(PARAM_MIN_ITER_UNROLL_WITH_BRANCHES,
+	"min-iter-unroll-with-branches",
+	"Minimum iteration count to ignore branch effects when unrolling",
+	50, 0, 0)
+DEFPARAM(PARAM_UNROLL_OUTER_LOOP_BRANCH_BUDGET,
+	"unroll-outer-loop-branch-budget",
+	"Maximum number of branches allowed in hot outer loop region after unroll",
+	25, 0, 0)
 
 /* The maximum number of insns of an unswitched loop.  */
 DEFPARAM(PARAM_MAX_UNSWITCH_INSNS,
@@ -835,6 +879,155 @@ DEFPARAM (PARAM_LOOP_INVARIANT_MAX_BBS_IN_LOOP,
 	  "Max basic blocks number in loop for loop invariant motion",
 	  10000, 0, 0)
 
+/* Promote indirect call to conditional direct call only
+   when the percentage of the target count over the total
+   indirect call count is no smaller than the threshold.  */
+DEFPARAM (PARAM_ICALL_PROMOTE_PERCENT_THRESHOLD,
+	  "icall-promote-target-percent-threshold",
+	  "percentage threshold for direct call promotion"
+          " of a callee target",
+	  33, 0, 100)
+
+DEFPARAM (PARAM_ICALL_PROMOTE_COUNT_THRESHOLD,
+	  "icall-promote-target_count-threshold",
+	  "call count threshold for direct call promotion"
+          " of a callee target",
+	  1, 0, 0)
+
+/* 0: do not always inline icall target:
+   other value: always inline icall target when call count
+   exceeds this value.
+*/
+DEFPARAM (PARAM_ALWAYS_INLINE_ICALL_TARGET,
+	  "always-inline-icall-target",
+	  "force inline indirect call target when promoted",
+          0, 0, 0)
+
+/* Force the compiler to be in LIPO mode even there is no
+ profile data available. -fripa is also needed. */
+DEFPARAM (PARAM_FORCE_LIPO_MODE, 
+	  "force-lipo",
+	  "force LIPO compilation mode",
+          0, 0, 1)
+
+/* Limit max module group size in LIPO mode.  When the value
+ is set to 0 (which is the default), there is no limit.  */
+DEFPARAM (PARAM_MAX_LIPO_GROUP,
+	  "max-lipo-group",
+	  "maximum module group size.",
+          0, 0, 10000)
+
+/* In LIPO mode, stop processing any further auxiliary modules
+   if current memory consumption exceeds this limit (in kb).  */
+DEFPARAM (PARAM_MAX_LIPO_MEMORY,
+	  "max-lipo-mem",
+	  "don't import aux files if memory consumption exceeds this value",
+	  3000000, 0, 0)
+
+/* In LIPO profile-gen, use this parameter to record the cutoff value used at
+   profile collection runtime.  */
+DEFPARAM (PARAM_LIPO_CUTOFF,
+	  "lipo-cutoff",
+	  "The cutoff value of cumulative profile count. The value is between"
+          "0-99. 100 is reserved as a special value indicating default cutoff" 
+          "which is set at runtime. When the parameter is used and if its value"
+          "is not 100, it overrides the dafault as well as the value set by the"
+          " enviornment variable",
+	  100, 0, 100)
+
+/* In LIPO profile-gen, use this parameter to limit IPA inline.  */
+DEFPARAM (PARAM_LIPO_SKIP_SPECIAL_SECTIONS,
+	  "lipo-skip-special-sections",
+          "In LIPO profile gen compilation, do not generate direct call "
+          "profiling to functions marked with __attribute__((section(...))"
+          "Those functions can not be inlined so there is no point tracking"
+          "them.",
+	  1, 0, 1)
+
+/* In LIPO profile-gen, use this parameter to set random group generation
+   seed value.  */
+DEFPARAM (PARAM_LIPO_RANDOM_SEED,
+	  "lipo-random-seed",
+	  "random seed value used in random group testing",
+	  0, 0, 0)
+
+/* In LIPO profile-gen, use this parmaeter to set random group max size at profile
+   collection runtime.  */
+DEFPARAM (PARAM_LIPO_RANDOM_GROUP_SIZE,
+	  "lipo-random-group-size",
+	  "In LIPO random group testing, this parameter is used to set max group"
+          " size. The default value is 0 which is treated specially and specifies"
+          " no random grouping.",
+	  0, 0, 300)
+
+/* In LIPO profile-gen, use this parameter to specify the scale factor to propagate
+   callee module groups to caller.  */
+DEFPARAM (PARAM_LIPO_PROPAGATE_SCALE,
+	  "lipo-propagate-scale",
+	  "The scale factor to propagate callee module group's weight to the caller.",
+	  100, 0, 100)
+
+/* Choose different module grouping algorithms. This only affects
+   LIPO profile-gen.  */
+DEFPARAM (PARAM_LIPO_GROUPING_ALGORITHM,
+	  "lipo-grouping-algorithm",
+	  "Algorithm 0 uses the eager propagation algorithm."
+	  "Algorithm 1 uses the inclusion_based priority algorithm."
+	  "The default algorithm is 1.",
+	  1, 0, 1)
+
+/* In the inclusion_based_priority grouping algorithm, specify if we combine the
+   the edges b/w modules.  */
+DEFPARAM (PARAM_LIPO_MERGE_MODU_EDGES,
+	  "lipo-merge-modu-edges",
+	  "Default is 0 which not merge."
+	  "If the value is 1, merge the edges.",
+	  0, 0, 1)
+
+/* In the inclusion_based_priority grouping algorithm, specify if we force
+   strict inclusion of modules.  */
+DEFPARAM (PARAM_LIPO_WEAK_INCLUSION,
+	  "lipo-weak-inclusion",
+	  "0: force strict inclusion; 1: weak inclusion."
+	  "Default is 0.",
+	  0, 0, 1)
+
+/* In LIPO profile-use, use this parameter to enable the dumping of module id
+   in inline message.   */
+DEFPARAM (PARAM_INLINE_DUMP_MODULE_ID,
+	  "inline-dump-module-id",
+	  "Default is 1. If the value is 0, dumping is disabled.",
+	  1, 0, 1)
+
+/* In LIPO profile-gen, use this parameter to enable cgraph dumping.   */
+DEFPARAM (PARAM_LIPO_DUMP_CGRAPH,
+	  "lipo-dump-cgraph",
+	  "Default is 0. If the value is 1, text dump is used. If the value "
+	  "is 2, .dot dump is enabled. ", 
+	  0, 0, 2)
+
+DEFPARAM (PARAM_PROFILE_GENERATE_SAMPLING_PERIOD,
+         "profile-generate-sampling-period",
+         "sampling rate with -fprofile-generate-sampling",
+         100, 0, 2000000000)
+
+DEFPARAM (PARAM_COVERAGE_CALLBACK,
+         "coverage-callback",
+         "callback a user-define function when for arc counter increments.",
+         0, 0, 1)
+
+DEFPARAM (PARAM_COVERAGE_EXEC_ONCE,
+         "coverage-exec_once",
+         "Stop incrementing arc counts once they become 1.",
+         0, 0, 1)
+
+/* Used for debugging purpose. Tell the compiler to find
+   the gcda file in the current directory.  */
+DEFPARAM (PARAM_GCOV_DEBUG,
+	  "gcov-debug",
+	  "Looking for gcda file in current dir.",
+	  0, 0, 1)
+
 /* Avoid SLP vectorization of large basic blocks.  */
 DEFPARAM (PARAM_SLP_MAX_INSNS_IN_BB,
           "slp-max-insns-in-bb",
@@ -931,6 +1124,12 @@ DEFPARAM (MIN_PARTITION_SIZE,
 	  "Minimal size of a partition for LTO (in estimated instructions)",
 	  1000, 0, 0)
 
+DEFPARAM (PARAM_MIN_MCF_CANCEL_ITERS,
+	  "min-mcf-cancel-iters",
+	  "the minimum number of iterations of negative cycle cancellation "
+	  "in MCF",
+	  10, 1, 0)
+
 /* Diagnostic parameters.  */
 
 DEFPARAM (CXX_MAX_NAMESPACES_FOR_DIAGNOSTIC_HELP,
@@ -939,6 +1138,15 @@ DEFPARAM (CXX_MAX_NAMESPACES_FOR_DIAGNOSTIC_HELP,
 	  "name lookup fails",
 	  1000, 0, 0)
 
+
+/* Only output those call graph edges in .gnu.callgraph.text sections
+   whose count is greater than this value. */
+DEFPARAM (PARAM_GNU_CGRAPH_SECTION_EDGE_THRESHOLD,
+	  "gnu-cgraph-section-edge-threshold",
+	  "minimum call graph edge count for inclusion in "
+          ".gnu.callgraph.text section",
+	  0, 0, 0)
+
 /* Maximum number of conditional store pairs that can be sunk.  */
 DEFPARAM (PARAM_MAX_STORES_TO_SINK,
           "max-stores-to-sink",
@@ -1014,6 +1222,15 @@ DEFPARAM (PARAM_MAX_SLSR_CANDIDATE_SCAN,
 	  "strength reduction",
 	  50, 1, 999999)
 
+/* Parameters to be used with -mpatch-functions-for-instrumentation.
+   See config/i386/i386.opt  */
+DEFPARAM (PARAM_FUNCTION_PATCH_MIN_INSTRUCTIONS,
+          "function-patch-min-instructions",
+          "Minimum number of instructions in the function without loop before "
+          "the function is qualified for patching for instrumentation (for use "
+          "with -mpatch-functions-for-instrumentation)",
+          200, 0, 0)
+
 /*
 Local variables:
 mode:c
diff --git a/gcc/passes.c b/gcc/passes.c
index 8390223..531d10e 100644
--- a/gcc/passes.c
+++ b/gcc/passes.c
@@ -67,6 +67,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "predict.h"
 #include "lto-streamer.h"
 #include "plugin.h"
+#include "l-ipo.h"
 #include "ipa-utils.h"
 #include "tree-pretty-print.h" /* for dump_function_header */
 
@@ -180,6 +181,13 @@ rest_of_decl_compilation (tree decl,
 				     top_level, at_end);
 	}
 #endif
+      if (L_IPO_COMP_MODE)
+        {
+          /* Create the node early during parsing so
+             that module id can be captured.  */
+          if (TREE_CODE (decl) == VAR_DECL)
+            varpool_node_for_decl (decl);
+        }
 
       timevar_pop (TV_VARCONST);
     }
@@ -296,6 +304,10 @@ struct simple_ipa_opt_pass pass_early_local_passes =
  }
 };
 
+/* Decides if the cgraph callee edges are being cleaned up for the
+   last time.  */
+bool cgraph_callee_edges_final_cleanup = false;
+
 /* Gate: execute, or not, all of the non-trivial optimizations.  */
 
 static bool
@@ -331,6 +343,8 @@ static struct gimple_opt_pass pass_all_early_optimizations =
 static bool
 gate_all_optimizations (void)
 {
+  /* The cgraph callee edges are being cleaned up for the last time.  */
+  cgraph_callee_edges_final_cleanup = true;
   return optimize >= 1 && !optimize_debug;
 }
 
@@ -525,6 +539,11 @@ register_one_dump_file (struct opt_pass *pass)
   flag_name = concat (prefix, name, num, NULL);
   glob_name = concat (prefix, name, NULL);
   optgroup_flags |= pass->optinfo_flags;
+  /* For any passes that do not have an optgroup set, and which are not
+     IPA passes setup above, set the optgroup to OPTGROUP_OTHER so that
+     any dump messages are emitted properly under -fopt-info(-optall).  */
+  if (optgroup_flags == OPTGROUP_NONE)
+    optgroup_flags = OPTGROUP_OTHER;
   id = dump_register (dot_name, flag_name, glob_name, flags, optgroup_flags);
   set_pass_for_id (id, pass);
   full_name = concat (prefix, pass->name, num, NULL);
@@ -712,7 +731,7 @@ dump_passes (void)
 
   create_pass_tab();
 
-  FOR_EACH_DEFINED_FUNCTION (n)
+  FOR_EACH_FUNCTION (n)
     if (DECL_STRUCT_FUNCTION (n->symbol.decl))
       {
 	node = n;
@@ -1348,6 +1367,7 @@ init_optimization_passes (void)
       NEXT_PASS (pass_inline_parameters);
     }
   NEXT_PASS (pass_ipa_free_inline_summary);
+  NEXT_PASS (pass_ipa_auto_profile);
   NEXT_PASS (pass_ipa_tree_profile);
     {
       struct opt_pass **p = &pass_ipa_tree_profile.pass.sub;
@@ -1383,6 +1403,7 @@ init_optimization_passes (void)
   /* These passes are run after IPA passes on every function that is being
      output to the assembler file.  */
   p = &all_passes;
+  NEXT_PASS (pass_direct_call_profile);
   NEXT_PASS (pass_fixup_cfg);
   NEXT_PASS (pass_lower_eh_dispatch);
   NEXT_PASS (pass_all_optimizations);
diff --git a/gcc/predict.c b/gcc/predict.c
index a54412e..907dc19 100644
--- a/gcc/predict.c
+++ b/gcc/predict.c
@@ -56,6 +56,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "tree-scalar-evolution.h"
 #include "cfgloop.h"
 #include "pointer-set.h"
+#include "auto-profile.h"
 
 /* real constants: 0, 1, 1-1/REG_BR_PROB_BASE, REG_BR_PROB_BASE,
 		   1/REG_BR_PROB_BASE, 0.5, BB_FREQ_MAX.  */
@@ -132,13 +133,15 @@ maybe_hot_frequency_p (struct function *fun, int freq)
 
 /* Return TRUE if frequency FREQ is considered to be hot.  */
 
-static inline bool
+bool
 maybe_hot_count_p (struct function *fun, gcov_type count)
 {
   gcov_working_set_t *ws;
   static gcov_type min_count = -1;
   if (fun && profile_status_for_function (fun) != PROFILE_READ)
     return true;
+  if (!profile_info)
+    return false;
   /* Code executed at most once is not hot.  */
   if (profile_info->runs >= count)
     return false;
@@ -2831,7 +2834,8 @@ compute_function_frequency (void)
   if (DECL_STATIC_DESTRUCTOR (current_function_decl))
     node->only_called_at_exit = true;
 
-  if (!profile_info || !flag_branch_probabilities)
+  if (!profile_info || !flag_branch_probabilities
+      || (flag_auto_profile && profile_status == PROFILE_GUESSED))
     {
       int flags = flags_from_decl_or_type (current_function_decl);
       if (lookup_attribute ("cold", DECL_ATTRIBUTES (current_function_decl))
@@ -2935,13 +2939,26 @@ rebuild_frequencies (void)
   timevar_push (TV_REBUILD_FREQUENCIES);
   if (profile_status == PROFILE_GUESSED)
     {
-      loop_optimizer_init (0);
-      add_noreturn_fake_exit_edges ();
-      mark_irreducible_loops ();
-      connect_infinite_loops_to_exit ();
-      estimate_bb_frequencies ();
-      remove_fake_exit_edges ();
-      loop_optimizer_finalize ();
+      /* In AutoFDO it is possible that some basic blocks will get
+	 non-zero counts after function inlining. In this case, we
+	 will use profile information to estimated the frequency.  */
+      if (flag_auto_profile && counts_to_freqs ())
+	{
+	  afdo_calculate_branch_prob ();
+	  counts_to_freqs();
+	  profile_status = PROFILE_READ;
+	  compute_function_frequency ();
+	}
+      else
+	{
+	  loop_optimizer_init (0);
+	  add_noreturn_fake_exit_edges ();
+	  mark_irreducible_loops ();
+	  connect_infinite_loops_to_exit ();
+	  estimate_bb_frequencies ();
+	  remove_fake_exit_edges ();
+	  loop_optimizer_finalize ();
+	}
     }
   else if (profile_status == PROFILE_READ)
     counts_to_freqs ();
diff --git a/gcc/print-rtl.c b/gcc/print-rtl.c
index 3793109..843599c 100644
--- a/gcc/print-rtl.c
+++ b/gcc/print-rtl.c
@@ -398,7 +398,13 @@ print_rtx (const_rtx in_rtx)
 		redundant with line number information and do not print anything
 		when there is no location information available.  */
 	    if (INSN_LOCATION (in_rtx) && insn_file (in_rtx))
-	      fprintf(outfile, " %s:%i", insn_file (in_rtx), insn_line (in_rtx));
+	      {
+		int discriminator = insn_discriminator (in_rtx);
+		fprintf (outfile, " %s:%i", insn_file (in_rtx),
+			 insn_line (in_rtx));
+		if (discriminator)
+		  fprintf (outfile, " discrim %d", discriminator);
+	      }
 #endif
 	  }
 	else if (i == 6 && GET_CODE (in_rtx) == ASM_OPERANDS)
diff --git a/gcc/profile.c b/gcc/profile.c
index 2c2680c..ab34c92 100644
--- a/gcc/profile.c
+++ b/gcc/profile.c
@@ -64,6 +64,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "tree-flow.h"
 #include "cfgloop.h"
 #include "dumpfile.h"
+#include "params.h"
 
 #include "profile.h"
 
@@ -104,6 +105,12 @@ static int total_num_times_called;
 static int total_hist_br_prob[20];
 static int total_num_branches;
 
+void add_working_set (gcov_working_set_t *set) {
+  int i = 0;
+  for (; i < NUM_GCOV_WORKING_SETS; i++)
+    gcov_working_sets[i] = set[i];
+}
+
 /* Forward declarations.  */
 static void find_spanning_tree (struct edge_list *);
 
@@ -159,6 +166,14 @@ instrument_values (histogram_values values)
       histogram_value hist = values[i];
       unsigned t = COUNTER_FOR_HIST_TYPE (hist->type);
 
+      /* See condition in gimple_gen_ic_func_topn_profiler  */
+      if (t == GCOV_COUNTER_ICALL_TOPNV
+          && (DECL_STATIC_CONSTRUCTOR (current_function_decl)
+              || DECL_STATIC_CONSTRUCTOR (current_function_decl)
+              || DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (
+                  current_function_decl)))
+         continue;
+
       if (!coverage_counter_alloc (t, hist->n_counters))
 	continue;
 
@@ -181,6 +196,7 @@ instrument_values (histogram_values values)
 	  break;
 
  	case HIST_TYPE_INDIR_CALL:
+ 	case HIST_TYPE_INDIR_CALL_TOPN:
  	  gimple_gen_ic_profiler (hist, t, 0);
   	  break;
 
@@ -393,6 +409,7 @@ is_edge_inconsistent (vec<edge, va_gc> *edges)
         {
           if (e->count < 0
 	      && (!(e->flags & EDGE_FAKE)
+		  || e->src == ENTRY_BLOCK_PTR
 	          || !block_ends_with_call_p (e->src)))
 	    {
 	      if (dump_file)
@@ -529,8 +546,8 @@ read_profile_edge_counts (gcov_type *exec_counts)
 		    if (flag_profile_correction)
 		      {
 			static bool informed = 0;
-			if (!informed)
-		          inform (input_location,
+			if (dump_enabled_p () && !informed)
+		          dump_printf_loc (MSG_NOTE, input_location,
 			          "corrupted profile info: edge count exceeds maximal count");
 			informed = 1;
 		      }
@@ -789,10 +806,11 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)
        {
          /* Inconsistency detected. Make it flow-consistent. */
          static int informed = 0;
-         if (informed == 0)
+         if (dump_enabled_p () && informed == 0)
            {
              informed = 1;
-             inform (input_location, "correcting inconsistent profile data");
+             dump_printf_loc (MSG_NOTE, input_location,
+                              "correcting inconsistent profile data");
            }
          correct_negative_edge_counts ();
          /* Set bb counts to the sum of the outgoing edge counts */
@@ -944,9 +962,14 @@ compute_value_histograms (histogram_values values, unsigned cfg_checksum,
   gcov_type *histogram_counts[GCOV_N_VALUE_COUNTERS];
   gcov_type *act_count[GCOV_N_VALUE_COUNTERS];
   gcov_type *aact_count;
+  bool warned[GCOV_N_VALUE_COUNTERS];
+  static const char *const ctr_names[] = GCOV_COUNTER_NAMES;
 
   for (t = 0; t < GCOV_N_VALUE_COUNTERS; t++)
-    n_histogram_counters[t] = 0;
+    {
+      n_histogram_counters[t] = 0;
+      warned[t] = 0;
+    }
 
   for (i = 0; i < values.length (); i++)
     {
@@ -982,6 +1005,19 @@ compute_value_histograms (histogram_values values, unsigned cfg_checksum,
       t = (int) hist->type;
 
       aact_count = act_count[t];
+      /* If the counter cannot be found in gcda file, skip this 
+         histogram and give a warning.  */
+      if (aact_count == 0)
+        {
+          if (!warned[t])
+            warning (0, "cannot find %s counters in function %s.",
+                     ctr_names[COUNTER_FOR_HIST_TYPE(t)],
+                     IDENTIFIER_POINTER (
+                       DECL_ASSEMBLER_NAME (current_function_decl)));
+          hist->n_counters = 0;
+          warned[t] = true;
+          continue;
+        }
       act_count[t] += hist->n_counters;
 
       gimple_add_histogram_value (cfun, stmt, hist);
@@ -1364,7 +1400,7 @@ branch_prob (void)
   if (flag_profile_values)
     gimple_find_values_to_profile (&values);
 
-  if (flag_branch_probabilities)
+  if (flag_branch_probabilities && !flag_auto_profile)
     {
       compute_branch_probabilities (cfg_checksum, lineno_checksum);
       if (flag_profile_values)
@@ -1390,6 +1426,10 @@ branch_prob (void)
 
       /* Commit changes done by instrumentation.  */
       gsi_commit_edge_inserts ();
+
+      if (flag_profile_generate_sampling
+          || PARAM_VALUE (PARAM_COVERAGE_EXEC_ONCE))
+        add_sampling_to_edge_counters ();
     }
 
   free_aux_for_edges ();
diff --git a/gcc/profile.h b/gcc/profile.h
index e21250b..eb673de 100644
--- a/gcc/profile.h
+++ b/gcc/profile.h
@@ -46,6 +46,14 @@ extern gcov_type sum_edge_counts (vec<edge, va_gc> *edges);
 extern void init_node_map (void);
 extern void del_node_map (void);
 
+/* Implement sampling to avoid writing to edge counters very often.
+   Many concurrent writes to the same counters, or to counters that share
+   the same cache line leads to up to 30x slowdown on an application running
+   on 8 CPUs.  With sampling, the slowdown reduced to 2x.  */
+extern void add_sampling_to_edge_counters (void);
+
 extern void compute_working_sets (void);
 
+extern void add_working_set (gcov_working_set_t *);
+
 #endif /* PROFILE_H */
diff --git a/gcc/ree.c b/gcc/ree.c
index ff96df8..ccd8a09 100644
--- a/gcc/ree.c
+++ b/gcc/ree.c
@@ -928,6 +928,9 @@ find_and_remove_re (void)
 static unsigned int
 rest_of_handle_ree (void)
 {
+  if (df_check_ud_du_memory_usage ())
+    return 0;
+
   timevar_push (TV_REE);
   find_and_remove_re ();
   timevar_pop (TV_REE);
diff --git a/gcc/regs.h b/gcc/regs.h
index 090d6b6..7408727 100644
--- a/gcc/regs.h
+++ b/gcc/regs.h
@@ -137,6 +137,7 @@ extern size_t reg_info_p_size;
    frequency.  */
 #define REG_FREQ_FROM_BB(bb) (optimize_size				      \
 			      || (flag_branch_probabilities		      \
+				  && !flag_auto_profile			      \
 				  && !ENTRY_BLOCK_PTR->count)		      \
 			      ? REG_FREQ_MAX				      \
 			      : ((bb)->frequency * REG_FREQ_MAX / BB_FREQ_MAX)\
diff --git a/gcc/rtl.h b/gcc/rtl.h
index 93a64f4..a0127ef 100644
--- a/gcc/rtl.h
+++ b/gcc/rtl.h
@@ -1916,6 +1916,7 @@ extern rtx prev_cc0_setter (rtx);
 extern int insn_line (const_rtx);
 extern const char * insn_file (const_rtx);
 extern tree insn_scope (const_rtx);
+extern int insn_discriminator (const_rtx);
 extern location_t prologue_location, epilogue_location;
 
 /* In jump.c */
diff --git a/gcc/stmt.c b/gcc/stmt.c
index ca58786..e658ac6 100644
--- a/gcc/stmt.c
+++ b/gcc/stmt.c
@@ -50,6 +50,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "regs.h"
 #include "alloc-pool.h"
 #include "pretty-print.h"
+#include "coverage.h"
+#include "bitmap.h"
 #include "pointer-set.h"
 #include "params.h"
 #include "dumpfile.h"
@@ -1074,6 +1076,7 @@ expand_asm_operands (tree string, tree outputs, tree inputs,
       emit_move_insn (real_output_rtx[i], output_rtx[i]);
 
   crtl->has_asm_statement = 1;
+  coverage_has_asm_stmt ();
   free_temp_slots ();
 }
 
diff --git a/gcc/symtab.c b/gcc/symtab.c
index 7388b2c..ac6619a 100644
--- a/gcc/symtab.c
+++ b/gcc/symtab.c
@@ -101,7 +101,7 @@ eq_assembler_name (const void *p1, const void *p2)
 
 /* Insert NODE to assembler name hash.  */
 
-static void
+void
 insert_to_assembler_name_hash (symtab_node node)
 {
   if (is_a <varpool_node> (node) && DECL_HARD_REGISTER (node->symbol.decl))
@@ -127,7 +127,7 @@ insert_to_assembler_name_hash (symtab_node node)
 
 /* Remove NODE from assembler name hash.  */
 
-static void
+void
 unlink_from_assembler_name_hash (symtab_node node)
 {
   if (assembler_name_hash)
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-static8.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-static8.C
index 7c84cf8..658a458 100644
--- a/gcc/testsuite/g++.dg/cpp0x/constexpr-static8.C
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-static8.C
@@ -1,5 +1,5 @@
 // PR c++/50258
-// { dg-options "-std=c++0x -fpermissive" }
+// { dg-options "-std=c++0x -pedantic" }
 
 struct Foo {
   static const double d = 3.14; // { dg-warning "constexpr" }
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-static8_nonpedantic.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-static8_nonpedantic.C
new file mode 100644
index 0000000..28d34a1
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-static8_nonpedantic.C
@@ -0,0 +1,7 @@
+// PR c++/50258
+// { dg-options "-std=c++0x" }
+
+struct Foo {
+  static const double d = 3.14; // no warning
+};
+const double Foo::d;
diff --git a/gcc/testsuite/g++.dg/debug/dwarf2/dwarf4-nested.C b/gcc/testsuite/g++.dg/debug/dwarf2/dwarf4-nested.C
new file mode 100644
index 0000000..f83c092
--- /dev/null
+++ b/gcc/testsuite/g++.dg/debug/dwarf2/dwarf4-nested.C
@@ -0,0 +1,54 @@
+// { dg-do compile }
+// { dg-options "--std=c++11 -dA -gdwarf-4 -fdebug-types-section -fno-merge-debug-strings" }
+
+// Check that -fdebug-types-sections does not copy a full referenced type
+// into a type unit.
+
+// Checks that at least one type unit is generated.
+//
+// { dg-final { scan-assembler "DIE \\(\[^\n\]*\\) DW_TAG_type_unit" } }
+//
+// Check that func is declared exactly once in the debug info.
+//
+// { dg-final { scan-assembler-times "\\.ascii \"func\\\\0\"\[^\n\]*DW_AT_name" 1 } }
+//
+// Check to make sure that no type unit contains a DIE with DW_AT_low_pc
+// or DW_AT_ranges.  These patterns assume that the compile unit is always
+// emitted after all type units.
+//
+// { dg-final { scan-assembler-not "\\.quad\[^\n\]*DW_AT_low_pc.*DIE \\(\[^\n\]*\\) DW_TAG_compile_unit" } }
+// { dg-final { scan-assembler-not "\\.quad\[^\n\]*DW_AT_ranges.*DIE \\(\[^\n\]*\\) DW_TAG_compile_unit" } }
+
+struct A {
+  A();
+  virtual ~A();
+  virtual void foo();
+ private:
+  int data;
+};
+
+struct B {
+  B();
+  virtual ~B();
+};
+
+extern B* table[];
+
+struct D {
+  template <typename T>
+  T* get(int i)
+  {
+    B*& cell = table[i];
+    if (cell == 0)
+      cell = new T();
+    return static_cast<T*>(cell);
+  }
+};
+
+void func(D* d)
+{
+  struct C : B {
+    A a;
+  };
+  d->get<C>(0)->a.foo();
+}
diff --git a/gcc/testsuite/g++.dg/debug/dwarf2/dwarf4-typedef.C b/gcc/testsuite/g++.dg/debug/dwarf2/dwarf4-typedef.C
index c5520fa..89a6bb4 100644
--- a/gcc/testsuite/g++.dg/debug/dwarf2/dwarf4-typedef.C
+++ b/gcc/testsuite/g++.dg/debug/dwarf2/dwarf4-typedef.C
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-gdwarf-4" } */
+/* { dg-options "-gdwarf-4 -fdebug-types-section" } */
 
 /* Regression test for an ICE in output_die when using -gdwarf-4.  */
 
diff --git a/gcc/testsuite/g++.dg/debug/dwarf2/explicit-constructor.C b/gcc/testsuite/g++.dg/debug/dwarf2/explicit-constructor.C
index 32d205d..782d71a 100644
--- a/gcc/testsuite/g++.dg/debug/dwarf2/explicit-constructor.C
+++ b/gcc/testsuite/g++.dg/debug/dwarf2/explicit-constructor.C
@@ -1,7 +1,7 @@
 // Contributed by Dodji Seketeli <dodji@redhat.com>
 // Origin: PR c++
 // { dg-do compile }
-// { dg-options "-O -g -dA -gno-strict-dwarf" }
+// { dg-options "-O -g -dA -gno-strict-dwarf -fno-debug-types-section" }
 // { dg-final { scan-assembler-times "DW_AT_explicit" 2 } }
 
 struct Foo
diff --git a/gcc/testsuite/g++.dg/debug/dwarf2/global-used-types-1.C b/gcc/testsuite/g++.dg/debug/dwarf2/global-used-types-1.C
index 69b5647..702a33f 100644
--- a/gcc/testsuite/g++.dg/debug/dwarf2/global-used-types-1.C
+++ b/gcc/testsuite/g++.dg/debug/dwarf2/global-used-types-1.C
@@ -1,5 +1,5 @@
 // Contributed by Dodji Seketeli <dodji@redhat.com>
-// { dg-options "-g -dA -fno-merge-debug-strings" }
+// { dg-options "-g -dA -fno-merge-debug-strings -fno-debug-types-section" }
 // { dg-do compile }
 // { dg-final { scan-assembler-times "DIE \\(0x\[^\n\]*\\) DW_TAG_enumeration_type" 1 } }
 // { dg-final { scan-assembler-times "DIE \\(0x\[^\n\]*\\) DW_TAG_enumerator" 2 } }
diff --git a/gcc/testsuite/g++.dg/debug/dwarf2/integer-typedef.C b/gcc/testsuite/g++.dg/debug/dwarf2/integer-typedef.C
index 3379b71..f22fe28 100644
--- a/gcc/testsuite/g++.dg/debug/dwarf2/integer-typedef.C
+++ b/gcc/testsuite/g++.dg/debug/dwarf2/integer-typedef.C
@@ -1,5 +1,5 @@
 // Origin: PR debug/49130
-// { dg-options "-g -dA -fno-merge-debug-strings" }
+// { dg-options "-g -dA -fno-merge-debug-strings -fno-debug-types-section" }
 
 typedef long unsigned int size_t;
 static const size_t foo = 2048;
diff --git a/gcc/testsuite/g++.dg/debug/dwarf2/namespace-2.C b/gcc/testsuite/g++.dg/debug/dwarf2/namespace-2.C
index 0289e90..8715ca6 100644
--- a/gcc/testsuite/g++.dg/debug/dwarf2/namespace-2.C
+++ b/gcc/testsuite/g++.dg/debug/dwarf2/namespace-2.C
@@ -1,6 +1,6 @@
 // Test that we define A inside the namespace rather than declaring it
 // there and then defining it at CU scope.
-// { dg-options "-g -dA" }
+// { dg-options "-g -dA -fno-debug-types-section" }
 // { dg-final { scan-assembler-not "DW_AT_declaration" } }
 
 namespace N {
diff --git a/gcc/testsuite/g++.dg/debug/dwarf2/nested-2.C b/gcc/testsuite/g++.dg/debug/dwarf2/nested-2.C
index cec7034..b0c858c 100644
--- a/gcc/testsuite/g++.dg/debug/dwarf2/nested-2.C
+++ b/gcc/testsuite/g++.dg/debug/dwarf2/nested-2.C
@@ -1,6 +1,6 @@
 /*
   Origin: PR debug/45024
-  { dg-options "-g -dA -fno-merge-debug-strings" }
+  { dg-options "-g -dA -fno-merge-debug-strings -fno-debug-types-section" }
   { dg-do compile }
 */
 
diff --git a/gcc/testsuite/g++.dg/debug/dwarf2/pubnames-2.C b/gcc/testsuite/g++.dg/debug/dwarf2/pubnames-2.C
index 64b121b..52ae5c4 100644
--- a/gcc/testsuite/g++.dg/debug/dwarf2/pubnames-2.C
+++ b/gcc/testsuite/g++.dg/debug/dwarf2/pubnames-2.C
@@ -1,5 +1,5 @@
 // { dg-do compile }
-// { dg-options "-gpubnames -gdwarf-4 -std=c++0x -dA" }
+// { dg-options "-gpubnames -gdwarf-4 -fno-debug-types-section -std=c++0x -dA" }
 // { dg-final { scan-assembler-times "\.section\[\t \]\[^\n\]*debug_pubnames" 1 } }
 // { dg-final { scan-assembler "\"\\(anonymous namespace\\)\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
 // { dg-final { scan-assembler "\"one\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
diff --git a/gcc/testsuite/g++.dg/debug/dwarf2/pubnames-3.C b/gcc/testsuite/g++.dg/debug/dwarf2/pubnames-3.C
new file mode 100644
index 0000000..6c1e265
--- /dev/null
+++ b/gcc/testsuite/g++.dg/debug/dwarf2/pubnames-3.C
@@ -0,0 +1,193 @@
+// { dg-do compile }
+// { dg-options "-gpubnames -gdwarf-4 -fdebug-types-section -std=c++0x -dA" }
+// { dg-final { scan-assembler-times "\.section\[\t \]\[^\n\]*debug_pubnames" 1 } }
+// { dg-final { scan-assembler "\"\\(anonymous namespace\\)\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"one\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"one::G_A\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"one::G_B\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"one::G_C\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"one::\\(anonymous namespace\\)\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"two\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"F_A\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"F_B\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"F_C\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"inline_func_1\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"one::c1::c1\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"one::c1::~c1\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"one::c1::val\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"check_enum\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"main\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"two::c2<int>::c2\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"two::c2<double>::c2\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"two::c2<int const\\\*>::c2\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"check<one::c1>\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"check<two::c2<int> \\>\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"check<two::c2<double> \\>\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"check<two::c2<int const\\\*> \\>\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"two::c2<int>::val\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"two::c2<double>::val\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"two::c2<int const\\\*>::val\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"__static_initialization_and_destruction_0\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"two::c2<int>::~c2\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"two::c2<double>::~c2\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"two::c2<int const\\\*>::~c2\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"anonymous_union_var\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"two::ci\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"two::c2v1\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"two::c2v2\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"two::c2v3\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"one::c1v\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"one::\\(anonymous namespace\\)::one_anonymous_var\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"\\(anonymous namespace\\)::c1_count\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"\\(anonymous namespace\\)::c2_count\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"\\(anonymous namespace\\)::three\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"\\(anonymous namespace\\)::three::anonymous_three_var\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler-times "\.section\[\t \]\[^\n\]*debug_pubtypes" 1 } }
+// { dg-final { scan-assembler "\"one::G\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"one::c1\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"int\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"one::c1\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"two::c2<int>\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"two::c2<int>\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"two::c2<double>\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"double\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"two::c2<double>\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"two::c2<int const\\\*>\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"two::c2<int const\\\*>\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"F\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"anonymous_union_container\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+// { dg-final { scan-assembler "\"bool\\\\0\"+\[ \t\]+\[#;/|@!]+\[ \t\]+external name" } }
+
+namespace
+{
+int c1_count;
+int c2_count;
+
+namespace three
+{
+int anonymous_three_var;
+}
+};
+
+namespace one
+{
+
+enum G
+{
+  G_A,
+  G_B,
+  G_C
+};
+
+namespace {
+int one_anonymous_var;
+}
+
+class c1
+{
+ public:
+  static int count;
+
+  c1()
+  { ++c1_count; }
+
+  ~c1()
+  {
+    --c1_count;
+  }
+
+  enum E
+  {
+    E_A,
+    E_B,
+    E_C,
+  };
+
+  int
+  val()
+  { return E_A; }
+};
+
+c1 c1v;
+};
+
+namespace two
+{
+const int ci = 3;
+
+template <typename T>
+class c2
+{
+ public:
+  c2(T t)
+    : t_(t)
+  {
+    ++c2_count;
+  }
+
+  ~c2()
+  { --c2_count; }
+
+  T
+  val()
+  { return this->t_; }
+
+  T t_;
+};
+
+c2<int> c2v1(1);
+c2<double> c2v2(2.0);
+c2<int const*> c2v3(&ci);
+};
+
+enum F
+{
+  F_A,
+  F_B,
+  F_C
+};
+
+template <class C>
+bool
+check(C* c)
+{ return c->val() == 0; }
+
+bool
+check_enum(int i)
+{ return i > 0; }
+
+struct anonymous_union_container {
+  union {
+    struct astruct {
+      int a;
+    };
+    int b;
+  } u;
+};
+
+anonymous_union_container anonymous_union_var;
+
+#ifdef __GNUC__
+#define ALWAYS_INLINE __attribute__((always_inline))
+#else
+#define ALWAYS_INLINE
+#endif
+
+static inline ALWAYS_INLINE int
+inline_func_1(int i)
+{ return i * 17; }
+
+int
+main()
+{
+  F f = F_A;
+  one::G g = one::G_A;
+  check_enum(f);
+  check_enum(g);
+  check(&one::c1v);
+  check(&two::c2v1);
+  check(&two::c2v2);
+  check(&two::c2v3);
+  anonymous_union_var.u.b = inline_func_1(3) - 51;
+  return anonymous_union_var.u.b;
+}
diff --git a/gcc/testsuite/g++.dg/debug/dwarf2/self-ref-1.C b/gcc/testsuite/g++.dg/debug/dwarf2/self-ref-1.C
index 06db9dc..89467ad 100644
--- a/gcc/testsuite/g++.dg/debug/dwarf2/self-ref-1.C
+++ b/gcc/testsuite/g++.dg/debug/dwarf2/self-ref-1.C
@@ -1,6 +1,6 @@
 // Origin: PR debug/45088
 // { dg-do compile }
-// { dg-options "-g -dA" }
+// { dg-options "-g -dA -fno-debug-types-section" }
 // { dg-final { scan-assembler-times "\[^\n\r\]*\\(DIE\[^\n\r\]*DW_TAG_pointer_type\\)\[\n\r\]{1,2}\[^\n\r\]*DW_AT_byte_size\[\n\r\]{1,2}\[^\n\r\]*DW_AT_type" 4 } }
 
 struct A
diff --git a/gcc/testsuite/g++.dg/debug/dwarf2/self-ref-2.C b/gcc/testsuite/g++.dg/debug/dwarf2/self-ref-2.C
index d5463c0..c319c68 100644
--- a/gcc/testsuite/g++.dg/debug/dwarf2/self-ref-2.C
+++ b/gcc/testsuite/g++.dg/debug/dwarf2/self-ref-2.C
@@ -1,6 +1,6 @@
 // Origin: PR debug/45088
 // { dg-do compile }
-// { dg-options "-g -dA" }
+// { dg-options "-g -dA -fno-debug-types-section" }
 // { dg-final { scan-assembler-times "\[^\n\r\]*\\(DIE\[^\n\r\]*DW_TAG_pointer_type\\)\[\n\r\]{1,2}\[^\n\r\]*DW_AT_byte_size\[\n\r\]{1,2}\[^\n\r\]*DW_AT_type" 4 } }
 
 template<class T>
diff --git a/gcc/testsuite/g++.dg/debug/dwarf2/static-data-member1.C b/gcc/testsuite/g++.dg/debug/dwarf2/static-data-member1.C
index dce279e..b807e47 100644
--- a/gcc/testsuite/g++.dg/debug/dwarf2/static-data-member1.C
+++ b/gcc/testsuite/g++.dg/debug/dwarf2/static-data-member1.C
@@ -1,5 +1,5 @@
 // { dg-do compile }
-// { dg-options "-g -dA -fno-merge-debug-strings" }
+// { dg-options "-g -dA -fno-merge-debug-strings -fno-debug-types-section" }
 
 struct A
 {
diff --git a/gcc/testsuite/g++.dg/debug/dwarf2/typedef1.C b/gcc/testsuite/g++.dg/debug/dwarf2/typedef1.C
index a9ce44d..795dc7f 100644
--- a/gcc/testsuite/g++.dg/debug/dwarf2/typedef1.C
+++ b/gcc/testsuite/g++.dg/debug/dwarf2/typedef1.C
@@ -1,6 +1,6 @@
 // Contributed by Dodji Seketeli <dodji@redhat.com>
 // Origin: PR c++/40705
-// { dg-options "-g -dA" }
+// { dg-options "-g -dA -fno-debug-types-section" }
 // { dg-do compile }
 // { dg-final { scan-assembler-times "DW_TAG_structure_type" 2 } }
 // { dg-final { scan-assembler-times "DW_AT_name: \"foo<1u>\"|\"foo<1u>..\"\[^\n\]*DW_AT_name" 1 } }
diff --git a/gcc/testsuite/g++.dg/debug/dwarf2/typedef2.C b/gcc/testsuite/g++.dg/debug/dwarf2/typedef2.C
index 5bf0499..0bc27f2 100644
--- a/gcc/testsuite/g++.dg/debug/dwarf2/typedef2.C
+++ b/gcc/testsuite/g++.dg/debug/dwarf2/typedef2.C
@@ -1,5 +1,5 @@
 // Origin: PR debug/43628
-// { dg-options "-g -dA" }
+// { dg-options "-g -dA -fno-debug-types-section" }
 // { dg-do compile }
 
 // { dg-final { scan-assembler-times "\[^\n\r\]*\\(DIE\[^\n\r\]*DW_TAG_formal_parameter\\)\[\n\r\]{1,2}\[^\n\r\]*DW_AT_type\[\n\r\]{1,2}" 1 } }
diff --git a/gcc/testsuite/g++.dg/debug/dwarf2/typedef4.C b/gcc/testsuite/g++.dg/debug/dwarf2/typedef4.C
index 2879f60..6749e1b 100644
--- a/gcc/testsuite/g++.dg/debug/dwarf2/typedef4.C
+++ b/gcc/testsuite/g++.dg/debug/dwarf2/typedef4.C
@@ -1,5 +1,5 @@
 // Origin: PR debug/45171
-// { dg-options "-g -dA -fno-eliminate-unused-debug-types" }
+// { dg-options "-g -dA -fno-eliminate-unused-debug-types -fno-debug-types-section" }
 // { dg-do compile }
 
 // There should be 2 real instances of byte_size -- one for the
diff --git a/gcc/testsuite/g++.dg/fstack-protector-strong.C b/gcc/testsuite/g++.dg/fstack-protector-strong.C
new file mode 100644
index 0000000..a4f0f81
--- /dev/null
+++ b/gcc/testsuite/g++.dg/fstack-protector-strong.C
@@ -0,0 +1,35 @@
+/* Test that stack protection is done on chosen functions. */
+
+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */
+/* { dg-options "-O2 -fstack-protector-strong" } */
+
+class A
+{
+public:
+  A() {}
+  ~A() {}
+  void method();
+  int state;
+};
+
+/* Frame address exposed to A::method via "this". */
+int
+foo1 ()
+{
+  A a;
+  a.method ();
+  return a.state;
+}
+
+/* Possible destroying foo2's stack via &a. */
+int
+global_func (A& a);
+
+/* Frame address exposed to global_func. */
+int foo2 ()
+{
+  A a;
+  return global_func (a);
+}
+
+/* { dg-final { scan-assembler-times "stack_chk_fail" 2 } } */
diff --git a/gcc/testsuite/g++.dg/gcov/gcov-7.C b/gcc/testsuite/g++.dg/gcov/gcov-7.C
deleted file mode 100644
index db3e95a..0000000
--- a/gcc/testsuite/g++.dg/gcov/gcov-7.C
+++ /dev/null
@@ -1,28 +0,0 @@
-/* Check that Exception handler specification is not
-   mapped to the curly braces below the function
-   declaration.  */
-
-/* { dg-options "-fprofile-arcs -ftest-coverage" } */
-/* { dg-do run { target native } } */
-
-struct foo
-{
-  foo () throw (int)
-    {			/* count (-) */
-      throw (1);
-    }
-};
-
-int main ()
-{
-  try
-    {
-      foo f;
-    }
-  catch ( ...)
-    {
-      return 0;
-    }
-}
-
-/* { dg-final { run-gcov gcov-7.C } } */
diff --git a/gcc/testsuite/g++.dg/gcov/gcov-8.C b/gcc/testsuite/g++.dg/gcov/gcov-8.C
new file mode 100644
index 0000000..7acab46
--- /dev/null
+++ b/gcc/testsuite/g++.dg/gcov/gcov-8.C
@@ -0,0 +1,35 @@
+/* Verify that intermediate coverage format can be generated for simple code. */
+
+/* { dg-options "-fprofile-arcs -ftest-coverage" } */
+/* { dg-do run { target native } } */
+
+class C {
+public:
+  C()
+  {
+    i = 0;
+  }
+  ~C() {}
+  void seti (int j)
+  {
+    if (j > 0)
+      i = j;
+    else
+      i = 0;
+  }
+private:
+  int i;
+};
+
+void foo()
+{
+  C c;
+  c.seti (1);
+}
+
+int main()
+{
+  foo();
+}
+
+/* { dg-final { run-gcov intermediate { -i -b gcov-8.C } } } */
diff --git a/gcc/testsuite/g++.dg/guality/guality.exp b/gcc/testsuite/g++.dg/guality/guality.exp
index 9a17850..a07a628 100644
--- a/gcc/testsuite/g++.dg/guality/guality.exp
+++ b/gcc/testsuite/g++.dg/guality/guality.exp
@@ -1,5 +1,8 @@
 # This harness is for tests that should be run at all optimisation levels.
 
+# Disable everywhere.  These tests are very flaky.
+return
+
 load_lib g++-dg.exp
 load_lib gcc-gdb-test.exp
 
diff --git a/gcc/testsuite/g++.dg/ipa/devirt-11.C b/gcc/testsuite/g++.dg/ipa/devirt-11.C
index c139f8f..b40faf6 100644
--- a/gcc/testsuite/g++.dg/ipa/devirt-11.C
+++ b/gcc/testsuite/g++.dg/ipa/devirt-11.C
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -fdump-ipa-inline" } */
+/* { dg-options "-O2 -fdump-ipa-inline --param=early-inlining-insns-comdat=0" } */
 int baz ();
 struct A
 {
diff --git a/gcc/testsuite/g++.dg/ipa/devirt-9.C b/gcc/testsuite/g++.dg/ipa/devirt-9.C
index 5be458c..a5c03ac 100644
--- a/gcc/testsuite/g++.dg/ipa/devirt-9.C
+++ b/gcc/testsuite/g++.dg/ipa/devirt-9.C
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -fdump-ipa-inline"  } */
+/* { dg-options "-O2 -fdump-ipa-inline --param=early-inlining-insns-comdat=0" } */
 double foo ();
 struct B
 {
diff --git a/gcc/testsuite/g++.dg/other/no-strict-enum-precision-1.C b/gcc/testsuite/g++.dg/other/no-strict-enum-precision-1.C
new file mode 100644
index 0000000..2115627
--- /dev/null
+++ b/gcc/testsuite/g++.dg/other/no-strict-enum-precision-1.C
@@ -0,0 +1,35 @@
+/* { dg-do run } */
+/* { dg-options "-fno-strict-enums" } */
+
+extern "C" void abort (void);
+
+enum zero_one
+{ zero = 0, one = 1 };
+
+int *
+allocate_bool (zero_one e)
+{
+  int *v = 0;
+  switch (e)
+    {
+    case zero:
+      v = new int (0);
+    case one:
+      v = new int (1);
+    }
+  return v;
+}
+
+int
+main ()
+{
+  if (allocate_bool (static_cast < zero_one > (999)))
+    {
+      /* Error: should not have matched any case label.  */
+      abort ();
+    }
+  else
+    {
+      return 0;
+    }
+}
diff --git a/gcc/testsuite/g++.dg/other/no-strict-enum-precision-2.C b/gcc/testsuite/g++.dg/other/no-strict-enum-precision-2.C
new file mode 100644
index 0000000..086989c
--- /dev/null
+++ b/gcc/testsuite/g++.dg/other/no-strict-enum-precision-2.C
@@ -0,0 +1,37 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-strict-enums" } */
+
+extern "C" void abort (void);
+
+enum X
+{
+  X1,
+  X2
+};
+
+int
+foo (enum X x)
+{
+  switch (x)
+    {
+    case X1:
+      return 0;
+    case X2:
+      return 1;
+    }
+  return x;
+}
+
+int
+main (int argc, char *argv[])
+{
+  int n = argc + 999;
+  if (n == foo (static_cast < X > (n)))
+    {
+      return 0;
+    }
+  else
+    {
+      abort ();
+    }
+}
diff --git a/gcc/testsuite/g++.dg/other/no-strict-enum-precision-3.C b/gcc/testsuite/g++.dg/other/no-strict-enum-precision-3.C
new file mode 100755
index 0000000..673601a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/other/no-strict-enum-precision-3.C
@@ -0,0 +1,21 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-strict-enums" } */
+
+extern "C" void abort (void);
+
+enum X
+{
+  X1,
+  X2
+};
+
+int
+main (int argc, char *argv[])
+{
+  X x = static_cast < X > (argc + 999);
+  if (x == X1)
+    abort ();
+  if (x == X2)
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/other/sized-delete-1.C b/gcc/testsuite/g++.dg/other/sized-delete-1.C
new file mode 100644
index 0000000..76f861a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/other/sized-delete-1.C
@@ -0,0 +1,14 @@
+// { dg-do link}
+// { dg-options "-O -fsized-delete" }
+// { dg-final { scan-assembler "_ZdlPv\[mj\]" } }
+struct A
+{
+  int a[100];
+};
+
+int main(void)
+{
+  A *a = new A;
+  delete a;
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/plugin/selfassign.c b/gcc/testsuite/g++.dg/plugin/selfassign.c
index 37a0a97..bc318c8 100644
--- a/gcc/testsuite/g++.dg/plugin/selfassign.c
+++ b/gcc/testsuite/g++.dg/plugin/selfassign.c
@@ -196,7 +196,7 @@ compare_and_warn (gimple stmt, tree lhs, tree rhs)
 /* Check and warn if STMT is a self-assign statement.  */
 
 static void
-warn_self_assign (gimple stmt)
+check_self_assign (gimple stmt)
 {
   tree rhs, lhs;
 
@@ -249,7 +249,7 @@ execute_warn_self_assign (void)
   FOR_EACH_BB (bb)
     {
       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
-        warn_self_assign (gsi_stmt (gsi));
+        check_self_assign (gsi_stmt (gsi));
     }
 
   return 0;
diff --git a/gcc/testsuite/g++.dg/pr57878.C b/gcc/testsuite/g++.dg/pr57878.C
index b1aa25c..d4e7d86 100644
--- a/gcc/testsuite/g++.dg/pr57878.C
+++ b/gcc/testsuite/g++.dg/pr57878.C
@@ -1,5 +1,5 @@
-/* { dg-do compile { target i?86-*-* x86_64-*-* } } */
-/* { dg-options "-m32 -O2 -fno-omit-frame-pointer -fPIC -std=gnu++11" } */
+/* { dg-do compile { target { { i?86-*-* x86_64-*-* } && ilp32 } } } */
+/* { dg-options "-O2 -fno-omit-frame-pointer -fPIC -std=gnu++11" } */
 
 typedef int int32;
 typedef long long int64;
diff --git a/gcc/testsuite/g++.dg/rtti/repo1.C b/gcc/testsuite/g++.dg/rtti/repo1.C
index f72a973..16dd302 100644
--- a/gcc/testsuite/g++.dg/rtti/repo1.C
+++ b/gcc/testsuite/g++.dg/rtti/repo1.C
@@ -2,6 +2,7 @@
 // { dg-options "-frepo" }
 // { dg-require-host-local "" }
 // { dg-skip-if "dkms are not final links" { vxworks_kernel } }
+// { dg-skip-if "-frepo not supported with --sysroot (as it is not passed to COLLECT_GCC_OPTIONS" { *-*-linux* } { "*" } { "" } }
 
 #include <typeinfo>
 template<int>
diff --git a/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_1.C b/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_1.C
new file mode 100644
index 0000000..d82b895
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_1.C
@@ -0,0 +1,45 @@
+/* Verify if call-graph profile sections are created with -freorder-functions=.
+   Check of edge profiles and node profiles are present in the profile
+   sections.  Check if the segment splitting API is invoked.  */
+/* { dg-require-section-exclude "" } */
+/* { dg-require-linker-function-reordering-plugin "" } */
+/* { dg-options "-O2 -freorder-functions=callgraph -ffunction-sections --save-temps -Wl,-plugin-opt,file=linker.dump -Wl,-plugin-opt,split_segment=yes" } */
+
+int
+notcalled ()
+{
+  return 0;
+}
+
+int __attribute__ ((noinline))
+foo ()
+{
+  return 1;
+}
+
+int __attribute__ ((noinline))
+bar ()
+{
+  return 0;
+}
+
+int main ()
+{
+  int sum;
+  for (int i = 0; i< 1000; i++)
+    {
+      sum = foo () + bar();
+    }
+  return sum * bar ();
+}
+
+/* { dg-final-use { scan-assembler "\.gnu\.callgraph\.text\.main" } } */
+/* { dg-final-use { scan-assembler "\.string \"1000\"" } } */
+/* { dg-final-use { scan-assembler "\.string \"Weight 1000 1000\"" } }  */
+/* { dg-final-use { scan-assembler "\.string \"Weight 1001 1001\"" } }  */
+/* { dg-final-use { scan-file linker.dump "Callgraph group : _Z3foov _Z3barv main\n" } }  */
+/* { dg-final-use { scan-file linker.dump ".text\.*\._Z9notcalledv entry count = 0 computed = 0 max count = 0" } }  */
+/* { dg-final-use { scan-file linker.dump "\.text\.*\._Z3foov.*\n\.text\.*\._Z3barv.*\n\.text\.*\.main.*\n" } }  */
+/* { dg-final-use { scan-file linker.dump "Moving . section\\(s\\) to new segment" } }  */
+/* { dg-final-use { cleanup-saved-temps } }  */
+/* { dg-final-use { remove-build-file "linker.dump" } }  */
diff --git a/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_2.C b/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_2.C
new file mode 100644
index 0000000..5e238d8
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_2.C
@@ -0,0 +1,25 @@
+/* Check if the edge_cutoffa option to the function reordering plugin works as
+   expected.  */
+/* { dg-require-section-exclude "" } */
+/* { dg-require-linker-function-reordering-plugin "" } */
+/* { dg-options "-O2 -freorder-functions=callgraph -ffunction-sections -Wl,-plugin-opt,file=linker.dump -Wl,-plugin-opt,edge_cutoff=a1000" } */
+
+int __attribute__ ((noinline))
+foo ()
+{
+  return 1;
+}
+
+int main ()
+{
+  int sum = 0;
+  for (int i = 0; i< 1000; i++)
+    {
+      sum += foo ();
+    }
+  return sum - 1000;
+}
+
+/* { dg-final-use { scan-file linker.dump "Not considering edge with weight 1000 and below" } }  */
+/* { dg-final-use { scan-file-not linker.dump "Callgraph group" } }  */
+/* { dg-final-use { remove-build-file "linker.dump" } }  */
diff --git a/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_3.C b/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_3.C
new file mode 100644
index 0000000..f316701
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_3.C
@@ -0,0 +1,25 @@
+/* Check if the edge_cutoffp option to the function reordering plugin works as
+   expected.  */
+/* { dg-require-section-exclude "" } */
+/* { dg-require-linker-function-reordering-plugin "" } */
+/* { dg-options "-O2 -freorder-functions=callgraph -ffunction-sections -Wl,-plugin-opt,file=linker.dump -Wl,-plugin-opt,edge_cutoff=p100" } */
+
+int __attribute__ ((noinline))
+foo ()
+{
+  return 1;
+}
+
+int main ()
+{
+  int sum = 0;
+  for (int i = 0; i< 1000; i++)
+    {
+      sum += foo ();
+    }
+  return sum - 1000;
+}
+
+/* { dg-final-use { scan-file linker.dump "Not considering edge with weight 1000 and below" } }  */
+/* { dg-final-use { scan-file-not linker.dump "Callgraph group" } }  */
+/* { dg-final-use { remove-build-file "linker.dump" } }  */
diff --git a/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_4.C b/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_4.C
new file mode 100644
index 0000000..58e38ad
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_4.C
@@ -0,0 +1,41 @@
+/* Check if cutting off callgraph gets all functions laid out only according to
+   function profiles and not prefixes. foo_200 is as hot as the other foo's but
+   has a unlikely section prefix.  This should not matter as sort_name_prefix
+   is turned off.  */
+/* { dg-require-section-exclude "" } */
+/* { dg-require-linker-function-reordering-plugin "" } */
+/* { dg-options "-O2 -freorder-functions=callgraph -ffunction-sections -Wl,-plugin-opt,file=linker.dump,-plugin-opt,edge_cutoff=p100,-plugin-opt,sort_name_prefix=no" } */
+
+int __attribute__ ((noinline, section(".text.unlikely._Z7foo_200v")))
+foo_200 ()
+{
+  return 1;
+}
+
+int __attribute__ ((noinline))
+foo_100 ()
+{
+  return 1;
+}
+
+int __attribute__ ((noinline))
+foo_300 ()
+{
+  return 1;
+}
+int main ()
+{
+  int sum = 0;
+  for (int i = 0; i< 200; i++)
+    sum += foo_200 ();
+  for (int i = 0; i< 100; i++)
+    sum += foo_100 ();
+  for (int i = 0; i< 300; i++)
+    sum += foo_300 ();
+  return sum - 600;
+}
+
+/* { dg-final-use { scan-file-not linker.dump "Callgraph group" } }  */
+/* { dg-final-use { scan-file linker.dump ".text.unlikely._Z7foo_200v entry count = 200 computed = 200 max count = 200" } }  */
+/* { dg-final-use { scan-file linker.dump "\.text\.*\._Z7foo_100v.*\n\.text\.unlikely\._Z7foo_200v.*\n\.text\.*\._Z7foo_300v.*\n" } }  */
+/* { dg-final-use { remove-build-file "linker.dump" } }  */
diff --git a/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_5.C b/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_5.C
new file mode 100644
index 0000000..dbae8d7
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_5.C
@@ -0,0 +1,41 @@
+/* Check if cutting off callgraph and using sort_name_prefix gets all functions laid out
+   according to prefixes.   foo_200 is almost as hot as the other foo's but should
+   not be grouped with them as it has a different section prefix and sort_name_prefix is
+   turned on.  */
+/* { dg-require-section-exclude "" } */
+/* { dg-require-linker-function-reordering-plugin "" } */
+/* { dg-options "-O2 -freorder-functions=callgraph -ffunction-sections -Wl,-plugin-opt,file=linker.dump,-plugin-opt,edge_cutoff=p100,-plugin-opt,sort_name_prefix=yes" } */
+
+int __attribute__ ((noinline, section(".text.unlikely._Z7foo_200v")))
+foo_200 ()
+{
+  return 1;
+}
+
+int __attribute__ ((noinline))
+foo_100 ()
+{
+  return 1;
+}
+
+int __attribute__ ((noinline))
+foo_300 ()
+{
+  return 1;
+}
+int main ()
+{
+  int sum = 0;
+  for (int i = 0; i< 200; i++)
+    sum += foo_200 ();
+  for (int i = 0; i< 100; i++)
+    sum += foo_100 ();
+  for (int i = 0; i< 300; i++)
+    sum += foo_300 ();
+  return sum - 600;
+}
+
+/* { dg-final-use { scan-file-not linker.dump "Callgraph group" } }  */
+/* { dg-final-use { scan-file linker.dump ".text.unlikely._Z7foo_200v entry count = 200 computed = 200 max count = 200" } }  */
+/* { dg-final-use { scan-file linker.dump "\.text\.unlikely\._Z7foo_200v.*\n\.text\.*\._Z7foo_100v.*\n\.text\.*\._Z7foo_300v.*\n" } }  */
+/* { dg-final-use { remove-build-file "linker.dump" } }  */
diff --git a/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_6.C b/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_6.C
new file mode 100644
index 0000000..1116a4f
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_6.C
@@ -0,0 +1,53 @@
+/* Check if use_maxcount works as expected.  This makes the node profile weight to
+   be equal to the maximum count of any basic block in a function rather than the
+   entry count.   foo_100's maxcount > foo_200's max count  */
+/* { dg-require-section-exclude "" } */
+/* { dg-require-linker-function-reordering-plugin "" } */
+/* { dg-options "-O2 -freorder-functions=callgraph -ffunction-sections -Wl,-plugin-opt,file=linker.dump -Wl,-plugin-opt,edge_cutoff=p100,-plugin-opt,use_maxcount=yes" } */
+
+
+int __attribute__ ((noinline))
+bar (int *i)
+{
+  (*i)--;
+  if (*i >= 0)
+    return 1;
+  return 0;
+}
+
+int __attribute__ ((noinline))
+foo_100 (int count)
+{
+  int sum = 0;
+  while (count > 0)
+    {
+      sum += bar(&count);  
+    }
+  return sum;
+}
+
+int __attribute__ ((noinline))
+foo_200 (int count)
+{
+  int sum = 0;
+  while (count > 0)
+    {
+      sum += bar(&count);  
+    }
+  return sum;
+}
+
+int main ()
+{
+  int sum = 0;
+  for (int i = 0; i< 200; i++)
+    sum += foo_200 (100);
+  for (int i = 0; i< 100; i++)
+    sum += foo_100 (400);
+  return sum - 60000;
+}
+/* { dg-final-use { scan-file-not linker.dump "Callgraph group" } }  */
+/* { dg-final-use { scan-file linker.dump "\.text\.*\._Z7foo_100i entry count = 100 computed = 100 max count = 40000" } }  */
+/* { dg-final-use { scan-file linker.dump "\.text\.*\._Z7foo_200i entry count = 200 computed = 200 max count = 20000" } }  */
+/* { dg-final-use { scan-file linker.dump "\.text\.*\._Z7foo_200i.*\n\.text\.*\._Z7foo_100i.*\n\.text\.*\._Z3barPi.*\n" } }  */
+/* { dg-final-use { remove-build-file "linker.dump" } }  */
diff --git a/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_7.C b/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_7.C
new file mode 100644
index 0000000..3af8636
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_7.C
@@ -0,0 +1,55 @@
+/* Check if turning off use_maxcount works as expected.  This makes the node
+   profile weight to be equal to the entry count of any basic block in a
+   function rather than the max count.
+   foo_100's maxcount > foo_200's max count but 
+   foo_100's entry count < foo_200's entry count.  */
+/* { dg-require-section-exclude "" } */
+/* { dg-require-linker-function-reordering-plugin "" } */
+/* { dg-options "-O2 -freorder-functions=callgraph -ffunction-sections -Wl,-plugin-opt,file=linker.dump -Wl,-plugin-opt,edge_cutoff=p100,-plugin-opt,use_maxcount=no" } */
+
+
+int __attribute__ ((noinline))
+bar (int *i)
+{
+  (*i)--;
+  if (*i >= 0)
+    return 1;
+  return 0;
+}
+
+int __attribute__ ((noinline))
+foo_100 (int count)
+{
+  int sum = 0;
+  while (count > 0)
+    {
+      sum += bar(&count);  
+    }
+  return sum;
+}
+
+int __attribute__ ((noinline))
+foo_200 (int count)
+{
+  int sum = 0;
+  while (count > 0)
+    {
+      sum += bar(&count);  
+    }
+  return sum;
+}
+
+int main ()
+{
+  int sum = 0;
+  for (int i = 0; i< 200; i++)
+    sum += foo_200 (100);
+  for (int i = 0; i< 100; i++)
+    sum += foo_100 (400);
+  return sum - 60000;
+}
+/* { dg-final-use { scan-file-not linker.dump "Callgraph group" } }  */
+/* { dg-final-use { scan-file linker.dump "\.text\.*\._Z7foo_100i entry count = 100 computed = 100 max count = 40000" } }  */
+/* { dg-final-use { scan-file linker.dump "\.text\.*\._Z7foo_200i entry count = 200 computed = 200 max count = 20000" } }  */
+/* { dg-final-use { scan-file linker.dump "\.text\.*\._Z7foo_100i.*\n\.text\.*\._Z7foo_200i.*\n\.text\.*\._Z3barPi.*\n" } }  */
+/* { dg-final-use { remove-build-file "linker.dump" } }  */
diff --git a/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_8.C b/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_8.C
new file mode 100644
index 0000000..9beeffb
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-prof/func_reorder_gold_plugin_8.C
@@ -0,0 +1,19 @@
+/* Check if unlikely_cutoff works as expected.  Function foo is unlikely because of the cutoff.  */
+/* { dg-require-section-exclude "" } */
+/* { dg-require-linker-function-reordering-plugin "" } */
+/* { dg-options "-O2 -freorder-functions=callgraph -ffunction-sections -Wl,-plugin-opt,file=linker.dump -Wl,-plugin-opt,edge_cutoff=p100,-plugin-opt,unlikely_cutoff=1" } */
+
+int __attribute__ ((noinline,section(".text.hot._Z3foov")))
+foo ()
+{
+  return 0;
+}
+
+int main()
+{
+  return foo ();
+}
+
+/* { dg-final-use { scan-file-not linker.dump "Callgraph group" } }  */
+/* { dg-final-use { scan-file linker.dump "=== Unlikely sections start ===\n.*\.text\.hot\._Z3foov.* entry count = 1 computed = 1 max count = 1\n.*=== Unlikely sections end ===" } }  */
+/* { dg-final-use { remove-build-file "linker.dump" } }  */
diff --git a/gcc/testsuite/g++.dg/tree-prof/lipo/indir-call-prof-2_0.C b/gcc/testsuite/g++.dg/tree-prof/lipo/indir-call-prof-2_0.C
new file mode 100644
index 0000000..e20cc64
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-prof/lipo/indir-call-prof-2_0.C
@@ -0,0 +1,35 @@
+/* { dg-options "-O" } */
+
+int foo1(void) { return 0; }
+int bar1(void) { throw 1; }
+void foo2(void) { }
+void bar2(void) { throw 1; }
+void __attribute__((noinline,noclone)) test1(void (*f)(void)) { (*f)(); }
+void __attribute__((noinline,noclone)) test2(void (*f)(void)) { (*f)(); }
+int __attribute__((noinline,noclone)) test3(int (*f)(void)) { return (*f)(); }
+int __attribute__((noinline,noclone)) test4(int (*f)(void)) { return (*f)(); }
+int __attribute__((noinline,noclone)) test5(int (*f)(void), int x) { return x ? x : (*f)(); }
+int __attribute__((noinline,noclone)) test6(int (*f)(void), int x) { return x ? x : (*f)(); }
+void __attribute__((noinline,noclone)) test7(void (*f)(void)) { try { (*f)(); } catch (...) {} }
+void __attribute__((noinline,noclone)) test8(void (*f)(void)) { try { (*f)();  } catch (...) {}}
+int __attribute__((noinline,noclone)) test9(int (*f)(void)) { try { return (*f)(); } catch (...) {return 0;} }
+int __attribute__((noinline,noclone)) test10(int (*f)(void)) { try { return (*f)(); } catch (...) {return 0;} }
+int __attribute__((noinline,noclone)) test11(int (*f)(void), int x) { try { return x ? x : (*f)(); } catch (...) {return 0;} }
+int __attribute__((noinline,noclone)) test12(int (*f)(void), int x) { try { return x ? x : (*f)(); } catch (...) {return 0;} }
+
+int main()
+{
+  for (int i = 0; i < 100; ++i) test1(foo2);
+  for (int i = 0; i < 100; ++i) try { test2(bar2); } catch (...) {} 
+  for (int i = 0; i < 100; ++i) test3(foo1);
+  for (int i = 0; i < 100; ++i) try { test4(bar1); } catch (...) {} 
+  for (int i = 0; i < 100; ++i) test5(foo1, 0);
+  for (int i = 0; i < 100; ++i) try { test6(bar1, 0); } catch (...) {} 
+  for (int i = 0; i < 100; ++i) test7(foo2);
+  for (int i = 0; i < 100; ++i) try { test8(bar2); } catch (...) {} 
+  for (int i = 0; i < 100; ++i) test9(foo1);
+  for (int i = 0; i < 100; ++i) try { test10(bar1); } catch (...) {} 
+  for (int i = 0; i < 100; ++i) test11(foo1, 0);
+  for (int i = 0; i < 100; ++i) try { test12(bar1, 0); } catch (...) {} 
+  return 0;
+}
diff --git a/gcc/testsuite/g++.dg/tree-prof/lipo/indir-call-prof_0.C b/gcc/testsuite/g++.dg/tree-prof/lipo/indir-call-prof_0.C
new file mode 100644
index 0000000..b34b937
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-prof/lipo/indir-call-prof_0.C
@@ -0,0 +1,39 @@
+/* { dg-options "-O2 -fdump-tree-optimized -fdump-ipa-profile" } */
+
+struct A {
+  A () {}
+
+  virtual int AA (void)
+  { return 0; }
+
+};
+
+struct B : public A {
+  B () {}
+
+  virtual int AA (void)
+  { return 1; }
+};
+
+void * __attribute__((noinline,noclone)) wrap (void *p) { return p; }
+int
+main (void)
+{
+  A a;
+  B b;
+  
+  A* p;
+
+  p = (A *)wrap ((void *)&a);
+  p->AA ();
+
+  p = (B *)wrap ((void *)&b);
+  p->AA ();
+  
+  return 0;
+}
+
+/* { dg-final-use { scan-ipa-dump "Indirect call -> direct call.* AA " "profile" } } */
+/* { dg-final-use { scan-tree-dump-not "Invalid sum" "optimized" } } */
+/* { dg-final-use { cleanup-tree-dump "optimized" } } */
+/* { dg-final-use { cleanup-ipa-dump "profile" } } */
diff --git a/gcc/testsuite/g++.dg/tree-prof/lipo/inline_mismatch_args_0.C b/gcc/testsuite/g++.dg/tree-prof/lipo/inline_mismatch_args_0.C
new file mode 100644
index 0000000..e82a46e
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-prof/lipo/inline_mismatch_args_0.C
@@ -0,0 +1,36 @@
+/* { dg-options "-O2 -fdump-tree-einline" } */
+class DocId {
+ public:
+ DocId() { }
+ DocId(const DocId &other) {  }
+};
+
+int g;
+class Base {
+ public:
+ virtual void Foo(DocId id) { g++; }
+};
+
+class Super: public Base {
+ public:
+ void Foo(DocId id) { }
+ void Bar(Base *base, DocId id) __attribute__((noinline));
+};
+
+void Super::Bar(Base *base, DocId id) {
+ Super::Foo(id); // direct call is inlined
+ base->Foo(id); // indirect call is marked do not inline
+}
+
+int main(void)
+{
+ Base bah;
+ Super baz;
+ DocId gid;
+
+ baz.Bar(&baz, gid);
+ return 0;
+}
+/* { dg-final-use { scan-tree-dump "Inlining .*Super::Foo" "einline" } } */
+/* { dg-final-use { scan-tree-dump-not "mismatched arguments" "einline" } } */
+/* { dg-final-use { cleanup-tree-dump "einline" } } */
diff --git a/gcc/testsuite/g++.dg/tree-prof/lipo/lipo.exp b/gcc/testsuite/g++.dg/tree-prof/lipo/lipo.exp
new file mode 100644
index 0000000..2d1ddd7
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-prof/lipo/lipo.exp
@@ -0,0 +1,60 @@
+# Copyright (C) 2001, 2002, 2004, 2005, 2007, 2008
+# Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# Test the functionality of programs compiled with profile-directed block
+# ordering using -fprofile-generate followed by -fprofile-use.
+
+load_lib target-supports.exp
+
+# Some targets don't support tree profiling.
+if { ![check_profiling_available ""] } {
+    return
+}
+
+# The procedures in profopt.exp need these parameters.
+set tool g++
+set prof_ext [list {gcda} {gcda.imports} ] 
+
+# Override the list defined in profopt.exp.
+set PROFOPT_OPTIONS [list {}]
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+# Load support procs.
+load_lib profopt.exp
+
+# These are globals used by profopt-execute.  The first is options
+# needed to generate profile data, the second is options to use the
+# profile data.
+set profile_option "-fprofile-generate -fripa"
+set feedback_option "-fprofile-use -fripa"
+
+# Add -fno-section-anchors for powerpc.  Workround for Google ref b/6663281
+if {[istarget powerpc*-*-*]} {
+    set profile_option "$profile_option -fno-section-anchors"
+    set feedback_option "$feedback_option -fno-section-anchors"
+}
+
+foreach src [lsort [glob -nocomplain $srcdir/$subdir/*_0.C]] {
+    # If we're only testing specific files and this isn't one of them, skip it.
+    if ![runtest_file_p $runtests $src] then {
+        continue
+    }
+    profopt-execute $src
+}
diff --git a/gcc/testsuite/g++.dg/tree-prof/lipo/partition1_0.C b/gcc/testsuite/g++.dg/tree-prof/lipo/partition1_0.C
new file mode 100644
index 0000000..1088039
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-prof/lipo/partition1_0.C
@@ -0,0 +1,54 @@
+/* { dg-require-effective-target freorder } */
+/* { dg-options "-O2 -freorder-blocks-and-partition" } */
+/* { dg-skip-if "PR target/47683" { mips-sgi-irix* } } */
+
+struct A { A () __attribute__((noinline)); ~A () __attribute__((noinline)); };
+A::A () { asm volatile ("" : : : "memory"); }
+A::~A () { asm volatile ("" : : : "memory"); }
+
+int bar () __attribute__((noinline));
+void foo () __attribute__((noinline));
+
+volatile int k, l;
+
+int bar (int i)
+{
+  void *p = __builtin_alloca (i);
+  asm volatile ("" : : "r" (i), "r" (p) : "memory");
+  if (k) throw 6;
+  return ++l;
+}
+
+void foo ()
+{
+  A a;
+  try {
+    A b;
+    int i = bar (5);
+    try { throw 6; } catch (int) {}
+    if (__builtin_expect (i < 4500, 0)) {
+      bar (7);
+      try { bar (8); } catch (long) {}
+      bar (10);
+      if (__builtin_expect (i < 0, 0)) {
+	try { bar (12); } catch (...) {}
+	bar (16);
+	bar (122);
+      } else {
+	try { bar (bar (7)); } catch (int) {}
+      }
+    } else {
+      try { bar (bar (bar (9))); } catch (...) {}
+      bar (5);
+    }
+  } catch (...) {
+  }
+}
+
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 10000; i++)
+    foo ();
+}
diff --git a/gcc/testsuite/g++.dg/tree-prof/lipo/partition2_0.C b/gcc/testsuite/g++.dg/tree-prof/lipo/partition2_0.C
new file mode 100644
index 0000000..6715da5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-prof/lipo/partition2_0.C
@@ -0,0 +1,16 @@
+// PR middle-end/45458
+// { dg-require-effective-target freorder }
+// { dg-options "-fnon-call-exceptions -freorder-blocks-and-partition" }
+// { dg-skip-if "PR target/47683" { mips-sgi-irix* } }
+
+int
+main ()
+{
+  try
+  {
+    throw 6;
+  }
+  catch (...)
+  {
+  }
+}
diff --git a/gcc/testsuite/g++.dg/tree-prof/lipo/partition3_0.C b/gcc/testsuite/g++.dg/tree-prof/lipo/partition3_0.C
new file mode 100644
index 0000000..7846983
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-prof/lipo/partition3_0.C
@@ -0,0 +1,18 @@
+// PR middle-end/45566
+// { dg-require-effective-target freorder }
+// { dg-options "-O -fnon-call-exceptions -freorder-blocks-and-partition" }
+
+int k;
+
+int
+main ()
+{
+  try
+  {
+    if (k)
+      throw 6;
+  }
+  catch (...)
+  {
+  }
+}
diff --git a/gcc/testsuite/g++.dg/tree-prof/lipo/target_builtin_0.C b/gcc/testsuite/g++.dg/tree-prof/lipo/target_builtin_0.C
new file mode 100644
index 0000000..b28125b
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-prof/lipo/target_builtin_0.C
@@ -0,0 +1,11 @@
+/* Test case to check if LIPO and target specific builtins work fine.  */
+/* { dg-skip-if "" { ! { i?86-*-* x86_64-*-* } } { "*" } { "" } } */
+/* { dg-options "-O2" } */
+
+__attribute__((target("sse4.2")))
+unsigned int crc_aux (unsigned int A, unsigned int B);
+
+int main ()
+{
+  return crc_aux (0, 0);
+}
diff --git a/gcc/testsuite/g++.dg/tree-prof/lipo/target_builtin_1.C b/gcc/testsuite/g++.dg/tree-prof/lipo/target_builtin_1.C
new file mode 100644
index 0000000..e2faaf9
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-prof/lipo/target_builtin_1.C
@@ -0,0 +1,9 @@
+/* Test case to check if LIPO and target specific builtins work fine.  */
+/* { dg-skip-if "" { ! { i?86-*-* x86_64-*-* } } { "*" } { "" } } */
+/* { dg-options "-O2" } */
+
+__attribute__((target("sse4.2")))
+unsigned int crc_aux (unsigned int A, unsigned int B)
+{
+  return __builtin_ia32_crc32qi (A, B);
+}
diff --git a/gcc/testsuite/g++.dg/tree-prof/lipo/vcall1_0.C b/gcc/testsuite/g++.dg/tree-prof/lipo/vcall1_0.C
new file mode 100644
index 0000000..3052344
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-prof/lipo/vcall1_0.C
@@ -0,0 +1,41 @@
+/* { dg-options "-O2 -fdump-tree-optimized -fdump-ipa-profile" } */
+#include <stdio.h>
+struct A {
+  A () {}
+  virtual int AA (void) { return 0; }
+};
+
+extern A* getB (void);
+extern A* getC (void);
+
+int g;
+
+int
+main (void)
+{
+  A* p;
+  int i;
+  int s = 0;
+
+  p = getB();
+  for (i = 0; i < 100; i++)
+   {
+      s += p->AA();
+   }
+
+  for (i = 0; i < 100; i++)
+   {
+      if (i%10 == 0)
+        p = getB();
+      else
+        p = getC();
+
+      s += p->AA();
+   }
+   printf ("result = %d\n",s);
+}
+
+/* { dg-final-use { scan-ipa-dump-times "Indirect call -> direct call" 2 "profile" } } */
+/* { dg-final-use { scan-tree-dump-not "Invalid sum" "optimized" } } */
+/* { dg-final-use { cleanup-tree-dump "optimized" } } */
+/* { dg-final-use { cleanup-ipa-dump "profile" } } */
diff --git a/gcc/testsuite/g++.dg/tree-prof/lipo/vcall1_1.C b/gcc/testsuite/g++.dg/tree-prof/lipo/vcall1_1.C
new file mode 100644
index 0000000..6023024
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-prof/lipo/vcall1_1.C
@@ -0,0 +1,23 @@
+/* { dg-options "-O2 -fdump-tree-optimized -fdump-ipa-profile" } */
+
+struct A {
+  A () {}
+
+  virtual int AA (void)
+  { return 0; }
+
+};
+
+struct B : public A {
+  B () {}
+
+  virtual int AA (void)
+  { return 1; }
+};
+
+B b;
+
+A* getB (void)
+{
+  return &b;
+}
diff --git a/gcc/testsuite/g++.dg/tree-prof/lipo/vcall1_2.C b/gcc/testsuite/g++.dg/tree-prof/lipo/vcall1_2.C
new file mode 100644
index 0000000..cc33d6a
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-prof/lipo/vcall1_2.C
@@ -0,0 +1,31 @@
+/* { dg-options "-O2 -fdump-tree-optimized -fdump-ipa-profile" } */
+
+struct A {
+  A () {}
+
+  virtual int AA (void)
+  { return 0; }
+
+};
+
+struct B : public A {
+  B () {}
+
+  virtual int AA (void)
+  { return 1; }
+};
+
+struct C : public B {
+  C () {}
+
+  virtual int AA (void)
+  { return 2; }
+
+};
+
+C c;
+
+A* getC(void)
+{
+  return &c;
+}
diff --git a/gcc/testsuite/g++.dg/tree-ssa/dom-invalid.C b/gcc/testsuite/g++.dg/tree-ssa/dom-invalid.C
index 5513d36..91f43ae 100644
--- a/gcc/testsuite/g++.dg/tree-ssa/dom-invalid.C
+++ b/gcc/testsuite/g++.dg/tree-ssa/dom-invalid.C
@@ -1,7 +1,7 @@
 // PR tree-optimization/39557
 // invalid post-dom info leads to infinite loop
 // { dg-do run }
-// { dg-options "-Wall -fno-exceptions -O2 -fprofile-use -fno-rtti" }
+// { dg-options "-Wall -fno-exceptions -O2 -fprofile-use -fopt-info -fno-rtti" }
 
 struct C
 {
diff --git a/gcc/testsuite/g++.dg/vect/slp-pr50413.cc b/gcc/testsuite/g++.dg/vect/slp-pr50413.cc
index e7bdf1f..c47caf1 100644
--- a/gcc/testsuite/g++.dg/vect/slp-pr50413.cc
+++ b/gcc/testsuite/g++.dg/vect/slp-pr50413.cc
@@ -160,6 +160,6 @@ void shift(unsigned char t)
   V.bitmap.b96 = t;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 0 "slp" } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 0 "slp" } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
 
diff --git a/gcc/testsuite/g++.dg/vect/slp-pr50819.cc b/gcc/testsuite/g++.dg/vect/slp-pr50819.cc
index 402218b..96f82c3 100644
--- a/gcc/testsuite/g++.dg/vect/slp-pr50819.cc
+++ b/gcc/testsuite/g++.dg/vect/slp-pr50819.cc
@@ -49,5 +49,5 @@ const & v2) {
   res = res + s*(v1+v2);
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 2 "slp" } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 2 "slp" } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
diff --git a/gcc/testsuite/g++.dg/warn/Wnull-conversion-1.C b/gcc/testsuite/g++.dg/warn/Wnull-conversion-1.C
index 84a1d38..ff82fd4 100644
--- a/gcc/testsuite/g++.dg/warn/Wnull-conversion-1.C
+++ b/gcc/testsuite/g++.dg/warn/Wnull-conversion-1.C
@@ -3,7 +3,7 @@
 
 #include <stddef.h>
 
-void func1(int* ptr);
+void func1 (int *ptr);
 
 void func2() {
   int* t = false;             // { dg-warning "converting 'false' to pointer" }
diff --git a/gcc/testsuite/g++.dg/warn/Wnull-conversion-2.C b/gcc/testsuite/g++.dg/warn/Wnull-conversion-2.C
index 92a87d1..6ce7605 100644
--- a/gcc/testsuite/g++.dg/warn/Wnull-conversion-2.C
+++ b/gcc/testsuite/g++.dg/warn/Wnull-conversion-2.C
@@ -3,43 +3,53 @@
 
 #include <stddef.h>
 
-class Foo {
- public:
-  template <typename T1, typename T2>
-  static void Compare(const T1& expected, const T2& actual) { }
+class Foo
+{
+public:
+  template < typename T1, typename T2 >
+    static void Compare (const T1 & expected, const T2 & actual)
+  {
+  }
 
-  template <typename T1, typename T2>
-  static void Compare(const T1& expected, T2* actual) { }
+  template < typename T1, typename T2 >
+    static void Compare (const T1 & expected, T2 * actual)
+  {
+  }
 
 };
 
-template<typename T1>
-class Foo2 {
- public:
-  Foo2(int x);
-  template<typename T2> void Bar(T2 y);
+template < typename T1 > class Foo2
+{
+public:
+  Foo2 (int x);
+  template < typename T2 > void Bar (T2 y);
 };
 
-template<typename T3> void func(T3 x) { }
+template < typename T3 > void
+func (T3 x)
+{
+}
 
-typedef Foo2<int> MyFooType;
+typedef Foo2 < int >MyFooType;
 
-void func1(long int a) {
-  MyFooType *foo2 = new MyFooType(NULL); // { dg-warning "passing NULL to" }
-  foo2->Bar(a);
-  func(NULL);
-  func<int>(NULL);                       // { dg-warning "passing NULL to" }
-  func<int *>(NULL);
+void
+func1 (long int a)
+{
+  MyFooType *foo2 = new MyFooType (NULL); // { dg-warning "passing NULL to" }
+  foo2->Bar (a);
+  func (NULL);
+  func < int >(NULL);		// { dg-warning "passing NULL to" }
+  func < int *>(NULL);
 }
 
 int x = 1;
 
-main()
+main ()
 {
   int *p = &x;
 
-  Foo::Compare(0, *p);
-  Foo::Compare<long int, int>(NULL, p);  // { dg-warning "passing NULL to" }
-  Foo::Compare(NULL, p);
-  func1(NULL);                           // { dg-warning "passing NULL to" }
+  Foo::Compare (0, *p);
+  Foo::Compare < long int, int >(NULL, p); // { dg-warning "passing NULL to" }
+  Foo::Compare (NULL, p);
+  func1 (NULL);			// { dg-warning "passing NULL to" }
 }
diff --git a/gcc/testsuite/g++.dg/warn/Wreal-conversion-1.C b/gcc/testsuite/g++.dg/warn/Wreal-conversion-1.C
new file mode 100644
index 0000000..ff97a18
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wreal-conversion-1.C
@@ -0,0 +1,25 @@
+// { dg-do compile }
+// { dg-options "-Wreal-conversion" }
+
+#include <stddef.h>
+
+int func1(int a) {
+  double f = a;
+  return f;           // { dg-warning "conversion to" }
+}
+
+double func3();
+
+void func2() {
+  double g = 3.14;
+  float f = 1.8f;
+  int t = g;          // { dg-warning "conversion to" }
+  bool b = g;
+  int p;
+  p = f;              // { dg-warning "conversion to" }
+  func1(g);           // { dg-warning "conversion to" }
+  char c = f;         // { dg-warning "conversion to" }
+  c = p;
+  int q;
+  q = func3();        // { dg-warning "conversion to" }
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wself-assign-1.C b/gcc/testsuite/g++.dg/warn/Wself-assign-1.C
new file mode 100644
index 0000000..f152805
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wself-assign-1.C
@@ -0,0 +1,54 @@
+// Test the self-assignemnt detection and warning.
+// { dg-do compile }
+// { dg-options "-Wself-assign" }
+
+class Foo {
+ private:
+  int a_;
+
+ public:
+  Foo() : a_(a_) {} // { dg-warning "assigned to itself" }
+
+  void setA(int a) {
+    a_ = a_; // { dg-warning "assigned to itself" }
+  }
+
+  void operator=(Foo& rhs) {
+    this->a_ = rhs.a_;
+  }
+};
+
+struct Bar {
+  int b_;
+  int c_;
+};
+
+int g = g; // { dg-warning "assigned to itself" }
+Foo foo = foo; // { dg-warning "assigned to itself" }
+
+int func()
+{
+  Bar *bar1, bar2;
+  Foo local_foo;
+  int x = x; // { dg-warning "assigned to itself" }
+  static int y = y; // { dg-warning "assigned to itself" }
+  float *f;
+  Bar bar_array[5];
+  char n;
+  int overflow;
+
+  *f = *f; // { dg-warning "assigned to itself" }
+  bar1->b_ = bar1->b_; // { dg-warning "assigned to itself" }
+  bar2.c_ = bar2.c_; // { dg-warning "assigned to itself" }
+  local_foo = local_foo;
+  foo = foo;
+  foo.setA(5);
+  bar_array[3].c_ = bar_array[3].c_; // { dg-warning "assigned to itself" }
+  bar_array[x+g].b_ = bar_array[x+g].b_; // { dg-warning "assigned to itself" }
+  y = x;
+  x = y;
+  x += 0; // should not warn
+  y -= 0; // should not warn
+  x /= x; // should not warn
+  y *= y; // should not warn
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wself-assign-2.C b/gcc/testsuite/g++.dg/warn/Wself-assign-2.C
new file mode 100644
index 0000000..35c3d84
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wself-assign-2.C
@@ -0,0 +1,31 @@
+// Test the handling of expressions that depend on template parameters in
+// self-assignemnt detection.
+// { dg-do compile }
+// { dg-options "-Wself-assign" }
+
+template<typename T>
+struct Bar {
+  T x;
+  Bar operator++(int) {
+    Bar tmp = *this;
+    ++x;
+    tmp = tmp; // { dg-warning "assigned to itself" }
+    return tmp;
+  }
+};
+
+template<typename T>
+T DoSomething(T y) {
+  T a[5], *p;
+  Bar<T> b;
+  b.x = b.x;
+  *p = *p;
+  a[2] = a[2];
+  return *p;
+}
+
+main() {
+  Bar<int> bar;
+  bar++;
+  DoSomething(5);
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wself-assign-3.C b/gcc/testsuite/g++.dg/warn/Wself-assign-3.C
new file mode 100644
index 0000000..bc5732d
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wself-assign-3.C
@@ -0,0 +1,35 @@
+// Test how operands_equal_p handles a NULL operand.
+// { dg-do compile }
+// { dg-options "-Wself-assign" }
+
+#include <cstdio>
+
+namespace testing {
+
+class Foo {
+  int f;
+ public:
+  Foo() { printf("Construct Foo\n"); }
+};
+
+class Bar {
+  int b;
+ public:
+  Bar(int x) { printf("Construct Bar\n"); }
+
+  void operator=(const Foo& foo) {
+    printf("Assign Foo to Bar\n");
+  }
+};
+
+}
+
+template <class T>
+void func(T t) {
+  ::testing::Bar(1) = ::testing::Foo(); // used to trigger a segfault
+  ::testing::Foo() = ::testing::Foo();
+}
+
+main() {
+  func(2);
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wself-assign-4.C b/gcc/testsuite/g++.dg/warn/Wself-assign-4.C
new file mode 100644
index 0000000..abe96b5
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wself-assign-4.C
@@ -0,0 +1,48 @@
+// Test how self-assignment detection handles constant-folding happening
+// when parsing the RHS or the initializer.
+// { dg-do compile }
+// { dg-options "-Wself-assign" }
+
+class Foo {
+ private:
+  int a_;
+
+ public:
+  Foo() : a_(a_+0) {} // should not warn
+
+  void setA(int a) {
+    a_ = a_ + 0; // should not warn
+  }
+
+  void operator=(Foo& rhs) {
+    this->a_ = rhs.a_;
+  }
+};
+
+struct Bar {
+  int b_;
+  float c_;
+};
+
+int g = g * 1; // should not warn
+
+int func()
+{
+  Bar *bar1, bar2;
+  Foo foo;
+  int x = x - 0;        // should not warn
+  static int y = y / 1; // should not warn
+  float *f;
+  Bar bar_array[5];
+
+  *f = *f / 1;             // should not warn
+  bar1->b_ = bar1->b_ * 1; // should not warn
+  bar2.c_ = bar2.c_ - 0;   // should not warn
+  foo.setA(5);
+  bar_array[3].c_ = bar_array[3].c_ * 1;     // should not warn
+  bar_array[x+g].b_ = bar_array[x+g].b_ / 1; // should not warn
+  x += 0;
+  y -= 0;
+  foo = foo;
+  foo.operator=(foo);  // should not warn
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wself-assign-5.C b/gcc/testsuite/g++.dg/warn/Wself-assign-5.C
new file mode 100644
index 0000000..20df214
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wself-assign-5.C
@@ -0,0 +1,38 @@
+// Test -Wself-assign does not warn on self-assignment of non-POD variables.
+// { dg-do compile }
+// { dg-options "-Wself-assign" }
+
+template<typename T>
+class Foo {
+ private:
+  T a_;
+ public:
+  Foo() : a_(a_) {}  // { dg-warning "assigned to itself" }
+  void Set() { a_ = a_; }
+};
+
+struct Bar {
+  int b_;
+  int c_;
+  void operator=(Bar& rhs) {
+    this->b_ = rhs.b_;
+    this->c_ = rhs.c_;
+  }
+};
+
+template <typename T>
+void func() {
+  T a;
+  a = a;
+}
+
+main()
+{
+  Foo<Bar> foo;
+  Bar *bar1, bar2;
+  func<int>();
+  foo = foo;
+  bar2 = bar2;
+  bar1 = bar1;        // { dg-warning "assigned to itself" }
+  bar2.b_ = bar2.b_;  // { dg-warning "assigned to itself" }
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wself-assign-non-pod-1.C b/gcc/testsuite/g++.dg/warn/Wself-assign-non-pod-1.C
new file mode 100644
index 0000000..6f9dfb7
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wself-assign-non-pod-1.C
@@ -0,0 +1,54 @@
+// Test the self-assignemnt detection and warning.
+// { dg-do compile }
+// { dg-options "-Wself-assign -Wself-assign-non-pod" }
+
+class Foo {
+ private:
+  int a_;
+
+ public:
+  Foo() : a_(a_) {} // { dg-warning "assigned to itself" }
+
+  void setA(int a) {
+    a_ = a_; // { dg-warning "assigned to itself" }
+  }
+
+  void operator=(Foo& rhs) {
+    this->a_ = rhs.a_;
+  }
+};
+
+struct Bar {
+  int b_;
+  int c_;
+};
+
+int g = g; // { dg-warning "assigned to itself" }
+Foo foo = foo; // { dg-warning "assigned to itself" }
+
+int func()
+{
+  Bar *bar1, bar2;
+  Foo local_foo;
+  int x = x; // { dg-warning "assigned to itself" }
+  static int y = y; // { dg-warning "assigned to itself" }
+  float *f;
+  Bar bar_array[5];
+  char n;
+  int overflow;
+
+  *f = *f; // { dg-warning "assigned to itself" }
+  bar1->b_ = bar1->b_; // { dg-warning "assigned to itself" }
+  bar2.c_ = bar2.c_; // { dg-warning "assigned to itself" }
+  local_foo = local_foo; // { dg-warning "assigned to itself" }
+  foo = foo; // { dg-warning "assigned to itself" }
+  foo.setA(5);
+  bar_array[3].c_ = bar_array[3].c_; // { dg-warning "assigned to itself" }
+  bar_array[x+g].b_ = bar_array[x+g].b_; // { dg-warning "assigned to itself" }
+  y = x;
+  x = y;
+  x += 0; // should not warn
+  y -= 0; // should not warn
+  x /= x; // should not warn
+  y *= y; // should not warn
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wself-assign-non-pod-2.C b/gcc/testsuite/g++.dg/warn/Wself-assign-non-pod-2.C
new file mode 100644
index 0000000..b31b575
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wself-assign-non-pod-2.C
@@ -0,0 +1,31 @@
+// Test the handling of expressions that depend on template parameters in
+// self-assignemnt detection.
+// { dg-do compile }
+// { dg-options "-Wself-assign -Wself-assign-non-pod" }
+
+template<typename T>
+struct Bar {
+  T x;
+  Bar operator++(int) {
+    Bar tmp = *this;
+    ++x;
+    tmp = tmp; // { dg-warning "assigned to itself" }
+    return tmp;
+  }
+};
+
+template<typename T>
+T DoSomething(T y) {
+  T a[5], *p;
+  Bar<T> b;
+  b.x = b.x; // { dg-warning "assigned to itself" }
+  *p = *p; // { dg-warning "assigned to itself" }
+  a[2] = a[2]; // { dg-warning "assigned to itself" }
+  return *p;
+}
+
+main() {
+  Bar<int> bar;
+  bar++;
+  DoSomething(5);
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wself-assign-non-pod-3.C b/gcc/testsuite/g++.dg/warn/Wself-assign-non-pod-3.C
new file mode 100644
index 0000000..4c37f57
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wself-assign-non-pod-3.C
@@ -0,0 +1,35 @@
+// Test how operands_equal_p handles a NULL operand.
+// { dg-do compile }
+// { dg-options "-Wself-assign  -Wself-assign-non-pod" }
+
+#include <cstdio>
+
+namespace testing {
+
+class Foo {
+  int f;
+ public:
+  Foo() { printf("Construct Foo\n"); }
+};
+
+class Bar {
+  int b;
+ public:
+  Bar(int x) { printf("Construct Bar\n"); }
+
+  void operator=(const Foo& foo) {
+    printf("Assign Foo to Bar\n");
+  }
+};
+
+}
+
+template <class T>
+void func(T t) {
+  ::testing::Bar(1) = ::testing::Foo(); // used to trigger a segfault
+  ::testing::Foo() = ::testing::Foo(); // { dg-warning "assigned to itself" }
+}
+
+main() {
+  func(2);
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wself-assign-non-pod-4.C b/gcc/testsuite/g++.dg/warn/Wself-assign-non-pod-4.C
new file mode 100644
index 0000000..86db4e3
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wself-assign-non-pod-4.C
@@ -0,0 +1,48 @@
+// Test how self-assignment detection handles constant-folding happening
+// when parsing the RHS or the initializer.
+// { dg-do compile }
+// { dg-options "-Wself-assign -Wself-assign-non-pod" }
+
+class Foo {
+ private:
+  int a_;
+
+ public:
+  Foo() : a_(a_+0) {} // should not warn
+
+  void setA(int a) {
+    a_ = a_ + 0; // should not warn
+  }
+
+  void operator=(Foo& rhs) {
+    this->a_ = rhs.a_;
+  }
+};
+
+struct Bar {
+  int b_;
+  float c_;
+};
+
+int g = g * 1; // should not warn
+
+int func()
+{
+  Bar *bar1, bar2;
+  Foo foo;
+  int x = x - 0;        // should not warn
+  static int y = y / 1; // should not warn
+  float *f;
+  Bar bar_array[5];
+
+  *f = *f / 1;             // should not warn
+  bar1->b_ = bar1->b_ * 1; // should not warn
+  bar2.c_ = bar2.c_ - 0;   // should not warn
+  foo.setA(5);
+  bar_array[3].c_ = bar_array[3].c_ * 1;     // should not warn
+  bar_array[x+g].b_ = bar_array[x+g].b_ / 1; // should not warn
+  x += 0;
+  y -= 0;
+  foo = foo;           // { dg-warning "assigned to itself" }
+  foo.operator=(foo);  // should not warn
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wself-assign-non-pod-5.C b/gcc/testsuite/g++.dg/warn/Wself-assign-non-pod-5.C
new file mode 100644
index 0000000..898ddec
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wself-assign-non-pod-5.C
@@ -0,0 +1,38 @@
+// Test -Wself-assign and -Wself-assign-non-pod.
+// { dg-do compile }
+// { dg-options "-Wself-assign -Wself-assign-non-pod" }
+
+template<typename T>
+class Foo {
+ private:
+  T a_;
+ public:
+  Foo() : a_(a_) {}        // { dg-warning "assigned to itself" }
+  void Set() { a_ = a_; }  // { dg-warning "assigned to itself" }
+};
+
+struct Bar {
+  int b_;
+  int c_;
+  void operator=(Bar& rhs) {
+    this->b_ = rhs.b_;
+    this->c_ = rhs.c_;
+  }
+};
+
+template <typename T>
+void func() {
+  T a;
+  a = a;  // { dg-warning "assigned to itself" }
+}
+
+main()
+{
+  Foo<Bar> foo;
+  Bar *bar1, bar2;
+  func<int>();
+  foo = foo;          // { dg-warning "assigned to itself" }
+  bar2 = bar2;        // { dg-warning "assigned to itself" }
+  bar1 = bar1;        // { dg-warning "assigned to itself" }
+  bar2.b_ = bar2.b_;  // { dg-warning "assigned to itself" }
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wshadow-compatible-local-1.C b/gcc/testsuite/g++.dg/warn/Wshadow-compatible-local-1.C
new file mode 100644
index 0000000..e251b72
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wshadow-compatible-local-1.C
@@ -0,0 +1,63 @@
+/* { dg-do compile } */
+/* { dg-options -Wshadow-compatible-local } */
+
+class Bar {
+};
+
+class ChildBar : public Bar {
+};
+
+Bar bar;
+
+class Foo {
+ private:
+  int val;
+
+ public:
+  int func1(int x) {
+    int val;
+    val = x;
+    return val;
+  }
+
+  int func2(int i) { // { dg-warning "shadowed declaration" }
+    int a = 3;       // { dg-warning "shadowed declaration" }
+
+    for (int i = 0; i < 5; ++i) {   // { dg-warning "shadows a parameter" }
+      for (int i = 0; i < 3; ++i) { // { dg-warning "shadows a previous local" }
+        int a = i;   // { dg-warning "shadows a previous local" }
+        func1(a);
+      }
+    }
+
+    return a;
+  }
+
+  int func3() {
+    int bar;
+    float func1 = 0.3;
+    int f = 5;       // { dg-warning "shadowed declaration" }
+
+    if (func1 > 1) {
+      float f = 2.0; // { dg-warning "shadows a previous local" }
+      bar = f;
+    }
+    else
+      bar = 1;
+    return bar;
+  }
+
+  void func4() {
+    Bar *bar;        // { dg-bogus "shadowed declaration" }
+    ChildBar *cbp;   // { dg-bogus "shadowed declaration" }
+    Bar *bp;         // { dg-warning "shadowed declaration" }
+    if (val) {
+      int bar;       // { dg-bogus "shadows a previous local" }
+      Bar *cbp;      // { dg-bogus "shadows a previous local" }
+      ChildBar *bp;  // { dg-warning "shadows a previous local" }
+      func1(bar);
+    }
+  }
+};
+
+// { dg-warning "shadowed declaration" "" { target *-*-* } 26 }
diff --git a/gcc/testsuite/g++.dg/warn/Wshadow-local-1.C b/gcc/testsuite/g++.dg/warn/Wshadow-local-1.C
new file mode 100644
index 0000000..24a5bc2
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wshadow-local-1.C
@@ -0,0 +1,35 @@
+/* { dg-do compile } */
+/* { dg-options -Wshadow-local } */
+
+struct status
+{
+  int member;
+  void foo2 ();
+
+  inline static int foo3 (int member)
+  {
+    return member;
+  }
+};
+
+int decl1;                      // { dg-bogus "shadowed declaration" }
+int decl2;                      // { dg-bogus "shadowed declaration" }
+void foo (struct status &status,
+	  double decl1)		// { dg-bogus "shadows a global" }
+{
+}
+
+void foo1 (int d)
+{
+  double d;			// { dg-error "shadows a parameter" }
+}
+
+void status::foo2 ()
+{
+  int member;			// { dg-bogus "shadows a member" }
+  int decl2;			// { dg-bogus "shadows a global" }
+  int local;			// { dg-warning "shadowed declaration" }
+  {
+    int local;			// { dg-warning "shadows a previous local" }
+  }
+}
diff --git a/gcc/testsuite/g++.dg/warn/Wshadow-local-2.C b/gcc/testsuite/g++.dg/warn/Wshadow-local-2.C
new file mode 100644
index 0000000..ac3951e
--- /dev/null
+++ b/gcc/testsuite/g++.dg/warn/Wshadow-local-2.C
@@ -0,0 +1,63 @@
+/* { dg-do compile } */
+/* { dg-options -Wshadow-local } */
+
+class Bar {
+};
+
+class ChildBar : public Bar {
+};
+
+Bar bar;             // { dg-bogus "shadowed declaration" }
+
+class Foo {
+ private:
+  int val;
+
+ public:
+  int func1(int x) {
+    int val;         // { dg-bogus "shadows a member" }
+    val = x;
+    return val;
+  }
+
+  int func2(int i) { // { dg-warning "shadowed declaration" }
+    int a = 3;       // { dg-warning "shadowed declaration" }
+
+    for (int i = 0; i < 5; ++i) {   // { dg-warning "shadows a parameter" }
+      for (int i = 0; i < 3; ++i) { // { dg-warning "shadows a previous local" }
+        int a = i;   // { dg-warning "shadows a previous local" }
+        func1(a);
+      }
+    }
+
+    return a;
+  }
+
+  int func3() {
+    int bar;         // { dg-bogus "shadows a global" }
+    float func1 = 0.3; // { dg-bogus "shadows a member" }
+    int f = 5;       // { dg-warning "shadowed declaration" }
+
+    if (func1 > 1) {
+      float f = 2.0; // { dg-warning "shadows a previous local" }
+      bar = f;
+    }
+    else
+      bar = 1;
+    return bar;
+  }
+
+  void func4() {
+    Bar *bar;        // { dg-warning "shadowed declaration" }
+    ChildBar *cbp;   // { dg-warning "shadowed declaration" }
+    Bar *bp;         // { dg-warning "shadowed declaration" }
+    if (val) {
+      int bar;       // { dg-warning "shadows a previous local" }
+      Bar *cbp;      // { dg-warning "shadows a previous local" }
+      ChildBar *bp;  // { dg-warning "shadows a previous local" }
+      func1(bar);
+    }
+  }
+};
+
+// { dg-warning "shadowed declaration" "" { target *-*-* } 26 }
diff --git a/gcc/testsuite/g++.old-deja/g++.ext/memconst.C b/gcc/testsuite/g++.old-deja/g++.ext/memconst.C
index d934763..7e86156 100644
--- a/gcc/testsuite/g++.old-deja/g++.ext/memconst.C
+++ b/gcc/testsuite/g++.old-deja/g++.ext/memconst.C
@@ -1,5 +1,5 @@
 // { dg-do assemble  }
-// { dg-options "" }
+// { dg-options "-pedantic -pedantic-errors" }
 // From: Ove.Ewerlid@syscon.uu.se (Ove Ewerlid)
 // Subject: ss-940630:cc1plus: internal error
 // Date: Sat, 2 Jul 1994 05:07:20 +0200
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr43791.c b/gcc/testsuite/gcc.c-torture/compile/pr43791.c
index 38cb3c8..2b1d06f 100644
--- a/gcc/testsuite/gcc.c-torture/compile/pr43791.c
+++ b/gcc/testsuite/gcc.c-torture/compile/pr43791.c
@@ -18,4 +18,3 @@ void fasttrylock(void (*slowfn)()) {
 void trylock(void) {
      fasttrylock(slowtrylock);
 }
-
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr57698.c b/gcc/testsuite/gcc.c-torture/compile/pr57698.c
new file mode 100644
index 0000000..a9efb42
--- /dev/null
+++ b/gcc/testsuite/gcc.c-torture/compile/pr57698.c
@@ -0,0 +1,19 @@
+typedef int (*IsAcceptableThis) (const int );
+inline int
+fn1 (IsAcceptableThis p1)
+{
+    p1 (0);
+    return 0;
+}
+
+__attribute__ ((always_inline))
+inline int fn2 (const int a)
+{
+    return 0;
+}
+
+void
+fn3 ()
+{
+    fn1 (fn2);
+}
diff --git a/gcc/testsuite/gcc.dg/Wreal-conversion-1.c b/gcc/testsuite/gcc.dg/Wreal-conversion-1.c
new file mode 100644
index 0000000..bcb9c2e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Wreal-conversion-1.c
@@ -0,0 +1,24 @@
+// { dg-do compile }
+// { dg-options "-Wreal-conversion" }
+
+#include <stddef.h>
+
+int func1(int a) {
+  double f = a;
+  return f;           // { dg-warning "conversion to" }
+}
+
+double func3();
+
+void func2() {
+  double g = 3.14;
+  float f = 1.8f;
+  int t = g;          // { dg-warning "conversion to" }
+  int p;
+  p = f;              // { dg-warning "conversion to" }
+  func1(g);           // { dg-warning "conversion to" }
+  char c = f;         // { dg-warning "conversion to" }
+  c = p;
+  int q;
+  q = func3();        // { dg-warning "conversion to" }
+}
diff --git a/gcc/testsuite/gcc.dg/Wshadow-compatible-local-1.c b/gcc/testsuite/gcc.dg/Wshadow-compatible-local-1.c
new file mode 100644
index 0000000..cb21be9
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Wshadow-compatible-local-1.c
@@ -0,0 +1,36 @@
+/* { dg-do compile } */
+/* { dg-options "-Wshadow-compatible-local" } */
+
+struct Bar {
+};
+
+struct Bar bar;       /* { dg-bogus "shadowed declaration" } */
+
+int val;              /* { dg-bogus "shadowed declaration" } */
+
+int func1(int x) {    /* { dg-bogus "shadowed declaration" } */
+  int val;            /* { dg-bogus "shadows a global" } */
+  val = x;
+  return val;
+}
+
+int func2(int i) {
+  int a = 3;          /* { dg-warning "shadowed declaration" } */
+  int j;              /* { dg-warning "shadowed declaration" } */
+
+  for (j = 0; j < i; ++j) {
+    int a = j;        /* { dg-warning "shadows a previous local" } */
+    int j = a + 1;    /* { dg-warning "shadows a previous local" } */
+    func1(j);
+  }
+
+  return a;
+}
+
+void func4() {
+  struct Bar bar;     /* { dg-bogus "shadowed declaration" } */
+  if (val) {
+    int bar;          /* { dg-bogus "shadows a previous local" } */
+    func1(bar);
+  }
+}
diff --git a/gcc/testsuite/gcc.dg/Wshadow-local-1.c b/gcc/testsuite/gcc.dg/Wshadow-local-1.c
new file mode 100644
index 0000000..b21661e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Wshadow-local-1.c
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-Wshadow-local" } */
+
+int decl1;			/* should not warn */
+void foo (double decl1)		/* should not warn */
+{				
+}
+
+void foo2 (int d)		/* { dg-warning "shadowed declaration" } */
+{
+  {
+    double d;			/* { dg-warning "shadows a parameter" } */
+  }
+}
+
+void foo3 ()
+{
+  int local;			/* { dg-warning "shadowed declaration" } */
+  {
+    int local;			/* { dg-warning "shadows a previous local" } */
+  }
+}
+/* { dg-do compile } */
diff --git a/gcc/testsuite/gcc.dg/Wshadow-local-2.c b/gcc/testsuite/gcc.dg/Wshadow-local-2.c
new file mode 100644
index 0000000..9d52fac
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Wshadow-local-2.c
@@ -0,0 +1,49 @@
+/* { dg-do compile } */
+/* { dg-options "-Wshadow-local" } */
+
+struct Bar {
+};
+
+struct Bar bar;       /* { dg-bogus "shadowed declaration" } */
+
+int val;              /* { dg-bogus "shadowed declaration" } */
+
+int func1(int x) {    /* { dg-bogus "shadowed declaration" } */
+  int val;            /* { dg-bogus "shadows a global" } */
+  val = x;
+  return val;
+}
+
+int func2(int i) {
+  int a = 3;          /* { dg-warning "shadowed declaration" } */
+  int j;              /* { dg-warning "shadowed declaration" } */
+
+  for (j = 0; j < i; ++j) {
+    int a = j;        /* { dg-warning "shadows a previous local" } */
+    int j = a + 1;    /* { dg-warning "shadows a previous local" } */
+    func1(j);
+  }
+
+  return a;
+}
+
+int func3() {
+  int bar;            /* { dg-bogus "shadows a global" } */
+  float func1 = 0.3;  /* { dg-bogus "shadows a global" } */
+
+  if (func1 > 1)
+    bar = 2;
+  else
+    bar = 1;
+  return bar;
+}
+
+void func4() {
+  struct Bar bar;     /* { dg-warning "shadowed declaration" } */
+  if (val) {
+    int bar;          /* { dg-warning "shadows a previous local" } */
+    func1(bar);
+  }
+}
+
+/* { dg-bogus "shadows a global" ""  { target *-*-* } 42 } */
diff --git a/gcc/testsuite/gcc.dg/Wshadow-local-3.c b/gcc/testsuite/gcc.dg/Wshadow-local-3.c
new file mode 100644
index 0000000..429df37
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/Wshadow-local-3.c
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-Wno-shadow" } */
+
+void func() {
+  int i;
+    {
+      int i; /* should not warn */
+    }
+}
diff --git a/gcc/testsuite/gcc.dg/debug/dwarf2/discriminator.c b/gcc/testsuite/gcc.dg/debug/dwarf2/discriminator.c
new file mode 100644
index 0000000..64434d2
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/debug/dwarf2/discriminator.c
@@ -0,0 +1,16 @@
+/* { dg-do compile { target { i?86-*-* x86_64-*-* } } } */
+/* { dg-options "-O0 -gdwarf-2" } */
+/* { dg-final { scan-assembler "loc \[0-9] 9 \[0-9]( is_stmt \[0-9])?\n" } } */
+/* { dg-final { scan-assembler "loc \[0-9] 9 \[0-9]( is_stmt \[0-9])? discriminator 2\n" } } */
+/* { dg-final { scan-assembler "loc \[0-9] 9 \[0-9]( is_stmt \[0-9])? discriminator 1\n" } } */
+
+int foo(int n) {
+  int i, ret = 0;
+  for (i = 0; i < n; i++) {
+    if (i % 10 == 1)
+      ret++;
+    else
+      ret--;
+  }
+  return ret;
+}
diff --git a/gcc/testsuite/gcc.dg/debug/dwarf2/mlt1.c b/gcc/testsuite/gcc.dg/debug/dwarf2/mlt1.c
new file mode 100644
index 0000000..b916e69
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/debug/dwarf2/mlt1.c
@@ -0,0 +1,32 @@
+/* Test that -g1 includes line tables and inlined subroutine entries,
+   and excludes types and variables.  */
+/* Origin: Cary Coutant  <ccoutant@google.com> */
+/* { dg-do compile } */
+/* { dg-options "-O2 -gdwarf-2 -dA -g1" } */
+/* { dg-final { scan-assembler "DW_AT_stmt_list" } } */
+/* { dg-final { scan-assembler "DW_TAG_subprogram" } } */
+/* { dg-final { scan-assembler "DW_TAG_inlined_subroutine" } } */
+/* { dg-final { scan-assembler-not "DW_TAG_variable" } } */
+/* { dg-final { scan-assembler-not "DW_TAG_formal_parameter" } } */
+/* { dg-final { scan-assembler-not "DW_TAG_base_type" } } */
+
+static inline __attribute__((always_inline)) int
+a(int i, int j)
+{
+  return (i << 5) + j;
+}
+
+int
+b(int i, int j)
+{
+  return (i >> 5) + (j << 27);
+}
+
+int
+c(int i, int j)
+{
+  int r = a(i, j);
+  r = b(r, i);
+  r = b(r, j);
+  return r;
+}
diff --git a/gcc/testsuite/gcc.dg/debug/dwarf2/mlt2.c b/gcc/testsuite/gcc.dg/debug/dwarf2/mlt2.c
new file mode 100644
index 0000000..2fd5b0f
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/debug/dwarf2/mlt2.c
@@ -0,0 +1,31 @@
+/* Test that -g overrides -g1.  */
+/* Origin: Cary Coutant  <ccoutant@google.com> */
+/* { dg-do compile } */
+/* { dg-options "-O2 -gdwarf-2 -dA -g1 -g" } */
+/* { dg-final { scan-assembler "DW_AT_stmt_list" } } */
+/* { dg-final { scan-assembler "DW_TAG_subprogram" } } */
+/* { dg-final { scan-assembler "DW_TAG_inlined_subroutine" } } */
+/* { dg-final { scan-assembler "DW_TAG_variable" } } */
+/* { dg-final { scan-assembler "DW_TAG_formal_parameter" } } */
+/* { dg-final { scan-assembler "DW_TAG_base_type" } } */
+
+static inline __attribute__((always_inline)) int
+a(int i, int j)
+{
+  return (i << 5) + j;
+}
+
+int
+b(int i, int j)
+{
+  return (i >> 5) + (j << 27);
+}
+
+int
+c(int i, int j)
+{
+  int r = a(i, j);
+  r = b(r, i);
+  r = b(r, j);
+  return r;
+}
diff --git a/gcc/testsuite/gcc.dg/fstack-protector-strong.c b/gcc/testsuite/gcc.dg/fstack-protector-strong.c
new file mode 100644
index 0000000..5a5cf98
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/fstack-protector-strong.c
@@ -0,0 +1,135 @@
+/* Test that stack protection is done on chosen functions. */
+
+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */
+/* { dg-options "-O2 -fstack-protector-strong" } */
+
+#include<string.h>
+#include<stdlib.h>
+
+extern int g0;
+extern int* pg0;
+int
+goo (int *);
+int
+hoo (int);
+
+/* Function frame address escaped function call. */
+int
+foo1 ()
+{
+  int i;
+  return goo (&i);
+}
+
+struct ArrayStruct
+{
+  int a;
+  int array[10];
+};
+
+struct AA
+{
+  int b;
+  struct ArrayStruct as;
+};
+
+/* Function frame contains array. */
+int
+foo2 ()
+{
+  struct AA aa;
+  int i;
+  for (i = 0; i < 10; ++i)
+    {
+      aa.as.array[i] = i * (i-1) + i / 2;
+    }
+  return aa.as.array[5];
+}
+
+/* Address computation based on a function frame address. */
+int
+foo3 ()
+{
+  int a;
+  int *p;
+  p = &a + 5;
+  return goo (p);
+}
+
+/* Address cast based on a function frame address. */
+int
+foo4 ()
+{
+  int a;
+  return goo (g0 << 2 ? (int *)(3 * (long)(void *)(&a)) : 0);
+}
+
+/* Address cast based on a local array. */
+int
+foo5 ()
+{
+  short array[10];
+  return goo ((int *)(array + 5));
+}
+
+struct BB
+{
+  int one;
+  int two;
+  int three;
+};
+
+/* Address computaton based on a function frame address.*/
+int
+foo6 ()
+{
+  struct BB bb;
+  return goo (&bb.one + sizeof(int));
+}
+
+/* Function frame address escaped via global variable. */
+int
+foo7 ()
+{
+  int a;
+  pg0 = &a;
+  goo (pg0);
+  return *pg0;
+}
+
+/* Check that this covers -fstack-protector. */
+int
+foo8 ()
+{
+  char base[100];
+  memcpy ((void *)base, (const void *)pg0, 105);
+  return (int)(base[32]);
+}
+
+/* Check that this covers -fstack-protector. */
+int
+foo9 ()
+{
+  char* p = alloca (100);
+  return goo ((int *)(p + 50));
+}
+
+int
+global2 (struct BB* pbb);
+
+/* Address taken on struct. */
+int
+foo10 ()
+{
+  struct BB bb;
+  int i;
+  bb.one = global2 (&bb);
+  for (i = 0; i < 10; ++i)
+    {
+      bb.two = bb.one + bb.two;
+      bb.three = bb.one + bb.two + bb.three;
+    }
+  return bb.three;
+}
+
+/* { dg-final { scan-assembler-times "stack_chk_fail" 10 } } */
diff --git a/gcc/testsuite/gcc.dg/guality/guality.exp b/gcc/testsuite/gcc.dg/guality/guality.exp
index 49e2ac5..39bf4e3 100644
--- a/gcc/testsuite/gcc.dg/guality/guality.exp
+++ b/gcc/testsuite/gcc.dg/guality/guality.exp
@@ -1,5 +1,8 @@
 # This harness is for tests that should be run at all optimisation levels.
 
+# Disable everywhere.  These tests are very flaky.
+return
+
 load_lib gcc-dg.exp
 load_lib gcc-gdb-test.exp
 
diff --git a/gcc/testsuite/gcc.dg/inline-dump.c b/gcc/testsuite/gcc.dg/inline-dump.c
new file mode 100644
index 0000000..09bd2cc
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/inline-dump.c
@@ -0,0 +1,11 @@
+/* Verify that -fopt-info can output correct inline info.  */
+/* { dg-do compile } */
+/* { dg-options "-Wall -fopt-info-inline=stderr -O2 -fno-early-inlining" } */
+static inline int leaf() {
+  int i, ret = 0;
+  for (i = 0; i < 10; i++)
+    ret += i;
+  return ret;
+}
+static inline int foo(void) { return leaf(); } /* { dg-message "note: leaf inlined into bar .via inline instance foo.\n" } */
+int bar(void) { return foo(); }
diff --git a/gcc/testsuite/gcc.dg/inline_1.c b/gcc/testsuite/gcc.dg/inline_1.c
index 0301381..08ccb86 100644
--- a/gcc/testsuite/gcc.dg/inline_1.c
+++ b/gcc/testsuite/gcc.dg/inline_1.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -fdump-tree-optimized -fdisable-tree-einline -fdisable-ipa-inline -Wno-attributes" } */
+/* { dg-options "-O2 -fdump-tree-optimized -fdisable-tree-einline -fdisable-ipa-inline" } */
 int g;
 __attribute__((always_inline)) void bar (void)
 {
@@ -20,3 +20,4 @@ int foo2 (void)
 
 /* { dg-final { scan-tree-dump-times "bar" 5 "optimized" } } */
 /* { dg-final { cleanup-tree-dump "optimized" } } */
+/* { dg-excess-errors "extra notes" } */
diff --git a/gcc/testsuite/gcc.dg/inline_2.c b/gcc/testsuite/gcc.dg/inline_2.c
index e3b1df4..efdc76a 100644
--- a/gcc/testsuite/gcc.dg/inline_2.c
+++ b/gcc/testsuite/gcc.dg/inline_2.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -fdump-tree-optimized -fdisable-tree-einline=0:100 -fdisable-ipa-inline -Wno-attributes" } */
+/* { dg-options "-O2 -fdump-tree-optimized -fdisable-tree-einline=0:100 -fdisable-ipa-inline" } */
 int g;
 __attribute__((always_inline)) void bar (void)
 {
@@ -20,3 +20,4 @@ int foo2 (void)
 
 /* { dg-final { scan-tree-dump-times "bar" 5 "optimized" } } */
 /* { dg-final { cleanup-tree-dump "optimized" } } */
+/* { dg-excess-errors "extra notes" } */
diff --git a/gcc/testsuite/gcc.dg/inline_3.c b/gcc/testsuite/gcc.dg/inline_3.c
index 773c301..13796dc 100644
--- a/gcc/testsuite/gcc.dg/inline_3.c
+++ b/gcc/testsuite/gcc.dg/inline_3.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -fdump-tree-optimized -fdisable-tree-einline=foo,foo2 -fdisable-ipa-inline -Wno-attributes" } */
+/* { dg-options "-O2 -fdump-tree-optimized -fdisable-tree-einline=foo,foo2 -fdisable-ipa-inline" } */
 int g;
 __attribute__((always_inline)) void bar (void)
 {
diff --git a/gcc/testsuite/gcc.dg/inline_4.c b/gcc/testsuite/gcc.dg/inline_4.c
index dd4fadb..0ef3bcd 100644
--- a/gcc/testsuite/gcc.dg/inline_4.c
+++ b/gcc/testsuite/gcc.dg/inline_4.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -fdump-tree-optimized -fdisable-tree-einline=foo2 -fdisable-ipa-inline -Wno-attributes" } */
+/* { dg-options "-O2 -fdump-tree-optimized -fdisable-tree-einline=foo2 -fdisable-ipa-inline" } */
 int g;
 __attribute__((always_inline)) void bar (void)
 {
diff --git a/gcc/testsuite/gcc.dg/plugin/selfassign.c b/gcc/testsuite/gcc.dg/plugin/selfassign.c
index 37a0a97..bc318c8 100644
--- a/gcc/testsuite/gcc.dg/plugin/selfassign.c
+++ b/gcc/testsuite/gcc.dg/plugin/selfassign.c
@@ -196,7 +196,7 @@ compare_and_warn (gimple stmt, tree lhs, tree rhs)
 /* Check and warn if STMT is a self-assign statement.  */
 
 static void
-warn_self_assign (gimple stmt)
+check_self_assign (gimple stmt)
 {
   tree rhs, lhs;
 
@@ -249,7 +249,7 @@ execute_warn_self_assign (void)
   FOR_EACH_BB (bb)
     {
       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
-        warn_self_assign (gsi_stmt (gsi));
+        check_self_assign (gsi_stmt (gsi));
     }
 
   return 0;
diff --git a/gcc/testsuite/gcc.dg/pr26570.c b/gcc/testsuite/gcc.dg/pr26570.c
index 5768d32..71c16f2 100644
--- a/gcc/testsuite/gcc.dg/pr26570.c
+++ b/gcc/testsuite/gcc.dg/pr26570.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -fprofile-generate -fprofile-use" } */
+/* { dg-options "-O2 -fprofile-generate -fprofile-use -fopt-info" } */
 
 unsigned test (unsigned a, unsigned b)
 {
diff --git a/gcc/testsuite/gcc.dg/pr32773.c b/gcc/testsuite/gcc.dg/pr32773.c
index e9cdd4c..19a9019 100644
--- a/gcc/testsuite/gcc.dg/pr32773.c
+++ b/gcc/testsuite/gcc.dg/pr32773.c
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O -fprofile-use" } */
-/* { dg-options "-O -m4 -fprofile-use" { target sh-*-* } } */
+/* { dg-options "-O -fprofile-use -fopt-info" } */
+/* { dg-options "-O -m4 -fprofile-use -fopt-info" { target sh-*-* } } */
 
 void foo (int *p)
 {
diff --git a/gcc/testsuite/gcc.dg/pr40209.c b/gcc/testsuite/gcc.dg/pr40209.c
index f367f7c..afe131f 100644
--- a/gcc/testsuite/gcc.dg/pr40209.c
+++ b/gcc/testsuite/gcc.dg/pr40209.c
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -fprofile-use" } */
+/* { dg-options "-O2 -fprofile-use -fopt-info" } */
 
 void process(const char *s);
 
diff --git a/gcc/testsuite/gcc.dg/pr47793.c b/gcc/testsuite/gcc.dg/pr47793.c
index 0ee1aae..da6b6ea 100644
--- a/gcc/testsuite/gcc.dg/pr47793.c
+++ b/gcc/testsuite/gcc.dg/pr47793.c
@@ -1,7 +1,6 @@
 /* Bug pr47793: Allow relative paths in profile-generate.  */
 /* { dg-do run } */
 /* { dg-options "-O -fprofile-generate=./" } */
-/* { dg-require-profiling "-fprofile-generate" } */
 /* { dg-final { scan-file pr47793.gcda "."} } */
 
 int
diff --git a/gcc/testsuite/gcc.dg/record-compilation-info-in-elf-1.c b/gcc/testsuite/gcc.dg/record-compilation-info-in-elf-1.c
new file mode 100644
index 0000000..881281f
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/record-compilation-info-in-elf-1.c
@@ -0,0 +1,16 @@
+/* { dg-do compile} */
+/* { dg-options "-frecord-compilation-info-in-elf -Dtest -dA" } */
+
+void foobar(int);
+
+void
+foo (void)
+{
+  int i;
+  for (i = 0; i < 100; i++)
+    {
+      foobar(i);
+    }
+}
+
+/* { dg-final { scan-assembler-times "Dtest" 1 } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/inliner-1.c b/gcc/testsuite/gcc.dg/tree-prof/inliner-1.c
index b5340b5..8c6c879 100644
--- a/gcc/testsuite/gcc.dg/tree-prof/inliner-1.c
+++ b/gcc/testsuite/gcc.dg/tree-prof/inliner-1.c
@@ -1,4 +1,4 @@
-/* { dg-options "-O2 -fdump-tree-optimized" } */
+/* { dg-options "-O2 --param inline-hot-caller=0 -fdump-tree-optimized" } */
 int a;
 int b[100];
 void abort (void);
@@ -34,7 +34,7 @@ main ()
   return 0;
 }
 
-/* cold function should be inlined, while hot function should not.  
+/* cold function should be not inlined, while hot function should be.
    Look for "cold_function () [tail call];" call statement not for the
    declaration or other apperances of the string in dump.  */
 /* { dg-final-use { scan-tree-dump "cold_function ..;" "optimized"} } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/bb-reorg_0.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/bb-reorg_0.c
new file mode 100644
index 0000000..f850c9b
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/bb-reorg_0.c
@@ -0,0 +1,39 @@
+/* { dg-require-effective-target freorder } */
+/* { dg-options "-O2 -freorder-blocks-and-partition" } */
+
+#include <string.h>
+
+#define SIZE 1000
+int t0 = 0;
+const char *t2[SIZE];
+char buf[SIZE];
+
+void
+foo (void)
+{
+  char *s = buf;
+  t0 = 1;
+
+  for (;;)
+    {
+      if (*s == '\0')
+	break;
+      else
+	{
+	  t2[t0] = s;
+	  t0++;
+	}
+      *s++ = '\0';
+    }
+  t2[t0] = NULL;
+}
+
+
+int
+main ()
+{
+  strcpy (buf, "hello");
+  foo ();
+  return 0; 
+}
+
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/ic-misattribution-1_0.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/ic-misattribution-1_0.c
new file mode 100644
index 0000000..ff103a8
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/ic-misattribution-1_0.c
@@ -0,0 +1,19 @@
+/* { dg-options "-O2 -fdump-ipa-profile" } */
+
+extern void callee (void);
+extern void caller (void (*func) (void));
+
+typedef void (*func_t) (void);
+func_t func;
+
+int
+main ()
+{
+  func = callee;
+  caller (callee);
+  func ();
+  return 0;
+}
+
+/* { dg-final-use { scan-ipa-dump-times "Indirect call -> direct call" 2 "profile" } } */
+/* { dg-final-use { cleanup-ipa-dump "profile" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/ic-misattribution-1_1.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/ic-misattribution-1_1.c
new file mode 100644
index 0000000..4948ec4
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/ic-misattribution-1_1.c
@@ -0,0 +1,18 @@
+/* { dg-options "-O2 -fdump-ipa-profile" } */
+
+extern void other_caller (void);
+
+void
+callee (void)
+{
+  return;
+}
+
+void
+caller(void (*func) (void))
+{
+  func ();
+}
+
+/* { dg-final-use { scan-ipa-dump "Indiret call -> direct call"  "profile" } } */
+/* { dg-final-use { cleanup-ipa-dump "profile" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/indir-call-prof-single_0.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/indir-call-prof-single_0.c
new file mode 100644
index 0000000..29a216c
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/indir-call-prof-single_0.c
@@ -0,0 +1,43 @@
+/* { dg-options "-O2 -fdump-tree-optimized -fdump-ipa-profile" } */
+
+static int a1 (void)
+{
+    return 10;
+}
+
+static int a2 (void)
+{
+    return 0;
+}
+
+typedef int (*tp) (void);
+
+static tp aa [] = {a2, a1, a1, a1, a1};
+
+__attribute__((noinline)) void setp (int (**pp) (void), int i)
+{
+  if (!i)
+    *pp = aa [i];
+  else
+    *pp = aa [(i & 2) + 1];
+}
+
+int
+main (void)
+{
+  int (*p) (void);
+  int  i;
+
+  for (i = 0; i < 10; i ++)
+    {
+	setp (&p, i);
+	p ();
+    }
+  
+  return 0;
+}
+
+/* { dg-final-use { scan-ipa-dump "Indirect call -> direct call.* a1" "profile"} } */
+/* { dg-final-use { scan-tree-dump-not "Invalid sum" "optimized"} } */
+/* { dg-final-use { cleanup-tree-dump "optimized" } } */
+/* { dg-final-use { cleanup-ipa-dump "profile" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/indir-call-prof_0.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/indir-call-prof_0.c
new file mode 100644
index 0000000..6bd048d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/indir-call-prof_0.c
@@ -0,0 +1,23 @@
+/* { dg-options "-O2 -fdump-tree-optimized -fdump-ipa-profile" } */
+
+extern void setp (int (**pp) (void), int i);
+
+int
+main (void)
+{
+  int (*p) (void);
+  int  i;
+
+  for (i = 0; i < 10; i ++)
+    {
+	setp (&p, i);
+	p ();
+    }
+  
+  return 0;
+}
+
+/* { dg-final-use { scan-ipa-dump "Indirect call -> direct call.* a1" "profile"} } */
+/* { dg-final-use { scan-tree-dump-not "Invalid sum" "optimized"} } */
+/* { dg-final-use { cleanup-tree-dump "optimized" } } */
+/* { dg-final-use { cleanup-ipa-dump "profile" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/indir-call-prof_1.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/indir-call-prof_1.c
new file mode 100644
index 0000000..0cdb607
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/indir-call-prof_1.c
@@ -0,0 +1,23 @@
+/* { dg-options "-O2 -fdump-tree-optimized -fdump-ipa-profile" } */
+
+int a1 (void)
+{
+    return 10;
+}
+
+int a2 (void)
+{
+    return 0;
+}
+
+typedef int (*tp) (void);
+
+tp aa [] = {a2, a1, a1, a1, a1};
+
+__attribute__((noinline)) void setp (int (**pp) (void), int i)
+{
+  if (!i)
+    *pp = aa [i];
+  else
+    *pp = aa [(i & 2) + 1];
+}
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/inliner-1_0.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/inliner-1_0.c
new file mode 100644
index 0000000..a82b95d
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/inliner-1_0.c
@@ -0,0 +1,42 @@
+/* { dg-options "-O2 --param inline-hot-caller=0 -fdump-tree-optimized" } */
+int a;
+int b[100];
+void abort (void);
+
+inline void
+cold_function ()
+{
+  int i;
+  for (i = 0; i < 99; i++)
+    if (b[i] / (b[i+1] + 1))
+      abort ();
+}
+
+inline void
+hot_function ()
+{
+  int i;
+  for (i = 0; i < 99; i++)
+    if (b[i] / (b[i+1] + 1))
+      abort ();
+}
+
+main ()
+{
+  int i;
+  for (i = 0; i < 100; i++)
+    {
+      if (a)
+        cold_function ();
+      else
+        hot_function ();
+    }
+  return 0;
+}
+
+/* cold function should not be inlined, while hot function should be.
+   Look for "cold_function () [tail call];" call statement not for the
+   declaration or other apperances of the string in dump.  */
+/* { dg-final-use { scan-tree-dump "cold_function ..;" "optimized"} } */
+/* { dg-final-use { scan-tree-dump-not "hot_function ..;" "optimized"} } */
+/* { dg-final-use { cleanup-tree-dump "optimized" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/lipo.exp b/gcc/testsuite/gcc.dg/tree-prof/lipo/lipo.exp
new file mode 100644
index 0000000..26abc7f
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/lipo.exp
@@ -0,0 +1,60 @@
+# Copyright (C) 2001, 2002, 2004, 2005, 2007, 2008
+# Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# Test the functionality of programs compiled with profile-directed block
+# ordering using -fprofile-generate followed by -fbranch-use.
+
+load_lib target-supports.exp
+
+# Some targets don't support tree profiling.
+if { ![check_profiling_available ""] } {
+    return
+}
+
+# The procedures in profopt.exp need these parameters.
+set tool gcc
+set prof_ext [list {gcda} {gcda.imports} ]
+
+# Override the list defined in profopt.exp.
+set PROFOPT_OPTIONS [list {}]
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+# Load support procs.
+load_lib profopt.exp
+
+# These are globals used by profopt-execute.  The first is options
+# needed to generate profile data, the second is options to use the
+# profile data.
+set profile_option "-fprofile-generate -fripa -D_PROFILE_GENERATE"
+set feedback_option "-fprofile-use -fripa -D_PROFILE_USE"
+
+# Add -fno-section-anchors for powerpc.  Workround for Google ref b/6663281
+if {[istarget powerpc*-*-*]} {
+    set profile_option "$profile_option -fno-section-anchors"
+    set feedback_option "$feedback_option -fno-section-anchors"
+}
+
+foreach src [lsort [glob -nocomplain $srcdir/$subdir/*_0.c]] {
+    # If we're only testing specific files and this isn't one of them, skip it.
+    if ![runtest_file_p $runtests $src] then {
+        continue
+    }
+    profopt-execute $src
+}
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/lipo_inline1_0.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/lipo_inline1_0.c
new file mode 100644
index 0000000..d480809
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/lipo_inline1_0.c
@@ -0,0 +1,29 @@
+/* { dg-options "-O2 -fdump-tree-optimized-details-blocks -fdump-ipa-inline-details -fopt-info" } */
+
+extern int foo (void);
+extern int goo (void);
+
+
+int bar (void)
+{
+  return 2;
+}
+
+int g;
+int main ()
+{
+   int s = 0, i;
+
+   for (i = 0; i < 1000; i ++)
+    {
+     s += foo();  /* Should be inlined */
+     s += goo();  /* Should be inlined */
+    }
+
+   g = s;
+   return 0;
+}
+
+/* { dg-final-use { scan-tree-dump-not "foo" "optimized"} } */
+/* { dg-final-use { scan-tree-dump-not "goo" "optimized"} } */
+/* { dg-final-use { cleanup-tree-dump "optimized" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/lipo_inline1_1.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/lipo_inline1_1.c
new file mode 100644
index 0000000..9725ca7
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/lipo_inline1_1.c
@@ -0,0 +1,22 @@
+extern int bar(void);
+extern int blah(void);
+int foo (void)
+{
+  int i, s = 0;
+
+  for (i = 0; i < 2; i++)
+   {
+     s += bar();  /* Inlined */
+     s += blah(); /* Inlined */
+   }
+   return s;
+}
+
+int goo (void)
+{
+ return 10;
+}
+
+/* { dg-final-use { scan-tree-dump-not "bar" "optimized"} } */
+/* { dg-final-use { scan-tree-dump-not "blah" "optimized"} } */
+/* { dg-final-use { cleanup-tree-dump "optimized" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/lipo_inline1_2.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/lipo_inline1_2.c
new file mode 100644
index 0000000..9eeadb2
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/lipo_inline1_2.c
@@ -0,0 +1,6 @@
+int blah (void)
+{
+  return 2;
+}
+
+/* { dg-final-use { cleanup-tree-dump "optimized" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/pr34999_0.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/pr34999_0.c
new file mode 100644
index 0000000..4ec4279
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/pr34999_0.c
@@ -0,0 +1,45 @@
+/* Same test as built-in-setjmp.c.  Includes the case where
+   the source block of a crossing fallthru edge ends with a call.  */
+/* { dg-require-effective-target freorder } */
+/* { dg-options "-O2 -freorder-blocks-and-partition" } */
+
+extern int strcmp(const char *, const char *);
+extern char *strcpy(char *, const char *);
+extern void abort(void);
+extern void exit(int);
+
+void *buf[20];
+
+void __attribute__((noinline))
+sub2 (void)
+{
+  __builtin_longjmp (buf, 1);
+}
+
+int
+main ()
+{
+  char *p = (char *) __builtin_alloca (20);
+
+  strcpy (p, "test");
+
+  if (__builtin_setjmp (buf))
+    {
+      if (strcmp (p, "test") != 0)
+	abort ();
+
+      exit (0);
+    }
+
+  {
+    int *q = (int *) __builtin_alloca (p[2] * sizeof (int));
+    int i;
+    
+    for (i = 0; i < p[2]; i++)
+      q[i] = 0;
+
+    while (1)
+      sub2 ();
+  }
+}
+
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/pr45354_0.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/pr45354_0.c
new file mode 100644
index 0000000..b30ad77
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/pr45354_0.c
@@ -0,0 +1,43 @@
+/* { dg-require-effective-target freorder } */
+/* { dg-options "-O -freorder-blocks-and-partition -fschedule-insns -fselective-scheduling" { target powerpc*-*-* ia64-*-* x86_64-*-* } } */
+
+extern void abort (void);
+
+int ifelse_val2;
+
+int __attribute__((noinline))
+test_ifelse2 (int i)
+{
+  int result = 0;
+  if (!i)				/* count(6) */
+    result = 1;				/* count(1) */
+  if (i == 1)				/* count(6) */
+    result = 1024;
+  if (i == 2)				/* count(6) */
+    result = 2;				/* count(3) */
+  if (i == 3)				/* count(6) */
+    return 8;				/* count(2) */
+  if (i == 4)				/* count(4) */
+    return 2048;
+  return result;			/* count(4) */
+}
+
+void __attribute__((noinline))
+call_ifelse ()
+{
+  ifelse_val2 += test_ifelse2 (0);
+  ifelse_val2 += test_ifelse2 (2);
+  ifelse_val2 += test_ifelse2 (2);
+  ifelse_val2 += test_ifelse2 (2);
+  ifelse_val2 += test_ifelse2 (3);
+  ifelse_val2 += test_ifelse2 (3);
+}
+
+int
+main()
+{
+  call_ifelse ();
+  if (ifelse_val2 != 23)
+    abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/pr47187_0.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/pr47187_0.c
new file mode 100644
index 0000000..467ce25
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/pr47187_0.c
@@ -0,0 +1,23 @@
+/* PR bootstrap/47187 */
+/* { dg-options "-O2" } */
+
+char buf[64];
+char buf2[64];
+
+void *
+foo (char *p, long size)
+{
+  return __builtin_memcpy (buf, p, size);
+}
+
+int
+main (void)
+{
+  long i;
+  for (i = 0; i < 65536; i++)
+    if (foo ("abcdefghijkl", 12) != buf)
+      __builtin_abort ();
+  if (foo (buf2, 64) != buf)
+    __builtin_abort ();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/stringop-1_0.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/stringop-1_0.c
new file mode 100644
index 0000000..f730613
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/stringop-1_0.c
@@ -0,0 +1,22 @@
+/* { dg-options "-O2 -fdump-tree-optimized -fdump-ipa-profile" } */
+int a[1000];
+int b[1000];
+int size=1;
+int max=10000;
+main()
+{
+  int i;
+  for (i=0;i<max; i++)
+    {
+      __builtin_memcpy (a, b, size * sizeof (a[0]));
+      asm("");
+    }
+   return 0;
+}
+/* { dg-final-use { scan-ipa-dump "Single value 4 stringop" "profile"} } */
+/* Really this ought to simplify into assignment, but we are not there yet.  */
+/* a[0] = b[0] is what we fold the resulting memcpy into.  */
+/* { dg-final-use { scan-tree-dump " = MEM.*&b" "optimized"} } */
+/* { dg-final-use { scan-tree-dump "MEM.*&a\\\] = " "optimized"} } */
+/* { dg-final-use { cleanup-tree-dump "optimized" } } */
+/* { dg-final-use { cleanup-ipa-dump "profile" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/stringop-2_0.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/stringop-2_0.c
new file mode 100644
index 0000000..d5c5856
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/stringop-2_0.c
@@ -0,0 +1,20 @@
+/* { dg-options "-O2 -fdump-tree-optimized -fdump-ipa-profile" } */
+int a[1000];
+int b[1000];
+int size=1;
+int max=10000;
+main()
+{
+  int i;
+  for (i=0;i<max; i++)
+    {
+      __builtin_memset (a, 10, size * sizeof (a[0]));
+      asm("");
+    }
+   return 0;
+}
+/* { dg-final-use { scan-ipa-dump "Single value 4 stringop" "profile"} } */
+/* The versioned memset of size 4 should be optimized to an assignment.  */
+/* { dg-final-use { scan-tree-dump "a\\\[0\\\] = 168430090" "optimized"} } */
+/* { dg-final-use { cleanup-tree-dump "optimized" } } */
+/* { dg-final-use { cleanup-ipa-dump "profile" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/tracer-1_0.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/tracer-1_0.c
new file mode 100644
index 0000000..385a1a5
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/tracer-1_0.c
@@ -0,0 +1,18 @@
+/* { dg-options "-O2 -ftracer -fdump-tree-tracer" } */
+volatile int a, b, c;
+int main ()
+{
+  int i;
+  for (i = 0; i < 1000; i++)
+    {
+      if (i % 17)
+	a++;
+      else
+	b++;
+      c++;
+    }
+  return 0;
+}
+/* Superblock formation should produce two copies of the increment of c */
+/* { dg-final-generate { scan-tree-dump-times "c =" 2 "tracer" } } */
+/* { dg-final-use { cleanup-tree-dump "tracer" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/update-cunroll-2_0.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/update-cunroll-2_0.c
new file mode 100644
index 0000000..d559b92
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/update-cunroll-2_0.c
@@ -0,0 +1,21 @@
+
+/* { dg-options "-O2 -fdump-tree-optimized-blocks" } */
+int a[8];
+__attribute__ ((noinline))
+int t()
+{
+	int i;
+	for (i = 0; i < 3; i++)
+		if (a[i])
+			break;
+	return i;
+}
+main ()
+{
+  int i;
+  for (i = 0; i < 1000; i++)
+    t ();
+  return 0;
+}
+/* { dg-final-use { scan-tree-dump-not "Invalid sum" "optimized"} } */
+/* { dg-final-use { cleanup-tree-dump "optimized" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/update-loopch_0.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/update-loopch_0.c
new file mode 100644
index 0000000..e5a4e45
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/update-loopch_0.c
@@ -0,0 +1,21 @@
+/* { dg-options "-O2 -fdump-ipa-profile-blocks -fdump-tree-optimized-blocks-details" } */
+int max = 33333;
+int a[8];
+int
+main ()
+{
+  int i;
+  for (i = 0; i < max; i++)
+    {
+      a[i % 8]++;
+    }
+  return 0;
+}
+/* Loop header copying will peel away the initial conditional, so the loop body
+   is once reached directly from entry point of function, rest via loopback
+   edge.  */
+/* { dg-final-use { scan-ipa-dump "count:33333" "profile"} } */
+/* { dg-final-use { scan-tree-dump "count:33332" "optimized"} } */
+/* { dg-final-use { scan-tree-dump-not "Invalid sum" "optimized"} } */
+/* { dg-final-use { cleanup-ipa-dump "profile" } } */
+/* { dg-final-use { cleanup-tree-dump "optimized" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/update-tailcall_0.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/update-tailcall_0.c
new file mode 100644
index 0000000..2854914
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/update-tailcall_0.c
@@ -0,0 +1,20 @@
+/* { dg-options "-O2 -fdump-tree-tailc -fdump-tree-optimized" } */
+__attribute__ ((noinline))
+int factorial(int x)
+{
+   if (x == 1)
+     return 1;
+   else
+     return x*factorial(--x);
+}
+int gbl;
+int
+main()
+{
+   gbl = factorial(100);
+   return 0;
+}
+/* { dg-final-use { scan-tree-dump-not "Invalid sum" "tailc"} } */
+/* { dg-final-use { scan-tree-dump-not "Invalid sum" "optimized"} } */
+/* { dg-final-use { cleanup-tree-dump "tailc" } } */
+/* { dg-final-use { cleanup-tree-dump "optimized" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/val-prof-1_0.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/val-prof-1_0.c
new file mode 100644
index 0000000..d6f603e
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/val-prof-1_0.c
@@ -0,0 +1,22 @@
+/* { dg-options "-O2 -fdump-tree-optimized -fdump-ipa-profile" } */
+int a[1000];
+int b = 256;
+int c = 257;
+main ()
+{
+  int i;
+  int n;
+  for (i = 0; i < 1000; i++)
+    {
+      if (i % 17)
+	n = c;
+      else n = b;
+      a[i] /= n;
+    }
+  return 0;
+}
+/* { dg-final-use { scan-ipa-dump "Div.mod by constant n_\[0-9\]*=257 transformation on insn" "profile"} } */
+/* { dg-final-use { scan-tree-dump "if \\(n_\[0-9\]* != 257\\)" "optimized"} } */
+/* { dg-final-use { scan-tree-dump-not "Invalid sum" "optimized"} } */
+/* { dg-final-use { cleanup-tree-dump "optimized" } } */
+/* { dg-final-use { cleanup-ipa-dump "profile" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/val-prof-2_0.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/val-prof-2_0.c
new file mode 100644
index 0000000..1683961
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/val-prof-2_0.c
@@ -0,0 +1,32 @@
+/* { dg-options "-O2 -fdump-tree-optimized -fdump-ipa-profile" } */
+unsigned int a[1000];
+unsigned int b = 256;
+unsigned int c = 1024;
+unsigned int d = 17;
+main ()
+{
+  int i;
+  unsigned int n;
+  for (i = 0; i < 1000; i++)
+    {
+	    a[i]=100*i;
+    }
+  for (i = 0; i < 1000; i++)
+    {
+      if (i % 2)
+	n = b;
+      else if (i % 3)
+	n = c;
+      else
+	n = d;
+      a[i] %= n;
+    }
+  return 0;
+}
+/* { dg-final-use { scan-ipa-dump "Mod power of 2 transformation on insn" "profile" } } */
+/* This is part of code checking that n is power of 2, so we are sure that the transformation
+   didn't get optimized out.  */
+/* { dg-final-use { scan-tree-dump "n_\[0-9\]* \\+ (4294967295|0x0*ffffffff)" "optimized"} } */
+/* { dg-final-use { scan-tree-dump-not "Invalid sum" "optimized"} } */
+/* { dg-final-use { cleanup-tree-dump "optimized" } } */
+/* { dg-final-use { cleanup-ipa-dump "profile" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/val-prof-3_0.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/val-prof-3_0.c
new file mode 100644
index 0000000..d7b3914
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/val-prof-3_0.c
@@ -0,0 +1,32 @@
+/* { dg-options "-O2 -fdump-tree-optimized -fdump-ipa-profile" } */
+unsigned int a[1000];
+unsigned int b = 257;
+unsigned int c = 1023;
+unsigned int d = 19;
+main ()
+{
+  int i;
+  unsigned int n;
+  for (i = 0; i < 1000; i++)
+    {
+	    a[i]=18;
+    }
+  for (i = 0; i < 1000; i++)
+    {
+      if (i % 2)
+	n = b;
+      else if (i % 3)
+	n = c;
+      else
+	n = d;
+      a[i] %= n;
+    }
+  return 0;
+}
+/* { dg-final-use { scan-ipa-dump "Mod subtract transformation on insn" "profile" } } */
+/* This is part of code checking that n is greater than the divisor so we are sure that it
+   didn't get optimized out.  */
+/* { dg-final-use { scan-tree-dump "if \\(n_\[0-9\]* \\>" "optimized"} } */
+/* { dg-final-use { scan-tree-dump-not "Invalid sum" "optimized"} } */
+/* { dg-final-use { cleanup-tree-dump "optimized" } } */
+/* { dg-final-use { cleanup-ipa-dump "profile" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/val-prof-4_0.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/val-prof-4_0.c
new file mode 100644
index 0000000..239bf59
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/val-prof-4_0.c
@@ -0,0 +1,32 @@
+/* { dg-options "-O2 -fdump-tree-optimized -fdump-ipa-profile" } */
+unsigned int a[1000];
+unsigned int b = 999;
+unsigned int c = 1002;
+unsigned int d = 1003;
+main ()
+{
+  int i;
+  unsigned int n;
+  for (i = 0; i < 1000; i++)
+    {
+	    a[i]=1000+i;
+    }
+  for (i = 0; i < 1000; i++)
+    {
+      if (i % 2)
+	n = b;
+      else if (i % 3)
+	n = c;
+      else
+	n = d;
+      a[i] %= n;
+    }
+  return 0;
+}
+/* { dg-final-use { scan-ipa-dump "Mod subtract transformation on insn" "profile" } } */
+/* This is part of code checking that n is greater than the divisor so we are sure that it
+   didn't get optimized out.  */
+/* { dg-final-use { scan-tree-dump "if \\(n_\[0-9\]* \\>" "optimized"} } */
+/* { dg-final-use { scan-tree-dump-not "Invalid sum" "optimized"} } */
+/* { dg-final-use { cleanup-tree-dump "optimized" } } */
+/* { dg-final-use { cleanup-ipa-dump "profile" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/val-prof-5_0.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/val-prof-5_0.c
new file mode 100644
index 0000000..1a804a7
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/val-prof-5_0.c
@@ -0,0 +1,17 @@
+/* { dg-options "-O2 -fdump-tree-optimized -fdump-ipa-profile" } */
+int a[1000];
+int b=997;
+main()
+{
+	int i;
+	for (i = 0; i < 1000; i++)
+		if (a[i])
+			a[i]/=b;
+		else
+			a[i]/=b;
+	return 0;
+}
+/* { dg-final-use { scan-ipa-dump "Div.mod by constant b.*=997 transformation on insn" "profile" } } */
+/* { dg-final-use { scan-tree-dump-not "Invalid sum" "optimized"} } */
+/* { dg-final-use { cleanup-tree-dump "optimized" } } */
+/* { dg-final-use { cleanup-ipa-dump "profile" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/val-prof-6_0.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/val-prof-6_0.c
new file mode 100644
index 0000000..c439fcf
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/val-prof-6_0.c
@@ -0,0 +1,20 @@
+/* { dg-options "-O2 -fdump-tree-optimized" } */
+char a[1000];
+char b[1000];
+int size=1000;
+__attribute__ ((noinline))
+t(int size)
+{
+  __builtin_memcpy(a,b,size);
+}
+int
+main()
+{
+  int i;
+  for (i=0; i < size; i++)
+    t(i);
+  return 0;
+}
+/* { dg-final-use { scan-tree-dump "Average value sum:499500" "optimized"} } */
+/* { dg-final-use { scan-tree-dump "IOR value" "optimized"} } */
+/* { dg-final-use { cleanup-tree-dump "optimized" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/val-prof-7_0.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/val-prof-7_0.c
new file mode 100644
index 0000000..5f53263
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/val-prof-7_0.c
@@ -0,0 +1,26 @@
+/* { dg-options "-O2 -fdump-ipa-profile -mtune=core2" } */
+/* { dg-skip-if "" { ! { i?86-*-* x86_64-*-* } } { "*" } { "" } } */
+
+#include <strings.h>
+
+int foo(int len)
+{
+  char array[1000];
+  bzero(array, len);
+  return 0;
+}
+
+int main() {
+  int i;
+  for (i = 0; i < 1000; i++)
+    {
+      if (i > 990)
+	foo(16);
+      else
+	foo(8);
+    }
+  return 0;
+}
+
+/* { dg-final-use { scan-ipa-dump "Single value 8 stringop transformation on bzero" "profile" } } */
+/* { dg-final-use { cleanup-ipa-dump "profile" } } */
diff --git a/gcc/testsuite/gcc.dg/tree-prof/lipo/wcoverage-mismatch_0.c b/gcc/testsuite/gcc.dg/tree-prof/lipo/wcoverage-mismatch_0.c
new file mode 100644
index 0000000..e423105
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-prof/lipo/wcoverage-mismatch_0.c
@@ -0,0 +1,20 @@
+/* { dg-options "-O2 -Wno-coverage-mismatch" } */
+
+int __attribute__((noinline)) bar (void)
+{
+}
+
+int foo (int i)
+{
+#ifdef _PROFILE_USE
+  if (i)
+    bar ();
+#endif
+  return 0;
+}
+
+int main(int argc, char **argv)
+{
+  foo (argc);
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-1.c b/gcc/testsuite/gcc.dg/vect/bb-slp-1.c
index c13ee3b..11882ec 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-1.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-1.c
@@ -56,6 +56,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-10.c b/gcc/testsuite/gcc.dg/vect/bb-slp-10.c
index f127c7f..6eb8f54 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-10.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-10.c
@@ -50,6 +50,6 @@ int main (void)
 }
 
 /* { dg-final { scan-tree-dump-times "unsupported alignment in basic block." 1 "slp" { xfail vect_element_align } } } */
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" { target vect_element_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" { target vect_element_align } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-11.c b/gcc/testsuite/gcc.dg/vect/bb-slp-11.c
index 225d08e..9844788 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-11.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-11.c
@@ -48,6 +48,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" { target vect64 } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" { target vect64 } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-13.c b/gcc/testsuite/gcc.dg/vect/bb-slp-13.c
index 4e114d5..f312ea6 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-13.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-13.c
@@ -46,6 +46,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" { target vect_int_mult } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" { target vect_int_mult } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-14.c b/gcc/testsuite/gcc.dg/vect/bb-slp-14.c
index fc6b457..9a36033 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-14.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-14.c
@@ -47,6 +47,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 0 "slp"  } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 0 "slp"  } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-15.c b/gcc/testsuite/gcc.dg/vect/bb-slp-15.c
index cab46d6..842699e 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-15.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-15.c
@@ -51,6 +51,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" { target vect_int_mult } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" { target vect_int_mult } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-16.c b/gcc/testsuite/gcc.dg/vect/bb-slp-16.c
index 4390753..609dc7b 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-16.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-16.c
@@ -65,6 +65,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-17.c b/gcc/testsuite/gcc.dg/vect/bb-slp-17.c
index a64543f..5a917b8 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-17.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-17.c
@@ -57,6 +57,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" { target vect_int_mult } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" { target vect_int_mult } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-18.c b/gcc/testsuite/gcc.dg/vect/bb-slp-18.c
index 7869e32..98501cc 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-18.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-18.c
@@ -46,6 +46,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" { target vect_int_mult } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" { target vect_int_mult } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-19.c b/gcc/testsuite/gcc.dg/vect/bb-slp-19.c
index a314626..2f72612 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-19.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-19.c
@@ -53,6 +53,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp"  { xfail *-*-* }  } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp"  { xfail *-*-* }  } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-2.c b/gcc/testsuite/gcc.dg/vect/bb-slp-2.c
index 20a61a0..da228f7 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-2.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-2.c
@@ -53,6 +53,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-20.c b/gcc/testsuite/gcc.dg/vect/bb-slp-20.c
index 9991fe3..caaecb9 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-20.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-20.c
@@ -63,7 +63,7 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" { target vect_int_mult } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" { target vect_int_mult } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "slp" { target vect_int_mult } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-21.c b/gcc/testsuite/gcc.dg/vect/bb-slp-21.c
index acd3320..eba9d08 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-21.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-21.c
@@ -63,7 +63,7 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp"  } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp"  } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 1 "slp" { target { ! {vect_int_mult } } } } } */
 /* { dg-final { scan-tree-dump-times "vectorizing stmts using SLP" 2 "slp" { target vect_int_mult } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-22.c b/gcc/testsuite/gcc.dg/vect/bb-slp-22.c
index 2fa2c1b..30bc57a 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-22.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-22.c
@@ -63,7 +63,7 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp"  { target { ! {vect_int_mult } } } } } */
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 2 "slp"  { target vect_int_mult  } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp"  { target { ! {vect_int_mult } } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 2 "slp"  { target vect_int_mult  } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-23.c b/gcc/testsuite/gcc.dg/vect/bb-slp-23.c
index 1c09048..a736c38 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-23.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-23.c
@@ -51,6 +51,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" { target vect_int_mult } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" { target vect_int_mult } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-24.c b/gcc/testsuite/gcc.dg/vect/bb-slp-24.c
index cbe1cb3..10d8e40 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-24.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-24.c
@@ -54,6 +54,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" { target vect_element_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" { target vect_element_align } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
 
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-25.c b/gcc/testsuite/gcc.dg/vect/bb-slp-25.c
index 193ab9d..b92535d 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-25.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-25.c
@@ -54,6 +54,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" { target vect_element_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" { target vect_element_align } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
 
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-26.c b/gcc/testsuite/gcc.dg/vect/bb-slp-26.c
index cf8f958..f40c124 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-26.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-26.c
@@ -55,6 +55,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" { target vect64 } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" { target vect64 } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
 
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-27.c b/gcc/testsuite/gcc.dg/vect/bb-slp-27.c
index 7157eba..e9b386f 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-27.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-27.c
@@ -44,6 +44,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" { target { vect_int_mult && { vect_unpack && vect_pack_trunc } } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" { target { vect_int_mult && { vect_unpack && vect_pack_trunc } } } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
 
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-28.c b/gcc/testsuite/gcc.dg/vect/bb-slp-28.c
index 996f8f3..3dc1a0d 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-28.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-28.c
@@ -66,6 +66,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" { target { vect_int_mult &&  { vect_pack_trunc && vect_unpack } } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" { target { vect_int_mult &&  { vect_pack_trunc && vect_unpack } } } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
 
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-29.c b/gcc/testsuite/gcc.dg/vect/bb-slp-29.c
index e37b96d..c2bc391 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-29.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-29.c
@@ -54,6 +54,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp"  { target { vect_int_mult &&  vect_element_align } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp"  { target { vect_int_mult &&  vect_element_align } } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
 
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-3.c b/gcc/testsuite/gcc.dg/vect/bb-slp-3.c
index fee62d7..98cbc5b 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-3.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-3.c
@@ -42,6 +42,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-30.c b/gcc/testsuite/gcc.dg/vect/bb-slp-30.c
index 63689e34..a587780 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-30.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-30.c
@@ -43,5 +43,5 @@ test1(void)
 
 int main() { test1(); return a[21]; }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-4.c b/gcc/testsuite/gcc.dg/vect/bb-slp-4.c
index a7632f9..5b983c7 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-4.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-4.c
@@ -38,6 +38,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 0 "slp" } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 0 "slp" } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-5.c b/gcc/testsuite/gcc.dg/vect/bb-slp-5.c
index c4a8a88..cd1679e 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-5.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-5.c
@@ -47,6 +47,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-6.c b/gcc/testsuite/gcc.dg/vect/bb-slp-6.c
index 176010a..39d8c04 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-6.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-6.c
@@ -45,6 +45,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" { target vect_int_mult } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" { target vect_int_mult } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-7.c b/gcc/testsuite/gcc.dg/vect/bb-slp-7.c
index 4f82122..c0ca017 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-7.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-7.c
@@ -46,6 +46,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 0 "slp" } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 0 "slp" } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-8.c b/gcc/testsuite/gcc.dg/vect/bb-slp-8.c
index b1203f4..1cb3ddd 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-8.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-8.c
@@ -48,6 +48,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp"  { target vect_hw_misalign } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp"  { target vect_hw_misalign } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-8a.c b/gcc/testsuite/gcc.dg/vect/bb-slp-8a.c
index 2251275..9db6747 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-8a.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-8a.c
@@ -47,6 +47,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 0 "slp" } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 0 "slp" } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-8b.c b/gcc/testsuite/gcc.dg/vect/bb-slp-8b.c
index 62a691e..dc63539 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-8b.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-8b.c
@@ -49,6 +49,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp"  { target vect_hw_misalign } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp"  { target vect_hw_misalign } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-9.c b/gcc/testsuite/gcc.dg/vect/bb-slp-9.c
index 5535dee..3b95089 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-9.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-9.c
@@ -46,6 +46,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp"  { xfail  vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp"  { xfail  vect_no_align } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-cond-1.c b/gcc/testsuite/gcc.dg/vect/bb-slp-cond-1.c
index ae833e5..38c18a7 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-cond-1.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-cond-1.c
@@ -41,6 +41,6 @@ int main ()
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" { target vect_element_align } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" { target vect_element_align } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
 
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-pattern-2.c b/gcc/testsuite/gcc.dg/vect/bb-slp-pattern-2.c
index 30fa487..0d4d54f 100644
--- a/gcc/testsuite/gcc.dg/vect/bb-slp-pattern-2.c
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-pattern-2.c
@@ -48,5 +48,5 @@ int main ()
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" { target { vect_element_align && vect_pack_trunc } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" { target { vect_element_align && vect_pack_trunc } } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/fast-math-bb-slp-call-1.c b/gcc/testsuite/gcc.dg/vect/fast-math-bb-slp-call-1.c
index 7b76b44..d842658 100644
--- a/gcc/testsuite/gcc.dg/vect/fast-math-bb-slp-call-1.c
+++ b/gcc/testsuite/gcc.dg/vect/fast-math-bb-slp-call-1.c
@@ -45,5 +45,5 @@ main ()
   return main1 ();
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" { target { vect_call_copysignf && vect_call_sqrtf } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" { target { vect_call_copysignf && vect_call_sqrtf } } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/fast-math-bb-slp-call-2.c b/gcc/testsuite/gcc.dg/vect/fast-math-bb-slp-call-2.c
index bf19fcd..d6fb6a2 100644
--- a/gcc/testsuite/gcc.dg/vect/fast-math-bb-slp-call-2.c
+++ b/gcc/testsuite/gcc.dg/vect/fast-math-bb-slp-call-2.c
@@ -63,5 +63,5 @@ main ()
   return main1 ();
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 2 "slp" { target vect_call_lrint } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 2 "slp" { target vect_call_lrint } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
diff --git a/gcc/testsuite/gcc.dg/vect/no-tree-reassoc-bb-slp-12.c b/gcc/testsuite/gcc.dg/vect/no-tree-reassoc-bb-slp-12.c
index 349bf8b..b415483 100644
--- a/gcc/testsuite/gcc.dg/vect/no-tree-reassoc-bb-slp-12.c
+++ b/gcc/testsuite/gcc.dg/vect/no-tree-reassoc-bb-slp-12.c
@@ -47,6 +47,6 @@ int main (void)
   return 0;
 }
 
-/* { dg-final { scan-tree-dump-times "basic block vectorized using SLP" 1 "slp" { target vect_int_mult } } } */
+/* { dg-final { scan-tree-dump-times "Vectorized basic-block" 1 "slp" { target vect_int_mult } } } */
 /* { dg-final { cleanup-tree-dump "slp" } } */
   
diff --git a/gcc/testsuite/gcc.dg/wself-assign-1.c b/gcc/testsuite/gcc.dg/wself-assign-1.c
new file mode 100644
index 0000000..19324a6
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/wself-assign-1.c
@@ -0,0 +1,27 @@
+/* Test the self-assignemnt detection and warning.  */
+/* { dg-do compile } */
+/* { dg-options "-Wself-assign" } */
+
+struct Bar {
+  int b_;
+  int c_;
+};
+
+int g;
+
+int main()
+{
+  struct Bar *bar;
+  int x = x; /* { dg-warning "assigned to itself" } */
+  static int y;
+  struct Bar b_array[5];
+
+  b_array[x+g].b_ = b_array[x+g].b_; /* { dg-warning "assigned to itself" } */
+  g = g; /* { dg-warning "assigned to itself" } */
+  y = y; /* { dg-warning "assigned to itself" } */
+  bar->b_ = bar->b_; /* { dg-warning "assigned to itself" } */
+  x += 0; /* should not warn */
+  y -= 0; /* should not warn */
+  x /= x; /* should not warn */
+  y *= y; /* should not warn */
+}
diff --git a/gcc/testsuite/gcc.dg/wself-assign-2.c b/gcc/testsuite/gcc.dg/wself-assign-2.c
new file mode 100644
index 0000000..d0f69cb
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/wself-assign-2.c
@@ -0,0 +1,24 @@
+/* Test how self-assignment detection handles constant-folding happening */
+/*   when parsing the RHS or the initializer.  */
+/* { dg-do compile } */
+/* { dg-options "-Wself-assign" } */
+
+struct Bar {
+  int b_;
+  float c_;
+};
+
+int g;
+
+int main()
+{
+  struct Bar *bar;
+  int x = x - 0; /* should not warn */
+  static int y;
+  struct Bar b_array[5];
+
+  b_array[x+g].b_ = b_array[x+g].b_ * 1; /* should no warn */
+  g = g + 0; /* should not warn */
+  y = y / 1; /* should not warn */
+  bar->b_ = bar->b_ - 0; /* should not warn  */
+}
diff --git a/gcc/testsuite/gcc.target/i386/avx-1.c b/gcc/testsuite/gcc.target/i386/avx-1.c
index 4f40abb..7496746 100644
--- a/gcc/testsuite/gcc.target/i386/avx-1.c
+++ b/gcc/testsuite/gcc.target/i386/avx-1.c
@@ -159,6 +159,13 @@
 #define __builtin_ia32_vec_ext_v4hi(A, N) __builtin_ia32_vec_ext_v4hi(A, 0)
 #define __builtin_ia32_shufps(A, B, N) __builtin_ia32_shufps(A, B, 0)
 
+/* f16cintrin.h */
+#define __builtin_ia32_vcvtps2ph(A, I) __builtin_ia32_vcvtps2ph(A, 0)
+#define __builtin_ia32_vcvtps2ph256(A, I) __builtin_ia32_vcvtps2ph256(A, 0)
+
+/* rtmintrin.h */
+#define __builtin_ia32_xabort(I) __builtin_ia32_xabort(0)
+
 #include <wmmintrin.h>
 #include <immintrin.h>
 #include <mm3dnow.h>
diff --git a/gcc/testsuite/gcc.target/i386/avx-inline.c b/gcc/testsuite/gcc.target/i386/avx-inline.c
new file mode 100644
index 0000000..05df95e
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/avx-inline.c
@@ -0,0 +1,20 @@
+/* Check if avx target functions can inline lower target functions.   */
+/* { dg-do compile } */
+/* { dg-options "-O0 -mno-avx -mno-sse3" } */
+
+__attribute__((always_inline,target("sse3")))
+inline int callee ()
+{
+  return 0;
+}
+
+__attribute__((target("avx")))
+inline int caller ()
+{
+  return callee ();
+}
+
+int main ()
+{
+  return caller ();
+}
diff --git a/gcc/testsuite/gcc.target/i386/inline_error.c b/gcc/testsuite/gcc.target/i386/inline_error.c
new file mode 100644
index 0000000..da1cea1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/inline_error.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O0 -mno-popcnt" } */
+
+inline int __attribute__ ((__gnu_inline__, __always_inline__, target("popcnt")))
+foo () /* { dg-error "inlining failed in call to always_inline .* target specific option mismatch" } */
+{
+  return 0;
+}
+
+int bar()
+{
+  return foo (); /* { dg-error "called from here" } */
+}
diff --git a/gcc/testsuite/gcc.target/i386/intrinsics_1.c b/gcc/testsuite/gcc.target/i386/intrinsics_1.c
new file mode 100644
index 0000000..802979f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/intrinsics_1.c
@@ -0,0 +1,13 @@
+/* Test case to check if intrinsics and function specific target
+   optimizations work together.  Check by including x86intrin.h  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -msse -mno-sse4.1 -mno-sse4.2" } */
+
+#include <x86intrin.h>
+
+__attribute__((target("sse4.2")))
+__m128i foo(__m128i *V)
+{
+    return _mm_stream_load_si128(V);
+}
diff --git a/gcc/testsuite/gcc.target/i386/intrinsics_2.c b/gcc/testsuite/gcc.target/i386/intrinsics_2.c
new file mode 100644
index 0000000..329ac88
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/intrinsics_2.c
@@ -0,0 +1,13 @@
+/* Test case to check if intrinsics and function specific target
+   optimizations work together.  Check by including immintrin.h  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -msse -mno-sse4.1" } */
+
+#include <immintrin.h>
+
+__attribute__((target("sse4.2")))
+__m128i foo(__m128i *V)
+{
+    return _mm_stream_load_si128(V);
+}
diff --git a/gcc/testsuite/gcc.target/i386/intrinsics_3.c b/gcc/testsuite/gcc.target/i386/intrinsics_3.c
new file mode 100644
index 0000000..e5ea8a9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/intrinsics_3.c
@@ -0,0 +1,15 @@
+/* Test case to check if intrinsics and function specific target
+   optimizations work together.  Check if the POPCNT specific intrinsics
+   in included with popcntintrin.h get enabled by directly including
+   popcntintrin.h  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -msse -mno-sse4.1 -mno-sse4.2 -mno-popcnt" } */
+
+#include <popcntintrin.h>
+
+__attribute__((target("popcnt")))
+long long foo(unsigned long long X)
+{
+    return _mm_popcnt_u64 (X);
+}
diff --git a/gcc/testsuite/gcc.target/i386/intrinsics_4.c b/gcc/testsuite/gcc.target/i386/intrinsics_4.c
new file mode 100644
index 0000000..4e124c9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/intrinsics_4.c
@@ -0,0 +1,14 @@
+/* Test case to check if AVX intrinsics and function specific target
+   optimizations work together.  Check by including immintrin.h  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -msse -mno-avx" } */
+
+#include <immintrin.h>
+
+__m256 a[10], b[10], c[10];
+void __attribute__((target ("avx")))
+foo (void)
+{
+  a[0] = _mm256_and_ps (b[0], c[0]);
+}
diff --git a/gcc/testsuite/gcc.target/i386/intrinsics_5.c b/gcc/testsuite/gcc.target/i386/intrinsics_5.c
new file mode 100644
index 0000000..e4486b1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/intrinsics_5.c
@@ -0,0 +1,16 @@
+/* Test case to check if intrinsics and function specific target
+   optimizations work together.  Check if an error is issued in
+   -O2 mode when foo calls an intrinsic without the right target
+   attribute.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -msse -mno-sse4.1 -mno-sse4.2" } */
+
+#include <smmintrin.h>
+
+__m128i foo(__m128i *V)
+{
+    return _mm_stream_load_si128(V); /* { dg-error "called from here" } */
+}
+
+/* { dg-prune-output ".*inlining failed.*" }  */
diff --git a/gcc/testsuite/gcc.target/i386/intrinsics_6.c b/gcc/testsuite/gcc.target/i386/intrinsics_6.c
new file mode 100644
index 0000000..eea22bb
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/intrinsics_6.c
@@ -0,0 +1,16 @@
+/* Test case to check if intrinsics and function specific target
+   optimizations work together.  Check if an error is issued in
+   -O0 mode when foo calls an intrinsic without the right target
+   attribute.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O0 -msse -mno-sse4.1 -mno-sse4.2" } */
+
+#include <smmintrin.h>
+
+__m128i foo(__m128i *V)
+{
+    return _mm_stream_load_si128(V); /* { dg-error "called from here" } */
+}
+
+/* { dg-prune-output ".*inlining failed.*" }  */
diff --git a/gcc/testsuite/gcc.target/i386/patch-functions-1.c b/gcc/testsuite/gcc.target/i386/patch-functions-1.c
new file mode 100644
index 0000000..aa1f424
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/patch-functions-1.c
@@ -0,0 +1,23 @@
+/* Verify -mpatch-functions-for-instrumentation works.  */
+/* { dg-do compile } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-options "-mpatch-functions-for-instrumentation" } */
+
+/* Check nop-bytes at beginning.  */
+/* { dg-final { scan-assembler ".byte\t0xeb,0x09(.*).byte\t0x90" } } */
+/* Check nop-bytes at end.  */
+/* { dg-final { scan-assembler "ret(.*).byte\t0x90(.*).byte\t0x90" } } */
+
+__attribute__ ((noinline))
+void foo()
+{
+  /* Dummy loop.  */
+  int x = 0;
+  while (++x);
+}
+
+int main()
+{
+  foo();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/patch-functions-2.c b/gcc/testsuite/gcc.target/i386/patch-functions-2.c
new file mode 100644
index 0000000..78de867
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/patch-functions-2.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-options "-mpatch-functions-for-instrumentation -mno-patch-functions-main-always" } */
+
+/* Function is small to be instrumented with default values. Check there
+   aren't any nop-bytes at beginning or end of function.  */
+
+/* { dg-final { scan-assembler-not ".byte\t0xeb,0x09(.*).byte\t0x90" } } */
+/* { dg-final { scan-assembler-not "ret(.*).byte\t0x90(.*).byte\t0x90" } } */
+
+__attribute__ ((noinline))
+void foo()
+{
+  int x = 0;
+}
+
+int main()
+{
+  foo();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/patch-functions-3.c b/gcc/testsuite/gcc.target/i386/patch-functions-3.c
new file mode 100644
index 0000000..9e8eb52
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/patch-functions-3.c
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-options "-mpatch-functions-for-instrumentation --param function-patch-min-instructions=0" } */
+
+/* Function should have nop-bytes with -mpatch-function-min-instructions=0.
+   Check there are nop-bytes at beginning and end of function.  */
+
+/* { dg-final { scan-assembler ".byte\t0xeb,0x09(.*).byte\t0x90" } } */
+/* { dg-final { scan-assembler "ret(.*).byte\t0x90(.*).byte\t0x90" } } */
+
+__attribute__ ((noinline))
+void foo()
+{
+  int x = 0;
+}
+
+int main()
+{
+  foo();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/patch-functions-4.c b/gcc/testsuite/gcc.target/i386/patch-functions-4.c
new file mode 100644
index 0000000..7a031d7
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/patch-functions-4.c
@@ -0,0 +1,22 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-options "-mpatch-functions-for-instrumentation -mpatch-functions-ignore-loops -mno-patch-functions-main-always" } */
+
+/* Function is too small to be patched when ignoring the loop.
+   Check there aren't any nop-bytes at beginning and end of function.  */
+
+/* { dg-final { scan-assembler-not ".byte\t0xeb,0x09(.*).byte\t0x90" } } */
+/* { dg-final { scan-assembler-not "ret(.*).byte\t0x90(.*).byte\t0x90" } } */
+
+__attribute__ ((noinline))
+void foo()
+{
+  int x = 0;
+  while (++x);
+}
+
+int main()
+{
+  foo();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/patch-functions-5.c b/gcc/testsuite/gcc.target/i386/patch-functions-5.c
new file mode 100644
index 0000000..cd6a014
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/patch-functions-5.c
@@ -0,0 +1,22 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-options "-mpatch-functions-for-instrumentation -mpatch-functions-ignore-loops --param function-patch-min-instructions=0" } */
+
+/* Function should be patched with nop bytes with given options.
+   Check there are nop-bytes at beginning and end of function.  */
+
+/* { dg-final { scan-assembler ".byte\t0xeb,0x09(.*).byte\t0x90" } } */
+/* { dg-final { scan-assembler "ret(.*).byte\t0x90(.*).byte\t0x90" } } */
+
+__attribute__ ((noinline))
+void foo()
+{
+  int x = 0;
+  while (++x);
+}
+
+int main()
+{
+  foo();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/patch-functions-6.c b/gcc/testsuite/gcc.target/i386/patch-functions-6.c
new file mode 100644
index 0000000..c1d6446
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/patch-functions-6.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-options "-mpatch-functions-for-instrumentation" } */
+
+/* 'main' function should always be patched, irrespective of how small it is.
+   Check there are nop-bytes at beginning and end of main.  */
+
+/* { dg-final { scan-assembler ".byte\t0xeb,0x09(.*).byte\t0x90" } } */
+/* { dg-final { scan-assembler "ret(.*).byte\t0x90(.*).byte\t0x90" } } */
+
+int main()
+{
+  int x = 0;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/patch-functions-7.c b/gcc/testsuite/gcc.target/i386/patch-functions-7.c
new file mode 100644
index 0000000..f625298
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/patch-functions-7.c
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-options "-mpatch-functions-for-instrumentation -mno-patch-functions-main-always" } */
+
+/* 'main' shouldn't be patched with the option -mno-patch-functions-main-always.
+   Check there aren't any nop-bytes at beginning and end of main.  */
+
+/* { dg-final { scan-assembler-not ".byte\t0xeb,0x09(.*).byte\t0x90" } } */
+/* { dg-final { scan-assembler-not "ret(.*).byte\t0x90(.*).byte\t0x90" } } */
+
+int main()
+{
+  int x = 0;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/patch-functions-8.c b/gcc/testsuite/gcc.target/i386/patch-functions-8.c
new file mode 100644
index 0000000..436379c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/patch-functions-8.c
@@ -0,0 +1,29 @@
+/* Verify -mpatch-functions-for-instrumentation works.  */
+/* { dg-do run } */
+/* { dg-require-effective-target lp64 } */
+
+/* -O2 forces a sibling call for foo from bar.  */
+/* { dg-options "-O2 -mpatch-functions-for-instrumentation --param function-patch-min-instructions=0" } */
+
+__attribute__ ((noinline))
+int foo()
+{
+  /* Dummy loop.  */
+  int x = 10;
+  int y = 100;
+  while (--x)
+    ++y;
+  return y;
+}
+
+__attribute__ ((noinline))
+int bar()
+{
+  return foo();
+}
+
+int main()
+{
+  bar();
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/patch-functions-force-no-patching.c b/gcc/testsuite/gcc.target/i386/patch-functions-force-no-patching.c
new file mode 100644
index 0000000..cad6f2d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/patch-functions-force-no-patching.c
@@ -0,0 +1,27 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-options "-mpatch-functions-for-instrumentation -mno-patch-functions-main-always" } */
+
+/* Even complicated functions shouldn't get patched if they have the
+   never_patch_for_instrumentation attribute. */
+
+/* { dg-final { scan-assembler-not ".byte\t0xeb,0x09(.*).byte\t0x90" } } */
+/* { dg-final { scan-assembler-not "ret(.*).byte\t0x90(.*).byte\t0x90" } } */
+
+__attribute__ ((never_patch_for_instrumentation))
+int foo () {
+  volatile unsigned x = 0;
+  volatile unsigned y = 1;
+  x += y;
+  x *= y;
+  while (++x)
+    foo ();
+  return y;
+}
+
+
+int main ()
+{
+  int x = 0;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/patch-functions-force-patching.c b/gcc/testsuite/gcc.target/i386/patch-functions-force-patching.c
new file mode 100644
index 0000000..86ad159
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/patch-functions-force-patching.c
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-options "-O3 -mpatch-functions-for-instrumentation -mno-patch-functions-main-always" } */
+
+/* Functions which have the always_patch attribute should be patched no matter
+   what.  Check that there are nop-bytes at the beginning and end of the
+   function.  We add -O3 so that the compiler will try to inline foo (but it
+   will be blocked by the attribute).  */
+
+/* { dg-final { scan-assembler ".byte\t0xeb,0x09(.*).byte\t0x90" } } */
+/* { dg-final { scan-assembler "ret(.*).byte\t0x90(.*).byte\t0x90" } } */
+
+__attribute__ ((always_patch_for_instrumentation))
+static int foo () {
+  return 3;
+}
+
+int main () {
+  volatile int x = foo ();
+}
diff --git a/gcc/testsuite/gcc.target/i386/patch-functions-sibling-call.c b/gcc/testsuite/gcc.target/i386/patch-functions-sibling-call.c
new file mode 100644
index 0000000..847a95c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/patch-functions-sibling-call.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target lp64 } */
+/* -O2 forces a sibling call.  */
+/* { dg-options "-O2 -mpatch-functions-for-instrumentation" } */
+
+/* { dg-final { scan-assembler ".byte\t0xeb,0x09(.*).byte\t0x90" } } */
+
+/* Checks correct nop-bytes are generated just before a sibling call.  */
+/* { dg-final { scan-assembler ".byte\t0xeb,0x09(.*).byte\t0x90(.*)jmp" } } */
+
+/* Not instrumented as function has no loop and is small.  */
+__attribute__ ((noinline))
+int foo(int n)
+{
+  int x = 0;
+  return n + 10;
+}
+
+__attribute__ ((noinline))
+int bar(int n)
+{
+  /* Dummy loop.  */
+  while (--n)
+    n = n * 2;
+  return foo(n);
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr57459.c b/gcc/testsuite/gcc.target/i386/pr57459.c
new file mode 100644
index 0000000..7510114
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr57459.c
@@ -0,0 +1,60 @@
+/* PR rtl-optimization/57459 */
+/* { dg-do run } */
+/* { dg-options "-fno-inline -O2 -minline-all-stringops -fno-omit-frame-pointer" } */
+
+int total1[10], total2[10], total3[10], total4[10], total5[10], a[20];
+int len;
+
+void stackclean() {
+  void *ptr = __builtin_alloca(20000);
+  __builtin_memset(ptr, 0, 20000);
+}
+
+void foo(const char *s) {
+  int r1 = a[1];
+  int r2 = a[2];
+  int r3 = a[3];
+  int r4 = a[4];
+  int r5 = a[5];
+
+  len =  __builtin_strlen(s);
+
+  if (s != 0)
+    return;
+
+  while (r1) {
+   total1[r1] = r1;
+   r1--;
+  }
+
+  while (r2) {
+   total2[r2] = r2;
+   r2--;
+  }
+
+  while (r3) {
+   total3[r3] = r3;
+   r3--;
+  }
+
+  while (r4) {
+   total4[r4] = r4;
+   r4--;
+  }
+
+  while (r5) {
+   total5[r5] = r5;
+   r5--;
+  }
+}
+
+extern void abort (void);
+
+int main() {
+  stackclean();
+  foo("abcdefgh");
+  if (len != 8)
+    abort ();
+  return 0;
+}
+
diff --git a/gcc/testsuite/gfortran.dg/guality/guality.exp b/gcc/testsuite/gfortran.dg/guality/guality.exp
index 2444d8d..fdf899b 100644
--- a/gcc/testsuite/gfortran.dg/guality/guality.exp
+++ b/gcc/testsuite/gfortran.dg/guality/guality.exp
@@ -1,5 +1,8 @@
 # This harness is for tests that should be run at all optimisation levels.
 
+# Disable everywhere.  These tests are very flaky.
+return
+
 load_lib gfortran-dg.exp
 load_lib gcc-gdb-test.exp
 
diff --git a/gcc/testsuite/lib/gcov.exp b/gcc/testsuite/lib/gcov.exp
index 07ff2a0..1f1536b 100644
--- a/gcc/testsuite/lib/gcov.exp
+++ b/gcc/testsuite/lib/gcov.exp
@@ -70,6 +70,61 @@ proc verify-lines { testname testcase file } {
     return $failed
 }
 
+
+#
+# verify-intermediate -- check that intermediate file has certain lines
+#
+# TESTNAME is the name of the test, including unique flags.
+# TESTCASE is the name of the test.
+# FILE is the name of the gcov output file.
+#
+# Checks are very loose, they are based on certain tags being present
+# in the output. They do not check for exact expected execution
+# counts. For that the regular gcov format should be checked.
+#
+proc verify-intermediate { testname testcase file } {
+    set failed 0
+    set srcfile 0
+    set function 0
+    set lcount 0
+    set branch 0
+    set fd [open $file r]
+    while { [gets $fd line] >= 0 } {
+	if [regexp "^file:" $line] {
+	    incr srcfile
+	}
+	if [regexp "^function:(\[0-9\]+),(\[0-9\]+),.*" $line] {
+	    incr function
+	}
+	if [regexp "^lcount:(\[0-9\]+),(\[0-9\]+)" $line] {
+	    incr lcount
+	}
+	if [regexp "^branch:(\[0-9\]+),(taken|nottaken|notexec)" $line] {
+	    incr branch
+	}
+    }
+
+    # We should see at least one tag of each type
+    if {$srcfile == 0} {
+	fail "$testname expected 'file:' tag not found"
+	incr failed
+    }
+    if {$function == 0} {
+	fail "$testname expected 'function:' tag not found"
+	incr failed
+    }
+    if {$lcount == 0} {
+	fail "$testname expected 'lcount:' tag not found"
+	incr failed
+    }
+    if {$branch == 0} {
+	fail "$testname expected 'branch:' tag not found"
+	incr failed
+    }
+    return $failed
+}
+
+
 #
 # verify-branches -- check that branch percentages are as expected
 #
@@ -248,6 +303,10 @@ proc run-gcov { args } {
     set gcov_args ""
     set gcov_verify_calls 0
     set gcov_verify_branches 0
+    set gcov_verify_lines 1
+    set gcov_verify_intermediate 0
+    set gcov_execute_xfail ""
+    set gcov_verify_xfail ""
     set xfailed 0
 
     foreach a $args {
@@ -255,6 +314,11 @@ proc run-gcov { args } {
 	  set gcov_verify_calls 1
 	} elseif { $a == "branches" } {
 	  set gcov_verify_branches 1
+	} elseif { $a == "intermediate" } {
+	  set gcov_verify_intermediate 1
+	  set gcov_verify_calls 0
+	  set gcov_verify_branches 0
+	  set gcov_verify_lines 0
 	} elseif { $gcov_args == "" } {
 	    set gcov_args $a
 	} else {
@@ -295,7 +359,12 @@ proc run-gcov { args } {
     remote_upload host $testcase.gcov $testcase.gcov
 
     # Check that line execution counts are as expected.
-    set lfailed [verify-lines $testname $testcase $testcase.gcov]
+    if { $gcov_verify_lines } {
+	# Check that line execution counts are as expected.
+	set lfailed [verify-lines $testname $testcase $testcase.gcov]
+    } else {
+	set lfailed 0
+    }
 
     # If requested via the .x file, check that branch and call information
     # is correct.
@@ -309,15 +378,21 @@ proc run-gcov { args } {
     } else {
 	set cfailed 0
     }
+    if { $gcov_verify_intermediate } {
+	# Check that intermediate format has the expected format
+	set ifailed [verify-intermediate $testname $testcase $testcase.gcov]
+    } else {
+	set ifailed 0
+    }
 
     # Report whether the gcov test passed or failed.  If there were
     # multiple failures then the message is a summary.
-    set tfailed [expr $lfailed + $bfailed + $cfailed]
+    set tfailed [expr $lfailed + $bfailed + $cfailed + $ifailed]
     if { $xfailed } {
 	setup_xfail "*-*-*"
     }
     if { $tfailed > 0 } {
-	fail "$testname gcov: $lfailed failures in line counts, $bfailed in branch percentages, $cfailed in return percentages"
+	fail "$testname gcov: $lfailed failures in line counts, $bfailed in branch percentages, $cfailed in return percentages, $ifailed in intermediate format"
     } else {
 	pass "$testname gcov"
 	clean-gcov $testcase
diff --git a/gcc/testsuite/lib/profopt.exp b/gcc/testsuite/lib/profopt.exp
index cdc6b00..9f23073 100644
--- a/gcc/testsuite/lib/profopt.exp
+++ b/gcc/testsuite/lib/profopt.exp
@@ -249,6 +249,27 @@ proc profopt-execute { src } {
     set executable $tmpdir/[file tail [file rootname $src].x]
     set basename [file tail $testcase]
     set base [file rootname $basename]
+    set dir [file dirname $src]
+    # multiple file test base
+    set mbase [file rootname $basename]
+    regsub "_0" $mbase "" mbase
+    regsub "/" $mbase "" mbase
+    set src_list $src
+    set i 1
+    set done 0
+    while { !$done } {
+	set names [glob -nocomplain -types f -- "${dir}/${mbase}_${i}.*"]
+	if { [llength ${names}] > 1 } {
+	    warning "profopt-execute: more than one file matched ${dir}/${mbase}_${i}.*"
+	}
+	if { [llength ${names}] == 1 } {
+	    lappend src_list [lindex ${names} 0]
+	    incr i
+	} else {
+	    set num_srcs ${i}
+	    set done 1
+	}
+    }
 
     set count 0
     foreach option $prof_option_list {
@@ -296,7 +317,7 @@ proc profopt-execute { src } {
 	set options "$extra_options"
 	lappend options "additional_flags=$option $extra_flags $profile_option"
 	set optstr "$option $profile_option"
-	set comp_output [${tool}_target_compile "$src" "$execname1" executable $options]
+	set comp_output [${tool}_target_compile "$src_list" "$execname1" executable $options]
 	if ![${tool}_check_compile "$testcase compilation" $optstr $execname1 $comp_output] {
  	    unresolved "$testcase execution,   $optstr"
  	    unresolved "$testcase compilation, $option $feedback_option"
@@ -311,15 +332,32 @@ proc profopt-execute { src } {
 	set missing_file 0
 	# Make sure the profile data was generated, and fail if not.
 	if { $status == "pass" } {
-	    foreach ext $prof_ext {
-		remote_upload target $tmpdir/$base.$ext
-		set files [glob -nocomplain $base.$ext]
-		if { $files == "" } {
-		    set status "fail"
-		    set missing_file 1
-		    fail "$testcase execution: file $base.$ext does not exist, $option $profile_option"
-		}
-	    }
+	   set i 0
+	   if { $num_srcs > 1 } {
+	       foreach s $src_list {
+ 	           foreach ext $prof_ext {
+	               remote_upload target $tmpdir/${mbase}_${i}.$ext
+	               set files [glob -nocomplain ${mbase}_${i}.$ext]
+                       if { $files == "" } {
+                           set status "fail"
+                           set missing_file 1
+                           fail "$testcase execution: file ${mbase}_${i}.$ext does not exist, $option $profile_option"
+	               }
+	           }
+	           incr i
+	       }
+	   } else {
+ 	       foreach ext $prof_ext {
+	           remote_upload target $tmpdir/$base.$ext
+	           set files [glob -nocomplain $base.$ext]
+                   if { $files == "" } {
+                       set status "fail"
+                       set missing_file 1
+                       fail "$testcase execution: file $base.$ext does not exist, $option $profile_option"
+	           }
+               }
+	   }
+
 	}
         if { $missing_file == 0 } {
 	    $status "$testcase execution,   $optstr"
@@ -345,7 +383,7 @@ proc profopt-execute { src } {
 	set options "$extra_options"
 	lappend options "additional_flags=$option $extra_flags $feedback_option"
 	set optstr "$option $feedback_option"
-	set comp_output [${tool}_target_compile "$src" "$execname2" "executable" $options]
+	set comp_output [${tool}_target_compile "$src_list" "$execname2" "executable" $options]
 
 	# Prune warnings we know are unwanted.
 	set comp_output [prune_warnings $comp_output]
@@ -367,8 +405,18 @@ proc profopt-execute { src } {
 	}
 
 	# Remove the profiling data files.
-	foreach ext $prof_ext {
-	    remote_file target delete $tmpdir/$base.$ext
+	if { $num_srcs > 1 } {
+	   set i 0
+	    foreach s $src_list {
+		foreach ext $prof_ext {
+		    remote_file target delete $tmpdir/${mbase}_${i}.$ext
+		}
+		incr i
+	    }
+	} else {
+	    foreach ext $prof_ext {
+		remote_file target delete $tmpdir/$base.$ext
+	    }
 	}
 
 	if { $status != "pass" } {
@@ -396,7 +444,7 @@ proc profopt-execute { src } {
 	set options "$extra_options"
 	lappend options "additional_flags=$option"
 	set optstr "$option"
-	set comp_output [${tool}_target_compile "$src" "$execname3" "executable" $options]
+	set comp_output [${tool}_target_compile "$src_list" "$execname3" "executable" $options]
 	if ![${tool}_check_compile "$testcase compilation" $optstr $execname3 $comp_output] {
  	    unresolved "$testcase execution,   $optstr"
 	    unresolved "$testcase perf check,  $optstr"
diff --git a/gcc/testsuite/lib/target-supports-dg.exp b/gcc/testsuite/lib/target-supports-dg.exp
index 1b56536..d16ec1f0 100644
--- a/gcc/testsuite/lib/target-supports-dg.exp
+++ b/gcc/testsuite/lib/target-supports-dg.exp
@@ -127,6 +127,25 @@ proc dg-require-ifunc { args } {
     }
 }
 
+# If this target does not support the section exclude "e" attribute,
+# skip this test.
+
+proc dg-require-section-exclude { args } {
+    if { ![ check_section_exclude_available ] } {
+	upvar dg-do-what dg-do-what
+	set dg-do-what [list [lindex ${dg-do-what} 0] "N" "P"]
+    }
+}
+# If this target uses a linker that supports plugins and can load
+# the function reordering linker plugin.
+
+proc dg-require-linker-function-reordering-plugin {args } {
+    if { ![ check_linker_function_reordering_plugin_supported ] } {
+	upvar dg-do-what dg-do-what
+	set dg-do-what [list [lindex ${dg-do-what} 0] "N" "P"]
+    }    
+}
+
 # If this target's linker does not support the --gc-sections flag,
 # skip this test.
 
diff --git a/gcc/testsuite/lib/target-supports.exp b/gcc/testsuite/lib/target-supports.exp
index a146f17..dde8904 100644
--- a/gcc/testsuite/lib/target-supports.exp
+++ b/gcc/testsuite/lib/target-supports.exp
@@ -376,6 +376,30 @@ proc check_ifunc_available { } {
     }]
 }
 
+# Returns true if tool chain supports "e" section attribute.
+
+proc check_section_exclude_available { } {
+    return [check_runtime_nocache section_exclude_available {
+		asm(".section \".gnu.callgraph.text.main\", \"e\"");
+		int main()
+		{
+		  return 0;
+		}
+  }]
+}
+
+# If this target uses a linker that supports plugins and can load
+# the function reordering linker plugin.
+
+proc check_linker_function_reordering_plugin_supported {} {
+    return [check_runtime_nocache function_reordering_plugin_supported {
+		int main()
+		{
+		  return 0;
+		}    
+  } "-freorder-functions=callgraph"]
+}
+
 # Returns true if --gc-sections is supported on the target.
 
 proc check_gc_sections_available { } {
diff --git a/gcc/timevar.def b/gcc/timevar.def
index 44f0eac..b63d296 100644
--- a/gcc/timevar.def
+++ b/gcc/timevar.def
@@ -83,6 +83,7 @@ DEFTIMEVAR (TV_WHOPR_PARTITIONING    , "whopr partitioning")
 DEFTIMEVAR (TV_WHOPR_LTRANS          , "whopr ltrans")
 DEFTIMEVAR (TV_IPA_REFERENCE         , "ipa reference")
 DEFTIMEVAR (TV_IPA_PROFILE           , "ipa profile")
+DEFTIMEVAR (TV_IPA_AUTOFDO           , "auto profile")
 DEFTIMEVAR (TV_IPA_PURE_CONST        , "ipa pure const")
 DEFTIMEVAR (TV_IPA_PTA               , "ipa points-to")
 DEFTIMEVAR (TV_IPA_SRA               , "ipa SRA")
diff --git a/gcc/toplev.c b/gcc/toplev.c
index be81437..80e9f4b 100644
--- a/gcc/toplev.c
+++ b/gcc/toplev.c
@@ -75,6 +75,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "tree-ssa-alias.h"
 #include "plugin.h"
 #include "diagnostic-color.h"
+#include "auto-profile.h"
 
 #if defined(DBX_DEBUGGING_INFO) || defined(XCOFF_DEBUGGING_INFO)
 #include "dbxout.h"
@@ -177,6 +178,19 @@ FILE *stack_usage_file = NULL;
 
 static const char *src_pwd;
 
+/* Primary module's id (non-zero). If no module-info was read in, this will
+   be zero.  */
+
+unsigned primary_module_id = 0;
+
+/* Current module id.  */
+
+unsigned current_module_id = 0;
+
+/* Include all auxiliary modules specified in the profile. This
+   will bypass the ggc_memory limit check.  */
+bool include_all_aux = 0;
+
 /* Initialize src_pwd with the given string, and return true.  If it
    was already initialized, return false.  As a special case, it may
    be called with a NULL argument to test whether src_pwd has NOT been
@@ -560,6 +574,9 @@ compile_file (void)
   if (seen_error ())
     return;
 
+  if (flag_dyn_ipa)
+    coverage_finish ();
+
   timevar_start (TV_PHASE_LATE_ASM);
 
   /* Compilation unit is finalized.  When producing non-fat LTO object, we are
@@ -660,6 +677,10 @@ compile_file (void)
       targetm.asm_out.output_ident (ident_str);
     }
 
+  /* Auto profile finalization. */
+  if (flag_auto_profile)
+    end_auto_profile ();
+
   /* Invoke registered plugin callbacks.  */
   invoke_plugin_callbacks (PLUGIN_FINISH_UNIT, NULL);
 
@@ -1402,6 +1423,9 @@ process_options (void)
     error ("target system does not support the \"%s\" debug format",
 	   debug_type_names[write_symbols]);
 
+  if (flag_auto_profile && debug_info_level == DINFO_LEVEL_NONE)
+    debug_hooks = &auto_profile_debug_hooks;
+
   /* We know which debug output will be used so we can set flag_var_tracking
      and flag_var_tracking_uninit if the user has not specified them.  */
   if (debug_info_level < DINFO_LEVEL_NORMAL
@@ -1863,13 +1887,15 @@ do_compile (void)
 
           init_cgraph ();
           init_final (main_input_filename);
-          coverage_init (aux_base_name);
+          coverage_init (aux_base_name, main_input_filename);
           statistics_init ();
           invoke_plugin_callbacks (PLUGIN_START_UNIT, NULL);
 
           timevar_stop (TV_PHASE_SETUP);
 
           compile_file ();
+	  if (flag_record_compilation_info_in_elf)
+	    write_compilation_info_to_asm ();
         }
       else
         {
diff --git a/gcc/tree-cfg.c b/gcc/tree-cfg.c
index 28f05a5..702b43d 100644
--- a/gcc/tree-cfg.c
+++ b/gcc/tree-cfg.c
@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "tm_p.h"
 #include "basic-block.h"
 #include "flags.h"
+#include "input.h"
 #include "function.h"
 #include "ggc.h"
 #include "gimple-pretty-print.h"
@@ -39,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "value-prof.h"
 #include "pointer-set.h"
 #include "tree-inline.h"
+#include "l-ipo.h"
 #include "target.h"
 
 /* This file contains functions for building the Control Flow Graph (CFG)
@@ -95,13 +97,13 @@ static void factor_computed_gotos (void);
 
 /* Edges.  */
 static void make_edges (void);
+static void assign_discriminators (void);
 static void make_cond_expr_edges (basic_block);
 static void make_gimple_switch_edges (basic_block);
 static void make_goto_expr_edges (basic_block);
 static void make_gimple_asm_edges (basic_block);
 static unsigned int locus_map_hash (const void *);
 static int locus_map_eq (const void *, const void *);
-static void assign_discriminator (location_t, basic_block);
 static edge gimple_redirect_edge_and_branch (edge, basic_block);
 static edge gimple_try_redirect_by_replacing_jump (edge, basic_block);
 static unsigned int split_critical_edges (void);
@@ -204,6 +206,7 @@ build_gimple_cfg (gimple_seq seq)
   discriminator_per_locus = htab_create (13, locus_map_hash, locus_map_eq,
                                          free);
   make_edges ();
+  assign_discriminators ();
   cleanup_dead_labels ();
   htab_delete (discriminator_per_locus);
 }
@@ -661,11 +664,7 @@ make_edges (void)
 	fallthru = true;
 
       if (fallthru)
-        {
-	  make_edge (bb, bb->next_bb, EDGE_FALLTHRU);
-	  if (last)
-            assign_discriminator (gimple_location (last), bb->next_bb);
-	}
+	make_edge (bb, bb->next_bb, EDGE_FALLTHRU);
     }
 
   if (root_omp_region)
@@ -681,7 +680,7 @@ make_edges (void)
 static unsigned int
 locus_map_hash (const void *item)
 {
-  return ((const struct locus_discrim_map *) item)->locus;
+  return LOCATION_LINE (((const struct locus_discrim_map *) item)->locus);
 }
 
 /* Equality function for the locus-to-discriminator map.  VA and VB
@@ -692,7 +691,7 @@ locus_map_eq (const void *va, const void *vb)
 {
   const struct locus_discrim_map *a = (const struct locus_discrim_map *) va;
   const struct locus_discrim_map *b = (const struct locus_discrim_map *) vb;
-  return a->locus == b->locus;
+  return LOCATION_LINE (a->locus) == LOCATION_LINE (b->locus);
 }
 
 /* Find the next available discriminator value for LOCUS.  The
@@ -745,22 +744,65 @@ same_line_p (location_t locus1, location_t locus2)
           && filename_cmp (from.file, to.file) == 0);
 }
 
-/* Assign a unique discriminator value to block BB if it begins at the same
-   LOCUS as its predecessor block.  */
+/* Assign a unique discriminator value to instructions in block BB that
+   have the same LOCUS as its predecessor block.  */
 
 static void
 assign_discriminator (location_t locus, basic_block bb)
 {
-  gimple first_in_to_bb, last_in_to_bb;
+  gimple_stmt_iterator gsi;
+  int discriminator;
+
+  locus = map_discriminator_location (locus);
 
-  if (locus == 0 || bb->discriminator != 0)
+  if (locus == UNKNOWN_LOCATION)
     return;
 
-  first_in_to_bb = first_non_label_stmt (bb);
-  last_in_to_bb = last_stmt (bb);
-  if ((first_in_to_bb && same_line_p (locus, gimple_location (first_in_to_bb)))
-      || (last_in_to_bb && same_line_p (locus, gimple_location (last_in_to_bb))))
-    bb->discriminator = next_discriminator_for_locus (locus);
+  discriminator = next_discriminator_for_locus (locus);
+
+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+    {
+      gimple stmt = gsi_stmt (gsi);
+      location_t stmt_locus = gimple_location (stmt);
+      if (same_line_p (locus, stmt_locus))
+	gimple_set_location (stmt,
+	    location_with_discriminator (stmt_locus, discriminator));
+    }
+}
+
+/* Assign discriminators to each basic block.  */
+
+static void
+assign_discriminators (void)
+{
+  basic_block bb;
+
+  FOR_EACH_BB (bb)
+    {
+      edge e;
+      edge_iterator ei;
+      gimple last = last_stmt (bb);
+      location_t locus = last ? gimple_location (last) : UNKNOWN_LOCATION;
+
+      if (locus == UNKNOWN_LOCATION)
+	continue;
+
+      FOR_EACH_EDGE (e, ei, bb->succs)
+	{
+	  gimple first = first_non_label_stmt (e->dest);
+	  gimple last = last_stmt (e->dest);
+	  if ((first && same_line_p (locus, gimple_location (first)))
+	      || (last && same_line_p (locus, gimple_location (last))))
+	    {
+	      if (((first && has_discriminator (gimple_location (first)))
+		   || (last && has_discriminator (gimple_location (last))))
+		  && !has_discriminator (locus))
+		assign_discriminator (locus, bb);
+	      else
+		assign_discriminator (locus, e->dest);
+	    }
+	}
+    }
 }
 
 /* Create the edges for a GIMPLE_COND starting at block BB.  */
@@ -773,13 +815,10 @@ make_cond_expr_edges (basic_block bb)
   basic_block then_bb, else_bb;
   tree then_label, else_label;
   edge e;
-  location_t entry_locus;
 
   gcc_assert (entry);
   gcc_assert (gimple_code (entry) == GIMPLE_COND);
 
-  entry_locus = gimple_location (entry);
-
   /* Entry basic blocks for each component.  */
   then_label = gimple_cond_true_label (entry);
   else_label = gimple_cond_false_label (entry);
@@ -789,14 +828,10 @@ make_cond_expr_edges (basic_block bb)
   else_stmt = first_stmt (else_bb);
 
   e = make_edge (bb, then_bb, EDGE_TRUE_VALUE);
-  assign_discriminator (entry_locus, then_bb);
   e->goto_locus = gimple_location (then_stmt);
   e = make_edge (bb, else_bb, EDGE_FALSE_VALUE);
   if (e)
-    {
-      assign_discriminator (entry_locus, else_bb);
-      e->goto_locus = gimple_location (else_stmt);
-    }
+    e->goto_locus = gimple_location (else_stmt);
 
   /* We do not need the labels anymore.  */
   gimple_cond_set_true_label (entry, NULL_TREE);
@@ -916,11 +951,8 @@ static void
 make_gimple_switch_edges (basic_block bb)
 {
   gimple entry = last_stmt (bb);
-  location_t entry_locus;
   size_t i, n;
 
-  entry_locus = gimple_location (entry);
-
   n = gimple_switch_num_labels (entry);
 
   for (i = 0; i < n; ++i)
@@ -928,7 +960,6 @@ make_gimple_switch_edges (basic_block bb)
       tree lab = CASE_LABEL (gimple_switch_label (entry, i));
       basic_block label_bb = label_to_block (lab);
       make_edge (bb, label_bb, 0);
-      assign_discriminator (entry_locus, label_bb);
     }
 }
 
@@ -1003,7 +1034,6 @@ make_goto_expr_edges (basic_block bb)
       basic_block label_bb = label_to_block (dest);
       edge e = make_edge (bb, label_bb, EDGE_FALLTHRU);
       e->goto_locus = gimple_location (goto_t);
-      assign_discriminator (e->goto_locus, label_bb);
       gsi_remove (&last, true);
       return;
     }
@@ -1018,7 +1048,6 @@ static void
 make_gimple_asm_edges (basic_block bb)
 {
   gimple stmt = last_stmt (bb);
-  location_t stmt_loc = gimple_location (stmt);
   int i, n = gimple_asm_nlabels (stmt);
 
   for (i = 0; i < n; ++i)
@@ -1026,7 +1055,6 @@ make_gimple_asm_edges (basic_block bb)
       tree label = TREE_VALUE (gimple_asm_label_op (stmt, i));
       basic_block label_bb = label_to_block (label);
       make_edge (bb, label_bb, 0);
-      assign_discriminator (stmt_loc, label_bb);
     }
 }
 
@@ -1419,6 +1447,13 @@ gimple_can_merge_blocks_p (basic_block a, basic_block b)
   if (b == EXIT_BLOCK_PTR)
     return false;
 
+  /* Some functions may have long jumps but not marked
+     properly to be control flow alterring. FIXME
+     this is a kludge  */
+  if (L_IPO_COMP_MODE && profile_info
+      && b->count != a->count)
+    return false;
+
   /* If A ends by a statement causing exceptions or something similar, we
      cannot merge the blocks.  */
   stmt = last_stmt (a);
@@ -1723,6 +1758,14 @@ gimple_merge_blocks (basic_block a, basic_block b)
 	}
     }
 
+  /* When merging two BBs, if their counts are different, the larger
+     count is selected as the new bb count.  */
+  if (flag_auto_profile && a->count != b->count)
+    {
+      a->count = MAX (a->count, b->count);
+      a->frequency = MAX (a->frequency, b->frequency);
+    } 
+
   /* Merge the sequences.  */
   last = gsi_last_bb (a);
   gsi_insert_seq_after (&last, bb_seq (b), GSI_NEW_STMT);
@@ -2857,7 +2900,8 @@ verify_types_in_gimple_reference (tree expr, bool require_lvalue)
       /* Verify if the reference array element types are compatible.  */
       if (TREE_CODE (expr) == ARRAY_REF
 	  && !useless_type_conversion_p (TREE_TYPE (expr),
-					 TREE_TYPE (TREE_TYPE (op))))
+					 TREE_TYPE (TREE_TYPE (op)))
+          && !L_IPO_COMP_MODE)
 	{
 	  error ("type mismatch in array reference");
 	  debug_generic_stmt (TREE_TYPE (expr));
@@ -3072,7 +3116,8 @@ verify_gimple_call (gimple stmt)
 	 returning java.lang.Object.
 	 For now simply allow arbitrary pointer type conversions.  */
       && !(POINTER_TYPE_P (TREE_TYPE (gimple_call_lhs (stmt)))
-	   && POINTER_TYPE_P (TREE_TYPE (fntype))))
+	   && POINTER_TYPE_P (TREE_TYPE (fntype)))
+      && !L_IPO_COMP_MODE)
     {
       error ("invalid conversion in gimple call");
       debug_generic_stmt (TREE_TYPE (gimple_call_lhs (stmt)));
@@ -3803,7 +3848,9 @@ verify_gimple_assign_single (gimple stmt)
   tree rhs1_type = TREE_TYPE (rhs1);
   bool res = false;
 
-  if (!useless_type_conversion_p (lhs_type, rhs1_type))
+  if (!useless_type_conversion_p (lhs_type, rhs1_type)
+      /* Relax for LIPO. TODO add structural or name check.  */
+      && !L_IPO_COMP_MODE)
     {
       error ("non-trivial conversion at assignment");
       debug_generic_expr (lhs_type);
@@ -4045,7 +4092,8 @@ verify_gimple_return (gimple stmt)
 	  && DECL_BY_REFERENCE (SSA_NAME_VAR (op))))
     op = TREE_TYPE (op);
 
-  if (!useless_type_conversion_p (restype, TREE_TYPE (op)))
+  if (!useless_type_conversion_p (restype, TREE_TYPE (op))
+      && !L_IPO_COMP_MODE)
     {
       error ("invalid conversion in return statement");
       debug_generic_stmt (restype);
@@ -4864,7 +4912,13 @@ gimple_verify_flow_info (void)
       if (gimple_code (stmt) == GIMPLE_LABEL)
 	continue;
 
-      err |= verify_eh_edges (stmt);
+      /* FIXME: there does seem to be an overassertion in eh
+         edge verification -- triggered by -fdyn-ipa: after eh
+         cleanup, there might not be an direct edge from a BB
+         to the parent try block's catch region, but the catch
+         region is still reachable.  */ 
+      if (!flag_dyn_ipa)
+        err |= verify_eh_edges (stmt);
 
       if (is_ctrl_stmt (stmt))
 	{
diff --git a/gcc/tree-diagnostic.c b/gcc/tree-diagnostic.c
index 08866a4..fe08b61 100644
--- a/gcc/tree-diagnostic.c
+++ b/gcc/tree-diagnostic.c
@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
+#include "input.h"
 #include "tree.h"
 #include "diagnostic.h"
 #include "tree-pretty-print.h"
@@ -107,6 +108,8 @@ maybe_unwind_expanded_macro_loc (diagnostic_context *context,
   unsigned ix;
   loc_map_pair loc, *iter;
 
+  if (has_discriminator (where))
+    where = map_discriminator_location (where);
   map = linemap_lookup (line_table, where);
   if (!linemap_macro_expansion_map_p (map))
     return;
diff --git a/gcc/tree-flow.h b/gcc/tree-flow.h
index 20584b8..4622479 100644
--- a/gcc/tree-flow.h
+++ b/gcc/tree-flow.h
@@ -466,7 +466,7 @@ extern void record_vars_into (tree, tree);
 extern void record_vars (tree);
 extern bool gimple_seq_may_fallthru (gimple_seq);
 extern bool gimple_stmt_may_fallthru (gimple);
-extern bool gimple_check_call_matching_types (gimple, tree);
+extern bool gimple_check_call_matching_types (gimple, tree, bool);
 
 
 /* In tree-ssa.c  */
diff --git a/gcc/tree-inline.c b/gcc/tree-inline.c
index 5121765..ef3c9aa 100644
--- a/gcc/tree-inline.c
+++ b/gcc/tree-inline.c
@@ -47,6 +47,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "value-prof.h"
 #include "tree-pass.h"
 #include "target.h"
+#include "langhooks.h"
+#include "l-ipo.h"
 
 #include "rtl.h"	/* FIXME: For asm_str_count.  */
 
@@ -1521,7 +1523,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,
      basic_block_info automatically.  */
   copy_basic_block = create_basic_block (NULL, (void *) 0,
                                          (basic_block) prev->aux);
-  copy_basic_block->count = bb->count * count_scale / REG_BR_PROB_BASE;
+  copy_basic_block->count = (double)bb->count * count_scale / REG_BR_PROB_BASE;
 
   /* We are going to rebuild frequencies from scratch.  These values
      have just small importance to drive canonicalize_loop_headers.  */
@@ -1884,13 +1886,15 @@ copy_edges_for_bb (basic_block bb, gcov_type count_scale, basic_block ret_bb)
 	edge new_edge;
 
 	flags = old_edge->flags;
+	flags &= (~EDGE_ANNOTATED);
 
 	/* Return edges do get a FALLTHRU flag when the get inlined.  */
-	if (old_edge->dest->index == EXIT_BLOCK && !old_edge->flags
+	if (old_edge->dest->index == EXIT_BLOCK && !flags
 	    && old_edge->dest->aux != EXIT_BLOCK_PTR)
 	  flags |= EDGE_FALLTHRU;
 	new_edge = make_edge (new_bb, (basic_block) old_edge->dest->aux, flags);
-	new_edge->count = old_edge->count * count_scale / REG_BR_PROB_BASE;
+	new_edge->count
+            = old_edge->count * (double)count_scale / REG_BR_PROB_BASE;
 	new_edge->probability = old_edge->probability;
       }
 
@@ -2061,7 +2065,7 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count)
   gcov_type count_scale;
 
   if (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count)
-    count_scale = (REG_BR_PROB_BASE * count
+    count_scale = (REG_BR_PROB_BASE * (double)count
 		   / ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count);
   else
     count_scale = REG_BR_PROB_BASE;
@@ -2094,17 +2098,18 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count)
   cfun->can_delete_dead_exceptions = src_cfun->can_delete_dead_exceptions;
   cfun->returns_struct = src_cfun->returns_struct;
   cfun->returns_pcc_struct = src_cfun->returns_pcc_struct;
+  cfun->module_id = src_cfun->module_id;
 
   init_empty_tree_cfg ();
 
   profile_status_for_function (cfun) = profile_status_for_function (src_cfun);
   ENTRY_BLOCK_PTR->count =
-    (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count * count_scale /
-     REG_BR_PROB_BASE);
+    (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count * (double)count_scale /
+    REG_BR_PROB_BASE);
   ENTRY_BLOCK_PTR->frequency
     = ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->frequency;
   EXIT_BLOCK_PTR->count =
-    (EXIT_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count * count_scale /
+    (EXIT_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count * (double)count_scale /
      REG_BR_PROB_BASE);
   EXIT_BLOCK_PTR->frequency =
     EXIT_BLOCK_PTR_FOR_FUNCTION (src_cfun)->frequency;
@@ -2208,7 +2213,7 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,
   gcov_type incoming_count = 0;
 
   if (ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count)
-    count_scale = (REG_BR_PROB_BASE * count
+    count_scale = (REG_BR_PROB_BASE * (double)count
 		   / ENTRY_BLOCK_PTR_FOR_FUNCTION (src_cfun)->count);
   else
     count_scale = REG_BR_PROB_BASE;
@@ -2362,8 +2367,20 @@ copy_debug_stmt (gimple stmt, copy_body_data *id)
       gimple_debug_bind_set_var (stmt, t);
 
       if (gimple_debug_bind_has_value_p (stmt))
-	walk_tree (gimple_debug_bind_get_value_ptr (stmt),
-		   remap_gimple_op_r, &wi, NULL);
+        {
+          tree v = gimple_debug_bind_get_value (stmt);
+          if (TREE_CODE (v) == ADDR_EXPR)
+            v = TREE_OPERAND (v, 0);
+
+          /* The global var may be deleted  */
+          if (L_IPO_COMP_MODE &&
+              ((TREE_CODE (v) != VAR_DECL)
+               || is_global_var (v)))
+            processing_debug_stmt = -1;
+          else
+            walk_tree (gimple_debug_bind_get_value_ptr (stmt),
+                       remap_gimple_op_r, &wi, NULL);
+        }
 
       /* Punt if any decl couldn't be remapped.  */
       if (processing_debug_stmt < 0)
@@ -3240,8 +3257,13 @@ tree_inlinable_function_p (tree fn)
   tree always_inline;
 
   /* If we've already decided this function shouldn't be inlined,
-     there's no need to check again.  */
-  if (DECL_UNINLINABLE (fn))
+     there's no need to check again. But the cached bit from analysis
+     can be reset during decl merge in multi-module compilation (C FE only).
+     The problem is we can not really use a 2 state cached value --
+     can not tell the init state (unknown value) from a computed value.  */
+  if (DECL_UNINLINABLE (fn) 
+      && (!L_IPO_COMP_MODE
+          || lookup_attribute ("noinline", DECL_ATTRIBUTES (fn))))
     return false;
 
   /* We only warn for functions declared `inline' by the user.  */
@@ -3767,6 +3789,15 @@ add_local_variables (struct function *callee, struct function *caller,
 	  {
 	    tree tem = DECL_DEBUG_EXPR (var);
 	    bool old_regimplify = id->regimplify;
+
+            /* The mapped debug expression might be deleted
+               as a varpool node (the reachbility analysis
+               of varpool node does not check the reference
+               from debug expressions.
+               Set it to 0 for all global vars.  */
+            if (L_IPO_COMP_MODE && tem && is_global_var (tem))
+              tem = NULL;
+
 	    id->remapping_type_depth++;
 	    walk_tree (&tem, copy_tree_body_r, id, NULL);
 	    id->remapping_type_depth--;
@@ -3844,8 +3875,10 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)
 	     for inlining, but we can't do that because frontends overwrite
 	     the body.  */
 	  && !cg_edge->callee->local.redefined_extern_inline
-	  /* Avoid warnings during early inline pass. */
-	  && cgraph_global_info_ready
+	  /* During early inline pass, report only when optimization is
+	     not turned on.  */
+	  && (cgraph_global_info_ready
+	      || !optimize)
 	  /* PR 20090218-1_0.c. Body can be provided by another module. */
 	  && (reason != CIF_BODY_NOT_AVAILABLE || !flag_generate_lto))
 	{
@@ -4324,7 +4357,7 @@ optimize_inline_calls (tree fn)
 
       /* Double check that we inlined everything we are supposed to inline.  */
       for (e = id.dst_node->callees; e; e = e->next_callee)
-	gcc_assert (e->inline_failed);
+	gcc_assert (e->inline_failed || !e->call_stmt /*fake edge*/);
     }
 #endif
 
@@ -4422,7 +4455,19 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)
   else if (TREE_CODE_CLASS (code) == tcc_type)
     *walk_subtrees = 0;
   else if (TREE_CODE_CLASS (code) == tcc_declaration)
-    *walk_subtrees = 0;
+    {
+      *walk_subtrees = 0;
+      if (L_IPO_COMP_MODE
+          && (code == VAR_DECL)
+          && (TREE_STATIC (*tp) || DECL_EXTERNAL (*tp)))
+        {
+          tree resolved_decl = real_varpool_node (*tp)->symbol.decl;
+          if (resolved_decl != *tp)
+            {
+              *tp = resolved_decl;
+            }
+        }
+    }
   else if (TREE_CODE_CLASS (code) == tcc_constant)
     *walk_subtrees = 0;
   return NULL_TREE;
diff --git a/gcc/tree-optimize.c b/gcc/tree-optimize.c
index 3f69fb3..2b0615d 100644
--- a/gcc/tree-optimize.c
+++ b/gcc/tree-optimize.c
@@ -51,6 +51,7 @@ static unsigned int
 execute_cleanup_cfg_post_optimizing (void)
 {
   unsigned int todo = 0;
+
   if (cleanup_tree_cfg ())
     todo |= TODO_update_ssa;
   maybe_remove_unreachable_handlers ();
@@ -128,22 +129,22 @@ execute_fixup_cfg (void)
 
   if (ENTRY_BLOCK_PTR->count)
     count_scale = ((cgraph_get_node (current_function_decl)->count
-		    * REG_BR_PROB_BASE + ENTRY_BLOCK_PTR->count / 2)
+		    * (double) REG_BR_PROB_BASE + ENTRY_BLOCK_PTR->count / 2)
 		   / ENTRY_BLOCK_PTR->count);
   else
     count_scale = REG_BR_PROB_BASE;
 
   ENTRY_BLOCK_PTR->count = cgraph_get_node (current_function_decl)->count;
-  EXIT_BLOCK_PTR->count = (EXIT_BLOCK_PTR->count * count_scale
+  EXIT_BLOCK_PTR->count = (EXIT_BLOCK_PTR->count * (double) count_scale
   			   + REG_BR_PROB_BASE / 2) / REG_BR_PROB_BASE;
 
   FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR->succs)
-    e->count = (e->count * count_scale
+    e->count = (e->count * (double) count_scale
        + REG_BR_PROB_BASE / 2) / REG_BR_PROB_BASE;
 
   FOR_EACH_BB (bb)
     {
-      bb->count = (bb->count * count_scale
+      bb->count = (bb->count * (double) count_scale
 		   + REG_BR_PROB_BASE / 2) / REG_BR_PROB_BASE;
       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
 	{
@@ -177,7 +178,7 @@ execute_fixup_cfg (void)
 	}
 
       FOR_EACH_EDGE (e, ei, bb->succs)
-        e->count = (e->count * count_scale
+          e->count = (e->count * (double) count_scale
 		    + REG_BR_PROB_BASE / 2) / REG_BR_PROB_BASE;
 
       /* If we have a basic block with no successors that does not
diff --git a/gcc/tree-pass.h b/gcc/tree-pass.h
index 0c83921..2651cf2 100644
--- a/gcc/tree-pass.h
+++ b/gcc/tree-pass.h
@@ -268,6 +268,7 @@ extern struct gimple_opt_pass pass_lower_eh;
 extern struct gimple_opt_pass pass_lower_eh_dispatch;
 extern struct gimple_opt_pass pass_lower_resx;
 extern struct gimple_opt_pass pass_build_cfg;
+extern struct gimple_opt_pass pass_direct_call_profile;
 extern struct gimple_opt_pass pass_early_tree_profile;
 extern struct gimple_opt_pass pass_cleanup_eh;
 extern struct gimple_opt_pass pass_sra;
@@ -369,6 +370,7 @@ extern struct gimple_opt_pass pass_strength_reduction;
 extern struct simple_ipa_opt_pass pass_ipa_lower_emutls;
 extern struct simple_ipa_opt_pass pass_ipa_function_and_variable_visibility;
 extern struct simple_ipa_opt_pass pass_ipa_tree_profile;
+extern struct simple_ipa_opt_pass pass_ipa_auto_profile;
 
 extern struct simple_ipa_opt_pass pass_early_local_passes;
 
diff --git a/gcc/tree-pretty-print.c b/gcc/tree-pretty-print.c
index 1613142..4bf3daf 100644
--- a/gcc/tree-pretty-print.c
+++ b/gcc/tree-pretty-print.c
@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "dumpfile.h"
 #include "value-prof.h"
 #include "predict.h"
+#include "l-ipo.h"
 
 /* Local functions, macros and variables.  */
 static const char *op_symbol (const_tree);
@@ -466,6 +467,7 @@ static void
 dump_location (pretty_printer *buffer, location_t loc)
 {
   expanded_location xloc = expand_location (loc);
+  int discriminator = get_discriminator_from_locus (loc);
 
   pp_character (buffer, '[');
   if (xloc.file)
@@ -474,6 +476,11 @@ dump_location (pretty_printer *buffer, location_t loc)
       pp_string (buffer, " : ");
     }
   pp_decimal_int (buffer, xloc.line);
+  if (discriminator)
+    {
+      pp_string (buffer, " discrim ");
+      pp_decimal_int (buffer, discriminator);
+    }
   pp_string (buffer, "] ");
 }
 
@@ -3143,8 +3150,13 @@ dump_function_header (FILE *dump_file, tree fdecl, int flags)
   else
     aname = "<unset-asm-name>";
 
-  fprintf (dump_file, "\n;; Function %s (%s, funcdef_no=%d",
-	   dname, aname, fun->funcdef_no);
+  if (L_IPO_COMP_MODE)
+    fprintf (dump_file, "\n;; Function %s (%s, funcdef_no=%d:%d",
+             dname, aname, FUNC_DECL_MODULE_ID (fun),
+             FUNC_DECL_FUNC_ID (fun));
+  else
+    fprintf (dump_file, "\n;; Function %s (%s, funcdef_no=%d",
+             dname, aname, fun->funcdef_no + (flag_dyn_ipa? 1 : 0));
   if (!(flags & TDF_NOUID))
     fprintf (dump_file, ", decl_uid=%d", DECL_UID (fdecl));
   if (node)
diff --git a/gcc/tree-profile.c b/gcc/tree-profile.c
index 9985b40..9eb0f73 100644
--- a/gcc/tree-profile.c
+++ b/gcc/tree-profile.c
@@ -29,6 +29,9 @@ along with GCC; see the file COPYING3.  If not see
 #include "coretypes.h"
 #include "tm.h"
 #include "flags.h"
+#include "target.h"
+#include "output.h"
+#include "regs.h"
 #include "function.h"
 #include "basic-block.h"
 #include "diagnostic-core.h"
@@ -38,25 +41,51 @@ along with GCC; see the file COPYING3.  If not see
 #include "tree-pass.h"
 #include "value-prof.h"
 #include "cgraph.h"
+#include "output.h"
+#include "params.h"
+#include "profile.h"
+#include "l-ipo.h"
 #include "profile.h"
 #include "target.h"
 
+/* Default name for coverage callback function.  */
+#define COVERAGE_CALLBACK_FUNC_NAME "__coverage_callback"
+
+/* True if we insert a callback to edge instrumentation code. Avoid this
+   for the callback function itself.  */
+#define COVERAGE_INSERT_CALL ((PARAM_VALUE (PARAM_COVERAGE_CALLBACK) == 1) \
+                              && strcmp (get_name (current_function_decl), \
+                                         COVERAGE_CALLBACK_FUNC_NAME))
+
+/* Number of statements inserted for each edge counter increment.  */
+#define EDGE_COUNTER_STMT_COUNT 3
+
 static GTY(()) tree gcov_type_node;
 static GTY(()) tree tree_interval_profiler_fn;
 static GTY(()) tree tree_pow2_profiler_fn;
 static GTY(()) tree tree_one_value_profiler_fn;
 static GTY(()) tree tree_indirect_call_profiler_fn;
+static GTY(()) tree tree_indirect_call_topn_profiler_fn;
+static GTY(()) tree tree_direct_call_profiler_fn;
 static GTY(()) tree tree_average_profiler_fn;
 static GTY(()) tree tree_ior_profiler_fn;
 
 
 static GTY(()) tree ic_void_ptr_var;
 static GTY(()) tree ic_gcov_type_ptr_var;
+static GTY(()) tree dc_void_ptr_var;
+static GTY(()) tree dc_gcov_type_ptr_var;
 static GTY(()) tree ptr_void;
+static GTY(()) tree gcov_info_decl;
 
 /* Do initialization work for the edge profiler.  */
 
 /* Add code:
+   // if flag_dyn_ipa
+   extern gcov*	__gcov_indirect_call_topn_counters; // pointer to actual counter
+   extern void*	__gcov_indirect_call_topn_callee; // actual callee address
+
+   // else
    static gcov*	__gcov_indirect_call_counters; // pointer to actual counter
    static void*	__gcov_indirect_call_callee; // actual callee address
 */
@@ -67,34 +96,421 @@ init_ic_make_global_vars (void)
 
   ptr_void = build_pointer_type (void_type_node);
 
-  ic_void_ptr_var
-    = build_decl (UNKNOWN_LOCATION, VAR_DECL,
-		  get_identifier ("__gcov_indirect_call_callee"),
-		  ptr_void);
-  TREE_STATIC (ic_void_ptr_var) = 1;
-  TREE_PUBLIC (ic_void_ptr_var) = 0;
+  if (flag_dyn_ipa)
+    {
+      ic_void_ptr_var 
+	= build_decl (UNKNOWN_LOCATION, VAR_DECL, 
+		      get_identifier ("__gcov_indirect_call_topn_callee"), 
+		      ptr_void);
+      TREE_PUBLIC (ic_void_ptr_var) = 1;
+      DECL_EXTERNAL (ic_void_ptr_var) = 1;
+      if (targetm.have_tls)
+        DECL_TLS_MODEL (ic_void_ptr_var) =
+          decl_default_tls_model (ic_void_ptr_var);
+
+      gcov_type_ptr = build_pointer_type (get_gcov_type ());
+      ic_gcov_type_ptr_var 
+	= build_decl (UNKNOWN_LOCATION, VAR_DECL, 
+		      get_identifier ("__gcov_indirect_call_topn_counters"), 
+		      gcov_type_ptr);
+      TREE_PUBLIC (ic_gcov_type_ptr_var) = 1;
+      DECL_EXTERNAL (ic_gcov_type_ptr_var) = 1;
+      if (targetm.have_tls)
+        DECL_TLS_MODEL (ic_gcov_type_ptr_var) =
+          decl_default_tls_model (ic_gcov_type_ptr_var);
+    }
+  else
+    {
+      ic_void_ptr_var 
+	= build_decl (UNKNOWN_LOCATION, VAR_DECL, 
+		      get_identifier ("__gcov_indirect_call_callee"), 
+		      ptr_void);
+      TREE_STATIC (ic_void_ptr_var) = 1;
+      TREE_PUBLIC (ic_void_ptr_var) = 0;
+      DECL_INITIAL (ic_void_ptr_var) = NULL;
+      if (targetm.have_tls)
+        DECL_TLS_MODEL (ic_void_ptr_var) =
+          decl_default_tls_model (ic_void_ptr_var);
+
+      gcov_type_ptr = build_pointer_type (get_gcov_type ());
+      ic_gcov_type_ptr_var 
+	= build_decl (UNKNOWN_LOCATION, VAR_DECL, 
+		      get_identifier ("__gcov_indirect_call_counters"), 
+		      gcov_type_ptr);
+      TREE_STATIC (ic_gcov_type_ptr_var) = 1;
+      TREE_PUBLIC (ic_gcov_type_ptr_var) = 0;
+      DECL_INITIAL (ic_gcov_type_ptr_var) = NULL;
+      if (targetm.have_tls)
+        DECL_TLS_MODEL (ic_gcov_type_ptr_var) =
+          decl_default_tls_model (ic_gcov_type_ptr_var);
+    }
+
   DECL_ARTIFICIAL (ic_void_ptr_var) = 1;
-  DECL_INITIAL (ic_void_ptr_var) = NULL;
-  if (targetm.have_tls)
-    DECL_TLS_MODEL (ic_void_ptr_var) =
-      decl_default_tls_model (ic_void_ptr_var);
-
-  varpool_finalize_decl (ic_void_ptr_var);
-
-  gcov_type_ptr = build_pointer_type (get_gcov_type ());
-  ic_gcov_type_ptr_var
-    = build_decl (UNKNOWN_LOCATION, VAR_DECL,
-		  get_identifier ("__gcov_indirect_call_counters"),
-		  gcov_type_ptr);
-  TREE_STATIC (ic_gcov_type_ptr_var) = 1;
-  TREE_PUBLIC (ic_gcov_type_ptr_var) = 0;
   DECL_ARTIFICIAL (ic_gcov_type_ptr_var) = 1;
-  DECL_INITIAL (ic_gcov_type_ptr_var) = NULL;
-  if (targetm.have_tls)
-    DECL_TLS_MODEL (ic_gcov_type_ptr_var) =
-      decl_default_tls_model (ic_gcov_type_ptr_var);
+  if (!flag_dyn_ipa)
+    {
+      varpool_finalize_decl (ic_void_ptr_var);
+      varpool_finalize_decl (ic_gcov_type_ptr_var);
+    }
+}
+
+/* A pointer-set of the first statement in each block of statements that need to
+   be applied a sampling wrapper.  */
+static struct pointer_set_t *instrumentation_to_be_sampled = NULL;
+
+/* extern __thread gcov_unsigned_t __gcov_sample_counter  */
+static GTY(()) tree gcov_sample_counter_decl = NULL_TREE;
+
+/* extern gcov_unsigned_t __gcov_sampling_period  */
+static GTY(()) tree gcov_sampling_period_decl = NULL_TREE;
+
+/* extern gcov_unsigned_t __gcov_has_sampling  */
+static tree gcov_has_sampling_decl = NULL_TREE;
+
+/* extern gcov_unsigned_t __gcov_lipo_cutoff  */
+static tree GTY(()) gcov_lipo_cutoff_decl = NULL_TREE;
+
+/* extern gcov_unsigned_t __gcov_lipo_random_seed  */
+static tree GTY(()) gcov_lipo_random_seed_decl = NULL_TREE;
+
+/* extern gcov_unsigned_t __gcov_lipo_random_group_size  */
+static tree GTY(()) gcov_lipo_random_group_size_decl = NULL_TREE;
+
+/* extern gcov_unsigned_t __gcov_lipo_propagate_scale  */
+static tree GTY(()) gcov_lipo_propagate_scale_decl = NULL_TREE;
+
+/* extern gcov_unsigned_t __gcov_lipo_dump_cgraph  */
+static tree GTY(()) gcov_lipo_dump_cgraph_decl = NULL_TREE;
+
+/* extern gcov_unsigned_t __gcov_lipo_max_mem  */
+static tree GTY(()) gcov_lipo_max_mem_decl = NULL_TREE;
+
+/* extern gcov_unsigned_t __gcov_lipo_grouping_algorithm  */
+static tree GTY(()) gcov_lipo_grouping_algorithm = NULL_TREE;
+
+/* extern gcov_unsigned_t __gcov_lipo_merge_modu_edges  */
+static tree GTY(()) gcov_lipo_merge_modu_edges = NULL_TREE;
+
+/* extern gcov_unsigned_t __gcov_lipo_strict_inclusion  */
+static tree GTY(()) gcov_lipo_strict_inclusion = NULL_TREE;
+
+/* Insert STMT_IF around given sequence of consecutive statements in the
+   same basic block starting with STMT_START, ending with STMT_END.
+   PROB is the probability of the taken branch.  */
+
+static void
+insert_if_then (gimple stmt_start, gimple stmt_end, gimple stmt_if, int prob)
+{
+  gimple_stmt_iterator gsi;
+  basic_block bb_original, bb_before_if, bb_after_if;
+  edge e_if_taken, e_then_join, e_else;
+  int orig_frequency;
+
+  gsi = gsi_for_stmt (stmt_start);
+  gsi_insert_before (&gsi, stmt_if, GSI_SAME_STMT);
+  bb_original = gsi_bb (gsi);
+  e_if_taken = split_block (bb_original, stmt_if);
+  e_if_taken->flags &= ~EDGE_FALLTHRU;
+  e_if_taken->flags |= EDGE_TRUE_VALUE;
+  e_then_join = split_block (e_if_taken->dest, stmt_end);
+  bb_before_if = e_if_taken->src;
+  bb_after_if = e_then_join->dest;
+  e_else = make_edge (bb_before_if, bb_after_if, EDGE_FALSE_VALUE);
+  orig_frequency = bb_original->frequency;
+  e_if_taken->probability = prob;
+  e_else->probability = REG_BR_PROB_BASE - prob;
+  e_if_taken->dest->frequency = orig_frequency * (prob / REG_BR_PROB_BASE);
+}
+
+/* Transform:
+
+   ORIGINAL CODE
+
+   Into:
+
+   __gcov_sample_counter++;
+   if (__gcov_sample_counter >= __gcov_sampling_period)
+     {
+       __gcov_sample_counter = 0;
+       ORIGINAL CODE
+     }
+
+   The original code block starts with STMT_START, is made of STMT_COUNT
+   consecutive statements in the same basic block.  */
+
+static void
+add_sampling_wrapper (gimple stmt_start, gimple stmt_end)
+{
+  tree zero, one, tmp_var, tmp1, tmp2, tmp3;
+  gimple stmt_inc_counter1, stmt_inc_counter2, stmt_inc_counter3;
+  gimple stmt_reset_counter, stmt_assign_period, stmt_if;
+  gimple_stmt_iterator gsi;
+
+  tmp_var = create_tmp_reg (get_gcov_unsigned_t (), "PROF_sample");
+  tmp1 = make_ssa_name (tmp_var, NULL);
+  tmp2 = make_ssa_name (tmp_var, NULL);
+
+  /* Create all the new statements needed.  */
+  stmt_inc_counter1 = gimple_build_assign (tmp1, gcov_sample_counter_decl);
+  one = build_int_cst (get_gcov_unsigned_t (), 1);
+  stmt_inc_counter2 = gimple_build_assign_with_ops (
+      PLUS_EXPR, tmp2, tmp1, one);
+  stmt_inc_counter3 = gimple_build_assign (gcov_sample_counter_decl, tmp2);
+  zero = build_int_cst (get_gcov_unsigned_t (), 0);
+  stmt_reset_counter = gimple_build_assign (gcov_sample_counter_decl, zero);
+  tmp3 = make_ssa_name (tmp_var, NULL);
+  stmt_assign_period = gimple_build_assign (tmp3, gcov_sampling_period_decl);
+  stmt_if = gimple_build_cond (GE_EXPR, tmp2, tmp3, NULL_TREE, NULL_TREE);
+
+  /* Insert them for now in the original basic block.  */
+  gsi = gsi_for_stmt (stmt_start);
+  gsi_insert_before (&gsi, stmt_inc_counter1, GSI_SAME_STMT);
+  gsi_insert_before (&gsi, stmt_inc_counter2, GSI_SAME_STMT);
+  gsi_insert_before (&gsi, stmt_inc_counter3, GSI_SAME_STMT);
+  gsi_insert_before (&gsi, stmt_assign_period, GSI_SAME_STMT);
+  gsi_insert_before (&gsi, stmt_reset_counter, GSI_SAME_STMT);
+
+  /* Insert IF block.  */
+  /* Sampling rate can be changed at runtime: hard to guess the branch prob,
+     so make it 1.  */
+  insert_if_then (stmt_reset_counter, stmt_end, stmt_if, REG_BR_PROB_BASE);
+}
+
+/* Add a conditional stmt so that counter update will only exec one time.  */
+ 
+static void
+add_execonce_wrapper (gimple stmt_start, gimple stmt_end)
+{
+  tree zero, tmp_var, tmp1;
+  gimple stmt_if, stmt_assign;
+  gimple_stmt_iterator gsi;
+
+  /* Create all the new statements needed.  */
+  tmp_var = create_tmp_reg (get_gcov_type (), "PROF_temp");
+  tmp1 = make_ssa_name (tmp_var, NULL);
+  stmt_assign = gimple_build_assign (tmp1, gimple_assign_lhs (stmt_end));
+
+  zero = build_int_cst (get_gcov_type (), 0);
+  stmt_if = gimple_build_cond (EQ_EXPR, tmp1, zero, NULL_TREE, NULL_TREE);
+
+  gsi = gsi_for_stmt (stmt_start);
+  gsi_insert_before (&gsi, stmt_assign, GSI_SAME_STMT);
 
-  varpool_finalize_decl (ic_gcov_type_ptr_var);
+  /* Insert IF block.  */
+  insert_if_then (stmt_start, stmt_end, stmt_if, 1);
+}
+
+/* Return whether STMT is the beginning of an instrumentation block to be
+   applied sampling.  */
+
+static bool
+is_instrumentation_to_be_sampled (gimple stmt)
+{
+  return pointer_set_contains (instrumentation_to_be_sampled, stmt);
+}
+
+/* Add sampling wrappers around edge counter code in current function.  */
+
+void
+add_sampling_to_edge_counters (void)
+{
+  gimple_stmt_iterator gsi;
+  basic_block bb;
+
+  FOR_EACH_BB_REVERSE (bb)
+    for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi); gsi_prev (&gsi))
+      {
+        gimple stmt_end = gsi_stmt (gsi);
+        if (is_instrumentation_to_be_sampled (stmt_end))
+          {
+            gimple stmt_beg;
+            int i;
+            int edge_counter_stmt_count = EDGE_COUNTER_STMT_COUNT;
+
+            /* The code for edge counter increment has EDGE_COUNTER_STMT_COUNT
+               gimple statements. Advance that many statements to find the
+               beginning statement.  */
+            if (COVERAGE_INSERT_CALL)
+              edge_counter_stmt_count++;
+
+            for (i = 0; i < edge_counter_stmt_count - 1; i++)
+              gsi_prev (&gsi);
+            stmt_beg = gsi_stmt (gsi);
+            gcc_assert (stmt_beg);
+
+
+            if (flag_profile_generate_sampling)
+              add_sampling_wrapper (stmt_beg, stmt_end);
+            if (PARAM_VALUE (PARAM_COVERAGE_EXEC_ONCE))
+              add_execonce_wrapper (stmt_beg, stmt_end);
+
+            /* reset the iterator and continue.  */
+            gsi = gsi_last_bb (bb);
+          }
+      }
+}
+
+/* Helper function to define a variable in comdat with initialization.
+   DECL is the variable, PARAM is the parameter to set init value.  */
+
+static void
+init_comdat_decl (tree decl, int param)
+{
+  TREE_PUBLIC (decl) = 1;
+  DECL_ARTIFICIAL (decl) = 1;
+  DECL_COMDAT_GROUP (decl)
+      = DECL_ASSEMBLER_NAME (decl);
+  TREE_STATIC (decl) = 1;
+  DECL_INITIAL (decl) = build_int_cst (
+      get_gcov_unsigned_t (),
+      PARAM_VALUE (param));
+  varpool_finalize_decl (decl);
+}
+
+/* Initialization function for LIPO runtime parameters.  */
+
+void
+tree_init_dyn_ipa_parameters (void)
+{
+  if (!gcov_lipo_cutoff_decl)
+    {
+      gcov_lipo_cutoff_decl = build_decl (
+          UNKNOWN_LOCATION,
+          VAR_DECL,
+          get_identifier ("__gcov_lipo_cutoff"),
+          get_gcov_unsigned_t ());
+      init_comdat_decl (gcov_lipo_cutoff_decl, PARAM_LIPO_CUTOFF);
+      gcov_lipo_random_seed_decl = build_decl (
+          UNKNOWN_LOCATION,
+          VAR_DECL,
+          get_identifier ("__gcov_lipo_random_seed"),
+          get_gcov_unsigned_t ());
+      init_comdat_decl (gcov_lipo_random_seed_decl, PARAM_LIPO_RANDOM_SEED);
+      gcov_lipo_random_group_size_decl = build_decl (
+          UNKNOWN_LOCATION,
+          VAR_DECL,
+          get_identifier ("__gcov_lipo_random_group_size"),
+          get_gcov_unsigned_t ());
+      init_comdat_decl (gcov_lipo_random_group_size_decl, PARAM_LIPO_RANDOM_GROUP_SIZE);
+      gcov_lipo_propagate_scale_decl = build_decl (
+          UNKNOWN_LOCATION,
+          VAR_DECL,
+          get_identifier ("__gcov_lipo_propagate_scale"),
+          get_gcov_unsigned_t ());
+      init_comdat_decl (gcov_lipo_propagate_scale_decl, PARAM_LIPO_PROPAGATE_SCALE);
+      gcov_lipo_dump_cgraph_decl = build_decl (
+          UNKNOWN_LOCATION,
+          VAR_DECL,
+          get_identifier ("__gcov_lipo_dump_cgraph"),
+          get_gcov_unsigned_t ());
+      init_comdat_decl (gcov_lipo_dump_cgraph_decl, PARAM_LIPO_DUMP_CGRAPH);
+      gcov_lipo_max_mem_decl = build_decl (
+          UNKNOWN_LOCATION,
+          VAR_DECL,
+          get_identifier ("__gcov_lipo_max_mem"),
+          get_gcov_unsigned_t ());
+      init_comdat_decl (gcov_lipo_max_mem_decl, PARAM_MAX_LIPO_MEMORY);
+      gcov_lipo_grouping_algorithm = build_decl (
+          UNKNOWN_LOCATION,
+          VAR_DECL,
+          get_identifier ("__gcov_lipo_grouping_algorithm"),
+          get_gcov_unsigned_t ());
+      init_comdat_decl (gcov_lipo_grouping_algorithm,
+                        PARAM_LIPO_GROUPING_ALGORITHM);
+      gcov_lipo_merge_modu_edges = build_decl (
+          UNKNOWN_LOCATION,
+          VAR_DECL,
+          get_identifier ("__gcov_lipo_merge_modu_edges"),
+          get_gcov_unsigned_t ());
+      init_comdat_decl (gcov_lipo_merge_modu_edges,
+                        PARAM_LIPO_MERGE_MODU_EDGES);
+      gcov_lipo_strict_inclusion = build_decl (
+          UNKNOWN_LOCATION,
+          VAR_DECL,
+          get_identifier ("__gcov_lipo_weak_inclusion"),
+          get_gcov_unsigned_t ());
+      init_comdat_decl (gcov_lipo_strict_inclusion,
+                        PARAM_LIPO_WEAK_INCLUSION);
+    }
+}
+
+static void
+cleanup_instrumentation_sampling (void)
+{
+  /* Free the bitmap.  */
+  if (flag_profile_generate_sampling && instrumentation_to_be_sampled)
+    {
+      pointer_set_destroy (instrumentation_to_be_sampled);
+      instrumentation_to_be_sampled = NULL;
+    }
+}
+
+/* Initialization function for FDO sampling.  */
+
+void
+tree_init_instrumentation_sampling (void)
+{
+  if (!gcov_sampling_period_decl)
+    {
+      /* Define __gcov_sampling_period regardless of
+         -fprofile-generate-sampling. Otherwise the extern reference to
+         it from libgcov becomes unmatched.
+      */
+      gcov_sampling_period_decl = build_decl (
+          UNKNOWN_LOCATION,
+          VAR_DECL,
+          get_identifier ("__gcov_sampling_period"),
+          get_gcov_unsigned_t ());
+      TREE_PUBLIC (gcov_sampling_period_decl) = 1;
+      DECL_ARTIFICIAL (gcov_sampling_period_decl) = 1;
+      DECL_COMDAT_GROUP (gcov_sampling_period_decl)
+          = DECL_ASSEMBLER_NAME (gcov_sampling_period_decl);
+      TREE_STATIC (gcov_sampling_period_decl) = 1;
+      DECL_INITIAL (gcov_sampling_period_decl) = build_int_cst (
+          get_gcov_unsigned_t (),
+          PARAM_VALUE (PARAM_PROFILE_GENERATE_SAMPLING_PERIOD));
+      varpool_finalize_decl (gcov_sampling_period_decl);
+    }
+
+  if (!gcov_has_sampling_decl)
+    {
+      /* Initialize __gcov_has_sampling to 1 if -fprofile-generate-sampling
+         specified, 0 otherwise. Used by libgcov to determine whether
+         a request to set the sampling period makes sense.  */
+      gcov_has_sampling_decl = build_decl (
+          UNKNOWN_LOCATION,
+          VAR_DECL,
+          get_identifier ("__gcov_has_sampling"),
+          get_gcov_unsigned_t ());
+      TREE_PUBLIC (gcov_has_sampling_decl) = 1;
+      DECL_ARTIFICIAL (gcov_has_sampling_decl) = 1;
+      DECL_COMDAT_GROUP (gcov_has_sampling_decl)
+          = DECL_ASSEMBLER_NAME (gcov_has_sampling_decl);
+      TREE_STATIC (gcov_has_sampling_decl) = 1;
+      DECL_INITIAL (gcov_has_sampling_decl) = build_int_cst (
+          get_gcov_unsigned_t (),
+          flag_profile_generate_sampling ? 1 : 0);
+      varpool_finalize_decl (gcov_has_sampling_decl);
+    }
+
+  if (flag_profile_generate_sampling && !instrumentation_to_be_sampled)
+    {
+      instrumentation_to_be_sampled = pointer_set_create ();
+      gcov_sample_counter_decl = build_decl (
+          UNKNOWN_LOCATION,
+          VAR_DECL,
+          get_identifier ("__gcov_sample_counter"),
+          get_gcov_unsigned_t ());
+      TREE_PUBLIC (gcov_sample_counter_decl) = 1;
+      DECL_EXTERNAL (gcov_sample_counter_decl) = 1;
+      DECL_ARTIFICIAL (gcov_sample_counter_decl) = 1;
+      if (targetm.have_tls)
+        DECL_TLS_MODEL (gcov_sample_counter_decl) =
+            decl_default_tls_model (gcov_sample_counter_decl);
+    }
+  if (PARAM_VALUE (PARAM_COVERAGE_EXEC_ONCE)
+      && instrumentation_to_be_sampled == 0)
+    instrumentation_to_be_sampled = pointer_set_create ();
 }
 
 /* Create the type and function decls for the interface with gcov.  */
@@ -107,13 +523,24 @@ gimple_init_edge_profiler (void)
   tree one_value_profiler_fn_type;
   tree gcov_type_ptr;
   tree ic_profiler_fn_type;
+  tree ic_topn_profiler_fn_type;
+  tree dc_profiler_fn_type;
   tree average_profiler_fn_type;
 
+
   if (!gcov_type_node)
     {
+      char name_buf[32];
       gcov_type_node = get_gcov_type ();
       gcov_type_ptr = build_pointer_type (gcov_type_node);
 
+      ASM_GENERATE_INTERNAL_LABEL (name_buf, "LPBX", 0);
+      gcov_info_decl = build_decl (UNKNOWN_LOCATION, VAR_DECL,
+                                   get_identifier (name_buf),
+                                   get_gcov_unsigned_t ());
+      DECL_EXTERNAL (gcov_info_decl) = 1;
+      TREE_ADDRESSABLE (gcov_info_decl) = 1;
+
       /* void (*) (gcov_type *, gcov_type, int, unsigned)  */
       interval_profiler_fn_type
 	      = build_function_type_list (void_type_node,
@@ -145,7 +572,12 @@ gimple_init_edge_profiler (void)
 	      = build_function_type_list (void_type_node,
 					  gcov_type_ptr, gcov_type_node,
 					  NULL_TREE);
-      tree_one_value_profiler_fn
+      if (PROFILE_GEN_VALUE_ATOMIC)
+        tree_one_value_profiler_fn
+	      = build_fn_decl ("__gcov_one_value_profiler_atomic",
+				     one_value_profiler_fn_type);
+      else
+        tree_one_value_profiler_fn
 	      = build_fn_decl ("__gcov_one_value_profiler",
 				     one_value_profiler_fn_type);
       TREE_NOTHROW (tree_one_value_profiler_fn) = 1;
@@ -157,18 +589,47 @@ gimple_init_edge_profiler (void)
 
       /* void (*) (gcov_type *, gcov_type, void *, void *)  */
       ic_profiler_fn_type
-	       = build_function_type_list (void_type_node,
-					  gcov_type_ptr, gcov_type_node,
-					  ptr_void,
-					  ptr_void, NULL_TREE);
-      tree_indirect_call_profiler_fn
-	      = build_fn_decl ("__gcov_indirect_call_profiler",
-				     ic_profiler_fn_type);
+          = build_function_type_list (void_type_node,
+                                      gcov_type_ptr, gcov_type_node,
+                                      ptr_void,
+                                      ptr_void, NULL_TREE);
+      if (PROFILE_GEN_VALUE_ATOMIC)
+        tree_indirect_call_profiler_fn
+          = build_fn_decl ("__gcov_indirect_call_profiler_atomic",
+                           ic_profiler_fn_type);
+      else
+        tree_indirect_call_profiler_fn
+          = build_fn_decl ("__gcov_indirect_call_profiler",
+                           ic_profiler_fn_type);
       TREE_NOTHROW (tree_indirect_call_profiler_fn) = 1;
       DECL_ATTRIBUTES (tree_indirect_call_profiler_fn)
 	= tree_cons (get_identifier ("leaf"), NULL,
 		     DECL_ATTRIBUTES (tree_indirect_call_profiler_fn));
 
+      /* void (*) (void *, void *, gcov_unsigned_t)  */
+      ic_topn_profiler_fn_type
+	= build_function_type_list (void_type_node, ptr_void, ptr_void,
+				    get_gcov_unsigned_t (), NULL_TREE);
+      tree_indirect_call_topn_profiler_fn
+	      = build_fn_decl ("__gcov_indirect_call_topn_profiler",
+                               ic_topn_profiler_fn_type);
+      TREE_NOTHROW (tree_indirect_call_topn_profiler_fn) = 1;
+      DECL_ATTRIBUTES (tree_indirect_call_topn_profiler_fn)
+	= tree_cons (get_identifier ("leaf"), NULL,
+		     DECL_ATTRIBUTES (tree_indirect_call_topn_profiler_fn));
+
+      /* void (*) (void *, void *, gcov_unsigned_t)  */
+      dc_profiler_fn_type
+	= build_function_type_list (void_type_node, ptr_void, ptr_void,
+				    get_gcov_unsigned_t (), NULL_TREE);
+      tree_direct_call_profiler_fn
+	= build_fn_decl ("__gcov_direct_call_profiler",
+			 dc_profiler_fn_type);
+      TREE_NOTHROW (tree_direct_call_profiler_fn) = 1;
+      DECL_ATTRIBUTES (tree_direct_call_profiler_fn)
+	= tree_cons (get_identifier ("leaf"), NULL,
+		     DECL_ATTRIBUTES (tree_direct_call_profiler_fn));
+
       /* void (*) (gcov_type *, gcov_type)  */
       average_profiler_fn_type
 	      = build_function_type_list (void_type_node,
@@ -208,20 +669,70 @@ gimple_gen_edge_profiler (int edgeno, edge e)
 {
   tree ref, one, gcov_type_tmp_var;
   gimple stmt1, stmt2, stmt3;
+  bool is_atomic = PROFILE_GEN_EDGE_ATOMIC;
+
+  if (is_atomic)
+    ref = tree_coverage_counter_addr (GCOV_COUNTER_ARCS, edgeno);
+  else
+    ref = tree_coverage_counter_ref (GCOV_COUNTER_ARCS, edgeno);
 
-  ref = tree_coverage_counter_ref (GCOV_COUNTER_ARCS, edgeno);
   one = build_int_cst (gcov_type_node, 1);
-  gcov_type_tmp_var = make_temp_ssa_name (gcov_type_node,
-					  NULL, "PROF_edge_counter");
-  stmt1 = gimple_build_assign (gcov_type_tmp_var, ref);
-  gcov_type_tmp_var = make_temp_ssa_name (gcov_type_node,
-					  NULL, "PROF_edge_counter");
-  stmt2 = gimple_build_assign_with_ops (PLUS_EXPR, gcov_type_tmp_var,
-					gimple_assign_lhs (stmt1), one);
-  stmt3 = gimple_build_assign (unshare_expr (ref), gimple_assign_lhs (stmt2));
-  gsi_insert_on_edge (e, stmt1);
-  gsi_insert_on_edge (e, stmt2);
+
+  /* insert a callback stmt stmt */
+  if (COVERAGE_INSERT_CALL)
+    {
+      gimple call;
+      tree tree_edgeno = build_int_cst (gcov_type_node, edgeno);
+      tree tree_uid = build_int_cst (gcov_type_node,
+                                     current_function_funcdef_no);
+      tree callback_fn_type
+              = build_function_type_list (void_type_node,
+                                          gcov_type_node,
+                                          integer_type_node,
+                                          NULL_TREE);
+      tree tree_callback_fn = build_fn_decl (COVERAGE_CALLBACK_FUNC_NAME,
+                                             callback_fn_type);
+      TREE_NOTHROW (tree_callback_fn) = 1;
+      DECL_ATTRIBUTES (tree_callback_fn)
+        = tree_cons (get_identifier ("leaf"), NULL,
+                     DECL_ATTRIBUTES (tree_callback_fn));
+  
+      call = gimple_build_call (tree_callback_fn, 2, tree_uid, tree_edgeno);
+      gsi_insert_on_edge(e, call);
+    }
+
+  if (is_atomic)
+    {
+      /* __atomic_fetch_add (&counter, 1, MEMMODEL_RELAXED); */
+      stmt3 = gimple_build_call (builtin_decl_explicit (
+                                   GCOV_TYPE_ATOMIC_FETCH_ADD),
+                                 3, ref, one,
+                                 build_int_cst (integer_type_node,
+                                   MEMMODEL_RELAXED));
+    }
+  else
+    {
+      gcov_type_tmp_var = make_temp_ssa_name (gcov_type_node,
+            				  NULL, "PROF_edge_counter");
+      stmt1 = gimple_build_assign (gcov_type_tmp_var, ref);
+      gcov_type_tmp_var = make_temp_ssa_name (gcov_type_node,
+            				  NULL, "PROF_edge_counter");
+      stmt2 = gimple_build_assign_with_ops (PLUS_EXPR, gcov_type_tmp_var,
+            				gimple_assign_lhs (stmt1), one);
+      stmt3 = gimple_build_assign (unshare_expr (ref), gimple_assign_lhs (stmt2));
+   }
+
+  if (flag_profile_generate_sampling
+      || PARAM_VALUE (PARAM_COVERAGE_EXEC_ONCE))
+    pointer_set_insert (instrumentation_to_be_sampled, stmt3);
+
+  if (!is_atomic)
+    {
+      gsi_insert_on_edge (e, stmt1);
+      gsi_insert_on_edge (e, stmt2);
+    }
   gsi_insert_on_edge (e, stmt3);
+
 }
 
 /* Emits code to get VALUE to instrument at GSI, and returns the
@@ -316,10 +827,13 @@ gimple_gen_ic_profiler (histogram_value value, unsigned tag, unsigned base)
 {
   tree tmp1;
   gimple stmt1, stmt2, stmt3;
-  gimple stmt = value->hvalue.stmt;
-  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);
-  tree ref_ptr = tree_coverage_counter_addr (tag, base);
+  gimple stmt;
+  gimple_stmt_iterator gsi;
+  tree ref_ptr;
 
+  stmt = value->hvalue.stmt;
+  gsi = gsi_for_stmt (stmt);
+  ref_ptr = tree_coverage_counter_addr (tag, base);
   ref_ptr = force_gimple_operand_gsi (&gsi, ref_ptr,
 				      true, NULL_TREE, true, GSI_SAME_STMT);
 
@@ -349,7 +863,7 @@ gimple_gen_ic_profiler (histogram_value value, unsigned tag, unsigned base)
 void
 gimple_gen_ic_func_profiler (void)
 {
-  struct cgraph_node * c_node = cgraph_get_node (current_function_decl);
+  struct cgraph_node * c_node = cgraph_get_create_node (current_function_decl);
   gimple_stmt_iterator gsi;
   gimple stmt1, stmt2;
   tree tree_uid, cur_func, counter_ptr, ptr_var, void0;
@@ -392,6 +906,105 @@ gimple_gen_ic_func_profiler (void)
   gsi_insert_before (&gsi, stmt2, GSI_SAME_STMT);
 }
 
+/* Output instructions as GIMPLE trees for code to find the most
+   common called function in indirect call. Insert instructions at the
+   beginning of every possible called function.
+  */
+
+static void
+gimple_gen_ic_func_topn_profiler (void)
+{
+  gimple_stmt_iterator gsi;
+  gimple stmt1;
+  tree cur_func, gcov_info, cur_func_id;
+
+  if (DECL_STATIC_CONSTRUCTOR (current_function_decl)
+      || DECL_STATIC_CONSTRUCTOR (current_function_decl)
+      || DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (current_function_decl))
+    return;
+
+  gimple_init_edge_profiler ();
+
+  gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR));
+
+  cur_func = force_gimple_operand_gsi (&gsi,
+				       build_addr (current_function_decl,
+						   current_function_decl),
+				       true, NULL_TREE,
+				       true, GSI_SAME_STMT);
+  gcov_info = build_fold_addr_expr (gcov_info_decl);
+  cur_func_id = build_int_cst (get_gcov_unsigned_t (),
+			       FUNC_DECL_FUNC_ID (cfun));
+  stmt1 = gimple_build_call (tree_indirect_call_topn_profiler_fn,
+			     3, cur_func, gcov_info, cur_func_id);
+  gsi_insert_before (&gsi, stmt1, GSI_SAME_STMT);
+}
+
+
+/* Output instructions as GIMPLE trees for code to find the number of
+   calls at each direct call site.
+   BASE is offset of the counter position, CALL_STMT is the direct call
+   whose call-count is profiled.  */
+
+static void
+gimple_gen_dc_profiler (unsigned base, gimple call_stmt)
+{
+  gimple stmt1, stmt2, stmt3;
+  gimple_stmt_iterator gsi = gsi_for_stmt (call_stmt);
+  tree tmp1, tmp2, tmp3, callee = gimple_call_fn (call_stmt);
+
+  /* Insert code:
+     __gcov_direct_call_counters = get_relevant_counter_ptr ();
+     __gcov_callee = (void *) callee;
+   */
+  tmp1 = tree_coverage_counter_addr (GCOV_COUNTER_DIRECT_CALL, base);
+  tmp1 = force_gimple_operand_gsi (&gsi, tmp1, true, NULL_TREE,
+				   true, GSI_SAME_STMT);
+  stmt1 = gimple_build_assign (dc_gcov_type_ptr_var, tmp1);
+  tmp2 = create_tmp_var (ptr_void, "PROF_dc");
+  stmt2 = gimple_build_assign (tmp2, unshare_expr (callee));
+  tmp3 = make_ssa_name (tmp2, stmt2);
+  gimple_assign_set_lhs (stmt2, tmp3);
+  stmt3 = gimple_build_assign (dc_void_ptr_var, tmp3);
+  gsi_insert_before (&gsi, stmt1, GSI_SAME_STMT);
+  gsi_insert_before (&gsi, stmt2, GSI_SAME_STMT);
+  gsi_insert_before (&gsi, stmt3, GSI_SAME_STMT);
+}
+
+
+/* Output instructions as GIMPLE trees for code to find the number of
+   calls at each direct call site. Insert instructions at the beginning of
+   every possible called function.  */
+
+static void
+gimple_gen_dc_func_profiler (void)
+{
+  gimple_stmt_iterator gsi;
+  gimple stmt1;
+  tree cur_func, gcov_info, cur_func_id;
+
+  if (DECL_STATIC_CONSTRUCTOR (current_function_decl) 
+      || DECL_STATIC_CONSTRUCTOR (current_function_decl)
+      || DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (current_function_decl))
+    return;
+
+  gimple_init_edge_profiler ();
+
+  gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR));
+
+  cur_func = force_gimple_operand_gsi (&gsi,
+				       build_addr (current_function_decl,
+						   current_function_decl),
+				       true, NULL_TREE,
+				       true, GSI_SAME_STMT);
+  gcov_info = build_fold_addr_expr (gcov_info_decl);
+  cur_func_id = build_int_cst (get_gcov_unsigned_t (),
+			       FUNC_DECL_FUNC_ID (cfun));
+  stmt1 = gimple_build_call (tree_direct_call_profiler_fn, 3, cur_func,
+			     gcov_info, cur_func_id);
+  gsi_insert_before (&gsi, stmt1, GSI_SAME_STMT);
+}
+
 /* Output instructions as GIMPLE trees for code to find the most common value
    of a difference between two evaluations of an expression.
    VALUE is the expression whose value is profiled.  TAG is the tag of the
@@ -461,6 +1074,16 @@ tree_profiling (void)
      cgraphunit.c:ipa_passes().  */
   gcc_assert (cgraph_state == CGRAPH_STATE_IPA_SSA);
 
+  /* After value profile transformation, artificial edges (that keep
+     function body from being deleted) won't be needed.  */
+
+  cgraph_pre_profiling_inlining_done = true;
+  cgraph_process_module_scope_statics ();
+  /* Now perform link to allow cross module inlining.  */
+  cgraph_do_link ();
+  varpool_do_link ();
+  cgraph_unify_type_alias_sets ();
+
   init_node_map();
 
   FOR_EACH_DEFINED_FUNCTION (node)
@@ -481,7 +1104,8 @@ tree_profiling (void)
       branch_prob ();
 
       if (! flag_branch_probabilities
-	  && flag_profile_values)
+	  && flag_profile_values
+	  && !flag_dyn_ipa)
 	gimple_gen_ic_func_profiler ();
 
       if (flag_branch_probabilities
@@ -544,10 +1168,106 @@ tree_profiling (void)
 
       rebuild_cgraph_edges ();
 
+      /* Call graph build may change call statements which impacts
+         CFG (e.g. eh) and SSA (e.g. NORETURN and virtual operands)  */
+      if (L_IPO_COMP_MODE)
+        {
+          update_ssa (TODO_update_ssa);
+          if (execute_fixup_cfg () & TODO_cleanup_cfg)
+             cleanup_tree_cfg ();
+        }
       pop_cfun ();
     }
 
   del_node_map();
+  cleanup_instrumentation_sampling();
+  return 0;
+}
+
+/* Return true if tree-based direct-call profiling is in effect, else false.  */
+
+static bool
+do_direct_call_profiling (void)
+{
+  return !flag_branch_probabilities
+    && (profile_arc_flag || flag_test_coverage)
+    && flag_dyn_ipa;
+}
+
+/* Instrument current function to collect direct call profile information.  */
+
+static unsigned int
+direct_call_profiling (void)
+{
+  basic_block bb;
+  gimple_stmt_iterator gsi;
+
+  /* Add code:
+     extern gcov* __gcov_direct_call_counters; // pointer to actual counter
+     extern void* __gcov_direct_call_callee;   // actual callee address
+  */
+  if (!dc_gcov_type_ptr_var)
+    {
+      dc_gcov_type_ptr_var
+	= build_decl (UNKNOWN_LOCATION, VAR_DECL,
+		      get_identifier ("__gcov_direct_call_counters"),
+		      build_pointer_type (gcov_type_node));
+      DECL_ARTIFICIAL (dc_gcov_type_ptr_var) = 1;
+      DECL_EXTERNAL (dc_gcov_type_ptr_var) = 1;
+      DECL_TLS_MODEL (dc_gcov_type_ptr_var) =
+	decl_default_tls_model (dc_gcov_type_ptr_var);
+
+      dc_void_ptr_var =
+	build_decl (UNKNOWN_LOCATION, VAR_DECL,
+	            get_identifier ("__gcov_direct_call_callee"),
+		    ptr_void);
+      DECL_ARTIFICIAL (dc_void_ptr_var) = 1;
+      DECL_EXTERNAL (dc_void_ptr_var) = 1;
+      DECL_TLS_MODEL (dc_void_ptr_var) =
+	decl_default_tls_model (dc_void_ptr_var);
+    }
+
+  if (!DECL_STATIC_CONSTRUCTOR (current_function_decl))
+    {
+      FOR_EACH_BB (bb)
+	for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+	  {
+	    gimple stmt = gsi_stmt (gsi);
+	    /* Check if this is a direct call, and not a builtin call.  */
+	    if (gimple_code (stmt) != GIMPLE_CALL
+		|| gimple_call_fndecl (stmt) == NULL_TREE
+		|| DECL_BUILT_IN (gimple_call_fndecl (stmt))
+		|| DECL_IS_BUILTIN (gimple_call_fndecl (stmt)))
+	      continue;
+
+            if (PARAM_VALUE (PARAM_LIPO_SKIP_SPECIAL_SECTIONS))
+            {
+              tree callee = gimple_call_fndecl (stmt);
+              if (DECL_IS_MALLOC (callee)
+                  || DECL_IS_OPERATOR_NEW (callee)
+                  || (DECL_ASSEMBLER_NAME_SET_P (callee)
+                      && (!strcmp (IDENTIFIER_POINTER (
+                          DECL_ASSEMBLER_NAME (callee)), "_ZdlPv")
+                          || !strcmp (IDENTIFIER_POINTER (
+                              DECL_ASSEMBLER_NAME (callee)), "_ZdaPv"))))
+                continue;
+            }
+
+	    if (!coverage_counter_alloc (GCOV_COUNTER_DIRECT_CALL, 2))
+	      continue;
+	    gimple_gen_dc_profiler (0, stmt);
+	  }
+      coverage_dc_end_function ();
+    }
+
+  if (coverage_function_present (FUNC_DECL_FUNC_ID (cfun)))
+    {
+      gimple_gen_dc_func_profiler ();
+      if (! flag_branch_probabilities
+          && flag_profile_values)
+        gimple_gen_ic_func_topn_profiler ();
+    }
+
   return 0;
 }
 
@@ -556,7 +1276,7 @@ tree_profiling (void)
 static bool
 gate_tree_profile_ipa (void)
 {
-  return (!in_lto_p
+  return (!in_lto_p && !flag_auto_profile
 	  && (flag_branch_probabilities || flag_test_coverage
 	      || profile_arc_flag));
 }
@@ -581,4 +1301,24 @@ struct simple_ipa_opt_pass pass_ipa_tree_profile =
  }
 };
 
+struct gimple_opt_pass pass_direct_call_profile =
+{
+ {
+  GIMPLE_PASS,
+  "dc_profile",				/* name */
+  OPTGROUP_NONE,                        /* optinfo_flags */
+  do_direct_call_profiling,		/* gate */
+  direct_call_profiling,		/* execute */
+  NULL,					/* sub */
+  NULL,					/* next */
+  0,					/* static_pass_number */
+  TV_BRANCH_PROB,			/* tv_id */
+  PROP_ssa | PROP_cfg,			/* properties_required */
+  0,					/* properties_provided */
+  0,					/* properties_destroyed */
+  0,					/* todo_flags_start */
+  TODO_update_ssa                      	/* todo_flags_finish */
+ }
+};
+
 #include "gt-tree-profile.h"
diff --git a/gcc/tree-sra.c b/gcc/tree-sra.c
index bb04fd7..29fb117 100644
--- a/gcc/tree-sra.c
+++ b/gcc/tree-sra.c
@@ -84,11 +84,13 @@ along with GCC; see the file COPYING3.  If not see
 #include "ipa-prop.h"
 #include "statistics.h"
 #include "params.h"
+#include "toplev.h"
 #include "target.h"
 #include "flags.h"
 #include "dbgcnt.h"
 #include "tree-inline.h"
 #include "gimple-pretty-print.h"
+#include "l-ipo.h"
 #include "ipa-inline.h"
 
 /* Enumeration of all aggregate reductions we can do.  */
@@ -4754,7 +4756,8 @@ convert_callers_for_node (struct cgraph_node *node,
 		 xstrdup (cgraph_node_name (cs->caller)),
 		 xstrdup (cgraph_node_name (cs->callee)));
 
-      ipa_modify_call_arguments (cs, cs->call_stmt, *adjustments);
+      if (cs->call_stmt)
+        ipa_modify_call_arguments (cs, cs->call_stmt, *adjustments);
 
       pop_cfun ();
     }
@@ -4831,6 +4834,7 @@ modify_function (struct cgraph_node *node, ipa_parm_adjustment_vec adjustments)
   sra_ipa_reset_debug_stmts (adjustments);
   convert_callers (new_node, node->symbol.decl, adjustments);
   cgraph_make_node_local (new_node);
+
   return cfg_changed;
 }
 
@@ -4983,7 +4987,7 @@ ipa_early_sra (void)
 static bool
 ipa_early_sra_gate (void)
 {
-  return flag_ipa_sra && dbg_cnt (eipa_sra);
+  return flag_ipa_sra && !flag_dyn_ipa && dbg_cnt (eipa_sra);
 }
 
 struct gimple_opt_pass pass_early_ipa_sra =
diff --git a/gcc/tree-ssa-alias.c b/gcc/tree-ssa-alias.c
index 2df27dd..eae5018f 100644
--- a/gcc/tree-ssa-alias.c
+++ b/gcc/tree-ssa-alias.c
@@ -42,6 +42,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "pointer-set.h"
 #include "alloc-pool.h"
 #include "tree-ssa-alias.h"
+#include "dbgcnt.h"
+#include "l-ipo.h"
 
 /* Broad overview of how alias analysis on gimple works:
 
@@ -603,6 +605,9 @@ same_type_for_tbaa (tree type1, tree type2)
   if (get_alias_set (type1) == get_alias_set (type2))
     return -1;
 
+  if (L_IPO_COMP_MODE)
+    return equivalent_struct_types_for_tbaa (type1, type2);
+
   /* The types are known to be not equal.  */
   return 0;
 }
@@ -1023,6 +1028,9 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)
 			   || TREE_CODE (ref2->ref) == MEM_REF
 			   || TREE_CODE (ref2->ref) == TARGET_MEM_REF));
 
+  if (!dbg_cnt (alias))
+    return true;
+
   /* Decompose the references into their base objects and the access.  */
   base1 = ao_ref_base (ref1);
   offset1 = ref1->offset;
@@ -2243,4 +2251,3 @@ walk_aliased_vdefs (ao_ref *ref, tree vdef,
 
   return ret;
 }
-
diff --git a/gcc/tree-ssa-live.c b/gcc/tree-ssa-live.c
index a72e9d5..05ced83 100644
--- a/gcc/tree-ssa-live.c
+++ b/gcc/tree-ssa-live.c
@@ -563,11 +563,11 @@ remove_unused_scope_block_p (tree scope)
       eliminated.  */
    else if (!nsubblocks)
      ;
-   /* For terse debug info we can eliminate info on unused variables.  */
-   else if (debug_info_level == DINFO_LEVEL_NONE
-	    || debug_info_level == DINFO_LEVEL_TERSE)
+   /* When not generating debug info we can eliminate info on unused
+      variables.  */
+   else if (!flag_auto_profile && debug_info_level == DINFO_LEVEL_NONE)
      {
-       /* Even for -g0/-g1 don't prune outer scopes from artificial
+       /* Even for -g0 don't prune outer scopes from artificial
 	  functions, otherwise diagnostics using tree_nonartificial_location
 	  will not be emitted properly.  */
        if (inlined_function_outer_scope_p (scope))
diff --git a/gcc/tree-ssa-structalias.c b/gcc/tree-ssa-structalias.c
index 31a4c49..d4b1400 100644
--- a/gcc/tree-ssa-structalias.c
+++ b/gcc/tree-ssa-structalias.c
@@ -2237,18 +2237,37 @@ perform_var_substitution (constraint_graph_t graph)
       {
 	unsigned j = si->node_mapping[i];
 	if (j != i)
-	  fprintf (dump_file, "%s node id %d (%s) mapped to SCC leader "
-		   "node id %d (%s)\n",
-		    bitmap_bit_p (graph->direct_nodes, i)
-		    ? "Direct" : "Indirect", i, get_varinfo (i)->name,
-		    j, get_varinfo (j)->name);
+	  {
+	    fprintf (dump_file, "%s node id %d ",
+		     bitmap_bit_p (graph->direct_nodes, i)
+		     ? "Direct" : "Indirect", i);
+	    if (i < FIRST_REF_NODE)
+	      fprintf (dump_file, "\"%s\"", get_varinfo (i)->name);
+	    else
+	      fprintf (dump_file, "\"*%s\"",
+		       get_varinfo (i - FIRST_REF_NODE)->name);
+	    fprintf (dump_file, " mapped to SCC leader node id %d ", j);
+	    if (j < FIRST_REF_NODE)
+	      fprintf (dump_file, "\"%s\"\n", get_varinfo (j)->name);
+	    else
+	      fprintf (dump_file, "\"*%s\"\n",
+		       get_varinfo (j - FIRST_REF_NODE)->name);
+	  }
 	else
-	  fprintf (dump_file,
-		   "Equivalence classes for %s node id %d (%s): pointer %d"
-		   ", location %d\n",
-		   bitmap_bit_p (graph->direct_nodes, i)
-		   ? "direct" : "indirect", i, get_varinfo (i)->name,
-		   graph->pointer_label[i], graph->loc_label[i]);
+	  {
+	    fprintf (dump_file,
+		     "Equivalence classes for %s node id %d ",
+		     bitmap_bit_p (graph->direct_nodes, i)
+		     ? "direct" : "indirect", i);
+	    if (i < FIRST_REF_NODE)
+	      fprintf (dump_file, "\"%s\"", get_varinfo (i)->name);
+	    else
+	      fprintf (dump_file, "\"*%s\"",
+		       get_varinfo (i - FIRST_REF_NODE)->name);
+	    fprintf (dump_file,
+		     ": pointer %d, location %d\n",
+		     graph->pointer_label[i], graph->loc_label[i]);
+	  }
       }
 
   /* Quickly eliminate our non-pointer variables.  */
diff --git a/gcc/tree-ssa-uninit.c b/gcc/tree-ssa-uninit.c
index 2c47fe9..0f8cdc4 100644
--- a/gcc/tree-ssa-uninit.c
+++ b/gcc/tree-ssa-uninit.c
@@ -2034,7 +2034,7 @@ execute_late_warn_uninitialized (void)
 static bool
 gate_warn_uninitialized (void)
 {
-  return warn_uninitialized != 0;
+  return (warn_uninitialized != 0 && warn_maybe_uninitialized != 0);
 }
 
 struct gimple_opt_pass pass_late_warn_uninitialized =
diff --git a/gcc/tree-ssa.c b/gcc/tree-ssa.c
index b0619fa..43b14dd 100644
--- a/gcc/tree-ssa.c
+++ b/gcc/tree-ssa.c
@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "ggc.h"
 #include "langhooks.h"
 #include "basic-block.h"
+#include "input.h"
 #include "function.h"
 #include "gimple-pretty-print.h"
 #include "bitmap.h"
@@ -38,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "hashtab.h"
 #include "tree-pass.h"
 #include "diagnostic-core.h"
+#include "l-ipo.h"
 #include "cfgloop.h"
 
 /* Pointer map of variable mappings, keyed by edge.  */
@@ -1406,7 +1408,9 @@ useless_type_conversion_p (tree outer_type, tree inner_type)
      compared types.  */
   else if (AGGREGATE_TYPE_P (inner_type)
 	   && TREE_CODE (inner_type) == TREE_CODE (outer_type))
-    return false;
+    return (L_IPO_COMP_MODE
+	    && (equivalent_struct_types_for_tbaa (inner_type,
+						  outer_type) == 1));
 
   return false;
 }
@@ -1607,6 +1611,8 @@ warn_uninit (enum opt_code wc, tree t,
   location = (context != NULL && gimple_has_location (context))
 	     ? gimple_location (context)
 	     : DECL_SOURCE_LOCATION (var);
+  if (has_discriminator (location))
+    location = map_discriminator_location (location);
   location = linemap_resolve_location (line_table, location,
 				       LRK_SPELLING_LOCATION,
 				       NULL);
diff --git a/gcc/tree-tsan.c b/gcc/tree-tsan.c
new file mode 100644
index 0000000..1930086
--- /dev/null
+++ b/gcc/tree-tsan.c
@@ -0,0 +1,1115 @@
+/* ThreadSanitizer, a data race detector.
+   Copyright (C) 2011 Free Software Foundation, Inc.
+   Contributed by Dmitry Vyukov <dvyukov@google.com>
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tree.h"
+#include "intl.h"
+#include "tm.h"
+#include "basic-block.h"
+#include "gimple.h"
+#include "function.h"
+#include "tree-flow.h"
+#include "tree-pass.h"
+#include "tree-iterator.h"
+#include "cfghooks.h"
+#include "langhooks.h"
+#include "output.h"
+#include "options.h"
+#include "target.h"
+#include "cgraph.h"
+#include "diagnostic.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+
+/* ThreadSanitizer is a data race detector for C/C++ programs.
+   http://code.google.com/p/data-race-test/wiki/ThreadSanitizer
+
+   The tool consists of two parts:
+   instrumentation module (this file) and a run-time library.
+   The instrumentation module maintains shadow call stacks
+   and intercepts interesting memory accesses.
+   The instrumentation is enabled with -ftsan flag.
+
+   Instrumentation for shadow stack maintenance is as follows:
+   void somefunc ()
+   {
+     __tsan_shadow_stack [-1] = __builtin_return_address (0);
+     __tsan_shadow_stack++;
+     // function body
+     __tsan_shadow_stack--;
+   }
+
+   Interception for memory access interception is as follows:
+   *addr = 1;
+   __tsan_handle_mop (addr, flags);
+   where flags are (is_sblock | (is_store << 1) | ((sizeof (*addr) - 1) << 2).
+   is_sblock is used merely for optimization purposes and can always
+   be set to 1, see comments in instrument_mops function.
+
+   Ignore files can be used to selectively non instrument some functions.
+   Ignore file is specified with -ftsan-ignore=filename flag.
+   There are 3 types of ignores: (1) do not instrument memory accesses
+   in the function, (2) do not create sblocks in the function
+   and (3) recursively ignore memory accesses in the function.
+   That last ignore type requires additional instrumentation of the form:
+   void somefunc ()
+   {
+     __tsan_thread_ignore++;
+     // function body
+     __tsan_thread_ignore--;
+   }
+
+   The run-time library provides __tsan_handle_mop function,
+   definitions of __tsan_shadow_stack and __tsan_thread_ignore variables,
+   and intercepts synchronization related functions.  */
+
+#define TSAN_IGNORE "__tsan_thread_ignore"
+#define TSAN_STACK "__tsan_shadow_stack"
+#define TSAN_MOP "__tsan_handle_mop"
+#define TSAN_INIT "__tsan_init"
+#define TSAN_PERFIX "__tsan_"
+#define MAX_MOP_BYTES 16
+#define SBLOCK_SIZE 5
+void tsan_finish_file (void);
+
+enum tsan_ignore_type
+{
+  tsan_ignore_none  = 1 << 0, /* Do not ignore.  */
+  tsan_ignore_func  = 1 << 1, /* Completely ignore the whole func.  */
+  tsan_ignore_mop   = 1 << 2, /* Do not instrument accesses.  */
+  tsan_ignore_rec   = 1 << 3, /* Do not instrument accesses recursively.  */
+  tsan_ignore_hist  = 1 << 4  /* Do not create superblocks.  */
+};
+
+/* Info associated with each basic block.
+   Used to determine super-blocks (see instrument_mops ()).  */
+
+struct bb_data
+{
+  int         is_visited;
+  int         has_sb;
+  const char *sb_file;
+  int         sb_line_min;
+  int         sb_line_max;
+};
+
+/* Memory access descriptor.  */
+
+struct mop_desc
+{
+  int                  is_call;
+  int                  is_store;
+  gimple_stmt_iterator gsi;
+  tree                 expr;
+};
+
+/* Descriptor of an ignore file entry.  */
+
+struct tsan_ignore_desc
+{
+  struct tsan_ignore_desc *next;
+  enum tsan_ignore_type    type;
+  char                    *name;
+};
+
+/* Number of instrumented memory accesses in the current function.  */
+
+static int func_mops;
+
+/* Number of function calls in the current function.  */
+
+static int func_calls;
+
+/* Ignore status for the current function (see tsan_ignore_type).  */
+
+static enum tsan_ignore_type func_ignore;
+
+static int ignore_init = 0;
+static struct tsan_ignore_desc *ignore_head;
+
+typedef struct mop_desc mop_desc;
+DEF_VEC_O (mop_desc);
+DEF_VEC_ALLOC_O (mop_desc, heap);
+static VEC (mop_desc, heap) *mop_list;
+
+/* Returns a definition of a runtime variable with type TYP and name NAME.  */
+
+static tree
+build_var_decl (tree typ, const char *name)
+{
+  tree id;
+  tree decl;
+  varpool_node_ptr var;
+
+  /* Check if a user has defined it for testing.  */
+  id = get_identifier (name);
+  var = varpool_node_for_asm (id);
+  if (var != NULL)
+    {
+      decl = var->decl;
+      gcc_assert (TREE_CODE (decl) == VAR_DECL);
+      return decl;
+    }
+
+  decl = build_decl (UNKNOWN_LOCATION, VAR_DECL, id, typ);
+  TREE_STATIC (decl) = 1;
+  TREE_PUBLIC (decl) = 1;
+  DECL_EXTERNAL (decl) = 1;
+  if (targetm.have_tls)
+    DECL_TLS_MODEL (decl) = decl_default_tls_model (decl);
+  TREE_USED (decl) = 1;
+  TREE_THIS_VOLATILE (decl) = 1;
+  SET_DECL_ASSEMBLER_NAME (decl, id);
+  return decl;
+}
+
+/* Builds the following decl
+   extern __thread void **__tsan_shadow_stack;  */
+
+static tree
+get_shadow_stack_decl (void)
+{
+  static tree decl;
+
+  if (decl == NULL)
+    decl = build_var_decl (build_pointer_type (ptr_type_node), TSAN_STACK);
+  return decl;
+}
+
+/* Builds the following decl
+   extern __thread int __tsan_thread_ignore;  */
+
+static tree
+get_thread_ignore_decl (void)
+{
+  static tree decl;
+
+  if (decl == NULL)
+    decl = build_var_decl (integer_type_node, TSAN_IGNORE);
+  return decl;
+}
+
+/* Returns a definition of a runtime functione with type TYP and name NAME.  */
+
+static tree
+build_func_decl (tree typ, const char *name)
+{
+  tree id;
+  cgraph_node_ptr func;
+  tree decl;
+
+  /* Check if a user has defined it for testing.  */
+  id = get_identifier (name);
+  func = cgraph_node_for_asm (id);
+  if (func != NULL)
+    {
+      decl = func->decl;
+      gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);
+      return decl;
+    }
+
+  decl = build_fn_decl (name, typ);
+  TREE_NOTHROW (decl) = 1;
+  DECL_ATTRIBUTES (decl) = tree_cons (get_identifier ("leaf"),
+                                     NULL, DECL_ATTRIBUTES (decl));
+  DECL_ASSEMBLER_NAME (decl);
+  return decl;
+}
+
+/* Builds the following decl
+   void __tsan_handle_mop (void *addr, unsigned flags);  */
+
+static tree
+get_handle_mop_decl (void)
+{
+  tree typ;
+  static tree decl;
+
+  if (decl != NULL)
+    return decl;
+
+  typ = build_function_type_list (void_type_node, ptr_type_node,
+                                  integer_type_node , NULL_TREE);
+  decl = build_func_decl (typ, TSAN_MOP);
+  return decl;
+}
+
+/* Builds the following decl
+   void __tsan_init (void);  */
+
+static tree
+get_init_decl (void)
+{
+  tree typ;
+  static tree decl;
+
+  if (decl != NULL)
+    return decl;
+
+  typ = build_function_type_list (void_type_node, NULL_TREE);
+  decl = build_func_decl (typ, TSAN_INIT);
+  return decl;
+}
+
+/* Adds new ignore definition to the global list.
+   TYPE is the ignore type (see tsan_ignore_type).
+   NAME is the ignore pattern (e.g. "std*string*insert").  */
+
+static void
+ignore_append (enum tsan_ignore_type type, char *name)
+{
+  struct tsan_ignore_desc *desc;
+
+  desc = XCNEW (struct tsan_ignore_desc);
+  desc->type = type;
+  desc->name = xstrdup (name);
+  desc->next = ignore_head;
+  ignore_head = desc;
+}
+
+/* Checks as to whether identifier STR matches template TEMPL.
+   Templates can only contain '*', e.g. 'std*string*insert'.
+   Templates implicitly start and end with '*'
+   since they are matched against mangled names.
+   Returns non-zero if STR is matched against TEMPL.  */
+
+static int
+ignore_match (char *templ, const char *str)
+{
+  char *tpos;
+  const char *spos;
+
+  while (templ && templ [0])
+    {
+      if (templ [0] == '*')
+        {
+          templ++;
+          continue;
+        }
+      if (str [0] == 0)
+        return 0;
+      tpos = strchr (templ, '*');
+      if (tpos != NULL)
+        tpos [0] = 0;
+      spos = strstr (str, templ);
+      str = spos + strlen (templ);
+      templ = tpos;
+      if (tpos != NULL)
+        tpos [0] = '*';
+      if (spos == NULL)
+        return 0;
+    }
+  return 1;
+}
+
+/* Loads ignore definitions from the file specified by -ftsan-ignore=filename.
+   The result is stored in the global ignore_head list.
+   Ignore files have the following format:
+
+# This is a comment - ignored
+
+# The below line says to not instrument memory accesses
+# in all functions that match 'std*string*insert'
+fun:std*string*insert
+
+# The below line says to not instrument memory accesses
+# in the function called 'foobar' *and* in all functions
+# that it calls recursively
+fun_r:foobar
+
+# The below line says to not create superblocks
+# in the function called 'barbaz'
+fun_hist:barbaz
+
+# Ignore all functions in the source file
+src:atomic.c
+
+# Everything else is uninteresting for us (e.g. obj:)
+*/
+
+static void
+ignore_load (void)
+{
+  FILE *f;
+  char *line;
+  size_t linesz;
+  ssize_t sz;
+  char buf [PATH_MAX];
+
+  if(getenv("GCCTSAN_PAUSE"))
+    {
+      int res;
+      printf("ATTACH A DEBUGGER AND PRESS ENTER\n");
+      res = scanf("%s", buf);
+      (void)res;
+    }
+
+  if (flag_tsan_ignore == NULL || flag_tsan_ignore [0] == 0)
+    return;
+
+  f = fopen (flag_tsan_ignore, "r");
+  if (f == NULL)
+    {
+      /* Try to open it relative to main_input_filename.  */
+      strncpy (buf, main_input_filename, sizeof (buf));
+      buf [sizeof (buf) - 1] = 0;
+      line = strrchr (buf, '/');
+      if (line != NULL)
+        {
+          line++;
+          strncpy (line, flag_tsan_ignore, sizeof (buf) - (line - buf));
+          buf [sizeof (buf) - 1] = 0;
+          f = fopen (buf, "r");
+        }
+    }
+  if (f == NULL)
+    {
+      error ("failed to open ignore file '%s'\n", flag_tsan_ignore);
+      return;
+    }
+
+  line = 0;
+  linesz = 0;
+  while ((sz = getline (&line, &linesz, f)) != -1)
+    {
+      if (sz == 0)
+        continue;
+      /* Strip line terminator.  */
+      if (line [sz - 1] == '\r' || line [sz - 1] == '\n')
+        line [sz - 1] = 0;
+      if (strncmp (line, "src:", sizeof ("src:") - 1) == 0)
+        ignore_append (tsan_ignore_func, line + sizeof ("src:") - 1);
+      else if (strncmp (line, "fun:", sizeof ("fun:") - 1) == 0)
+        ignore_append (tsan_ignore_mop, line + sizeof ("fun:") - 1);
+      else if (strncmp (line, "fun_r:", sizeof ("fun_r:") - 1) == 0)
+        ignore_append (tsan_ignore_rec, line + sizeof ("fun_r:") - 1);
+      else if (strncmp (line, "fun_hist:", sizeof ("fun_hist:") - 1) == 0)
+        ignore_append (tsan_ignore_hist, line + sizeof ("fun_hist:") - 1);
+      /* Other lines are not interesting.  */
+    }
+
+  free (line);
+  fclose (f);
+}
+
+/* Returns ignore status for the current function.  */
+
+static enum tsan_ignore_type
+tsan_ignore (void)
+{
+  const char *func_name;
+  const char *src_name;
+  struct tsan_ignore_desc *desc;
+
+  if (ignore_init == 0)
+    {
+      ignore_load ();
+      ignore_init = 1;
+    }
+
+  src_name = expand_location (cfun->function_start_locus).file;
+  if (src_name == NULL)
+    src_name = "";
+
+  func_name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (cfun->decl));
+  /* Ignore all functions starting with __tsan_ - intended for testing.  */
+  if (strncmp (func_name, TSAN_PERFIX, sizeof (TSAN_PERFIX) - 1) == 0)
+    return tsan_ignore_func;
+
+  /* Ignore global ctors.  */
+  if (strncmp (func_name, "_GLOBAL", sizeof ("_GLOBAL") - 1) == 0)
+    return tsan_ignore_func;
+
+  for (desc = ignore_head; desc; desc = desc->next)
+    {
+      if (desc->type == tsan_ignore_func)
+        {
+          if (ignore_match (desc->name, src_name))
+           return desc->type;
+        }
+      else if (ignore_match (desc->name, func_name))
+       return desc->type;
+    }
+  return tsan_ignore_none;
+}
+
+/* Builds either (__tsan_shadow_stack += 1) or (__tsan_shadow_stack -= 1)
+   expression depending on DO_DEC parameter.  Appends the result to SEQ.  */
+
+static void
+build_stack_op (gimple_seq *seq, bool do_dec)
+{
+  tree op_size;
+  double_int op_size_cst;
+  unsigned long long size_val;
+  unsigned long long size_valhi;
+  tree op_expr;
+  gimple assign;
+  tree sstack_decl;
+  gimple_seq s;
+
+  op_size = TYPE_SIZE (ptr_type_node);
+  op_size_cst = tree_to_double_int (op_size);
+  size_val = op_size_cst.low / BITS_PER_UNIT;
+  size_valhi = 0;
+  if (do_dec)
+    {
+      size_val = -size_val;
+      size_valhi = -1;
+    }
+  op_size = build_int_cst_wide (sizetype, size_val, size_valhi);
+  sstack_decl = get_shadow_stack_decl ();
+  op_expr = build2 (POINTER_PLUS_EXPR, ptr_type_node, sstack_decl, op_size);
+
+  s = NULL;
+  op_expr = force_gimple_operand (op_expr, &s, true, NULL_TREE);
+  gimple_seq_add_seq (seq, s);
+
+  assign = gimple_build_assign (sstack_decl, op_expr);
+  gimple_seq_add_stmt (seq, assign);
+}
+
+/* Builds either (__tsan_thread_ignore += 1) or (__tsan_thread_ignore -= 1)
+   expression depending on OP parameter.  Stores the result in SEQ.  */
+
+static void
+build_rec_ignore_op (gimple_seq *seq, enum tree_code op)
+{
+  tree rec_expr;
+  gimple_seq rec_inc;
+  gimple rec_assign;
+  tree ignore_decl;
+
+  ignore_decl = get_thread_ignore_decl ();
+  rec_expr = build2 (op, integer_type_node, ignore_decl, integer_one_node);
+  rec_inc = NULL;
+  rec_expr = force_gimple_operand (rec_expr, &rec_inc, true, NULL_TREE);
+  gimple_seq_add_seq (seq, rec_inc);
+  rec_assign = gimple_build_assign (ignore_decl, rec_expr);
+  gimple_seq_add_stmt (seq, rec_assign);
+}
+
+/* Build the following gimple sequence:
+   __tsan_shadow_stack [-1] = __builtin_return_address (0);
+   Stores the result in SEQ.  */
+
+static void
+build_stack_assign (gimple_seq *seq)
+{
+  tree pc_addr;
+  tree op_size;
+  tree op_expr;
+  tree stack_op;
+  tree retaddr_decl;
+  tree assign;
+
+  retaddr_decl = builtin_decl_implicit (BUILT_IN_RETURN_ADDRESS);
+  pc_addr = build_call_expr (retaddr_decl, 1, integer_zero_node);
+  op_size = build_int_cst_wide (sizetype, -(POINTER_SIZE / BITS_PER_UNIT), -1);
+  op_expr = build2 (POINTER_PLUS_EXPR, ptr_type_node,
+                    get_shadow_stack_decl (), op_size);
+  stack_op = build1 (INDIRECT_REF, ptr_type_node, op_expr);
+  assign = build2 (MODIFY_EXPR, ptr_type_node, stack_op, pc_addr);
+  force_gimple_operand (assign, seq, true, NULL_TREE);
+}
+
+/* Builds the following gimple sequence:
+   __tsan_handle_mop (&EXPR,
+                      (IS_SBLOCK | (IS_STORE << 1) | ((sizeof (EXPR) - 1) << 2);
+   The result is stored in GSEQ.  */
+
+static void
+instr_mop (tree expr, int is_store, int is_sblock, gimple_seq *gseq)
+{
+  tree addr_expr;
+  tree expr_type;
+  unsigned size;
+  unsigned flags;
+  tree flags_expr;
+  tree call_expr;
+
+  gcc_assert (gseq != 0 && *gseq == 0);
+  gcc_assert (is_gimple_addressable (expr));
+
+  addr_expr = build_addr (unshare_expr (expr), current_function_decl);
+  expr_type = TREE_TYPE (expr);
+  while (TREE_CODE (expr_type) == ARRAY_TYPE)
+    expr_type = TREE_TYPE (expr_type);
+  size = TREE_INT_CST_LOW (TYPE_SIZE (expr_type));
+  size = size / BITS_PER_UNIT;
+  if (size > MAX_MOP_BYTES)
+    size = MAX_MOP_BYTES;
+  size -= 1;
+  flags = ((!!is_sblock << 0) + (!!is_store << 1) + (size << 2));
+  flags_expr = build_int_cst (unsigned_type_node, flags);
+  call_expr = build_call_expr (get_handle_mop_decl (),
+                               2, addr_expr, flags_expr);
+  force_gimple_operand (call_expr, gseq, true, 0);
+}
+
+/* Builds the following gimple sequence:
+   int is_store = (EXPR != RHS); // The temp is not actually introduced.
+   __tsan_handle_mop (&EXPR,
+                      (IS_SBLOCK | (IS_STORE << 1) | ((sizeof (EXPR) - 1) << 2);
+   The result is stored in GSEQ.  */
+
+static void
+instr_vptr_store (tree expr, tree rhs, int is_sblock, gimple_seq *gseq)
+{
+  tree expr_ptr;
+  tree addr_expr;
+  tree expr_type;
+  tree expr_size;
+  double_int size;
+  unsigned flags;
+  tree flags_expr;
+  gimple_seq flags_seq;
+  gimple collect;
+  tree is_store_expr;
+
+  expr_ptr = build_addr (unshare_expr (expr), current_function_decl);
+  addr_expr = force_gimple_operand (expr_ptr, gseq, true, NULL_TREE);
+  expr_type = TREE_TYPE (expr);
+  while (TREE_CODE (expr_type) == ARRAY_TYPE)
+    expr_type = TREE_TYPE (expr_type);
+  expr_size = TYPE_SIZE (expr_type);
+  size = tree_to_double_int (expr_size);
+  gcc_assert (size.high == 0 && size.low != 0);
+  if (size.low > 128)
+    size.low = 128;
+  size.low = (size.low / 8) - 1;
+  flags = ((!!is_sblock << 0) + (size.low << 2));
+  flags_expr = build_int_cst (unsigned_type_node, flags);
+  is_store_expr = build2 (NE_EXPR, unsigned_type_node,
+                              build1 (VIEW_CONVERT_EXPR, size_type_node, expr),
+                              build1 (VIEW_CONVERT_EXPR, size_type_node, rhs));
+  is_store_expr = build2 (LSHIFT_EXPR, unsigned_type_node,
+                              is_store_expr, integer_one_node);
+  flags_expr = build2 (BIT_IOR_EXPR, unsigned_type_node,
+                              is_store_expr, flags_expr);
+  flags_seq = 0;
+  flags_expr = force_gimple_operand (flags_expr, &flags_seq, true, NULL_TREE);
+  gimple_seq_add_seq (gseq, flags_seq);
+  collect = gimple_build_call (
+      get_handle_mop_decl (), 2, addr_expr, flags_expr);
+  gimple_seq_add_stmt (gseq, collect);
+}
+
+/* Returns true if function entry and exit need to be instrumented.  */
+
+static bool
+is_func_instrumentation_required (void)
+{
+  if (func_calls == 0 && func_mops == 0)
+    return false;
+  if (func_ignore != tsan_ignore_rec)
+    return true;
+  if (func_ignore == tsan_ignore_rec && func_calls != 0)
+    return true;
+  return false;
+}
+
+/* Returns gimple seq that needs to be inserted at function entry.  */
+
+static gimple_seq
+build_func_entry_instr (void)
+{
+  gimple_seq gs;
+
+  gs = NULL;
+  gcc_assert (is_func_instrumentation_required ());
+  if (func_ignore != tsan_ignore_rec)
+    {
+      build_stack_assign (&gs);
+      build_stack_op (&gs, false);
+    }
+  else
+    build_rec_ignore_op (&gs, PLUS_EXPR);
+  return gs;
+}
+
+/* Returns gimple seq that needs to be inserted before function exit.  */
+
+static gimple_seq
+build_func_exit_instr (void)
+{
+  gimple_seq gs;
+
+  gs = NULL;
+  gcc_assert (is_func_instrumentation_required ());
+  if (func_ignore != tsan_ignore_rec)
+    build_stack_op (&gs, true);
+  else
+    build_rec_ignore_op (&gs, MINUS_EXPR);
+  return gs;
+}
+
+/* Sets location LOC for all gimples in the SEQ.  */
+
+static void
+set_location (gimple_seq seq, location_t loc)
+{
+  gimple_seq_node n;
+
+  for (n = gimple_seq_first (seq); n != NULL; n = n->next)
+    gimple_set_location (n->stmt, loc);
+  verify_gimple_in_seq (seq);
+}
+
+/* Check as to whether EXPR refers to a store to vptr.  */
+
+static tree
+is_vptr_store (gimple stmt, tree expr, int is_store)
+{
+  if (is_store == 1
+      && gimple_assign_single_p (stmt)
+      && TREE_CODE (expr) == COMPONENT_REF)
+    {
+      tree field = TREE_OPERAND (expr, 1);
+      if (TREE_CODE (field) == FIELD_DECL
+          && DECL_VIRTUAL_P (field))
+        return gimple_assign_rhs1 (stmt);
+    }
+  return NULL;
+}
+
+/* Checks as to whether EXPR refers to constant var/field/param.
+   Don't bother to instrument them.  */
+
+static int
+is_load_of_const (tree expr, int is_store)
+{
+  if (is_store)
+    return 0;
+  if (TREE_CODE (expr) == COMPONENT_REF)
+    expr = TREE_OPERAND (expr, 1);
+  if (TREE_CODE (expr) == VAR_DECL
+      || TREE_CODE (expr) == PARM_DECL
+      || TREE_CODE (expr) == FIELD_DECL)
+    {
+      if (TREE_READONLY (expr))
+        return 1;
+    }
+  return 0;
+}
+
+/* Checks as to whether EXPR needs to be instrumented,
+   if so puts it into the MOP_LIST.
+   GSI is the iterator from which EXPR was extracted.
+   IS_STORE says as to whether EXPR refers to a memory store
+   or a memory load.  */
+
+static void
+handle_expr (gimple_stmt_iterator gsi, tree expr, int is_store,
+             VEC (mop_desc, heap) **mop_list)
+{
+  enum tree_code tcode;
+  struct mop_desc mop;
+  unsigned fld_off;
+  unsigned fld_size;
+
+  tcode = TREE_CODE (expr);
+
+  /* Below are things we do not instrument
+     (no possibility of races or not implemented yet).  */
+  if ((func_ignore & (tsan_ignore_mop | tsan_ignore_rec))
+      || get_base_address (expr) == NULL
+      /* Compiler-emitted artificial variables.  */
+      || (DECL_P (expr) && DECL_ARTIFICIAL (expr))
+      /* The var does not live in memory -> no possibility of races.  */
+      || (tcode == VAR_DECL
+          && TREE_ADDRESSABLE (expr) == 0
+          && DECL_EXTERNAL (expr) == 0)
+      /* TODO (dvyukov): not implemented.  */
+      || TREE_CODE (TREE_TYPE (expr)) == RECORD_TYPE
+      /* TODO (dvyukov): not implemented.  */
+      || tcode == CONSTRUCTOR
+      /* TODO (dvyukov): not implemented.  */
+      || tcode == PARM_DECL
+      /* Load of a const variable/parameter/field.  */
+      || is_load_of_const (expr, is_store))
+    return;
+
+  if (tcode == COMPONENT_REF)
+    {
+      tree field = TREE_OPERAND (expr, 1);
+      if (TREE_CODE (field) == FIELD_DECL)
+        {
+          fld_off = TREE_INT_CST_LOW (DECL_FIELD_BIT_OFFSET (field));
+          fld_size = TREE_INT_CST_LOW (DECL_SIZE (field));
+          if (((fld_off % BITS_PER_UNIT) != 0)
+              || ((fld_size % BITS_PER_UNIT) != 0))
+            {
+              /* As of now it crashes compilation.
+                 TODO (dvyukov): handle bit-fields as if touching
+                 the whole field.  */
+              return;
+            }
+        }
+    }
+
+  /* TODO (dvyukov): handle other cases
+     (FIELD_DECL, MEM_REF, ARRAY_RANGE_REF, TARGET_MEM_REF, ADDR_EXPR).  */
+  if (tcode != ARRAY_REF
+      && tcode != VAR_DECL
+      && tcode != COMPONENT_REF
+      && tcode != INDIRECT_REF
+      && tcode != MEM_REF)
+    return;
+
+  mop.is_call = 0;
+  mop.gsi = gsi;
+  mop.expr = expr;
+  mop.is_store = is_store;
+  VEC_safe_push (mop_desc, heap, *mop_list, &mop);
+}
+
+/* Collects all interesting memory accesses from the gimple pointed to by GSI
+   into MOP_LIST.  */
+
+static void
+handle_gimple (gimple_stmt_iterator gsi, VEC (mop_desc, heap) **mop_list)
+{
+  unsigned i;
+  struct mop_desc mop;
+  gimple stmt;
+  enum gimple_code gcode;
+  tree rhs;
+  tree lhs;
+
+  stmt = gsi_stmt (gsi);
+  gcode = gimple_code (stmt);
+  if (gcode >= LAST_AND_UNUSED_GIMPLE_CODE)
+    return;
+
+  switch (gcode)
+    {
+      case GIMPLE_CALL:
+        {
+          func_calls += 1;
+          memset (&mop, 0, sizeof (mop));
+          mop.is_call = 1;
+          VEC_safe_push (mop_desc, heap, *mop_list, &mop);
+          break;
+        }
+
+      case GIMPLE_ASSIGN:
+        {
+          /* Handle assignment lhs as store.  */
+          lhs = gimple_assign_lhs (stmt);
+          handle_expr (gsi, lhs, 1, mop_list);
+
+          /* Handle operands as loads.  */
+          for (i = 1; i < gimple_num_ops (stmt); i++)
+            {
+              rhs = gimple_op (stmt, i);
+              handle_expr (gsi, rhs, 0, mop_list);
+            }
+          break;
+        }
+
+      default:
+        break;
+    }
+}
+
+/* Instruments single basic block BB.
+   BBD is the sblock info associated with the block.  */
+
+static void
+instrument_bblock (struct bb_data *bbd, basic_block bb)
+{
+  int ix;
+  int is_sblock;
+  gimple_stmt_iterator gsi;
+  struct mop_desc *mop;
+  gimple stmt;
+  location_t loc;
+  expanded_location eloc;
+  gimple_seq instr_seq;
+  tree rhs;
+
+  /* Iterate over all gimples and collect interesting mops into mop_list.  */
+  VEC_free (mop_desc, heap, mop_list);
+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+    {
+      handle_gimple (gsi, &mop_list);
+    }
+
+  mop = 0;
+  for (ix = 0; VEC_iterate (mop_desc, mop_list, ix, mop); ix += 1)
+    {
+      if (mop->is_call != 0)
+        {
+          /* After a function call we must start a brand new sblock,
+             because the function can contain synchronization.  */
+          bbd->has_sb = 0;
+          continue;
+        }
+
+      func_mops += 1;
+      stmt = gsi_stmt (mop->gsi);
+      loc = gimple_location (stmt);
+      eloc = expand_location (loc);
+
+      /* Check as to whether we may not set sblock flag for the access.  */
+      is_sblock = (bbd->has_sb == 0
+          || !(eloc.file != 0
+              && bbd->sb_file != 0
+              && strcmp (eloc.file, bbd->sb_file) == 0
+              && eloc.line >= bbd->sb_line_min
+              && eloc.line <= bbd->sb_line_max));
+
+      if (func_ignore == tsan_ignore_hist)
+        is_sblock = 0;
+
+      if (is_sblock)
+        {
+          /* Start new sblock with new source info.  */
+          bbd->has_sb = 1;
+          bbd->sb_file = eloc.file;
+          bbd->sb_line_min = eloc.line;
+          bbd->sb_line_max = eloc.line + SBLOCK_SIZE;
+        }
+
+      instr_seq = 0;
+      rhs = is_vptr_store (stmt, mop->expr, mop->is_store);
+      if (rhs == NULL)
+        instr_mop (mop->expr, mop->is_store, is_sblock, &instr_seq);
+      else
+        instr_vptr_store (mop->expr, rhs, is_sblock, &instr_seq);
+      gcc_assert (instr_seq != 0);
+      set_location (instr_seq, loc);
+      /* Instrumentation for assignment of a function result
+         must be inserted after the call.  Instrumentation for
+         reads of function arguments must be inserted before the call.
+         That's because the call can contain synchronization.  */
+      if (is_gimple_call (stmt) && mop->is_store == 1)
+        gsi_insert_seq_after (&mop->gsi, instr_seq, GSI_NEW_STMT);
+      else
+        gsi_insert_seq_before (&mop->gsi, instr_seq, GSI_SAME_STMT);
+    }
+}
+
+/* Instruments all interesting memory accesses in the current function.  */
+
+static void
+instrument_mops (void)
+{
+  basic_block bb;
+  int *blocks_inverted;
+  struct bb_data *bb_data;
+  struct bb_data *pred;
+  struct bb_data *bbd;
+  edge e;
+  edge_iterator ei;
+  int sb_line_min, sb_line_max;
+  int cnt, i;
+
+  /* The function does basic block traversal in reverse top sort order
+     of the inverted CFG.  Such order is required to properly mark super-blocks.
+     The idea behind super-blocks is as follows.
+     If several memory accesses happen within SBLOCK_SIZE source code lines
+     from each other, then we only mark the first access as SBLOCK.
+     This allows the runtime library to memorize a stack trace
+     only for the first access and do not memorize for others.
+     This significantly reduces memory consumption in exchange for slightly
+     imprecise stack traces for previous accesses.  */
+
+  blocks_inverted = XNEWVEC (int, last_basic_block + NUM_FIXED_BLOCKS);
+  bb_data = XCNEWVEC (struct bb_data, last_basic_block + NUM_FIXED_BLOCKS);
+  cnt = inverted_post_order_compute (blocks_inverted);
+  for (i = 0; i < cnt; i++)
+    {
+      bb = BASIC_BLOCK (blocks_inverted [i]);
+      bbd = &bb_data [bb->index];
+      /* Iterate over all predecessors and merge their sblock info.  */
+      FOR_EACH_EDGE (e, ei, bb->preds)
+        {
+          pred = &bb_data [e->src->index];
+          if (!pred->is_visited || !pred->has_sb || pred == bbd)
+            {
+              /* If there is a not visited predecessor,
+                 or a predecessor with no active sblock info,
+                 or a self-loop, then we will have to start
+                 a brand new sblock on next memory access.  */
+              bbd->has_sb = 0;
+              break;
+            }
+          else if (bbd->has_sb == 0)
+            {
+              /* If it's a first predecessor, just copy the info.  */
+              bbd->has_sb = 1;
+              bbd->sb_file = pred->sb_file;
+              bbd->sb_line_min = pred->sb_line_min;
+              bbd->sb_line_max = pred->sb_line_max;
+            }
+          else
+            {
+              /* Otherwise, find the interception
+                 between two sblock descriptors.  */
+              bbd->has_sb = 0;
+              if (bbd->sb_file != 0 && pred->sb_file != 0
+                  && strcmp (bbd->sb_file, pred->sb_file) == 0)
+                {
+                  sb_line_min = MAX (bbd->sb_line_min, pred->sb_line_min);
+                  sb_line_max = MIN (bbd->sb_line_max, pred->sb_line_max);
+                  if (sb_line_min <= sb_line_max)
+                    {
+                      bbd->has_sb = 1;
+                      bbd->sb_line_min = sb_line_min;
+                      bbd->sb_line_max = sb_line_max;
+                    }
+                }
+              /* No interception, have to start new sblock.  */
+              if (bbd->has_sb == 0)
+                break;
+            }
+        }
+
+      instrument_bblock (bbd, bb);
+      bbd->is_visited = 1;
+    }
+
+  free (blocks_inverted);
+  free (bb_data);
+}
+
+/* Instruments function entry.  */
+
+static void
+instrument_func_entry (void)
+{
+  gimple_seq seq;
+  basic_block entry_bb;
+  edge entry_edge;
+  gimple_stmt_iterator gsi;
+
+  /* Insert new BB before the first BB.  */
+  seq = build_func_entry_instr ();
+  gcc_assert (seq != NULL);
+  entry_bb = ENTRY_BLOCK_PTR;
+  entry_edge = single_succ_edge (entry_bb);
+  set_location (seq, cfun->function_start_locus);
+  entry_bb = split_edge (entry_edge);
+  gsi = gsi_start_bb (entry_bb);
+  gsi_insert_seq_after (&gsi, seq, GSI_NEW_STMT);
+}
+
+/* Instruments function exits.  */
+
+static void
+instrument_func_exit (void)
+{
+  location_t loc;
+  gimple_seq seq;
+  basic_block exit_bb;
+  gimple_stmt_iterator gsi;
+  gimple stmt;
+  edge e;
+  edge_iterator ei;
+
+  /* Find all function exits.  */
+  exit_bb = EXIT_BLOCK_PTR;
+  FOR_EACH_EDGE (e, ei, exit_bb->preds)
+    {
+      gsi = gsi_last_bb (e->src);
+      stmt = gsi_stmt (gsi);
+      gcc_assert (gimple_code (stmt) == GIMPLE_RETURN);
+      loc = gimple_location (stmt);
+      seq = build_func_exit_instr ();
+      gcc_assert (seq != NULL);
+      set_location (seq, loc);
+      gsi_insert_seq_before (&gsi, seq, GSI_SAME_STMT);
+    }
+}
+
+/* ThreadSanitizer instrumentation pass.  */
+
+static unsigned
+tsan_pass (void)
+{
+  struct gimplify_ctx gctx;
+
+  func_ignore = tsan_ignore ();
+  if (func_ignore == tsan_ignore_func)
+    return 0;
+
+  func_calls = 0;
+  func_mops = 0;
+
+  push_gimplify_context (&gctx);
+
+  instrument_mops ();
+
+  if (is_func_instrumentation_required ())
+    {
+      instrument_func_entry ();
+      instrument_func_exit ();
+    }
+
+  pop_gimplify_context (NULL);
+
+  return 0;
+}
+
+/* The pass's gate.  */
+
+static bool
+tsan_gate (void)
+{
+  return flag_tsan != 0;
+}
+
+/* Inserts __tsan_init () into the list of CTORs.  */
+
+void
+tsan_finish_file (void)
+{
+  tree ctor_statements;
+
+  ctor_statements = NULL_TREE;
+  append_to_statement_list (build_call_expr (get_init_decl (), 0),
+                            &ctor_statements);
+  cgraph_build_static_cdtor ('I', ctor_statements,
+                             MAX_RESERVED_INIT_PRIORITY - 1);
+}
+
+/* The pass descriptor.  */
+
+struct gimple_opt_pass pass_tsan = {{
+  GIMPLE_PASS,
+  "tsan",                               /* name  */
+  tsan_gate,                            /* gate  */
+  tsan_pass,                            /* execute  */
+  NULL,                                 /* sub  */
+  NULL,                                 /* next  */
+  0,                                    /* static_pass_number  */
+  TV_NONE,                              /* tv_id  */
+  PROP_trees | PROP_cfg,                /* properties_required  */
+  0,                                    /* properties_provided  */
+  0,                                    /* properties_destroyed  */
+  0,                                    /* todo_flags_start  */
+  TODO_dump_cgraph | TODO_dump_func | TODO_verify_all
+    | TODO_update_ssa | TODO_update_address_taken /* todo_flags_finish  */
+}};
diff --git a/gcc/tree-vect-loop-manip.c b/gcc/tree-vect-loop-manip.c
index 559f6e9..3633f54 100644
--- a/gcc/tree-vect-loop-manip.c
+++ b/gcc/tree-vect-loop-manip.c
@@ -1774,7 +1774,7 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,
   gimple_seq cond_expr_stmt_list = NULL;
 
   if (dump_enabled_p ())
-    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,
+    dump_printf_loc (MSG_NOTE, vect_location,
                      "=== vect_do_peeling_for_loop_bound ===");
 
   initialize_original_copy_tables ();
@@ -1828,7 +1828,7 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,
   if (check_profitability)
     max_iter = MAX (max_iter, (int) th - 1);
   record_niter_bound (new_loop, double_int::from_shwi (max_iter), false, true);
-  dump_printf (MSG_OPTIMIZED_LOCATIONS,
+  dump_printf (MSG_NOTE,
                "Setting upper bound of nb iterations for epilogue "
                "loop to %d\n", max_iter);
 
@@ -1893,7 +1893,7 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters, int
       int npeel = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);
 
       if (dump_enabled_p ())
-        dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,
+        dump_printf_loc (MSG_NOTE, vect_location,
                          "known peeling = %d.", npeel);
 
       iters = build_int_cst (niters_type, npeel);
@@ -1948,9 +1948,9 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters, int
 
   if (dump_enabled_p ())
     {
-      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,
+      dump_printf_loc (MSG_NOTE, vect_location,
                        "niters for prolog loop: ");
-      dump_generic_expr (MSG_OPTIMIZED_LOCATIONS, TDF_SLIM, iters);
+      dump_generic_expr (MSG_NOTE, TDF_SLIM, iters);
     }
 
   var = create_tmp_var (niters_type, "prolog_loop_niters");
@@ -2005,7 +2005,7 @@ vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters)
   struct data_reference *dr;
  
  if (dump_enabled_p ())
-    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,
+    dump_printf_loc (MSG_NOTE, vect_location,
                      "=== vect_update_inits_of_dr ===");
 
   FOR_EACH_VEC_ELT (datarefs, i, dr)
@@ -2034,7 +2034,7 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo,
   int bound = 0;
 
   if (dump_enabled_p ())
-    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,
+    dump_printf_loc (MSG_NOTE, vect_location,
                      "=== vect_do_peeling_for_alignment ===");
 
   initialize_original_copy_tables ();
@@ -2062,7 +2062,7 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo,
   if (check_profitability)
     max_iter = MAX (max_iter, (int) th - 1);
   record_niter_bound (new_loop, double_int::from_shwi (max_iter), false, true);
-  dump_printf (MSG_OPTIMIZED_LOCATIONS,
+  dump_printf (MSG_NOTE,
                "Setting upper bound of nb iterations for prologue "
                "loop to %d\n", max_iter);
 
@@ -2349,11 +2349,11 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,
 
       if (dump_enabled_p ())
 	{
-	  dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, 
+	  dump_printf_loc (MSG_NOTE, vect_location, 
                            "create runtime check for data references ");
-	  dump_generic_expr (MSG_OPTIMIZED_LOCATIONS, TDF_SLIM, DR_REF (dr_a));
-	  dump_printf (MSG_OPTIMIZED_LOCATIONS, " and ");
-	  dump_generic_expr (MSG_OPTIMIZED_LOCATIONS, TDF_SLIM, DR_REF (dr_b));
+	  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a));
+	  dump_printf (MSG_NOTE, " and ");
+	  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b));
 	}
 
       seg_a_min = addr_base_a;
@@ -2379,7 +2379,7 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo,
     }
 
   if (dump_enabled_p ())
-    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,
+    dump_printf_loc (MSG_NOTE, vect_location,
 		     "created %u versioning for alias checks.\n",
 		     may_alias_ddrs.length ());
 }
diff --git a/gcc/tree-vect-loop.c b/gcc/tree-vect-loop.c
index 1252c5a..707ba17 100644
--- a/gcc/tree-vect-loop.c
+++ b/gcc/tree-vect-loop.c
@@ -5779,8 +5779,10 @@ vect_transform_loop (loop_vec_info loop_vinfo)
   update_ssa (TODO_update_ssa);
 
   if (dump_enabled_p ())
-    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, "LOOP VECTORIZED.");
-  if (loop->inner && dump_enabled_p ())
-    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,
-		     "OUTER LOOP VECTORIZED.");
+    {
+      dump_printf_loc (MSG_NOTE, vect_location, "LOOP VECTORIZED.");
+      if (loop->inner)
+        dump_printf_loc (MSG_NOTE, vect_location,
+                         "OUTER LOOP VECTORIZED.");
+    }
 }
diff --git a/gcc/tree-vect-patterns.c b/gcc/tree-vect-patterns.c
index 554e186..ff84ba3 100644
--- a/gcc/tree-vect-patterns.c
+++ b/gcc/tree-vect-patterns.c
@@ -417,9 +417,9 @@ vect_recog_dot_prod_pattern (vec<gimple> *stmts, tree *type_in,
 
   if (dump_enabled_p ())
     {
-      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, 
+      dump_printf_loc (MSG_NOTE, vect_location, 
                        "vect_recog_dot_prod_pattern: detected: ");
-      dump_gimple_stmt (MSG_OPTIMIZED_LOCATIONS, TDF_SLIM, pattern_stmt, 0);
+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);
     }
 
   /* We don't allow changing the order of the computation in the inner-loop
@@ -679,7 +679,7 @@ vect_recog_widen_mult_pattern (vec<gimple> *stmts,
 
   /* Pattern detected.  */
   if (dump_enabled_p ())
-    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, 
+    dump_printf_loc (MSG_NOTE, vect_location, 
                      "vect_recog_widen_mult_pattern: detected: ");
 
   /* Check target support  */
@@ -916,9 +916,9 @@ vect_recog_widen_sum_pattern (vec<gimple> *stmts, tree *type_in,
 
   if (dump_enabled_p ())
     {
-      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, 
+      dump_printf_loc (MSG_NOTE, vect_location, 
                        "vect_recog_widen_sum_pattern: detected: ");
-      dump_gimple_stmt (MSG_OPTIMIZED_LOCATIONS, TDF_SLIM, pattern_stmt, 0);
+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);
     }
 
   /* We don't allow changing the order of the computation in the inner-loop
@@ -1221,9 +1221,9 @@ vect_recog_over_widening_pattern (vec<gimple> *stmts,
 
       if (dump_enabled_p ())
         {
-          dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,
+          dump_printf_loc (MSG_NOTE, vect_location,
                            "created pattern stmt: ");
-          dump_gimple_stmt (MSG_OPTIMIZED_LOCATIONS, TDF_SLIM, pattern_stmt, 0);
+          dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);
         }
 
       type = gimple_expr_type (stmt);
@@ -1289,9 +1289,9 @@ vect_recog_over_widening_pattern (vec<gimple> *stmts,
   /* Pattern detected.  */
   if (dump_enabled_p ())
     {
-      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, 
+      dump_printf_loc (MSG_NOTE, vect_location, 
                        "vect_recog_over_widening_pattern: detected: ");
-      dump_gimple_stmt (MSG_OPTIMIZED_LOCATIONS, TDF_SLIM, pattern_stmt, 0);
+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);
     }
 
   return pattern_stmt;
@@ -1424,7 +1424,7 @@ vect_recog_widen_shift_pattern (vec<gimple> *stmts,
 
   /* Pattern detected.  */
   if (dump_enabled_p ())
-    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,
+    dump_printf_loc (MSG_NOTE, vect_location,
                      "vect_recog_widen_shift_pattern: detected: ");
 
   /* Check target support.  */
@@ -1570,7 +1570,7 @@ vect_recog_vector_vector_shift_pattern (vec<gimple> *stmts,
 
   /* Pattern detected.  */
   if (dump_enabled_p ())
-    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, 
+    dump_printf_loc (MSG_NOTE, vect_location, 
                      "vect_recog_vector_vector_shift_pattern: detected: ");
 
   /* Pattern supported.  Create a stmt to be used to replace the pattern.  */
@@ -1688,7 +1688,7 @@ vect_recog_divmod_pattern (vec<gimple> *stmts,
 
       /* Pattern detected.  */
       if (dump_enabled_p ())
-        dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,
+        dump_printf_loc (MSG_NOTE, vect_location,
                          "vect_recog_divmod_pattern: detected: ");
 
       cond = build2 (LT_EXPR, boolean_type_node, oprnd0,
@@ -2035,9 +2035,9 @@ vect_recog_divmod_pattern (vec<gimple> *stmts,
   /* Pattern detected.  */
   if (dump_enabled_p ())
     {
-      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, 
+      dump_printf_loc (MSG_NOTE, vect_location, 
                        "vect_recog_divmod_pattern: detected: ");
-      dump_gimple_stmt (MSG_OPTIMIZED_LOCATIONS, TDF_SLIM, pattern_stmt, 0);
+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);
     }
 
   stmts->safe_push (last_stmt);
@@ -2202,7 +2202,7 @@ vect_recog_mixed_size_cond_pattern (vec<gimple> *stmts, tree *type_in,
   *type_out = vectype;
 
   if (dump_enabled_p ())
-    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, 
+    dump_printf_loc (MSG_NOTE, vect_location, 
                      "vect_recog_mixed_size_cond_pattern: detected: ");
 
   return pattern_stmt;
@@ -2595,7 +2595,7 @@ vect_recog_bool_pattern (vec<gimple> *stmts, tree *type_in,
       *type_in = vectype;
       stmts->safe_push (last_stmt);
       if (dump_enabled_p ())
-	dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location, 
+	dump_printf_loc (MSG_NOTE, vect_location, 
                          "vect_recog_bool_pattern: detected: ");
 
       return pattern_stmt;
@@ -2641,7 +2641,7 @@ vect_recog_bool_pattern (vec<gimple> *stmts, tree *type_in,
       *type_in = vectype;
       stmts->safe_push (last_stmt);
       if (dump_enabled_p ())
-	dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,
+	dump_printf_loc (MSG_NOTE, vect_location,
                          "vect_recog_bool_pattern: detected: ");
       return pattern_stmt;
     }
@@ -2792,9 +2792,9 @@ vect_pattern_recog_1 (vect_recog_func_ptr vect_recog_func,
   /* Found a vectorizable pattern.  */
   if (dump_enabled_p ())
     {
-      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,
+      dump_printf_loc (MSG_NOTE, vect_location,
                        "pattern recognized: ");
-      dump_gimple_stmt (MSG_OPTIMIZED_LOCATIONS, TDF_SLIM, pattern_stmt, 0);
+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);
     }
 
   /* Mark the stmts that are involved in the pattern. */
@@ -2818,9 +2818,9 @@ vect_pattern_recog_1 (vect_recog_func_ptr vect_recog_func,
       pattern_stmt = STMT_VINFO_RELATED_STMT (stmt_info);
       if (dump_enabled_p ())
         {
-          dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,
+          dump_printf_loc (MSG_NOTE, vect_location,
                            "additional pattern stmt: ");
-          dump_gimple_stmt (MSG_OPTIMIZED_LOCATIONS, TDF_SLIM, pattern_stmt, 0);
+          dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);
         }
 
       vect_mark_pattern_stmts (stmt, pattern_stmt, NULL_TREE);
diff --git a/gcc/tree-vect-slp.c b/gcc/tree-vect-slp.c
index e184326..7dcee1a 100644
--- a/gcc/tree-vect-slp.c
+++ b/gcc/tree-vect-slp.c
@@ -1793,7 +1793,7 @@ vect_make_slp_decision (loop_vec_info loop_vinfo)
   LOOP_VINFO_SLP_UNROLLING_FACTOR (loop_vinfo) = unrolling_factor;
 
   if (decided_to_slp && dump_enabled_p ())
-    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,
+    dump_printf_loc (MSG_NOTE, vect_location,
 		     "Decided to SLP %d instances. Unrolling factor %d",
 		     decided_to_slp, unrolling_factor);
 
@@ -3249,7 +3249,8 @@ vect_slp_transform_bb (basic_block bb)
     }
 
   if (dump_enabled_p ())
-    dump_printf (MSG_OPTIMIZED_LOCATIONS, "BASIC BLOCK VECTORIZED\n");
+    dump_printf_loc (MSG_NOTE, vect_location,
+                     "BASIC BLOCK VECTORIZED\n");
 
   destroy_bb_vec_info (bb_vinfo);
 }
diff --git a/gcc/tree-vectorizer.c b/gcc/tree-vectorizer.c
index 42ebb8d..02cf1a5 100644
--- a/gcc/tree-vectorizer.c
+++ b/gcc/tree-vectorizer.c
@@ -107,7 +107,7 @@ vectorize_loops (void)
 	vect_location = find_loop_location (loop);
         if (LOCATION_LOCUS (vect_location) != UNKNOWN_LOC
 	    && dump_enabled_p ())
-	  dump_printf (MSG_ALL, "\nAnalyzing loop at %s:%d\n",
+	  dump_printf (MSG_NOTE, "\nAnalyzing loop at %s:%d\n",
                        LOC_FILE (vect_location), LOC_LINE (vect_location));
 
 	loop_vinfo = vect_analyze_loop (loop);
@@ -118,8 +118,8 @@ vectorize_loops (void)
 
         if (LOCATION_LOCUS (vect_location) != UNKNOWN_LOC
 	    && dump_enabled_p ())
-          dump_printf (MSG_ALL, "\n\nVectorizing loop at %s:%d\n",
-                       LOC_FILE (vect_location), LOC_LINE (vect_location));
+          dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,
+                           "Vectorized loop\n");
 	vect_transform_loop (loop_vinfo);
 	num_vectorized_loops++;
       }
@@ -129,7 +129,7 @@ vectorize_loops (void)
   statistics_counter_event (cfun, "Vectorized loops", num_vectorized_loops);
   if (dump_enabled_p ()
       || (num_vectorized_loops > 0 && dump_enabled_p ()))
-    dump_printf_loc (MSG_ALL, vect_location,
+    dump_printf_loc (MSG_NOTE, vect_location,
                      "vectorized %u loops in function.\n",
                      num_vectorized_loops);
 
@@ -171,7 +171,7 @@ execute_vect_slp (void)
           vect_slp_transform_bb (bb);
           if (dump_enabled_p ())
             dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,
-			     "basic block vectorized using SLP\n");
+			     "Vectorized basic-block\n");
         }
     }
 
diff --git a/gcc/tree.h b/gcc/tree.h
index d6414fa..9624a5d 100644
--- a/gcc/tree.h
+++ b/gcc/tree.h
@@ -448,12 +448,13 @@ struct GTY(()) tree_base {
       unsigned lang_flag_5 : 1;
       unsigned lang_flag_6 : 1;
       unsigned saturating_flag : 1;
+      unsigned expr_folded_flag : 1;
 
       unsigned unsigned_flag : 1;
       unsigned packed_flag : 1;
       unsigned user_align : 1;
       unsigned nameless_flag : 1;
-      unsigned spare0 : 4;
+      unsigned spare0 : 3;
 
       unsigned spare1 : 8;
 
@@ -709,6 +710,13 @@ struct GTY(()) tree_base {
        SSA_NAME_IS_DEFAULT_DEF in
            SSA_NAME
 
+   expr_folded_flag:
+
+       EXPR_FOLDED in
+           all expressions
+           all decls
+           all constants
+
        DECL_NONLOCAL_FRAME in
 	   VAR_DECL
 */
@@ -1372,6 +1380,10 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,
 /* In fixed-point types, means a saturating type.  */
 #define TYPE_SATURATING(NODE) (TYPE_CHECK (NODE)->base.u.bits.saturating_flag)
 
+/* Nonzero in an expression, a decl, or a constant node if the node is
+   the result of a successful constant-folding.  */
+#define EXPR_FOLDED(NODE) ((NODE)->base.u.bits.expr_folded_flag)
+
 /* These flags are available for each language front end to use internally.  */
 #define TREE_LANG_FLAG_0(NODE) \
   (TREE_NOT_CHECK2(NODE, TREE_VEC, SSA_NAME)->base.u.bits.lang_flag_0)
@@ -5732,7 +5744,10 @@ enum operand_equal_flag
 {
   OEP_ONLY_CONST = 1,
   OEP_PURE_SAME = 2,
-  OEP_CONSTANT_ADDRESS_OF = 4
+  OEP_CONSTANT_ADDRESS_OF = 4,
+  OEP_ALLOW_NULL = 8,  /* Allow NULL operands to be passed in and compared.  */
+  OEP_ALLOW_NO_TYPE = 16  /* Allow operands both of which don't have a type
+                            to be compared.  */
 };
 
 extern int operand_equal_p (const_tree, const_tree, unsigned int);
diff --git a/gcc/value-prof.c b/gcc/value-prof.c
index c120c82..fc32cab 100644
--- a/gcc/value-prof.c
+++ b/gcc/value-prof.c
@@ -43,7 +43,11 @@ along with GCC; see the file COPYING3.  If not see
 #include "timevar.h"
 #include "dumpfile.h"
 #include "pointer-set.h"
+#include "langhooks.h"
+#include "params.h"
+#include "l-ipo.h"
 #include "profile.h"
+#include "ipa-inline.h"
 
 /* In this file value profile based optimizations are placed.  Currently the
    following optimizations are implemented (for more detailed descriptions
@@ -122,7 +126,7 @@ static bool gimple_ic_transform (gimple_stmt_iterator *);
 
 /* Allocate histogram value.  */
 
-static histogram_value
+histogram_value
 gimple_alloc_histogram_value (struct function *fun ATTRIBUTE_UNUSED,
 			      enum hist_type type, gimple stmt, tree value)
 {
@@ -333,6 +337,10 @@ dump_histogram_value (FILE *dump_file, histogram_value hist)
 	}
       fprintf (dump_file, ".\n");
       break;
+    case HIST_TYPE_INDIR_CALL_TOPN:
+      fprintf (dump_file, "Indirect call -- top N\n");
+      /* TODO add more elaborate dumping code.  */
+      break;
    }
 }
 
@@ -496,9 +504,11 @@ check_counter (gimple stmt, const char * name,
               : DECL_SOURCE_LOCATION (current_function_decl);
       if (flag_profile_correction)
         {
-	  inform (locus, "correcting inconsistent value profile: "
-		  "%s profiler overall count (%d) does not match BB count "
-                  "(%d)", name, (int)*all, (int)bb_count);
+          if (dump_enabled_p ())
+            dump_printf_loc (MSG_MISSED_OPTIMIZATION, locus,
+                             "correcting inconsistent value profile: %s "
+                             "profiler overall count (%d) does not match BB "
+                             "count (%d)", name, (int)*all, (int)bb_count);
 	  *all = bb_count;
 	  if (*count > *all)
             *count = *all;
@@ -520,6 +530,70 @@ check_counter (gimple stmt, const char * name,
   return false;
 }
 
+/* The overall number of invocations of the counter should match
+   execution count of basic block.  Report it as error rather than
+   internal error as it might mean that user has misused the profile
+   somehow.  STMT is the indiret call, COUNT1 and COUNT2 are counts
+   of two top targets, and ALL is the enclosing basic block execution
+   count.  */
+
+static bool
+check_ic_counter (gimple stmt, gcov_type *count1, gcov_type *count2,
+                  gcov_type all)
+{
+  location_t locus;
+  locus = (stmt != NULL)
+      ? gimple_location (stmt)
+      : DECL_SOURCE_LOCATION (current_function_decl);
+  if (*count1 > all && flag_profile_correction)
+    {
+      if (dump_enabled_p ())
+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, locus,
+                         "Correcting inconsistent value profile: "
+                         "ic (topn) profiler top target count (%ld) exceeds "
+                         "BB count (%ld)", (long)*count1, (long)all);
+      *count1 = all;
+    }
+  if (*count2 > all && flag_profile_correction)
+    {
+      if (dump_enabled_p ())
+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, locus,
+                         "Correcting inconsistent value profile: "
+                         "ic (topn) profiler second target count (%ld) exceeds "
+                         "BB count (%ld)", (long)*count2, (long)all);
+      *count2 = all;
+    }
+  
+  if (*count2 > *count1)
+    {
+      if (dump_enabled_p ())
+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, locus,
+                         "Corrupted topn ic value profile: "
+                         "first target count (%ld) is less than the second "
+                         "target count (%ld)", (long)*count1, (long)*count2);
+      return true;
+    }
+
+  if (*count1 + *count2 > all)
+    {
+      /* If (COUNT1 + COUNT2) is greater than ALL by less than around 10% then
+	 just fix COUNT2 up so that (COUNT1 + COUNT2) equals ALL.  */
+      if ((*count1 + *count2 - all) < (all >> 3))
+	*count2 = all - *count1;
+      else
+	{
+          if (dump_enabled_p ())
+            dump_printf_loc (MSG_MISSED_OPTIMIZATION, locus,
+                             "Corrupted topn ic value profile: top two "
+                             "targets's total count (%ld) exceeds bb count "
+                             "(%ld)",
+                             (long)(*count1 + *count2), (long)all);
+	  return true;
+	}
+    }
+  return false;
+}
+
 
 /* GIMPLE based transformations. */
 
@@ -572,9 +646,7 @@ gimple_value_profile_transformations (void)
     }
 
   if (changed)
-    {
-      counts_to_freqs ();
-    }
+    counts_to_freqs ();
 
   return changed;
 }
@@ -1094,6 +1166,9 @@ init_node_map (void)
 {
   struct cgraph_node *n;
 
+  if (L_IPO_COMP_MODE)
+    return;
+
   if (get_last_funcdef_no ())
     cgraph_node_map.safe_grow_cleared (get_last_funcdef_no ());
 
@@ -1109,6 +1184,9 @@ init_node_map (void)
 void
 del_node_map (void)
 {
+   if (L_IPO_COMP_MODE)
+     return;
+
    cgraph_node_map.release ();
 }
 
@@ -1120,9 +1198,11 @@ find_func_by_funcdef_no (int func_id)
   int max_id = get_last_funcdef_no ();
   if (func_id >= max_id || cgraph_node_map[func_id] == NULL)
     {
-      if (flag_profile_correction)
-        inform (DECL_SOURCE_LOCATION (current_function_decl),
-                "Inconsistent profile: indirect call target (%d) does not exist", func_id);
+      if (flag_profile_correction && dump_enabled_p ())
+        dump_printf_loc (MSG_MISSED_OPTIMIZATION,
+                         DECL_SOURCE_LOCATION (current_function_decl),
+                         "Inconsistent profile: indirect call target (%d) "
+                         "does not exist", func_id);
       else
         error ("Inconsistent profile: indirect call target (%d) does not exist", func_id);
 
@@ -1132,6 +1212,115 @@ find_func_by_funcdef_no (int func_id)
   return cgraph_node_map[func_id];
 }
 
+/* Initialize map of gids (gid -> cgraph node) */
+
+static htab_t gid_map = NULL;
+
+typedef struct func_gid_entry
+{
+  struct cgraph_node *node;
+  unsigned HOST_WIDEST_INT gid;
+} func_gid_entry_t;
+
+/* Hash function for function global unique ids.  */
+
+static hashval_t 
+htab_gid_hash (const void * ent)
+{
+  const func_gid_entry_t *const entry = (const func_gid_entry_t *) ent;
+  return entry->gid;
+}
+
+/* Hash table equality function for function global unique ids.  */
+
+static int
+htab_gid_eq (const void *ent1, const void * ent2)
+{
+  const func_gid_entry_t *const entry1 = (const func_gid_entry_t *) ent1;
+  const func_gid_entry_t *const entry2 = (const func_gid_entry_t *) ent2;
+  return entry1->gid == entry2->gid;
+}
+
+static void
+htab_gid_del (void *ent)
+{
+  func_gid_entry_t *const entry = (func_gid_entry_t *) ent;
+  free (entry);
+}
+
+/* Initialize the global unique id map for functions.  */
+
+static void
+init_gid_map (void)
+{
+  struct cgraph_node *n;
+
+  gcc_assert (!gid_map);
+
+  gid_map
+      = htab_create (10, htab_gid_hash, htab_gid_eq, htab_gid_del);
+
+  FOR_EACH_FUNCTION (n)
+    {
+      func_gid_entry_t ent, *entp;
+      func_gid_entry_t **slot;
+      struct function *f;
+      ent.node = n;
+      f = DECL_STRUCT_FUNCTION (n->symbol.decl);
+      /* Do not care to indirect call promote a function with id.  */
+      if (!f || DECL_ABSTRACT (n->symbol.decl))
+        continue;
+      /* The global function id computed at profile-use time
+        is slightly different from the one computed in
+         instrumentation runtime -- for the latter, the intra-
+         module function ident is 1 based while in profile-use
+         phase, it is zero based. See get_next_funcdef_no in
+         function.c.  */
+      ent.gid = FUNC_DECL_GLOBAL_ID (DECL_STRUCT_FUNCTION (n->symbol.decl));
+      slot = (func_gid_entry_t **) htab_find_slot (gid_map, &ent, INSERT);
+
+      gcc_assert (!*slot || ((*slot)->gid == ent.gid && (*slot)->node == n));
+      if (!*slot)
+        {
+          *slot = entp = XCNEW (func_gid_entry_t);
+          entp->node = n;
+          entp->gid = ent.gid;
+        }
+    }
+}
+
+/* Initialize the global unique id map for functions.  */
+
+void
+cgraph_init_gid_map (void)
+{
+  if (!L_IPO_COMP_MODE)
+    return;
+
+  init_gid_map ();
+}
+
+/* Return cgraph node for function with global id.  */
+
+struct cgraph_node *
+find_func_by_global_id (unsigned HOST_WIDE_INT gid, bool is_auto_fdo)
+{
+  func_gid_entry_t ent, *entp;
+
+  if (is_auto_fdo)
+    return cgraph_node_for_asm (get_identifier ((const char *) gid));
+
+  gcc_assert (gid_map);
+
+  ent.node = NULL;
+  ent.gid = gid;
+  entp = (func_gid_entry_t *)htab_find (gid_map, &ent);
+  if (entp)
+    return entp->node;
+  return NULL;
+}
+
+
 /* Perform sanity check on the indirect call target. Due to race conditions,
    false function target may be attributed to an indirect call site. If the
    call expression type mismatches with the target function's type, expand_call
@@ -1142,12 +1331,14 @@ static bool
 check_ic_target (gimple call_stmt, struct cgraph_node *target)
 {
    location_t locus;
-   if (gimple_check_call_matching_types (call_stmt, target->symbol.decl))
+   if (gimple_check_call_matching_types (call_stmt, target->symbol.decl, true))
      return true;
 
    locus =  gimple_location (call_stmt);
-   inform (locus, "Skipping target %s with mismatching types for icall ",
-           cgraph_node_name (target));
+   if (dump_enabled_p ())
+     dump_printf_loc (MSG_MISSED_OPTIMIZATION, locus,
+                      "Skipping target %s with mismatching types for icall ",
+                      cgraph_node_name (target));
    return false;
 }
 
@@ -1301,28 +1492,13 @@ gimple_ic (gimple icall_stmt, struct cgraph_node *direct_call,
  */
 
 static bool
-gimple_ic_transform (gimple_stmt_iterator *gsi)
+gimple_ic_transform_single_targ (gimple stmt, histogram_value histogram)
 {
-  gimple stmt = gsi_stmt (*gsi);
-  histogram_value histogram;
   gcov_type val, count, all, bb_all;
   gcov_type prob;
   gimple modify;
   struct cgraph_node *direct_call;
 
-  if (gimple_code (stmt) != GIMPLE_CALL)
-    return false;
-
-  if (gimple_call_fndecl (stmt) != NULL_TREE)
-    return false;
-
-  if (gimple_call_internal_p (stmt))
-    return false;
-
-  histogram = gimple_histogram_value_of_type (cfun, stmt, HIST_TYPE_INDIR_CALL);
-  if (!histogram)
-    return false;
-
   val = histogram->hvalue.counters [0];
   count = histogram->hvalue.counters [1];
   all = histogram->hvalue.counters [2];
@@ -1370,6 +1546,209 @@ gimple_ic_transform (gimple_stmt_iterator *gsi)
   return true;
 }
 
+/* Convert indirect function call STMT into guarded direct function
+   calls. Multiple indirect call targets are supported. HISTOGRAM
+   is the target distribution for the callsite.  */
+
+static bool
+gimple_ic_transform_mult_targ (gimple stmt, histogram_value histogram)
+{
+  gcov_type val1, val2, count1, count2, all, bb_all;
+  gcov_type prob1, prob2;
+  gimple modify1, modify2;
+  struct cgraph_node *direct_call1 = 0, *direct_call2 = 0;
+  int perc_threshold, count_threshold, always_inline;
+  location_t locus;
+
+  val1 = histogram->hvalue.counters [1];
+  count1 = histogram->hvalue.counters [2];
+  val2 = histogram->hvalue.counters [3];
+  count2 = histogram->hvalue.counters [4];
+  bb_all = flag_auto_profile ? histogram->hvalue.counters[0]
+			     : gimple_bb (stmt)->count;
+  all = bb_all;
+
+  gimple_remove_histogram_value (cfun, stmt, histogram);
+
+  if (count1 == 0)
+    return false;
+
+  perc_threshold = PARAM_VALUE (PARAM_ICALL_PROMOTE_PERCENT_THRESHOLD);
+  count_threshold = PARAM_VALUE (PARAM_ICALL_PROMOTE_COUNT_THRESHOLD);
+  always_inline = PARAM_VALUE (PARAM_ALWAYS_INLINE_ICALL_TARGET);
+
+  if (100 * count1 < all * perc_threshold || count1 < count_threshold)
+    return false;
+
+  if (check_ic_counter (stmt, &count1, &count2, all))
+    return false;
+
+  if (all > 0)
+    {
+      prob1 = (count1 * REG_BR_PROB_BASE + all / 2) / all;
+      if (all - count1 > 0)
+        prob2 = (count2 * REG_BR_PROB_BASE
+                 + (all - count1) / 2) / (all - count1);
+      else
+        prob2 = 0;
+    }
+  else
+    prob1 = prob2 = 0;
+
+  direct_call1 = find_func_by_global_id (val1, flag_auto_profile);
+
+  if (val2 && (100 * count2 >= all * perc_threshold)
+      && count2 > count_threshold)
+    direct_call2 = find_func_by_global_id (val2, flag_auto_profile);
+
+  locus = (stmt != NULL) ? gimple_location (stmt)
+      : DECL_SOURCE_LOCATION (current_function_decl);
+  if (direct_call1 == NULL
+      || !check_ic_target (stmt, direct_call1))
+    {
+      if (dump_enabled_p () && !flag_auto_profile)
+        {
+          if (!direct_call1)
+            dump_printf_loc (MSG_MISSED_OPTIMIZATION, locus,
+                             "Can not find indirect call target decl "
+                             "(%d:%d)[cnt:%u] in current module",
+                             EXTRACT_MODULE_ID_FROM_GLOBAL_ID (val1),
+                             EXTRACT_FUNC_ID_FROM_GLOBAL_ID (val1),
+                             (unsigned) count1);
+          else
+            dump_printf_loc (MSG_MISSED_OPTIMIZATION, locus,
+                             "Can not find promote indirect call target decl "
+                             "-- type mismatch (%d:%d)[cnt:%u] in current "
+                             "module",
+                             EXTRACT_MODULE_ID_FROM_GLOBAL_ID (val1),
+                             EXTRACT_FUNC_ID_FROM_GLOBAL_ID (val1),
+                             (unsigned) count1);
+        }
+      return false;
+    }
+
+  /* Don't indirect-call promote if the target is in auxiliary module and
+     DECL_ARTIFICIAL and not TREE_PUBLIC, because we don't static-promote
+     DECL_ARTIFICIALs yet.  */
+  if (cgraph_is_auxiliary (direct_call1->symbol.decl)
+      && DECL_ARTIFICIAL (direct_call1->symbol.decl)
+      && ! TREE_PUBLIC (direct_call1->symbol.decl))
+    return false;
+
+  modify1 = gimple_ic (stmt, direct_call1, prob1, count1, all);
+  if (dump_enabled_p ())
+     dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, locus,
+                      "Promote indirect call to target (call count:%u) %s",
+                      (unsigned) count1,
+                      lang_hooks.decl_printable_name (direct_call1->symbol.decl,
+                                                      3));
+
+  if (always_inline && count1 >= always_inline)
+    {
+      /* TODO: should mark the call edge. */
+      DECL_DISREGARD_INLINE_LIMITS (direct_call1->symbol.decl) = 1;
+    }
+  if (dump_file)
+    {
+      fprintf (dump_file, "Indirect call -> direct call ");
+      print_generic_expr (dump_file, gimple_call_fn (stmt), TDF_SLIM);
+      fprintf (dump_file, "=> ");
+      print_generic_expr (dump_file, direct_call1->symbol.decl, TDF_SLIM);
+      if (flag_auto_profile)
+	fprintf (dump_file, " (%s)\n", (char *) val1);
+      else
+	fprintf (dump_file, " (module_id:%d, func_id:%d)\n",
+                 EXTRACT_MODULE_ID_FROM_GLOBAL_ID (val1),
+                 EXTRACT_FUNC_ID_FROM_GLOBAL_ID (val1));
+      fprintf (dump_file, "Transformation on insn:\n");
+      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);
+      fprintf (dump_file, "==>\n");
+      print_gimple_stmt (dump_file, modify1, 0, TDF_SLIM);
+      fprintf (dump_file, "hist->count "HOST_WIDEST_INT_PRINT_DEC
+	       " hist->all "HOST_WIDEST_INT_PRINT_DEC"\n", count1, all);
+    }
+
+  if (direct_call2 && check_ic_target (stmt, direct_call2)
+      /* Don't indirect-call promote if the target is in auxiliary module and
+	 DECL_ARTIFICIAL and not TREE_PUBLIC, because we don't static-promote
+	 DECL_ARTIFICIALs yet.  */
+      && ! (cgraph_is_auxiliary (direct_call2->symbol.decl)
+	    && DECL_ARTIFICIAL (direct_call2->symbol.decl)
+	    && ! TREE_PUBLIC (direct_call2->symbol.decl)))
+    {
+      modify2 = gimple_ic (stmt, direct_call2,
+                           prob2, count2, all - count1);
+
+      if (dump_enabled_p ())
+        dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, locus,
+                         "Promote indirect call to target (call count:%u) %s",
+                         (unsigned) count2,
+                         lang_hooks.decl_printable_name (
+                             direct_call2->symbol.decl, 3));
+
+      if (always_inline && count2 >= always_inline)
+        {
+          /* TODO: should mark the call edge.  */
+          DECL_DISREGARD_INLINE_LIMITS (direct_call2->symbol.decl) = 1;
+        }
+      if (dump_file)
+        {
+          fprintf (dump_file, "Indirect call -> direct call ");
+          print_generic_expr (dump_file, gimple_call_fn (stmt), TDF_SLIM);
+          fprintf (dump_file, "=> ");
+          print_generic_expr (dump_file, direct_call2->symbol.decl, TDF_SLIM);
+	  if (flag_auto_profile)
+	    fprintf (dump_file, " (%s)\n", (char *) val2);
+	  else
+	    fprintf (dump_file, " (module_id:%d, func_id:%d)\n",
+                     EXTRACT_MODULE_ID_FROM_GLOBAL_ID (val2),
+                     EXTRACT_FUNC_ID_FROM_GLOBAL_ID (val2));
+          fprintf (dump_file, "Transformation on insn\n");
+          print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);
+          fprintf (dump_file, "=>\n");
+          print_gimple_stmt (dump_file, modify2, 0, TDF_SLIM);
+          fprintf (dump_file, "hist->count "HOST_WIDEST_INT_PRINT_DEC
+                   " hist->all "HOST_WIDEST_INT_PRINT_DEC"\n", count2,
+                   all - count1);
+        }
+    }
+
+  return true;
+}
+
+/* Perform indirect call (STMT) to guarded direct function call
+   transformation using value profile data.  */
+
+static bool
+gimple_ic_transform (gimple_stmt_iterator *gsi)
+{
+  gimple stmt = gsi_stmt (*gsi);
+  histogram_value histogram;
+  tree callee;
+
+  if (gimple_code (stmt) != GIMPLE_CALL)
+    return false;
+
+  callee = gimple_call_fn (stmt);
+
+  if (TREE_CODE (callee) == FUNCTION_DECL)
+    return false;
+
+  histogram = gimple_histogram_value_of_type (cfun, stmt, HIST_TYPE_INDIR_CALL);
+  if (!histogram)
+    {
+      histogram = gimple_histogram_value_of_type (cfun, stmt,
+                                                  HIST_TYPE_INDIR_CALL_TOPN);
+      if (!histogram)
+        return false;
+    }
+
+  if (histogram->type == HIST_TYPE_INDIR_CALL)
+    return gimple_ic_transform_single_targ (stmt, histogram);
+  else
+    return gimple_ic_transform_mult_targ (stmt, histogram);
+}
+
 /* Return true if the stringop CALL with FNDECL shall be profiled.
    SIZE_ARG be set to the argument index for the size of the string
    operation.
@@ -1713,9 +2092,13 @@ gimple_indirect_call_to_profile (gimple stmt, histogram_values *values)
 
   values->reserve (3);
 
-  values->quick_push (gimple_alloc_histogram_value (cfun, HIST_TYPE_INDIR_CALL,
-						    stmt, callee));
-
+  if (flag_dyn_ipa)
+    values->quick_push (gimple_alloc_histogram_value (cfun,
+                                                      HIST_TYPE_INDIR_CALL_TOPN,
+                                                      stmt, callee));
+  else
+    values->quick_push (gimple_alloc_histogram_value (cfun, HIST_TYPE_INDIR_CALL,
+                                                      stmt, callee));
   return;
 }
 
@@ -1799,7 +2182,7 @@ gimple_find_values_to_profile (histogram_values *values)
 	  break;
 
  	case HIST_TYPE_INDIR_CALL:
- 	  hist->n_counters = 3;
+	  hist->n_counters = 3;
 	  break;
 
 	case HIST_TYPE_AVERAGE:
@@ -1810,6 +2193,10 @@ gimple_find_values_to_profile (histogram_values *values)
 	  hist->n_counters = 1;
 	  break;
 
+ 	case HIST_TYPE_INDIR_CALL_TOPN:
+          hist->n_counters = (GCOV_ICALL_TOPN_VAL << 2) + 1;
+	  break;
+
 	default:
 	  gcc_unreachable ();
 	}
diff --git a/gcc/value-prof.h b/gcc/value-prof.h
index b6c77b6..05544da 100644
--- a/gcc/value-prof.h
+++ b/gcc/value-prof.h
@@ -33,7 +33,9 @@ enum hist_type
   HIST_TYPE_INDIR_CALL,   /* Tries to identify the function that is (almost)
 			    called in indirect call */
   HIST_TYPE_AVERAGE,	/* Compute average value (sum of all values).  */
-  HIST_TYPE_IOR		/* Used to compute expected alignment.  */
+  HIST_TYPE_IOR,	/* Used to compute expected alignment.  */
+  HIST_TYPE_INDIR_CALL_TOPN  /* Tries to identify the top N most frequently
+				called functions in indirect call.  */
 };
 
 #define COUNTER_FOR_HIST_TYPE(TYPE) ((int) (TYPE) + GCOV_FIRST_VALUE_COUNTER)
@@ -72,6 +74,8 @@ typedef vec<histogram_value> histogram_values;
 extern void gimple_find_values_to_profile (histogram_values *);
 extern bool gimple_value_profile_transformations (void);
 
+histogram_value gimple_alloc_histogram_value (struct function *, enum hist_type,
+					      gimple stmt, tree);
 histogram_value gimple_histogram_value (struct function *, gimple);
 histogram_value gimple_histogram_value_of_type (struct function *, gimple,
 						enum hist_type);
@@ -105,4 +109,3 @@ extern void branch_prob (void);
 extern void end_branch_prob (void);
 
 #endif	/* GCC_VALUE_PROF_H */
-
diff --git a/gcc/varasm.c b/gcc/varasm.c
index ea709fd..bcc2dde 100644
--- a/gcc/varasm.c
+++ b/gcc/varasm.c
@@ -49,6 +49,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "tree-mudflap.h"
 #include "cgraph.h"
 #include "pointer-set.h"
+#include "l-ipo.h"
 #include "asan.h"
 
 #ifdef XCOFF_DEBUGGING_INFO
@@ -1480,6 +1481,13 @@ notice_global_symbol (tree decl)
       || !MEM_P (DECL_RTL (decl)))
     return;
 
+  if (L_IPO_COMP_MODE
+      && ((TREE_CODE (decl) == FUNCTION_DECL
+           && cgraph_is_auxiliary (decl))
+          || (TREE_CODE (decl) == VAR_DECL
+              && varpool_is_auxiliary (varpool_get_node (decl)))))
+    return;
+
   /* We win when global object is found, but it is useful to know about weak
      symbol as well so we can produce nicer unique names.  */
   if (DECL_WEAK (decl) || DECL_ONE_ONLY (decl) || flag_shlib)
@@ -2172,6 +2180,13 @@ assemble_external (tree decl ATTRIBUTE_UNUSED)
       If it's not, we should not be calling this function.  */
   gcc_assert (asm_out_file);
 
+  /* Processing pending items from auxiliary modules are not supported
+     which means platforms that requires ASM_OUTPUT_EXTERNAL may 
+     have issues.  (TODO : one way is to flush the pending items from
+     auxiliary modules at the end of parsing the module)  */
+  if (L_IPO_IS_AUXILIARY_MODULE)
+    return;
+
   /* In a perfect world, the following condition would be true.
      Sadly, the Java and Go front ends emit assembly *from the front end*,
      bypassing the call graph.  See PR52739.  Fix before GCC 4.8.  */
@@ -2255,7 +2270,7 @@ mark_decl_referenced (tree decl)
 	 functions can be marked reachable, just use the external
 	 definition.  */
       struct cgraph_node *node = cgraph_get_create_node (decl);
-      if (!DECL_EXTERNAL (decl)
+      if (!(DECL_EXTERNAL (decl) || cgraph_is_aux_decl_external (node))
 	  && !node->local.finalized)
 	cgraph_mark_force_output_node (node);
     }
@@ -5454,6 +5469,11 @@ do_assemble_alias (tree decl, tree target)
   if (TREE_ASM_WRITTEN (decl))
     return;
 
+  if (L_IPO_COMP_MODE
+      && lookup_attribute ("weakref", DECL_ATTRIBUTES (decl))
+      && TREE_ASM_WRITTEN (DECL_ASSEMBLER_NAME (decl)))
+    return;
+
   /* We must force creation of DECL_RTL for debug info generation, even though
      we don't use it here.  */
   make_decl_rtl (decl);
@@ -5551,6 +5571,12 @@ assemble_alias (tree decl, tree target)
 {
   tree target_decl;
 
+  if (L_IPO_IS_AUXILIARY_MODULE)
+    {
+      if (!lookup_attribute ("weakref", DECL_ATTRIBUTES (decl)))
+        return;
+    }
+
   if (lookup_attribute ("weakref", DECL_ATTRIBUTES (decl)))
     {
       tree alias = DECL_ASSEMBLER_NAME (decl);
diff --git a/gcc/varpool.c b/gcc/varpool.c
index f5a905c..11fcac6 100644
--- a/gcc/varpool.c
+++ b/gcc/varpool.c
@@ -34,7 +34,9 @@ along with GCC; see the file COPYING3.  If not see
 #include "output.h"
 #include "gimple.h"
 #include "tree-flow.h"
+#include "toplev.h"
 #include "flags.h"
+#include "l-ipo.h"
 
 /* Return varpool node assigned to DECL.  Create new one when needed.  */
 struct varpool_node *
@@ -47,6 +49,7 @@ varpool_node_for_decl (tree decl)
     return node;
 
   node = ggc_alloc_cleared_varpool_node ();
+  node->module_id = current_module_id;
   node->symbol.type = SYMTAB_VARIABLE;
   node->symbol.decl = decl;
   symtab_register_node ((symtab_node)node);
@@ -57,6 +60,7 @@ varpool_node_for_decl (tree decl)
 void
 varpool_remove_node (struct varpool_node *node)
 {
+  varpool_remove_link_node (node);
   symtab_unregister_node ((symtab_node)node);
   if (DECL_INITIAL (node->symbol.decl)
       && !DECL_IN_CONSTANT_POOL (node->symbol.decl)
@@ -109,6 +113,7 @@ debug_varpool (void)
 }
 
 /* Given an assembler name, lookup node.  */
+
 struct varpool_node *
 varpool_node_for_asm (tree asmname)
 {
diff --git a/gcc/vec.h b/gcc/vec.h
index 3c1bb9a..09a1d0a 100644
--- a/gcc/vec.h
+++ b/gcc/vec.h
@@ -337,10 +337,22 @@ struct va_gc
 		       CXX_MEM_STAT_INFO);
 
   template<typename T, typename A>
-  static void release (vec<T, A, vl_embed> *&v) { v = NULL; }
+  static void release (vec<T, A, vl_embed> *&v);
 };
 
 
+/* Free GC memory used by V and reset V to NULL.  */
+
+template<typename T, typename A>
+inline void
+va_gc::release (vec<T, A, vl_embed> *&v)
+{
+  if (v)
+    ::ggc_free (v);
+  v = NULL;
+}
+
+
 /* Allocator for GC memory.  Ensure there are at least RESERVE free
    slots in V.  If EXACT is true, grow exactly, else grow
    exponentially.  As a special case, if the vector had not been
diff --git a/include/ChangeLog b/include/ChangeLog
index 9214e88..e66a9d6 100644
--- a/include/ChangeLog
+++ b/include/ChangeLog
@@ -172,6 +172,12 @@
 
 	* ansidecl.h (ENUM_BITFIELD): Always use enum in C++
 
+2012-01-26  Cary Coutant  <ccoutant@google.com>
+
+	* include/dwarf2.h (enum dwarf_form): Update Fission extensions, add
+	wiki reference.
+	(enum dwarf_attribute): Likewise.
+
 2011-09-28  Doug Evans  <dje@google.com>
 
 	* timeval-utils.h: New file.
diff --git a/include/gdb/gdb-index.h b/include/gdb/gdb-index.h
new file mode 100644
index 0000000..b43c68f
--- /dev/null
+++ b/include/gdb/gdb-index.h
@@ -0,0 +1,99 @@
+/* Public attributes of the .gdb_index section.
+   Copyright 2012 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* This file contains values for understanding the .gdb_index section
+   needed by more than just GDB, e.g. readelf.  */
+
+#ifndef GDB_INDEX_H
+#define GDB_INDEX_H
+
+/* Each symbol in .gdb_index refers to a set of CUs that defines the symbol.
+   Each CU is represented by a 32 bit number that is the index of the CU in
+   the CU table, plus some attributes of the use of the symbol in that CU.
+
+   The values are defined such that if all the bits are zero, then no
+   special meaning is assigned to any of them.  This is done to preserve
+   compatibility with older indices.  The way this is done is to specify
+   that if the GDB_INDEX_SYMBOL_KIND value is zero then all other attribute
+   bits must be zero.
+
+    0-23  CU index
+   24-27  reserved
+   28-30  symbol kind
+   31     0 == global, 1 == static
+
+   Bits 24-27 are reserved because it's easier to relax restrictions than
+   it is to impose them after the fact.  At present 24 bits to represent
+   the CU index is plenty.  If we need more bits for the CU index or for
+   attributes then we have them.  */
+
+/* Whether the symbol is in GLOBAL_BLOCK (== 0) or STATIC_BLOCK (== 1).  */
+#define GDB_INDEX_SYMBOL_STATIC_SHIFT 31
+#define GDB_INDEX_SYMBOL_STATIC_MASK 1
+#define GDB_INDEX_SYMBOL_STATIC_VALUE(cu_index) \
+  (((cu_index) >> GDB_INDEX_SYMBOL_STATIC_SHIFT) & GDB_INDEX_SYMBOL_STATIC_MASK)
+#define GDB_INDEX_SYMBOL_STATIC_SET_VALUE(cu_index, value) \
+  do { \
+    (cu_index) |= (((value) & GDB_INDEX_SYMBOL_STATIC_MASK) \
+		   << GDB_INDEX_SYMBOL_STATIC_SHIFT); \
+  } while (0)
+
+/* The kind of the symbol.
+   We don't use GDB's internal values as these numbers are published
+   so that other tools can build and read .gdb_index.  */
+
+typedef enum {
+  /* Special value to indicate no attributes are present.  */
+  GDB_INDEX_SYMBOL_KIND_NONE = 0,
+  GDB_INDEX_SYMBOL_KIND_TYPE = 1,
+  GDB_INDEX_SYMBOL_KIND_VARIABLE = 2,
+  GDB_INDEX_SYMBOL_KIND_FUNCTION = 3,
+  GDB_INDEX_SYMBOL_KIND_OTHER = 4,
+  /* We currently allocate 3 bits to record the symbol kind.
+     Give the unused bits a value so gdb will print them sensibly.  */
+  GDB_INDEX_SYMBOL_KIND_UNUSED5 = 5,
+  GDB_INDEX_SYMBOL_KIND_UNUSED6 = 6,
+  GDB_INDEX_SYMBOL_KIND_UNUSED7 = 7
+} gdb_index_symbol_kind;
+
+#define GDB_INDEX_SYMBOL_KIND_SHIFT 28
+#define GDB_INDEX_SYMBOL_KIND_MASK 7
+#define GDB_INDEX_SYMBOL_KIND_VALUE(cu_index) \
+  ((gdb_index_symbol_kind) (((cu_index) >> GDB_INDEX_SYMBOL_KIND_SHIFT) \
+			    & GDB_INDEX_SYMBOL_KIND_MASK))
+#define GDB_INDEX_SYMBOL_KIND_SET_VALUE(cu_index, value) \
+  do { \
+    (cu_index) |= (((value) & GDB_INDEX_SYMBOL_KIND_MASK) \
+		   << GDB_INDEX_SYMBOL_KIND_SHIFT); \
+  } while (0)
+
+#define GDB_INDEX_RESERVED_SHIFT 24
+#define GDB_INDEX_RESERVED_MASK 15
+#define GDB_INDEX_RESERVED_VALUE(cu_index) \
+  (((cu_index) >> GDB_INDEX_RESERVED_SHIFT) & GDB_INDEX_RESERVED_MASK)
+
+/* CU index.  */
+#define GDB_INDEX_CU_BITSIZE 24
+#define GDB_INDEX_CU_MASK ((1 << GDB_INDEX_CU_BITSIZE) - 1)
+#define GDB_INDEX_CU_VALUE(cu_index) ((cu_index) & GDB_INDEX_CU_MASK)
+#define GDB_INDEX_CU_SET_VALUE(cu_index, value) \
+  do { \
+    (cu_index) |= (value) & GDB_INDEX_CU_MASK; \
+  } while (0)
+
+#endif /* GDB_INDEX_H */
diff --git a/libatomic/configure b/libatomic/configure
index a9dfa03..a796f22 100755
--- a/libatomic/configure
+++ b/libatomic/configure
@@ -655,6 +655,7 @@ CCAS
 am__fastdepCC_FALSE
 am__fastdepCC_TRUE
 CCDEPMODE
+am__nodep
 AMDEPBACKSLASH
 AMDEP_FALSE
 AMDEP_TRUE
@@ -3044,11 +3045,11 @@ MAKEINFO=${MAKEINFO-"${am_missing_run}makeinfo"}
 
 # We need awk for the "check" target.  The system "awk" is bad on
 # some platforms.
-# Always define AMTAR for backward compatibility.
+# Always define AMTAR for backward compatibility.  Yes, it's still used
+# in the wild :-(  We should find a proper way to deprecate it ...
+AMTAR='$${TAR-tar}'
 
-AMTAR=${AMTAR-"${am_missing_run}tar"}
-
-am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'
+am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'
 
 
 
@@ -3946,6 +3947,7 @@ fi
 if test "x$enable_dependency_tracking" != xno; then
   am_depcomp="$ac_aux_dir/depcomp"
   AMDEPBACKSLASH='\'
+  am__nodep='_no'
 fi
  if test "x$enable_dependency_tracking" != xno; then
   AMDEP_TRUE=
@@ -3970,6 +3972,7 @@ else
   # instance it was reported that on HP-UX the gcc test will end up
   # making a dummy file named `D' -- because `-MD' means `put the output
   # in D'.
+  rm -rf conftest.dir
   mkdir conftest.dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
   # using a relative directory.
@@ -4029,7 +4032,7 @@ else
 	break
       fi
       ;;
-    msvisualcpp | msvcmsys)
+    msvc7 | msvc7msys | msvisualcpp | msvcmsys)
       # This compiler won't grok `-c -o', but also, the minuso test has
       # not run yet.  These depmodes are late enough in the game, and
       # so weak that their functioning should not be impacted.
@@ -4104,6 +4107,7 @@ else
   # instance it was reported that on HP-UX the gcc test will end up
   # making a dummy file named `D' -- because `-MD' means `put the output
   # in D'.
+  rm -rf conftest.dir
   mkdir conftest.dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
   # using a relative directory.
@@ -4161,7 +4165,7 @@ else
 	break
       fi
       ;;
-    msvisualcpp | msvcmsys)
+    msvc7 | msvc7msys | msvisualcpp | msvcmsys)
       # This compiler won't grok `-c -o', but also, the minuso test has
       # not run yet.  These depmodes are late enough in the game, and
       # so weak that their functioning should not be impacted.
@@ -7614,7 +7618,22 @@ fi
 
 # Check whether --with-pic was given.
 if test "${with_pic+set}" = set; then :
-  withval=$with_pic; pic_mode="$withval"
+  withval=$with_pic; p=${PACKAGE-default}
+    case "$withval" in
+    yes|no) pic_mode="$withval" ;;
+    *)
+      pic_mode=default
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $withval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  pic_mode=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
 else
   pic_mode=default
 fi
@@ -11013,7 +11032,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11016 "configure"
+#line 11035 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11119,7 +11138,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11122 "configure"
+#line 11141 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -15125,6 +15144,8 @@ fi
 
 ac_config_files="$ac_config_files Makefile testsuite/Makefile"
 
+ac_config_files="$ac_config_files testsuite/atomicconfig.exp"
+
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
 # tests run on this system so they can be shared between configure
@@ -16173,6 +16194,7 @@ do
     "gstdint.h") CONFIG_COMMANDS="$CONFIG_COMMANDS gstdint.h" ;;
     "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
     "testsuite/Makefile") CONFIG_FILES="$CONFIG_FILES testsuite/Makefile" ;;
+    "testsuite/atomicconfig.exp") CONFIG_FILES="$CONFIG_FILES testsuite/atomicconfig.exp" ;;
 
   *) as_fn_error "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
   esac
diff --git a/libatomic/configure.ac b/libatomic/configure.ac
index 0dc4a98..3e6165b 100644
--- a/libatomic/configure.ac
+++ b/libatomic/configure.ac
@@ -254,4 +254,5 @@ else
 fi
 
 AC_CONFIG_FILES(Makefile testsuite/Makefile)
+AC_CONFIG_FILES(testsuite/atomicconfig.exp)
 AC_OUTPUT
diff --git a/libatomic/testsuite/atomicconfig.exp.in b/libatomic/testsuite/atomicconfig.exp.in
new file mode 100644
index 0000000..5a5b7cc
--- /dev/null
+++ b/libatomic/testsuite/atomicconfig.exp.in
@@ -0,0 +1,2 @@
+global GCC_UNDER_TEST
+set GCC_UNDER_TEST "@CC@"
diff --git a/libatomic/testsuite/config/default.exp b/libatomic/testsuite/config/default.exp
index b98cbd2..adfd1e9 100644
--- a/libatomic/testsuite/config/default.exp
+++ b/libatomic/testsuite/config/default.exp
@@ -15,3 +15,4 @@
 # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 
 load_lib "standard.exp"
+load_lib "atomicconfig.exp"
diff --git a/libatomic/testsuite/lib/libatomic.exp b/libatomic/testsuite/lib/libatomic.exp
index 23c3b08..1b53ec6 100644
--- a/libatomic/testsuite/lib/libatomic.exp
+++ b/libatomic/testsuite/lib/libatomic.exp
@@ -120,7 +120,7 @@ proc libatomic_init { args } {
 	set compiler [lindex $GCC_UNDER_TEST 0]
 
 	if { [is_remote host] == 0 && [which $compiler] != 0 } {
-	  foreach i "[exec $compiler --print-multi-lib]" {
+	  foreach i "[eval "exec $GCC_UNDER_TEST --print-multi-lib"]" {
 	    set mldir ""
 	    regexp -- "\[a-z0-9=_/\.-\]*;" $i mldir
 	    set mldir [string trimright $mldir "\;@"]
diff --git a/libcpp/files.c b/libcpp/files.c
index 5c5a0b9..ea91b02 100644
--- a/libcpp/files.c
+++ b/libcpp/files.c
@@ -983,6 +983,7 @@ _cpp_stack_include (cpp_reader *pfile, const char *fname, int angle_brackets,
 {
   struct cpp_dir *dir;
   _cpp_file *file;
+  bool stacked;
 
   dir = search_path_head (pfile, fname, angle_brackets, type);
   if (!dir)
@@ -993,19 +994,26 @@ _cpp_stack_include (cpp_reader *pfile, const char *fname, int angle_brackets,
   if (type == IT_DEFAULT && file == NULL)
     return false;
 
-  /* Compensate for the increment in linemap_add that occurs in
-     _cpp_stack_file.  In the case of a normal #include, we're
-     currently at the start of the line *following* the #include.  A
-     separate source_location for this location makes no sense (until
-     we do the LC_LEAVE), and complicates LAST_SOURCE_LINE_LOCATION.
-     This does not apply if we found a PCH file (in which case
-     linemap_add is not called) or we were included from the
-     command-line.  */
+  /* Compensate for the increment in linemap_add that occurs if
+      _cpp_stack_file actually stacks the file.  In the case of a
+     normal #include, we're currently at the start of the line
+     *following* the #include.  A separate source_location for this
+     location makes no sense (until we do the LC_LEAVE), and
+     complicates LAST_SOURCE_LINE_LOCATION.  This does not apply if we
+     found a PCH file (in which case linemap_add is not called) or we
+     were included from the command-line.  */
   if (file->pchname == NULL && file->err_no == 0
       && type != IT_CMDLINE && type != IT_DEFAULT)
     pfile->line_table->highest_location--;
 
-  return _cpp_stack_file (pfile, file, type == IT_IMPORT);
+  stacked = _cpp_stack_file (pfile, file, type == IT_IMPORT);
+
+  if (!stacked)
+    /* _cpp_stack_file didn't stack the file, so let's rollback the
+       compensation dance we performed above.  */
+    pfile->line_table->highest_location++;
+
+  return stacked;
 }
 
 /* Could not open FILE.  The complication is dependency output.  */
diff --git a/libdecnumber/configure b/libdecnumber/configure
index 0466371..e24b81d 100755
--- a/libdecnumber/configure
+++ b/libdecnumber/configure
@@ -2220,6 +2220,29 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
 
+ac_aux_dir=
+for ac_dir in .. "$srcdir"/..; do
+  for ac_t in install-sh install.sh shtool; do
+    if test -f "$ac_dir/$ac_t"; then
+      ac_aux_dir=$ac_dir
+      ac_install_sh="$ac_aux_dir/$ac_t -c"
+      break 2
+    fi
+  done
+done
+if test -z "$ac_aux_dir"; then
+  as_fn_error "cannot find install-sh, install.sh, or shtool in .. \"$srcdir\"/.." "$LINENO" 5
+fi
+
+# These three variables are undocumented and unsupported,
+# and are intended to be withdrawn in a future Autoconf release.
+# They can cause serious problems if a builder's source tree is in a directory
+# whose full name contains unusual characters.
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
+ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
+
+
 
 # Checks for programs.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ${MAKE-make} sets \$(MAKE)" >&5
@@ -4458,29 +4481,6 @@ else
 fi
 
 
-ac_aux_dir=
-for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
-  for ac_t in install-sh install.sh shtool; do
-    if test -f "$ac_dir/$ac_t"; then
-      ac_aux_dir=$ac_dir
-      ac_install_sh="$ac_aux_dir/$ac_t -c"
-      break 2
-    fi
-  done
-done
-if test -z "$ac_aux_dir"; then
-  as_fn_error "cannot find install-sh, install.sh, or shtool in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" "$LINENO" 5
-fi
-
-# These three variables are undocumented and unsupported,
-# and are intended to be withdrawn in a future Autoconf release.
-# They can cause serious problems if a builder's source tree is in a directory
-# whose full name contains unusual characters.
-ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
-ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
-ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
-
-
 # Make sure we can run config.sub.
 $SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
   as_fn_error "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
diff --git a/libdecnumber/configure.ac b/libdecnumber/configure.ac
index a6f7f07..6cfc803 100644
--- a/libdecnumber/configure.ac
+++ b/libdecnumber/configure.ac
@@ -23,6 +23,7 @@ AC_PREREQ(2.64)
 AC_INIT(libdecnumber, [ ], gcc-bugs@gcc.gnu.org, libdecnumber)
 AC_CONFIG_SRCDIR(decNumber.h)
 AC_CONFIG_MACRO_DIR(../config)
+AC_CONFIG_AUX_DIR(..)
 
 # Checks for programs.
 AC_PROG_MAKE_SET
diff --git a/libffi/configure b/libffi/configure
index ce6c8ad..9656e0e 100755
--- a/libffi/configure
+++ b/libffi/configure
@@ -7501,7 +7501,22 @@ fi
 
 # Check whether --with-pic was given.
 if test "${with_pic+set}" = set; then :
-  withval=$with_pic; pic_mode="$withval"
+  withval=$with_pic; p=${PACKAGE-default}
+    case "$withval" in
+    yes|no) pic_mode="$withval" ;;
+    *)
+      pic_mode=default
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $withval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  pic_mode=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
 else
   pic_mode=default
 fi
@@ -10900,7 +10915,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10903 "configure"
+#line 10918 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11006,7 +11021,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11009 "configure"
+#line 11024 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
diff --git a/libgcc/Makefile.in b/libgcc/Makefile.in
index ba1a975..7681e5b 100644
--- a/libgcc/Makefile.in
+++ b/libgcc/Makefile.in
@@ -335,6 +335,12 @@ LIBUNWIND =
 SHLIBUNWIND_LINK =
 SHLIBUNWIND_INSTALL =
 
+# For -fvisibility=hidden.  We need both a -fvisibility=hidden on
+# the command line, and a #define to prevent libgcc2.h etc from
+# overriding that with #pragmas.  This is set before including $(tmake_file)
+# so it can be overridden on a host-specific basis.
+vis_hide = @vis_hide@
+
 tmake_file = @tmake_file@
 include $(srcdir)/empty.mk $(tmake_file)
 
@@ -865,17 +871,22 @@ LIBGCOV = _gcov _gcov_merge_add _gcov_merge_single _gcov_merge_delta \
     _gcov_execv _gcov_execvp _gcov_execve _gcov_reset _gcov_dump \
     _gcov_interval_profiler _gcov_pow2_profiler _gcov_one_value_profiler \
     _gcov_indirect_call_profiler _gcov_average_profiler _gcov_ior_profiler \
-    _gcov_merge_ior
+    _gcov_indirect_call_profiler _gcov_direct_call_profiler \
+    _gcov_average_profiler _gcov_ior_profiler _gcov_merge_ior _gcov_merge_dc \
+    _gcov_merge_icall_topn _gcov_indirect_call_topn_profiler \
+    _gcov_merge_reusedist
 
 libgcov-objects = $(patsubst %,%$(objext),$(LIBGCOV))
 
+dyn-ipa.o: %$(objext): $(srcdir)/libgcov.c
+	$(gcc_compile)  -c $(srcdir)/dyn-ipa.c
+
 $(libgcov-objects): %$(objext): $(srcdir)/libgcov.c
 	$(gcc_compile) -DL$* -c $(srcdir)/libgcov.c
 
-
 # Static libraries.
 libgcc.a: $(libgcc-objects)
-libgcov.a: $(libgcov-objects)
+libgcov.a: $(libgcov-objects) dyn-ipa$(objext)
 libunwind.a: $(libunwind-objects)
 libgcc_eh.a: $(libgcc-eh-objects)
 
@@ -1092,6 +1103,18 @@ install-leaf: $(install-shared) $(install-libunwind)
 	  esac;							\
 	done
 
+	if [ "$(MULTIDIR)" == "." ]; then			\
+	  gcov_src_dest="$(DESTDIR)$(inst_libdir)/gcov-src";	\
+	  $(mkinstalldirs) $$gcov_src_dest;			\
+	  cp ../../gcc/gcov-iov.h $$gcov_src_dest;		\
+	  cp $(srcdir)/../gcc/gcov-io.h $$gcov_src_dest;	\
+	  cp $(srcdir)/../gcc/gcov-io.c $$gcov_src_dest;	\
+	  cp $(srcdir)/libgcov.c $$gcov_src_dest;		\
+	  chmod 644 $$gcov_src_dest/gcov-iov.h			\
+	  $$gcov_src_dest/gcov-io.h $$gcov_src_dest/gcov-io.c	\
+	  $$gcov_src_dest/libgcov.c;				\
+	fi
+
 install: install-leaf install-unwind_h
 	@: $(MAKE) ; $(MULTIDO) $(FLAGS_TO_PASS) multi-do DO=install
 
diff --git a/libgcc/config.host b/libgcc/config.host
index 86255e6..6b68ae1 100644
--- a/libgcc/config.host
+++ b/libgcc/config.host
@@ -1168,3 +1168,10 @@ i[34567]86-*-linux* | x86_64-*-linux*)
 	tm_file="${tm_file} i386/value-unwind.h"
 	;;
 esac
+
+case ${host} in
+*-grtev3-*)
+	# Don't hide symbols in static libraries.
+	tmake_file="${tmake_file} t-static-no-vis-hide"
+	;;
+esac
diff --git a/libgcc/config/t-static-no-vis-hide b/libgcc/config/t-static-no-vis-hide
new file mode 100644
index 0000000..955ff35
--- /dev/null
+++ b/libgcc/config/t-static-no-vis-hide
@@ -0,0 +1,2 @@
+# Don't hide symbols in static libraries.
+vis_hide =
diff --git a/libgcc/dyn-ipa.c b/libgcc/dyn-ipa.c
new file mode 100644
index 0000000..1c29d48
--- /dev/null
+++ b/libgcc/dyn-ipa.c
@@ -0,0 +1,2406 @@
+/* Compile this one with gcc.  */
+/* Copyright (C) 2009. Free Software Foundation, Inc.
+   Contributed by Xinliang David Li (davidxl@google.com) and
+                  Raksit Ashok  (raksit@google.com)
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#include "tconfig.h"
+#include "tsystem.h"
+#include "coretypes.h"
+#include "tm.h"
+
+#if defined(inhibit_libc)
+#define IN_LIBGCOV (-1)
+#else
+#undef NULL /* Avoid errors if stdio.h and our stddef.h mismatch.  */
+#include <stdio.h>
+#include <stdlib.h>
+#define IN_LIBGCOV 1
+#if defined(L_gcov)
+#define GCOV_LINKAGE /* nothing */
+#endif
+#endif
+#include "gcov-io.h"
+
+struct dyn_pointer_set;
+
+#define XNEWVEC(type,ne) (type *)malloc(sizeof(type) * (ne))
+#define XCNEWVEC(type,ne) (type *)calloc(1, sizeof(type) * (ne))
+#define XNEW(type) (type *)malloc(sizeof(type))
+#define XDELETEVEC(p) free(p)
+#define XDELETE(p) free(p)
+
+struct dyn_cgraph_node
+{
+  struct dyn_cgraph_edge *callees;
+  struct dyn_cgraph_edge *callers;
+  struct dyn_pointer_set *imported_modules;
+
+  gcov_type guid;
+  gcov_type sum_in_count;
+  gcov_unsigned_t visited;
+};
+
+struct dyn_cgraph_edge
+{
+  struct dyn_cgraph_node *caller;
+  struct dyn_cgraph_node *callee;
+  struct dyn_cgraph_edge *next_caller;
+  struct dyn_cgraph_edge *next_callee;
+  gcov_type count;
+};
+
+struct dyn_module_info
+{
+  struct dyn_pointer_set *imported_modules;
+  gcov_unsigned_t max_func_ident;
+
+  /* Used by new algorithm. This dyn_pointer_set only
+     stored the gcov_info pointer, keyed by
+     module ident.  */
+  struct dyn_pointer_set *exported_to;
+  gcov_unsigned_t group_ggc_mem;
+};
+
+struct dyn_cgraph
+{
+  struct dyn_pointer_set **call_graph_nodes;
+  struct gcov_info **modules;
+  /* supplement module information  */
+  struct dyn_module_info *sup_modules;
+  unsigned num_modules;
+  unsigned num_nodes_executed;
+  /* used by new algorithm  */
+  struct modu_node *modu_nodes;
+};
+
+/* Module info is stored in dyn_caph->sup_modules
+   which is indexed by m_ix.  */
+struct modu_node
+{
+  struct gcov_info *module;
+  struct modu_edge *callees;
+  struct modu_edge *callers;
+};
+
+struct modu_edge
+{
+  struct modu_node *caller;
+  struct modu_node *callee;
+  struct modu_edge *next_caller;
+  struct modu_edge *next_callee;
+  unsigned n_edges;  /* used when combining edges */
+  gcov_type sum_count;
+  unsigned char visited;
+};
+
+struct dyn_pointer_set
+{
+  size_t log_slots;
+  size_t n_slots;		/* n_slots = 2^log_slots */
+  size_t n_elements;
+
+  void **slots;
+  unsigned (*get_key) (const void *);
+};
+
+typedef long dyn_fibheapkey_t;
+
+typedef struct dyn_fibheap
+{
+  size_t nodes;
+  struct fibnode *min;
+  struct fibnode *root;
+} *dyn_fibheap_t;
+
+typedef struct fibnode
+{
+  struct fibnode *parent;
+  struct fibnode *child;
+  struct fibnode *left;
+  struct fibnode *right;
+  dyn_fibheapkey_t key;
+  void *data;
+  unsigned int degree : 31;
+  unsigned int mark : 1;
+} *fibnode_t;
+
+static dyn_fibheap_t dyn_fibheap_new (void);
+static fibnode_t dyn_fibheap_insert (dyn_fibheap_t, dyn_fibheapkey_t, void *);
+static void *dyn_fibheap_extract_min (dyn_fibheap_t);
+
+extern gcov_unsigned_t __gcov_lipo_cutoff;
+extern gcov_unsigned_t __gcov_lipo_random_seed;
+extern gcov_unsigned_t __gcov_lipo_random_group_size;
+extern gcov_unsigned_t __gcov_lipo_propagate_scale;
+extern gcov_unsigned_t __gcov_lipo_dump_cgraph;
+extern gcov_unsigned_t __gcov_lipo_max_mem;
+extern gcov_unsigned_t __gcov_lipo_grouping_algorithm;
+extern gcov_unsigned_t __gcov_lipo_merge_modu_edges;
+extern gcov_unsigned_t __gcov_lipo_weak_inclusion;
+
+#if defined(inhibit_libc)
+__gcov_build_callgraph (void) {}
+#else
+
+void __gcov_compute_module_groups (void) ATTRIBUTE_HIDDEN;
+void __gcov_finalize_dyn_callgraph (void) ATTRIBUTE_HIDDEN;
+static void gcov_dump_callgraph (gcov_type);
+static void gcov_dump_cgraph_node_short (struct dyn_cgraph_node *node);
+static void gcov_dump_cgraph_node (struct dyn_cgraph_node *node,
+                                  unsigned m, unsigned f);
+static int do_cgraph_dump (void);
+
+static void
+gcov_dump_cgraph_node_dot (struct dyn_cgraph_node *node,
+                           unsigned m, unsigned f,
+                           gcov_type cutoff_count);
+static void
+pointer_set_destroy (struct dyn_pointer_set *pset);
+static void
+pointer_set_destroy_not_free_value_pointer (struct dyn_pointer_set *);
+static void **
+pointer_set_find_or_insert (struct dyn_pointer_set *pset, unsigned key);
+static struct dyn_pointer_set *
+pointer_set_create (unsigned (*get_key) (const void *));
+
+static struct dyn_cgraph the_dyn_call_graph;
+static int total_zero_count = 0;
+static int total_insane_count = 0;
+
+enum GROUPING_ALGORITHM
+{
+  EAGER_PROPAGATION_ALGORITHM=0,
+  INCLUSION_BASED_PRIORITY_ALGORITHM
+};
+static int flag_alg_mode;
+static int flag_modu_merge_edges;
+static int flag_weak_inclusion;
+static gcov_unsigned_t mem_threshold;
+
+/* Returns 0 if no dump is enabled. Returns 1 if text form graph
+   dump is enabled. Returns 2 if .dot form dump is enabled.  */
+
+static int
+do_cgraph_dump (void)
+{
+  const char *dyn_cgraph_dump = 0;
+
+  if (__gcov_lipo_dump_cgraph)
+    return __gcov_lipo_dump_cgraph;
+
+  dyn_cgraph_dump = getenv ("GCOV_DYN_CGRAPH_DUMP");
+
+  if (!dyn_cgraph_dump || !strlen (dyn_cgraph_dump))
+     return 0;
+
+  if (dyn_cgraph_dump[0] == '1')
+     return 1;
+  if (dyn_cgraph_dump[0] == '2')
+     return 2;
+
+  return 0;
+}
+
+static void
+init_dyn_cgraph_node (struct dyn_cgraph_node *node, gcov_type guid)
+{
+  node->callees = 0;
+  node->callers = 0;
+  node->imported_modules = 0;
+  node->guid = guid;
+  node->visited = 0;
+}
+
+/* Return module_id. FUNC_GUID is the global unique id.  
+   This id is 1 based. 0 is the invalid id.  */
+
+static inline gcov_unsigned_t
+get_module_ident_from_func_glob_uid (gcov_type func_guid)
+{
+  return EXTRACT_MODULE_ID_FROM_GLOBAL_ID (func_guid);
+}
+
+/* Return module_id for MODULE_INFO.  */
+
+static inline gcov_unsigned_t
+get_module_ident (const struct gcov_info *module_info)
+{
+  return module_info->mod_info->ident;
+}
+
+/* Return intra-module function id given function global unique id
+   FUNC_GUID.  */
+
+static inline gcov_unsigned_t
+get_intra_module_func_id (gcov_type func_guid)
+{
+  return EXTRACT_FUNC_ID_FROM_GLOBAL_ID (func_guid);
+}
+
+/* Return the pointer to the dynamic call graph node for FUNC_GUID.  */
+
+static inline struct dyn_cgraph_node *
+get_cgraph_node (gcov_type func_guid)
+{
+  gcov_unsigned_t mod_idx, func_id;
+
+  mod_idx = get_module_ident_from_func_glob_uid (func_guid) - 1;
+
+  /* This is to workaround: calls in __static_initialization_and_destruction
+     should not be instrumented as the module id context for the callees have
+     not setup yet -- this leads to mod_idx == (unsigned) (0 - 1). Multithreaded
+     programs may also produce insane func_guid in the profile counter.  */
+  if (mod_idx >= the_dyn_call_graph.num_modules)
+    return 0;
+
+  func_id = get_intra_module_func_id (func_guid);
+  if (func_id > the_dyn_call_graph.sup_modules[mod_idx].max_func_ident)
+    return 0;
+
+  return *(pointer_set_find_or_insert
+	   (the_dyn_call_graph.call_graph_nodes[mod_idx], func_id));
+}
+
+static inline unsigned
+imp_mod_get_key (const void *p)
+{
+  return ((const struct dyn_imp_mod *) p)->imp_mod->mod_info->ident;
+}
+
+static int
+imp_mod_set_insert (struct dyn_pointer_set *p, const struct gcov_info *imp_mod,
+		    double wt)
+{
+  struct dyn_imp_mod **m = (struct dyn_imp_mod **)
+    pointer_set_find_or_insert (p, get_module_ident (imp_mod));
+  if (*m)
+    {
+      (*m)->weight += wt;
+      return 1;
+    }
+  else
+    {
+      *m = XNEW (struct dyn_imp_mod);
+      (*m)->imp_mod = imp_mod;
+      (*m)->weight = wt;
+      p->n_elements++;
+      return 0;
+    }
+}
+
+/* Return the gcov_info pointer for module with id MODULE_ID.  */
+
+static inline struct gcov_info *
+get_module_info (gcov_unsigned_t module_id)
+{
+  return the_dyn_call_graph.modules[module_id - 1];
+}
+
+struct gcov_info *__gcov_list ATTRIBUTE_HIDDEN;
+
+static inline unsigned
+cgraph_node_get_key (const void *p)
+{
+  return get_intra_module_func_id (((const struct dyn_cgraph_node *) p)->guid);
+}
+
+static inline unsigned
+gcov_info_get_key (const void *p)
+{
+  return get_module_ident ((const struct gcov_info *)p);
+}
+
+static struct dyn_pointer_set *
+get_exported_to (unsigned module_ident)
+{
+  gcc_assert (module_ident != 0);
+  return the_dyn_call_graph.sup_modules[module_ident - 1].exported_to;
+}
+
+static struct dyn_pointer_set *
+create_exported_to (unsigned module_ident)
+{
+  struct dyn_pointer_set *p;
+
+  gcc_assert (module_ident != 0);
+  p = pointer_set_create (gcov_info_get_key);
+  the_dyn_call_graph.sup_modules[module_ident - 1].exported_to = p;
+  return p;
+}
+
+static struct dyn_pointer_set *
+get_imported_modus (unsigned module_ident)
+{
+  struct dyn_pointer_set *p;
+  struct gcov_info *gi_ptr;
+
+  gcc_assert (module_ident != 0);
+  p = the_dyn_call_graph.sup_modules[module_ident - 1].imported_modules;
+
+  if (p)
+    return p;
+
+  the_dyn_call_graph.sup_modules[module_ident - 1].imported_modules = p
+    = pointer_set_create (imp_mod_get_key);
+
+  gi_ptr = the_dyn_call_graph.modules[module_ident - 1];
+  /* make the modules an auxiliay module to itself.  */
+  imp_mod_set_insert (p, gi_ptr, 0);
+
+  return p;
+}
+
+/* Initialize dynamic call graph.  */
+
+static void
+init_dyn_call_graph (void)
+{
+  unsigned num_modules = 0;
+  struct gcov_info *gi_ptr;
+  const char *env_str;
+  int do_dump = (do_cgraph_dump () != 0);
+
+  the_dyn_call_graph.call_graph_nodes = 0;
+  the_dyn_call_graph.modules = 0;
+  the_dyn_call_graph.num_nodes_executed = 0;
+
+  flag_alg_mode = __gcov_lipo_grouping_algorithm;
+  flag_modu_merge_edges = __gcov_lipo_merge_modu_edges;
+  flag_weak_inclusion = __gcov_lipo_weak_inclusion;
+  mem_threshold = __gcov_lipo_max_mem * 1.25;
+
+  gi_ptr = __gcov_list;
+
+  for (; gi_ptr; gi_ptr = gi_ptr->next)
+    num_modules++;
+
+  the_dyn_call_graph.num_modules = num_modules;
+
+  the_dyn_call_graph.modules
+    = XNEWVEC (struct gcov_info *, num_modules);
+
+  the_dyn_call_graph.sup_modules
+    = XNEWVEC (struct dyn_module_info, num_modules);
+  memset (the_dyn_call_graph.sup_modules, 0,
+          num_modules * sizeof (struct dyn_module_info));
+
+  the_dyn_call_graph.call_graph_nodes
+    = XNEWVEC (struct dyn_pointer_set *, num_modules);
+
+  gi_ptr = __gcov_list;
+
+  if ((env_str = getenv ("GCOV_DYN_ALG")))
+    {
+      flag_alg_mode = atoi (env_str);
+
+      if ((env_str = getenv ("GCOV_DYN_MERGE_EDGES")))
+        flag_modu_merge_edges = atoi (env_str);
+
+      if ((env_str = getenv ("GCOV_DYN_WEAK_INCLUSION")))
+        flag_weak_inclusion = atoi (env_str);
+
+      if (do_dump)
+	fprintf (stderr, 
+            "!!!! Using ALG=%d merge_edges=%d weak_inclusion=%d. \n",
+            flag_alg_mode, flag_modu_merge_edges, flag_weak_inclusion);
+    }
+
+  if (do_dump)
+    fprintf (stderr, "Group mem limit: %u KB \n",
+             __gcov_lipo_max_mem);
+
+  for (; gi_ptr; gi_ptr = gi_ptr->next)
+    {
+      /* mod_idx is module_ident - 1.  */
+      unsigned j, mod_id, mod_idx, max_func_ident = 0;
+      struct dyn_cgraph_node *node;
+
+      /* initialize flags field.  */
+      gi_ptr->mod_info->flags = 0;
+
+      mod_id = get_module_ident (gi_ptr);
+      if (do_dump)
+        fprintf (stderr, "Module %s %d uses %u KB memory in parsing\n",
+	         gi_ptr->mod_info->source_filename, mod_id,
+		 gi_ptr->mod_info->ggc_memory);
+
+      if (mod_id == 0)
+        {
+          fprintf (stderr, "Bad module_ident of 0. Skipping.\n");
+          continue;
+        }
+      mod_idx = mod_id - 1;
+
+      the_dyn_call_graph.modules[mod_idx] = gi_ptr;
+
+      the_dyn_call_graph.call_graph_nodes[mod_idx]
+	= pointer_set_create (cgraph_node_get_key);
+
+      for (j = 0; j < gi_ptr->n_functions; j++)
+	{
+          const struct gcov_fn_info *fi_ptr = gi_ptr->functions[j];
+	  *(pointer_set_find_or_insert
+	    (the_dyn_call_graph.call_graph_nodes[mod_idx], fi_ptr->ident))
+	    = node = XNEW (struct dyn_cgraph_node);
+	  the_dyn_call_graph.call_graph_nodes[mod_idx]->n_elements++;
+	  init_dyn_cgraph_node (node, GEN_FUNC_GLOBAL_ID (gi_ptr->mod_info->ident,
+							  fi_ptr->ident));
+          if (fi_ptr->ident > max_func_ident)
+            max_func_ident = fi_ptr->ident;
+	}
+      the_dyn_call_graph.sup_modules[mod_idx].max_func_ident = max_func_ident;
+      if (flag_alg_mode == INCLUSION_BASED_PRIORITY_ALGORITHM)
+        {
+          struct dyn_module_info *sup_module =
+	    &(the_dyn_call_graph.sup_modules[mod_idx]);
+
+          sup_module->group_ggc_mem = gi_ptr->mod_info->ggc_memory;
+          sup_module->imported_modules = 0;
+          sup_module->exported_to = 0;
+        }
+    }
+}
+
+/* Free up memory allocated for dynamic call graph.  */
+
+void
+__gcov_finalize_dyn_callgraph (void)
+{
+  unsigned i;
+  struct gcov_info *gi_ptr;
+
+  for (i = 0; i < the_dyn_call_graph.num_modules; i++)
+    {
+      gi_ptr = the_dyn_call_graph.modules[i];
+      const struct gcov_fn_info *fi_ptr;
+      unsigned f_ix;
+      for (f_ix = 0; f_ix < gi_ptr->n_functions; f_ix++)
+        {
+          struct dyn_cgraph_node *node;
+          struct dyn_cgraph_edge *callees, *next_callee;
+          fi_ptr = gi_ptr->functions[f_ix];
+          node = *(pointer_set_find_or_insert
+                   (the_dyn_call_graph.call_graph_nodes[i], fi_ptr->ident));
+          gcc_assert (node);
+          callees = node->callees;
+
+          if (!callees)
+            continue;
+          while (callees != 0)
+            {
+              next_callee = callees->next_callee;
+              XDELETE (callees);
+              callees = next_callee;
+            }
+	  if (node->imported_modules)
+	    pointer_set_destroy (node->imported_modules);
+        }
+      if (the_dyn_call_graph.call_graph_nodes[i])
+        pointer_set_destroy (the_dyn_call_graph.call_graph_nodes[i]);
+      /* Now delete sup modules */
+      if (the_dyn_call_graph.sup_modules[i].imported_modules)
+        pointer_set_destroy (the_dyn_call_graph.sup_modules[i].imported_modules);
+      if (flag_alg_mode == INCLUSION_BASED_PRIORITY_ALGORITHM
+          && the_dyn_call_graph.sup_modules[i].exported_to)
+        pointer_set_destroy_not_free_value_pointer
+          (the_dyn_call_graph.sup_modules[i].exported_to);
+    }
+  XDELETEVEC (the_dyn_call_graph.call_graph_nodes);
+  XDELETEVEC (the_dyn_call_graph.sup_modules);
+  XDELETEVEC (the_dyn_call_graph.modules);
+}
+
+/* Add outgoing edge OUT_EDGE for caller node CALLER.  */
+
+static void
+gcov_add_out_edge (struct dyn_cgraph_node *caller,
+		   struct dyn_cgraph_edge *out_edge)
+{
+  if (!caller->callees)
+    caller->callees = out_edge;
+  else
+    {
+      out_edge->next_callee = caller->callees;
+      caller->callees = out_edge;
+    }
+}
+
+/* Add incoming edge IN_EDGE for callee node CALLEE.  */
+
+static void
+gcov_add_in_edge (struct dyn_cgraph_node *callee,
+		  struct dyn_cgraph_edge *in_edge)
+{
+  if (!callee->callers)
+    callee->callers = in_edge;
+  else
+    {
+      in_edge->next_caller = callee->callers;
+      callee->callers = in_edge;
+    }
+}
+
+/* Add a call graph edge between caller CALLER and callee CALLEE.
+   The edge count is COUNT.  */
+
+static void
+gcov_add_cgraph_edge (struct dyn_cgraph_node *caller,
+		      struct dyn_cgraph_node *callee,
+		      gcov_type count)
+{
+  struct dyn_cgraph_edge *new_edge = XNEW (struct dyn_cgraph_edge);
+  new_edge->caller = caller;
+  new_edge->callee = callee;
+  new_edge->count = count;
+  new_edge->next_caller = 0;
+  new_edge->next_callee = 0;
+
+  gcov_add_out_edge (caller, new_edge);
+  gcov_add_in_edge (callee, new_edge);
+}
+
+/* Add call graph edges from direct calls for caller CALLER. DIR_CALL_COUNTERS
+   is the array of call counters. N_COUNTS is the number of counters.  */
+
+static void
+gcov_build_callgraph_dc_fn (struct dyn_cgraph_node *caller,
+                            gcov_type *dir_call_counters,
+                            unsigned n_counts)
+{
+  unsigned i;
+
+  for (i = 0; i < n_counts; i += 2)
+    {
+      struct dyn_cgraph_node *callee;
+      gcov_type count;
+      gcov_type callee_guid = dir_call_counters[i];
+
+      count = dir_call_counters[i + 1];
+      if (count == 0)
+        {
+          total_zero_count++;
+          continue;
+        }
+      callee = get_cgraph_node (callee_guid);
+      if (!callee)
+        {
+          total_insane_count++;
+          continue;
+        }
+      gcov_add_cgraph_edge (caller, callee, count);
+    }
+}
+
+/* Add call graph edges from indirect calls for caller CALLER. ICALL_COUNTERS
+   is the array of icall counters. N_COUNTS is the number of counters.  */
+
+static void
+gcov_build_callgraph_ic_fn (struct dyn_cgraph_node *caller,
+                            gcov_type *icall_counters,
+                            unsigned n_counts)
+{
+  unsigned i, j;
+
+  for (i = 0; i < n_counts; i += GCOV_ICALL_TOPN_NCOUNTS)
+    {
+      gcov_type *value_array = &icall_counters[i + 1];
+      for (j = 0; j < GCOV_ICALL_TOPN_NCOUNTS - 1; j += 2)
+        {
+          struct dyn_cgraph_node *callee;
+          gcov_type count;
+          gcov_type callee_guid = value_array[j];
+
+          count = value_array[j + 1];
+	  /* Do not update zero count edge count
+	   * as it means there is no target in this entry.  */
+          if (count == 0)
+            continue;
+          callee = get_cgraph_node (callee_guid);
+          if (!callee)
+	    {
+              total_insane_count++;
+              continue;
+	    }
+          gcov_add_cgraph_edge (caller, callee, count);
+        }
+    }
+}
+
+/* Build the dynamic call graph.  */
+
+static void
+gcov_build_callgraph (void)
+{
+  struct gcov_info *gi_ptr;
+  unsigned m_ix;
+
+  init_dyn_call_graph ();
+
+  for (m_ix = 0; m_ix < the_dyn_call_graph.num_modules; m_ix++)
+    {
+      const struct gcov_fn_info *fi_ptr;
+      unsigned f_ix, i;
+
+      gi_ptr = the_dyn_call_graph.modules[m_ix];
+
+      for (f_ix = 0; f_ix < gi_ptr->n_functions; f_ix++)
+        {
+          struct dyn_cgraph_node *caller;
+          const struct gcov_ctr_info *ci_ptr = 0;
+
+          fi_ptr = gi_ptr->functions[f_ix];
+          ci_ptr = fi_ptr->ctrs;
+
+          caller = *(pointer_set_find_or_insert
+                    (the_dyn_call_graph.call_graph_nodes[m_ix],
+                     fi_ptr->ident));
+          gcc_assert (caller);
+
+          for (i = 0; i < GCOV_COUNTERS; i++)
+            {
+              if (!gi_ptr->merge[i])
+                continue;
+              if (i == GCOV_COUNTER_DIRECT_CALL)
+                gcov_build_callgraph_dc_fn (caller, ci_ptr->values, ci_ptr->num);
+
+              if (i == GCOV_COUNTER_ICALL_TOPNV)
+                gcov_build_callgraph_ic_fn (caller, ci_ptr->values, ci_ptr->num);
+
+              if (i == GCOV_COUNTER_ARCS && 0)
+                {
+                  gcov_type total_arc_count = 0;
+                  unsigned arc;
+                  for (arc = 0; arc < ci_ptr->num; arc++)
+                    total_arc_count += ci_ptr->values[arc];
+                  if (total_arc_count != 0)
+                    the_dyn_call_graph.num_nodes_executed++;
+                }
+              ci_ptr++;
+            }
+        }
+    }
+}
+
+static inline size_t
+hash1 (unsigned p, unsigned long max, unsigned long logmax)
+{
+  const unsigned long long A = 0x9e3779b97f4a7c16ull;
+  const unsigned long long shift = 64 - logmax;
+
+  return ((A * (unsigned long) p) >> shift) & (max - 1);
+}
+
+/* Allocate an empty imported-modules set.  */
+
+static struct dyn_pointer_set *
+pointer_set_create (unsigned (*get_key) (const void *))
+{
+  struct dyn_pointer_set *result = XNEW (struct dyn_pointer_set);
+
+  result->n_elements = 0;
+  result->log_slots = 8;
+  result->n_slots = (size_t) 1 << result->log_slots;
+
+  result->slots = XNEWVEC (void *, result->n_slots);
+  memset (result->slots, 0, sizeof (void *) * result->n_slots);
+  result->get_key = get_key;
+
+  return result;
+}
+
+/* Reclaim all memory associated with PSET.  */
+
+static void
+pointer_set_destroy (struct dyn_pointer_set *pset)
+{
+  size_t i;
+  for (i = 0; i < pset->n_slots; i++)
+    if (pset->slots[i])
+      XDELETE (pset->slots[i]);
+  XDELETEVEC (pset->slots);
+  XDELETE (pset);
+}
+
+/* Reclaim the memory of PSET but not the value pointer.  */
+static void
+pointer_set_destroy_not_free_value_pointer (struct dyn_pointer_set *pset)
+{
+  XDELETEVEC (pset->slots);
+  XDELETE (pset);
+}
+
+/* Subroutine of pointer_set_find_or_insert.  Return the insertion slot for KEY
+   into an empty element of SLOTS, an array of length N_SLOTS.  */
+static inline size_t
+insert_aux (unsigned key, void **slots,
+	    size_t n_slots, size_t log_slots,
+	    unsigned (*get_key) (const void *))
+{
+  size_t n = hash1 (key, n_slots, log_slots);
+  while (1)
+    {
+      if (slots[n] == 0 || get_key (slots[n]) == key)
+	return n;
+      else
+	{
+	  ++n;
+	  if (n == n_slots)
+	    n = 0;
+	}
+    }
+}
+
+/* Find slot for KEY. KEY must be nonnull.  */
+
+static void **
+pointer_set_find_or_insert (struct dyn_pointer_set *pset, unsigned key)
+{
+  size_t n;
+
+  /* For simplicity, expand the set even if KEY is already there.  This can be
+     superfluous but can happen at most once.  */
+  if (pset->n_elements > pset->n_slots / 4)
+    {
+      size_t new_log_slots = pset->log_slots + 1;
+      size_t new_n_slots = pset->n_slots * 2;
+      void **new_slots = XNEWVEC (void *, new_n_slots);
+      memset (new_slots, 0, sizeof (void *) * new_n_slots);
+      size_t i;
+
+      for (i = 0; i < pset->n_slots; ++i)
+        {
+	  void *value = pset->slots[i];
+	  if (!value)
+	    continue;
+	  n = insert_aux (pset->get_key (value), new_slots, new_n_slots,
+			  new_log_slots, pset->get_key);
+	  new_slots[n] = value;
+	}
+
+      XDELETEVEC (pset->slots);
+      pset->n_slots = new_n_slots;
+      pset->log_slots = new_log_slots;
+      pset->slots = new_slots;
+    }
+
+  n = insert_aux (key, pset->slots, pset->n_slots, pset->log_slots,
+		  pset->get_key);
+  return &pset->slots[n];
+}
+
+
+/* Pass each pointer in PSET to the function in FN, together with the fixed
+   parameters DATA1, DATA2, DATA3.  If FN returns false, the iteration stops.  */
+
+static void
+pointer_set_traverse (const struct dyn_pointer_set *pset,
+                      int (*fn) (const void *, void *, void *, void *),
+		      void *data1, void *data2, void *data3)
+{
+  size_t i;
+  for (i = 0; i < pset->n_slots; ++i)
+    if (pset->slots[i] && !fn (pset->slots[i], data1, data2, data3))
+      break;
+}
+
+
+/* Returns nonzero if PSET contains an entry with KEY as the key value.
+   Collisions are resolved by linear probing.  */
+
+static int
+pointer_set_contains (const struct dyn_pointer_set *pset, unsigned key)
+{
+  size_t n = hash1 (key, pset->n_slots, pset->log_slots);
+
+  while (1)
+    {
+      if (pset->slots[n] == 0)
+       return 0;
+      else if (pset->get_key (pset->slots[n]) == key)
+       return 1;
+      else
+       {
+         ++n;
+         if (n == pset->n_slots)
+           n = 0;
+       }
+    }
+}
+
+/* Callback function to propagate import module (VALUE) from callee to
+   caller's imported-module-set (DATA1).
+   The weight is scaled by the scaling-factor (DATA2) before propagation,
+   and accumulated into DATA3.  */
+
+static int
+gcov_propagate_imp_modules (const void *value, void *data1, void *data2,
+			    void *data3)
+{
+  const struct dyn_imp_mod *m = (const struct dyn_imp_mod *) value;
+  struct dyn_pointer_set *receiving_set = (struct dyn_pointer_set *) data1;
+  double *scale = (double *) data2;
+  double *sum = (double *) data3;
+  double wt = m->weight;
+  if (scale)
+    wt *= *scale;
+  if (sum)
+    (*sum) += wt;
+  imp_mod_set_insert (receiving_set, m->imp_mod, wt);
+  return 1;
+}
+
+static int
+sort_by_count (const void *pa, const void *pb)
+{
+  const struct dyn_cgraph_edge *edge_a = *(struct dyn_cgraph_edge * const *)pa;
+  const struct dyn_cgraph_edge *edge_b = *(struct dyn_cgraph_edge * const *)pb;
+
+  /* This can overvlow.  */
+  /* return edge_b->count - edge_a->count;  */
+  if (edge_b->count > edge_a->count)
+    return 1;
+  else if (edge_b->count == edge_a->count)
+    return 0;
+  else
+    return -1;
+}
+
+/* Compute the hot callgraph edge threhold.  */
+
+static gcov_type
+gcov_compute_cutoff_count (void)
+{
+  unsigned m_ix, capacity, i;
+  unsigned num_edges = 0;
+  gcov_type cutoff_count = 0;
+  double total, cum, cum_cutoff;
+  struct dyn_cgraph_edge **edges;
+  struct gcov_info *gi_ptr;
+  char *cutoff_str;
+  char *num_perc_str;
+  unsigned cutoff_perc;
+  unsigned num_perc;
+  int do_dump;
+
+  capacity = 100;
+  /* allocate an edge array */
+  edges = XNEWVEC (struct dyn_cgraph_edge*, capacity);
+  /* First count the number of edges.  */
+  for (m_ix = 0; m_ix < the_dyn_call_graph.num_modules; m_ix++)
+    {
+      const struct gcov_fn_info *fi_ptr;
+      unsigned f_ix;
+
+      gi_ptr = the_dyn_call_graph.modules[m_ix];
+
+      for (f_ix = 0; f_ix < gi_ptr->n_functions; f_ix++)
+	{
+	  struct dyn_cgraph_node *node;
+          struct dyn_cgraph_edge *callees;
+
+	  fi_ptr = gi_ptr->functions[f_ix];
+
+	  node = *(pointer_set_find_or_insert
+		   (the_dyn_call_graph.call_graph_nodes[m_ix], fi_ptr->ident));
+	  gcc_assert (node);
+
+          callees = node->callees;
+          while (callees != 0)
+            {
+              num_edges++;
+              if (num_edges < capacity)
+                edges[num_edges - 1] = callees;
+              else
+                {
+                  capacity = capacity + (capacity >> 1);
+                  edges = (struct dyn_cgraph_edge **)realloc (edges, sizeof (void*) * capacity);
+                  edges[num_edges - 1] = callees;
+                }
+              callees = callees->next_callee;
+            }
+	}
+    }
+
+  /* Now sort */
+  qsort (edges, num_edges, sizeof (void *), sort_by_count);
+#define CUM_CUTOFF_PERCENT 80
+#define MIN_NUM_EDGE_PERCENT 0
+
+  /* The default parameter value is 100 which is a reserved special value. When
+     the cutoff parameter is 100, use the environment variable setting if it
+     exists, otherwise, use the default value 80.  */
+  if (__gcov_lipo_cutoff != 100)
+    {
+      cutoff_perc = __gcov_lipo_cutoff;
+      num_perc = MIN_NUM_EDGE_PERCENT;
+    }
+  else
+    {
+      cutoff_str = getenv ("GCOV_DYN_CGRAPH_CUTOFF");
+      if (cutoff_str && strlen (cutoff_str))
+        {
+          if ((num_perc_str = strchr (cutoff_str, ':')))
+            {
+              *num_perc_str = '\0';
+              num_perc_str++;
+            }
+          cutoff_perc = atoi (cutoff_str);
+          if (num_perc_str)
+            num_perc = atoi (num_perc_str);
+          else
+            num_perc = MIN_NUM_EDGE_PERCENT;
+        }
+      else
+        {
+          cutoff_perc = CUM_CUTOFF_PERCENT;
+          num_perc = MIN_NUM_EDGE_PERCENT;
+        }
+    }
+
+  total = 0;
+  cum = 0;
+  for (i = 0; i < num_edges; i++)
+    total += edges[i]->count;
+
+  cum_cutoff = (total * cutoff_perc)/100;
+  do_dump = (do_cgraph_dump () != 0);
+  for (i = 0; i < num_edges; i++)
+    {
+      cum += edges[i]->count;
+      if (do_dump)
+        fprintf (stderr, "// edge[%d] count = %.0f [%llx --> %llx]\n",
+                 i, (double) edges[i]->count,
+                 (long long) edges[i]->caller->guid,
+                 (long long) edges[i]->callee->guid);
+      if (cum >= cum_cutoff && (i * 100 >= num_edges * num_perc))
+        {
+          cutoff_count = edges[i]->count;
+          break;
+        }
+    }
+
+  if (do_dump)
+    fprintf (stderr,"cum count cutoff = %d%%, minimal num edge cutoff = %d%%\n",
+             cutoff_perc, num_perc);
+
+  if (do_dump)
+    fprintf (stderr, "// total = %.0f cum = %.0f cum/total = %.0f%%"
+             " cutoff_count = %lld [total edges: %d hot edges: %d perc: %d%%]\n"
+	     " total_zero_count_edges = %d total_insane_count_edgess = %d\n"
+             " total_nodes_executed = %d\n",
+             total, cum, (cum * 100)/total, (long long) cutoff_count,
+             num_edges, i, (i * 100)/num_edges, total_zero_count,
+             total_insane_count, the_dyn_call_graph.num_nodes_executed);
+
+  XDELETEVEC (edges);
+  return cutoff_count;
+}
+
+/* Return the imported module set for NODE.  */
+
+static struct dyn_pointer_set *
+gcov_get_imp_module_set (struct dyn_cgraph_node *node)
+{
+  if (!node->imported_modules)
+    node->imported_modules = pointer_set_create (imp_mod_get_key);
+
+  return node->imported_modules;
+}
+
+/* Return the imported module set for MODULE MI.  */
+
+static struct dyn_pointer_set *
+gcov_get_module_imp_module_set (struct dyn_module_info *mi)
+{
+  if (!mi->imported_modules)
+    mi->imported_modules = pointer_set_create (imp_mod_get_key);
+
+  return mi->imported_modules;
+}
+
+/* Callback function to mark if a module needs to be exported.  */
+
+static int
+gcov_mark_export_modules (const void *value,
+			  void *data1 ATTRIBUTE_UNUSED,
+			  void *data2 ATTRIBUTE_UNUSED,
+			  void *data3 ATTRIBUTE_UNUSED)
+{
+  const struct gcov_info *module_info
+    = ((const struct dyn_imp_mod *) value)->imp_mod;
+
+  SET_MODULE_EXPORTED (module_info->mod_info);
+  return 1;
+}
+
+struct gcov_import_mod_array
+{
+  const struct dyn_imp_mod **imported_modules;
+  struct gcov_info *importing_module;
+  unsigned len;
+};
+
+/* Callback function to compute pointer set size.  */
+
+static int
+gcov_compute_mset_size (const void *value ATTRIBUTE_UNUSED,
+                        void *data1,
+			void *data2 ATTRIBUTE_UNUSED,
+			void *data3 ATTRIBUTE_UNUSED)
+{
+  unsigned *len = (unsigned *) data1;
+  (*len)++;
+  return 1;
+}
+
+/* Callback function to collect imported modules.  */
+
+static int
+gcov_collect_imported_modules (const void *value,
+			       void *data1,
+			       void *data2 ATTRIBUTE_UNUSED,
+			       void *data3 ATTRIBUTE_UNUSED)
+{
+  struct gcov_import_mod_array *out_array;
+  const struct dyn_imp_mod *m
+    = (const struct dyn_imp_mod *) value;
+
+  out_array = (struct gcov_import_mod_array *) data1;
+
+  if (m->imp_mod != out_array->importing_module)
+    out_array->imported_modules[out_array->len++] = m;
+
+  return 1;
+}
+
+/* Comparator for sorting imported modules using weights.  */
+
+static int
+sort_by_module_wt (const void *pa, const void *pb)
+{
+  const struct dyn_imp_mod *m_a = *((const struct dyn_imp_mod * const *) pa);
+  const struct dyn_imp_mod *m_b = *((const struct dyn_imp_mod * const *) pb);
+
+  /* We want to sort in descending order of weights.  */
+  if (m_a->weight < m_b->weight)
+    return +1;
+  if (m_a->weight > m_b->weight)
+    return -1;
+  return get_module_ident (m_a->imp_mod) - get_module_ident (m_b->imp_mod);
+}
+
+/* Return a dynamic array of imported modules that is sorted for
+   the importing module MOD_INFO. The length of the array is returned
+   in *LEN.  */
+
+const struct dyn_imp_mod **
+gcov_get_sorted_import_module_array (struct gcov_info *mod_info,
+                                     unsigned *len)
+{
+  unsigned mod_idx;
+  struct dyn_module_info *sup_mod_info;
+  unsigned array_len = 0;
+  struct gcov_import_mod_array imp_array;
+
+  mod_idx = get_module_ident (mod_info) - 1;
+  sup_mod_info = &the_dyn_call_graph.sup_modules[mod_idx];
+
+  if (sup_mod_info->imported_modules == 0)
+    return 0;
+
+  pointer_set_traverse (sup_mod_info->imported_modules,
+                        gcov_compute_mset_size, &array_len, 0, 0);
+  imp_array.imported_modules = XNEWVEC (const struct dyn_imp_mod *, array_len);
+  imp_array.len = 0;
+  imp_array.importing_module = mod_info;
+  pointer_set_traverse (sup_mod_info->imported_modules,
+                        gcov_collect_imported_modules, &imp_array, 0, 0);
+  *len = imp_array.len;
+  qsort (imp_array.imported_modules, imp_array.len,
+         sizeof (void *), sort_by_module_wt);
+  return imp_array.imported_modules;
+}
+
+/* Compute modules that are needed for NODE (for cross module inlining).
+   CUTTOFF_COUNT is the call graph edge count cutoff value.
+   IMPORT_SCALE is the scaling-factor (percent) by which to scale the
+   weights of imported modules of a callee before propagating them to
+   the caller, if the callee and caller are in different modules.
+
+   Each imported module is assigned a weight that corresponds to the
+   expected benefit due to cross-module inlining. When the imported modules
+   are written out, they are sorted with highest weight first.
+
+   The following example illustrates how the weight is computed:
+
+   Suppose we are processing call-graph node A. It calls function B 50 times,
+   which calls function C 1000 times, and function E 800 times. Lets say B has
+   another in-edge from function D, with edge-count of 50. Say all the
+   functions are in separate modules (modules a, b, c, d, e, respectively):
+
+              D
+              |
+              | 50
+              |
+       50     v     1000
+  A --------> B ----------> C
+              |
+              | 800
+              |
+              v
+              E
+
+  Nodes are processed in depth-first order, so when processing A, we first
+  process B. For node B, we are going to add module c to the imported-module
+  set, with weight 1000 (edge-count), and module e with weight 800.
+  Coming back to A, we are going to add the imported-module-set of B to A,
+  after doing some scaling.
+  The first scaling factor comes from the fact that A calls B 50 times, but B
+  has in-edge-count total of 100. So this scaling factor is 50/100 = 0.5
+  The second scaling factor is that since B is in a different module than A,
+  we want to slightly downgrade imported modules of B, before adding to the
+  imported-modules set of A. This scaling factor has a default value of 50%
+  (can be set via env variable GCOV_DYN_IMPORT_SCALE).
+  So we end up adding modules c and e to the imported-set of A, with weights
+  0.5*0.5*1000=250 and 0.5*0.5*800=200, respectively.
+
+  Next, we have to add module b itself to A. The weight is computed as the
+  edge-count plus the sum of scaled-weights of all modules in the
+  imported-module set of B, i.e., 50 + 250 + 200 = 500.
+
+  In computing the weight of module b, we add the sum of scaled-weights of
+  imported modules of b, because it doesn't make sense to import c, e in
+  module a, until module b is imported.  */
+
+static void
+gcov_process_cgraph_node (struct dyn_cgraph_node *node,
+                          gcov_type cutoff_count,
+			  unsigned import_scale)
+{
+  unsigned mod_id;
+  struct dyn_cgraph_edge *callees;
+  struct dyn_cgraph_edge *callers;
+  node->visited = 1;
+  node->sum_in_count = 0;
+
+  callers = node->callers;
+  while (callers)
+    {
+      node->sum_in_count += callers->count;
+      callers = callers->next_caller;
+    }
+
+  callees = node->callees;
+  mod_id = get_module_ident_from_func_glob_uid (node->guid);
+
+  while (callees)
+    {
+      if (!callees->callee->visited)
+        gcov_process_cgraph_node (callees->callee,
+                                  cutoff_count,
+				  import_scale);
+      callees = callees->next_callee;
+    }
+
+  callees = node->callees;
+  while (callees)
+    {
+      if (callees->count >= cutoff_count)
+        {
+          unsigned callee_mod_id;
+          struct dyn_pointer_set *imp_modules
+              = gcov_get_imp_module_set (node);
+
+          callee_mod_id
+              = get_module_ident_from_func_glob_uid (callees->callee->guid);
+
+	  double callee_mod_wt = (double) callees->count;
+          if (callees->callee->imported_modules)
+	    {
+	      double scale = ((double) callees->count) /
+		((double) callees->callee->sum_in_count);
+	      /* Reduce weight if callee is in different module.  */
+	      if (mod_id != callee_mod_id)
+		scale = (scale * import_scale) / 100.0;
+	      pointer_set_traverse (callees->callee->imported_modules,
+				    gcov_propagate_imp_modules,
+				    imp_modules, &scale, &callee_mod_wt);
+	    }
+          if (mod_id != callee_mod_id)
+            {
+              struct gcov_info *callee_mod_info
+                  = get_module_info (callee_mod_id);
+              imp_mod_set_insert (imp_modules, callee_mod_info, callee_mod_wt);
+            }
+        }
+
+      callees = callees->next_callee;
+    }
+}
+
+static void gcov_compute_module_groups_eager_propagation (gcov_type);
+static void gcov_compute_module_groups_inclusion_based_with_priority
+              (gcov_type);
+
+/* dyn_fibheap */
+static void dyn_fibheap_ins_root (dyn_fibheap_t, fibnode_t);
+static void dyn_fibheap_rem_root (dyn_fibheap_t, fibnode_t);
+static void dyn_fibheap_consolidate (dyn_fibheap_t);
+static void dyn_fibheap_link (dyn_fibheap_t, fibnode_t, fibnode_t);
+static fibnode_t dyn_fibheap_extr_min_node (dyn_fibheap_t);
+static int dyn_fibheap_compare (dyn_fibheap_t, fibnode_t, fibnode_t);
+static int dyn_fibheap_comp_data (dyn_fibheap_t, dyn_fibheapkey_t,
+                                  void *, fibnode_t);
+static fibnode_t fibnode_new (void);
+static void fibnode_insert_after (fibnode_t, fibnode_t);
+#define fibnode_insert_before(a, b) fibnode_insert_after (a->left, b)
+static fibnode_t fibnode_remove (fibnode_t);
+
+/* Create a new fibonacci heap.  */
+static dyn_fibheap_t
+dyn_fibheap_new (void)
+{
+  return (dyn_fibheap_t) calloc (1, sizeof (struct dyn_fibheap));
+}
+
+/* Create a new fibonacci heap node.  */
+static fibnode_t
+fibnode_new (void)
+{
+  fibnode_t node;
+
+  node = (fibnode_t) calloc (1, sizeof *node);
+  node->left = node;
+  node->right = node;
+
+  return node;
+}
+
+static inline int
+dyn_fibheap_compare (dyn_fibheap_t heap ATTRIBUTE_UNUSED, fibnode_t a,
+                     fibnode_t b)
+{
+  if (a->key < b->key)
+    return -1;
+  if (a->key > b->key)
+    return 1;
+  return 0;
+}
+
+static inline int
+dyn_fibheap_comp_data (dyn_fibheap_t heap, dyn_fibheapkey_t key,
+                       void *data, fibnode_t b)
+{
+  struct fibnode a;
+
+  a.key = key;
+  a.data = data;
+
+  return dyn_fibheap_compare (heap, &a, b);
+}
+
+/* Insert DATA, with priority KEY, into HEAP.  */
+static fibnode_t
+dyn_fibheap_insert (dyn_fibheap_t heap, dyn_fibheapkey_t key, void *data)
+{
+  fibnode_t node;
+
+  /* Create the new node.  */
+  node = fibnode_new ();
+
+  /* Set the node's data.  */
+  node->data = data;
+  node->key = key;
+
+  /* Insert it into the root list.  */
+  dyn_fibheap_ins_root (heap, node);
+
+  /* If their was no minimum, or this key is less than the min,
+     it's the new min.  */
+  if (heap->min == 0 || node->key < heap->min->key)
+    heap->min = node;
+
+  heap->nodes++;
+
+  return node;
+}
+
+/* Extract the data of the minimum node from HEAP.  */
+static void *
+dyn_fibheap_extract_min (dyn_fibheap_t heap)
+{
+  fibnode_t z;
+  void *ret = 0;
+
+  /* If we don't have a min set, it means we have no nodes.  */
+  if (heap->min != 0)
+    {
+      /* Otherwise, extract the min node, free the node, and return the
+         node's data.  */
+      z = dyn_fibheap_extr_min_node (heap);
+      ret = z->data;
+      free (z);
+    }
+
+  return ret;
+}
+
+/* Delete HEAP.  */
+static void
+dyn_fibheap_delete (dyn_fibheap_t heap)
+{
+  while (heap->min != 0)
+    free (dyn_fibheap_extr_min_node (heap));
+
+  free (heap);
+}
+
+/* Extract the minimum node of the heap.  */
+static fibnode_t
+dyn_fibheap_extr_min_node (dyn_fibheap_t heap)
+{
+  fibnode_t ret = heap->min;
+  fibnode_t x, y, orig;
+
+  /* Attach the child list of the minimum node to the root list of the heap.
+     If there is no child list, we don't do squat.  */
+  for (x = ret->child, orig = 0; x != orig && x != 0; x = y)
+    {
+      if (orig == 0)
+	orig = x;
+      y = x->right;
+      x->parent = 0;
+      dyn_fibheap_ins_root (heap, x);
+    }
+
+  /* Remove the old root.  */
+  dyn_fibheap_rem_root (heap, ret);
+  heap->nodes--;
+
+  /* If we are left with no nodes, then the min is 0.  */
+  if (heap->nodes == 0)
+    heap->min = 0;
+  else
+    {
+      /* Otherwise, consolidate to find new minimum, as well as do the reorg
+         work that needs to be done.  */
+      heap->min = ret->right;
+      dyn_fibheap_consolidate (heap);
+    }
+
+  return ret;
+}
+
+/* Insert NODE into the root list of HEAP.  */
+static void
+dyn_fibheap_ins_root (dyn_fibheap_t heap, fibnode_t node)
+{
+  /* If the heap is currently empty, the new node becomes the singleton
+     circular root list.  */
+  if (heap->root == 0)
+    {
+      heap->root = node;
+      node->left = node;
+      node->right = node;
+      return;
+    }
+
+  /* Otherwise, insert it in the circular root list between the root
+     and it's right node.  */
+  fibnode_insert_after (heap->root, node);
+}
+
+/* Remove NODE from the rootlist of HEAP.  */
+static void
+dyn_fibheap_rem_root (dyn_fibheap_t heap, fibnode_t node)
+{
+  if (node->left == node)
+    heap->root = 0;
+  else
+    heap->root = fibnode_remove (node);
+}
+
+/* Consolidate the heap.  */
+static void
+dyn_fibheap_consolidate (dyn_fibheap_t heap)
+{
+  fibnode_t a[1 + 8 * sizeof (long)];
+  fibnode_t w;
+  fibnode_t y;
+  fibnode_t x;
+  int i;
+  int d;
+  int D;
+
+  D = 1 + 8 * sizeof (long);
+
+  memset (a, 0, sizeof (fibnode_t) * D);
+
+  while ((w = heap->root) != 0)
+    {
+      x = w;
+      dyn_fibheap_rem_root (heap, w);
+      d = x->degree;
+      while (a[d] != 0)
+	{
+	  y = a[d];
+	  if (dyn_fibheap_compare (heap, x, y) > 0)
+	    {
+	      fibnode_t temp;
+	      temp = x;
+	      x = y;
+	      y = temp;
+	    }
+	  dyn_fibheap_link (heap, y, x);
+	  a[d] = 0;
+	  d++;
+	}
+      a[d] = x;
+    }
+  heap->min = 0;
+  for (i = 0; i < D; i++)
+    if (a[i] != 0)
+      {
+	dyn_fibheap_ins_root (heap, a[i]);
+	if (heap->min == 0 || dyn_fibheap_compare (heap, a[i], heap->min) < 0)
+	  heap->min = a[i];
+      }
+}
+
+/* Make NODE a child of PARENT.  */
+static void
+dyn_fibheap_link (dyn_fibheap_t heap ATTRIBUTE_UNUSED,
+              fibnode_t node, fibnode_t parent)
+{
+  if (parent->child == 0)
+    parent->child = node;
+  else
+    fibnode_insert_before (parent->child, node);
+  node->parent = parent;
+  parent->degree++;
+  node->mark = 0;
+}
+
+static void
+fibnode_insert_after (fibnode_t a, fibnode_t b)
+{
+  if (a == a->right)
+    {
+      a->right = b;
+      a->left = b;
+      b->right = a;
+      b->left = a;
+    }
+  else
+    {
+      b->right = a->right;
+      a->right->left = b;
+      a->right = b;
+      b->left = a;
+    }
+}
+
+static fibnode_t
+fibnode_remove (fibnode_t node)
+{
+  fibnode_t ret;
+
+  if (node == node->left)
+    ret = 0;
+  else
+    ret = node->left;
+
+  if (node->parent != 0 && node->parent->child == node)
+    node->parent->child = ret;
+
+  node->right->left = node->left;
+  node->left->right = node->right;
+
+  node->parent = 0;
+  node->left = node;
+  node->right = node;
+
+  return ret;
+}
+/* end of dyn_fibheap */
+
+/* Compute module grouping using CUTOFF_COUNT as the hot edge
+   threshold.  */
+
+static void
+gcov_compute_module_groups (gcov_type cutoff_count)
+{
+  switch (flag_alg_mode)
+    {
+      case INCLUSION_BASED_PRIORITY_ALGORITHM:
+        return gcov_compute_module_groups_inclusion_based_with_priority
+                 (cutoff_count);
+      case EAGER_PROPAGATION_ALGORITHM:
+      default:
+        return gcov_compute_module_groups_eager_propagation (cutoff_count);
+    }
+}
+
+static void
+modu_graph_add_edge (unsigned m_id, unsigned callee_m_id, gcov_type count)
+{
+  struct modu_node *mnode;
+  struct modu_node *callee_mnode;
+  struct modu_edge *e;
+
+  if (m_id == 0 || callee_m_id == 0)
+    return;
+
+  mnode = &the_dyn_call_graph.modu_nodes[m_id - 1];
+  callee_mnode = &the_dyn_call_graph.modu_nodes[callee_m_id - 1];
+
+  if (flag_modu_merge_edges)
+    {
+       struct modu_edge *callees = mnode->callees;
+       while (callees)
+         {
+            if (callees->callee == callee_mnode)
+              {
+                 callees->n_edges += 1;
+                 callees->sum_count += count;
+                 return;
+              }
+            callees = callees->next_callee;
+         }
+    }
+  e = XNEW (struct modu_edge);
+  e->caller = mnode;
+  e->callee = callee_mnode;
+  e->n_edges = 1;
+  e->sum_count = count;
+  e->next_callee = mnode->callees;
+  e->next_caller = callee_mnode->callers;
+  mnode->callees = e;
+  callee_mnode->callers = e;
+  e->visited = 0;
+}
+
+static void
+modu_graph_process_dyn_cgraph_node (struct dyn_cgraph_node *node,
+                                    gcov_type cutoff_count)
+{
+  unsigned m_id = get_module_ident_from_func_glob_uid (node->guid);
+  struct dyn_cgraph_edge *callees;
+  struct dyn_cgraph_node *callee;
+
+  callees = node->callees;
+  while (callees != 0)
+    {
+      callee = callees->callee;
+      unsigned callee_m_id = 
+        get_module_ident_from_func_glob_uid (callee->guid);
+      if (callee_m_id != m_id)
+        {
+          if (callees->count >= cutoff_count)
+            modu_graph_add_edge (m_id, callee_m_id, callees->count);
+        }
+      callees = callees->next_callee;
+    }
+}
+
+static void
+build_modu_graph (gcov_type cutoff_count)
+{
+  unsigned m_ix;
+  struct gcov_info *gi_ptr;
+  unsigned n_modules = the_dyn_call_graph.num_modules;
+  struct modu_node *modu_nodes;
+
+  /* Create modu graph nodes/edges.  */
+  modu_nodes = XCNEWVEC (struct modu_node, n_modules);
+  the_dyn_call_graph.modu_nodes = modu_nodes;
+  for (m_ix = 0; m_ix < n_modules; m_ix++)
+    {
+      const struct gcov_fn_info *fi_ptr;
+      unsigned f_ix;
+
+      gi_ptr = the_dyn_call_graph.modules[m_ix];
+      modu_nodes[m_ix].module = gi_ptr;
+
+      for (f_ix = 0; f_ix < gi_ptr->n_functions; f_ix++)
+	{
+	  struct dyn_cgraph_node *node;
+
+	  fi_ptr = gi_ptr->functions[f_ix];
+	  node = *(pointer_set_find_or_insert
+		   (the_dyn_call_graph.call_graph_nodes[m_ix], fi_ptr->ident));
+	  if (!node)
+            {
+              fprintf (stderr, "Cannot find module_node (ix = %u)./n", m_ix);
+              continue;
+            }
+          modu_graph_process_dyn_cgraph_node (node, cutoff_count);
+	}
+    }
+}
+
+/* Collect ggc_mem_size for the impored_module in VALUE
+   if DATA1 (a pointer_set) is provided, only count these not in DATA1.
+   Result is stored in DATA2.  */
+
+static int
+collect_ggc_mem_size (const void *value,
+                 void *data1,
+                 void *data2,
+                 void *data3 ATTRIBUTE_UNUSED)
+{
+  const struct dyn_imp_mod *g = (const struct dyn_imp_mod *) value;
+  struct dyn_pointer_set *s = (struct dyn_pointer_set *) data1;
+  unsigned mod_id = get_module_ident (g->imp_mod);
+  gcov_unsigned_t *size = (gcov_unsigned_t *) data2;
+
+  if (s && pointer_set_contains (s, mod_id))
+    return 1;
+
+  (*size) += g->imp_mod->mod_info->ggc_memory;
+
+  return 1;
+
+}
+
+/* Get the group ggc_memory size of a imported list.  */
+
+static gcov_unsigned_t
+get_group_ggc_mem (struct dyn_pointer_set *s)
+{
+  gcov_unsigned_t ggc_size = 0;
+
+  pointer_set_traverse (s, collect_ggc_mem_size, 0, &ggc_size, 0);
+  return ggc_size;
+}
+
+/* Get the group ggc_memory size of the unioned imported lists. */
+
+static gcov_unsigned_t
+modu_union_ggc_size (unsigned t_mid, unsigned s_mid)
+{
+  struct dyn_pointer_set *t_imported_mods = get_imported_modus (t_mid);
+  struct dyn_pointer_set *s_imported_mods = get_imported_modus (s_mid);
+  gcov_unsigned_t size = 0;
+
+  pointer_set_traverse (s_imported_mods, collect_ggc_mem_size,
+      t_imported_mods, &size, 0);
+
+  size += get_group_ggc_mem (t_imported_mods);
+
+  return size;
+}
+
+/* Insert one module (VALUE) to the target module (DATA1) */
+
+static int
+modu_add_auxiliary_1 (const void *value,
+                      void *data1,
+                      void *data2,
+                      void *data3 ATTRIBUTE_UNUSED)
+{
+  const struct dyn_imp_mod *src = (const struct dyn_imp_mod *) value;
+  const struct gcov_info *src_modu = src->imp_mod;
+  unsigned t_m_id = *(unsigned *) data1;
+  struct dyn_pointer_set *t_imported_mods = get_imported_modus (t_m_id);
+  double wt = (double) *(gcov_type*)data2;
+  unsigned s_m_id = get_module_ident (src_modu);
+  struct gcov_info **gp;
+  struct dyn_pointer_set *s_exported_to;
+  int already_have = 0;
+
+  if (pointer_set_contains (t_imported_mods, s_m_id))
+    already_have = 1;
+
+  /* Insert even it's already there. This is to update the wt.  */
+  imp_mod_set_insert (t_imported_mods, src_modu, wt);
+
+  if (already_have)
+    return 1;
+
+  /* add module t_m_id to s_m_id's exported list. */
+  s_exported_to = get_exported_to (s_m_id);
+  if (!s_exported_to)
+    s_exported_to = create_exported_to (s_m_id);
+  gp = (struct gcov_info **) pointer_set_find_or_insert
+             (s_exported_to, t_m_id);
+  *gp = the_dyn_call_graph.modules[t_m_id - 1];
+  s_exported_to->n_elements++;
+
+  return 1;
+}
+
+/* Insert module S_MID and it's imported modules to
+   imported list of module T_MID.  */
+
+static void
+modu_add_auxiliary (unsigned t_mid, unsigned s_mid, gcov_type count)
+{
+  struct dyn_pointer_set *s_imported_mods = get_imported_modus (s_mid);
+
+  pointer_set_traverse (s_imported_mods, modu_add_auxiliary_1,
+                        &t_mid, &count, 0);
+
+  /* Recompute the gcc_memory for the group.  */
+  the_dyn_call_graph.sup_modules[t_mid - 1].group_ggc_mem =
+    get_group_ggc_mem (get_imported_modus (t_mid));
+}
+
+/* Check if inserting the module specified by DATA1 (including
+   it's imported list to grouping VALUE, makes the ggc_memory
+   size exceed the memory threshold. 
+   Return 0 if size is great than the thereshold and 0 otherwise.  */
+
+static int
+ps_check_ggc_mem (const void *value,
+                  void *data1,
+                  void *data2,
+                  void *data3 ATTRIBUTE_UNUSED)
+{
+  const struct gcov_info *modu = (const struct gcov_info *) value;
+  unsigned s_m_id = *(unsigned *) data1;
+  unsigned *fail = (unsigned *) data2;
+  unsigned m_id = get_module_ident (modu);
+  gcov_unsigned_t new_ggc_size;
+
+  new_ggc_size = modu_union_ggc_size (m_id, s_m_id);
+  if (new_ggc_size > mem_threshold)
+    {
+      (*fail) = 1;
+      return 0;
+    }
+
+  return 1;
+}
+
+/* Add module specified by DATA1 and it's imported list to
+   the grouping specified by VALUE.  */
+
+static int
+ps_add_auxiliary (const void *value,
+                  void *data1,
+                  void *data2,
+                  void *data3)
+{
+  const struct gcov_info *modu = (const struct gcov_info *) value;
+  unsigned s_m_id = *(unsigned *) data1;
+  unsigned m_id = get_module_ident (modu);
+  int not_safe_to_insert = *(int *) data3;
+  gcov_unsigned_t new_ggc_size;
+
+  /* For strict inclusion, we know it's safe to insert.  */
+  if (!not_safe_to_insert)
+    {
+      modu_add_auxiliary (m_id, s_m_id, *(gcov_type*)data2);
+      return 1;
+    }
+
+  /* Check if we can do a partial insertion.  */
+  new_ggc_size = modu_union_ggc_size (m_id, s_m_id);
+  if (new_ggc_size > mem_threshold)
+    return 1;
+
+  modu_add_auxiliary (m_id, s_m_id, *(gcov_type*)data2);
+  return 1;
+}
+
+/* Return 1 if insertion happened, otherwise 0.  */
+
+static int
+modu_edge_add_auxiliary (struct modu_edge *edge)
+{
+  struct modu_node *node;
+  struct modu_node *callee;
+  struct gcov_info *node_modu;
+  struct gcov_info *callee_modu;
+  gcov_unsigned_t group_ggc_mem;
+  gcov_unsigned_t new_ggc_size;
+  struct dyn_pointer_set *node_imported_mods;
+  struct dyn_pointer_set *node_exported_to;
+  unsigned m_id, callee_m_id;
+  int fail = 0;
+
+  node = edge->caller;
+  callee = edge->callee;
+  node_modu = node->module;
+  callee_modu = callee->module;
+  m_id = get_module_ident (node_modu);
+
+  if (m_id == 0)
+    return 0;
+
+  group_ggc_mem = the_dyn_call_graph.sup_modules[m_id - 1].group_ggc_mem;
+
+  if (group_ggc_mem >= mem_threshold)
+    return 0;
+
+  node_imported_mods = get_imported_modus (m_id);
+
+  /* Check if the callee is already included.  */
+  callee_m_id = get_module_ident (callee_modu);
+  if (pointer_set_contains (node_imported_mods, callee_m_id))
+    return 0;
+
+  new_ggc_size = modu_union_ggc_size (m_id, callee_m_id);
+  if (new_ggc_size > mem_threshold)
+    return 0;
+
+  /* check the size for the grouping that includes this node. */
+  node_exported_to = get_exported_to (m_id);
+  if (node_exported_to)
+    {
+      pointer_set_traverse (node_exported_to, ps_check_ggc_mem,
+                            &callee_m_id, &fail, 0);
+      if (fail && !flag_weak_inclusion)
+        return 0;
+    }
+
+  /* Perform the insertion: first insert to node
+  and then to all the exported_to nodes.  */
+  modu_add_auxiliary (m_id, callee_m_id, edge->sum_count);
+
+  if (node_exported_to)
+    pointer_set_traverse (node_exported_to, ps_add_auxiliary,
+       &callee_m_id, &(edge->sum_count), &fail);
+  return 1;
+}
+
+static void
+compute_module_groups_inclusion_impl (void)
+{
+  dyn_fibheap_t heap;
+  unsigned i;
+  unsigned n_modules = the_dyn_call_graph.num_modules;
+
+  /* insert all the edges to the heap.  */
+  heap = dyn_fibheap_new ();
+  for (i = 0; i < n_modules; i++)
+    {
+      struct modu_edge * callees;
+      struct modu_node *node = &the_dyn_call_graph.modu_nodes[i];
+
+      callees = node->callees;
+      while (callees != 0)
+        {
+	  dyn_fibheap_insert (heap, -1 * callees->sum_count, callees);
+          callees = callees->next_callee;
+        }
+    }
+
+  while (1)
+    {
+      struct modu_edge *curr
+	= (struct modu_edge *) dyn_fibheap_extract_min (heap);
+
+      if (!curr)
+	break;
+      if (curr->visited)
+	continue;
+      curr->visited = 1;
+
+      modu_edge_add_auxiliary (curr);
+    }
+
+  dyn_fibheap_delete (heap);
+
+  /* Now compute the export attribute  */
+  for (i = 0; i < n_modules; i++)
+    {
+      struct dyn_module_info *mi
+          = &the_dyn_call_graph.sup_modules[i];
+      if (mi->exported_to)
+        SET_MODULE_EXPORTED (the_dyn_call_graph.modules[i]->mod_info);
+    }
+}
+
+static void
+gcov_compute_module_groups_inclusion_based_with_priority
+            (gcov_type cutoff_count)
+{
+  build_modu_graph (cutoff_count);
+  compute_module_groups_inclusion_impl ();
+}
+
+static void
+gcov_compute_module_groups_eager_propagation (gcov_type cutoff_count)
+{
+  unsigned m_ix;
+  struct gcov_info *gi_ptr;
+  const char *import_scale_str;
+  unsigned import_scale = __gcov_lipo_propagate_scale;
+
+  /* Different from __gcov_lipo_cutoff handling, the
+     environment variable here takes precedance  */
+  import_scale_str = getenv ("GCOV_DYN_IMPORT_SCALE");
+  if (import_scale_str && strlen (import_scale_str))
+    import_scale = atoi (import_scale_str);
+
+  for (m_ix = 0; m_ix < the_dyn_call_graph.num_modules; m_ix++)
+    {
+      const struct gcov_fn_info *fi_ptr;
+      unsigned f_ix;
+
+      gi_ptr = the_dyn_call_graph.modules[m_ix];
+
+      for (f_ix = 0; f_ix < gi_ptr->n_functions; f_ix++)
+	{
+	  struct dyn_cgraph_node *node;
+
+	  fi_ptr = gi_ptr->functions[f_ix];
+	  node = *(pointer_set_find_or_insert
+		   (the_dyn_call_graph.call_graph_nodes[m_ix], fi_ptr->ident));
+	  gcc_assert (node);
+          if (node->visited)
+            continue;
+
+          gcov_process_cgraph_node (node, cutoff_count, import_scale);
+	}
+    }
+
+  for (m_ix = 0; m_ix < the_dyn_call_graph.num_modules; m_ix++)
+    {
+      const struct gcov_fn_info *fi_ptr;
+      unsigned f_ix;
+
+      gi_ptr = the_dyn_call_graph.modules[m_ix];
+
+      for (f_ix = 0; f_ix < gi_ptr->n_functions; f_ix++)
+	{
+	  struct dyn_cgraph_node *node;
+          unsigned mod_id;
+          struct dyn_pointer_set *imp_modules;
+
+	  fi_ptr = gi_ptr->functions[f_ix];
+	  node = *(pointer_set_find_or_insert
+		   (the_dyn_call_graph.call_graph_nodes[m_ix], fi_ptr->ident));
+	  gcc_assert (node);
+
+          if (!node->imported_modules)
+            continue;
+
+          mod_id = get_module_ident_from_func_glob_uid (node->guid);
+          gcc_assert (mod_id == (m_ix + 1));
+
+          imp_modules
+              = gcov_get_module_imp_module_set (
+                  &the_dyn_call_graph.sup_modules[mod_id - 1]);
+
+          pointer_set_traverse (node->imported_modules,
+                                gcov_propagate_imp_modules,
+                                imp_modules, 0, 0);
+	}
+    }
+
+  /* Now compute the export attribute  */
+  for (m_ix = 0; m_ix < the_dyn_call_graph.num_modules; m_ix++)
+    {
+      struct dyn_module_info *mi
+          = &the_dyn_call_graph.sup_modules[m_ix];
+
+      if (mi->imported_modules)
+        pointer_set_traverse (mi->imported_modules,
+                              gcov_mark_export_modules, 0, 0, 0);
+    }
+}
+
+/* For each module, compute at random, the group of imported modules,
+   that is of size at most MAX_GROUP_SIZE.  */
+
+static void
+gcov_compute_random_module_groups (unsigned max_group_size)
+{
+  unsigned m_ix;
+
+  if (max_group_size > the_dyn_call_graph.num_modules)
+    max_group_size = the_dyn_call_graph.num_modules;
+
+  for (m_ix = 0; m_ix < the_dyn_call_graph.num_modules; m_ix++)
+    {
+      struct dyn_pointer_set *imp_modules =
+	gcov_get_module_imp_module_set (&the_dyn_call_graph.sup_modules[m_ix]);
+      int cur_group_size = random () % max_group_size;
+      int i = 0;
+      while (i < cur_group_size)
+	{
+	  struct gcov_info *imp_mod_info;
+	  unsigned mod_idx = random () % the_dyn_call_graph.num_modules;
+	  if (mod_idx == m_ix)
+	    continue;
+	  imp_mod_info = get_module_info (mod_idx + 1);
+	  if (!imp_mod_set_insert (imp_modules, imp_mod_info, 1.0))
+	    i++;
+	}
+    }
+
+  /* Now compute the export attribute  */
+  for (m_ix = 0; m_ix < the_dyn_call_graph.num_modules; m_ix++)
+    {
+      struct dyn_module_info *mi
+	= &the_dyn_call_graph.sup_modules[m_ix];
+      if (mi->imported_modules)
+        pointer_set_traverse (mi->imported_modules,
+                              gcov_mark_export_modules, 0, 0, 0);
+    }
+}
+
+/* Write out MOD_INFO into the gcda file. IS_PRIMARY is a flag
+   indicating if the module is the primary module in the group.  */
+
+static void
+gcov_write_module_info (const struct gcov_info *mod_info,
+                        unsigned is_primary)
+{
+  gcov_unsigned_t len = 0, filename_len = 0, src_filename_len = 0, i, j;
+  gcov_unsigned_t num_strings;
+  gcov_unsigned_t *aligned_fname;
+  struct gcov_module_info  *module_info = mod_info->mod_info;
+  filename_len = (strlen (module_info->da_filename) +
+		  sizeof (gcov_unsigned_t)) / sizeof (gcov_unsigned_t);
+  src_filename_len = (strlen (module_info->source_filename) +
+		      sizeof (gcov_unsigned_t)) / sizeof (gcov_unsigned_t);
+  len = filename_len + src_filename_len;
+  len += 2; /* each name string is led by a length.  */
+
+  num_strings = module_info->num_quote_paths + module_info->num_bracket_paths +
+    module_info->num_cpp_defines + module_info->num_cpp_includes +
+    module_info->num_cl_args;
+  for (i = 0; i < num_strings; i++)
+    {
+      gcov_unsigned_t string_len
+          = (strlen (module_info->string_array[i]) + sizeof (gcov_unsigned_t))
+          / sizeof (gcov_unsigned_t);
+      len += string_len;
+      len += 1; /* Each string is lead by a length.  */
+    }
+
+  len += 9; /* 9 more fields */
+
+  gcov_write_tag_length (GCOV_TAG_MODULE_INFO, len);
+  gcov_write_unsigned (module_info->ident);
+  gcov_write_unsigned (is_primary);
+  if (flag_alg_mode == INCLUSION_BASED_PRIORITY_ALGORITHM && is_primary)
+    SET_MODULE_INCLUDE_ALL_AUX (module_info);
+  gcov_write_unsigned (module_info->flags);
+  gcov_write_unsigned (module_info->lang);
+  gcov_write_unsigned (module_info->num_quote_paths);
+  gcov_write_unsigned (module_info->num_bracket_paths);
+  gcov_write_unsigned (module_info->num_cpp_defines);
+  gcov_write_unsigned (module_info->num_cpp_includes);
+  gcov_write_unsigned (module_info->num_cl_args);
+
+  /* Now write the filenames */
+  aligned_fname = (gcov_unsigned_t *) alloca ((filename_len + src_filename_len + 2) *
+					      sizeof (gcov_unsigned_t));
+  memset (aligned_fname, 0,
+          (filename_len + src_filename_len + 2) * sizeof (gcov_unsigned_t));
+  aligned_fname[0] = filename_len;
+  strcpy ((char*) (aligned_fname + 1), module_info->da_filename);
+  aligned_fname[filename_len + 1] = src_filename_len;
+  strcpy ((char*) (aligned_fname + filename_len + 2), module_info->source_filename);
+
+  for (i = 0; i < (filename_len + src_filename_len + 2); i++)
+    gcov_write_unsigned (aligned_fname[i]);
+
+  /* Now write the string array.  */
+  for (j = 0; j < num_strings; j++)
+    {
+      gcov_unsigned_t *aligned_string;
+      gcov_unsigned_t string_len =
+	(strlen (module_info->string_array[j]) + sizeof (gcov_unsigned_t)) /
+	sizeof (gcov_unsigned_t);
+      aligned_string = (gcov_unsigned_t *)
+	alloca ((string_len + 1) * sizeof (gcov_unsigned_t));
+      memset (aligned_string, 0, (string_len + 1) * sizeof (gcov_unsigned_t));
+      aligned_string[0] = string_len;
+      strcpy ((char*) (aligned_string + 1), module_info->string_array[j]);
+      for (i = 0; i < (string_len + 1); i++)
+        gcov_write_unsigned (aligned_string[i]);
+    }
+}
+
+/* Write out MOD_INFO and its imported modules into gcda file.  */
+
+void
+gcov_write_module_infos (struct gcov_info *mod_info)
+{
+  unsigned imp_len = 0;
+  const struct dyn_imp_mod **imp_mods;
+
+  gcov_write_module_info (mod_info, 1);
+
+  imp_mods = gcov_get_sorted_import_module_array (mod_info, &imp_len);
+  if (imp_mods)
+    {
+      unsigned i;
+
+      for (i = 0; i < imp_len; i++)
+        {
+          const struct gcov_info *imp_mod = imp_mods[i]->imp_mod;
+	  if (imp_mod != mod_info)
+            gcov_write_module_info (imp_mod, 0);
+        }
+      free (imp_mods);
+    }
+}
+
+/* Compute module groups needed for L-IPO compilation.  */
+
+void
+__gcov_compute_module_groups (void)
+{
+  gcov_type cut_off_count;
+  char *seed = getenv ("LIPO_RANDOM_GROUPING");
+  char *max_group_size = seed ? strchr (seed, ':') : 0;
+
+  /* The random group is set via compile time parameter.  */
+  if (__gcov_lipo_random_group_size != 0)
+    {
+      srandom (__gcov_lipo_random_seed);
+      init_dyn_call_graph ();
+      gcov_compute_random_module_groups (__gcov_lipo_random_group_size);
+      if (do_cgraph_dump () != 0)
+        {
+          fprintf (stderr, " Creating random grouping with %u:%u\n",
+                   __gcov_lipo_random_seed, __gcov_lipo_random_group_size);
+        }
+      return;
+    }
+  else if (seed && max_group_size)
+    {
+      *max_group_size = '\0';
+      max_group_size++;
+      srandom (atoi (seed));
+      init_dyn_call_graph ();
+      gcov_compute_random_module_groups (atoi (max_group_size));
+      if (do_cgraph_dump () != 0)
+        {
+          fprintf (stderr, " Creating random grouping with %s:%s\n",
+                   seed, max_group_size);
+        }
+      return;
+    }
+
+  /* First compute dynamic call graph.  */
+  gcov_build_callgraph ();
+
+  cut_off_count = gcov_compute_cutoff_count ();
+
+  gcov_compute_module_groups (cut_off_count);
+
+  gcov_dump_callgraph (cut_off_count);
+
+}
+
+/* Dumper function for NODE.  */
+static void
+gcov_dump_cgraph_node_short (struct dyn_cgraph_node *node)
+{
+  unsigned mod_id, func_id;
+  struct gcov_info *mod_info;
+  mod_id = get_module_ident_from_func_glob_uid (node->guid);
+  func_id = get_intra_module_func_id (node->guid);
+
+  mod_info = the_dyn_call_graph.modules[mod_id - 1];
+
+  fprintf (stderr, "NODE(%llx) module(%s) func(%u)",
+           (long long)node->guid,
+           mod_info->mod_info->source_filename, func_id);
+}
+
+/* Dumper function for NODE.   M is the module id and F is the function id.  */
+
+static void
+gcov_dump_cgraph_node (struct dyn_cgraph_node *node, unsigned m, unsigned f)
+{
+  unsigned mod_id, func_id;
+  struct gcov_info *mod_info;
+  struct dyn_cgraph_edge *callers;
+  struct dyn_cgraph_edge *callees;
+
+  mod_id = get_module_ident_from_func_glob_uid (node->guid);
+  func_id = get_intra_module_func_id (node->guid);
+  gcc_assert (mod_id == (m + 1) && func_id == f);
+
+  mod_info = the_dyn_call_graph.modules[mod_id - 1];
+
+  fprintf (stderr, "NODE(%llx) module(%s) func(%x)\n",
+           (long long) node->guid,
+           mod_info->mod_info->source_filename, f);
+
+  /* Now dump callers.  */
+  callers = node->callers;
+  fprintf (stderr, "\t[CALLERS]\n");
+  while (callers != 0)
+    {
+      fprintf (stderr,"\t\t[count=%ld] ", (long)  callers->count);
+      gcov_dump_cgraph_node_short (callers->caller);
+      fprintf (stderr,"\n");
+      callers = callers->next_caller;
+    }
+
+  callees = node->callees;
+  fprintf (stderr, "\t[CALLEES]\n");
+  while (callees != 0)
+    {
+      fprintf (stderr,"\t\t[count=%ld] ", (long)  callees->count);
+      gcov_dump_cgraph_node_short (callees->callee);
+      fprintf (stderr,"\n");
+      callees = callees->next_callee;
+    }
+}
+
+/* Dumper function for NODE.   M is the module_ident -1
+   and F is the function id.  */
+
+static void
+gcov_dump_cgraph_node_dot (struct dyn_cgraph_node *node,
+                           unsigned m, unsigned f,
+                           gcov_type cutoff_count)
+{
+  unsigned mod_id, func_id, imp_len = 0, i;
+  struct gcov_info *mod_info;
+  const struct dyn_imp_mod **imp_mods;
+  struct dyn_cgraph_edge *callees;
+
+  mod_id = get_module_ident_from_func_glob_uid (node->guid);
+  func_id = get_intra_module_func_id (node->guid);
+  gcc_assert (mod_id == (m + 1) && func_id == f);
+
+  mod_info = the_dyn_call_graph.modules[mod_id - 1];
+
+  fprintf (stderr, "NODE_%llx[label=\"MODULE\\n(%s)\\n FUNC(%x)\\n",
+           (long long) node->guid, mod_info->mod_info->source_filename, f);
+
+  imp_mods = gcov_get_sorted_import_module_array (mod_info, &imp_len);
+  fprintf (stderr, "IMPORTS:\\n");
+  if (imp_mods)
+    {
+      for (i = 0; i < imp_len; i++)
+        fprintf (stderr, "%s\\n", imp_mods[i]->imp_mod->mod_info->source_filename);
+      fprintf (stderr, "\"]\n");
+      free (imp_mods);
+    }
+  else
+    fprintf (stderr, "\"]\n");
+
+  callees = node->callees;
+  while (callees != 0)
+    {
+      if (callees->count >= cutoff_count)
+        fprintf (stderr, "NODE_%llx -> NODE_%llx[label=%lld color=red]\n",
+                 (long long) node->guid, (long long) callees->callee->guid,
+                 (long long) callees->count);
+      else
+        fprintf (stderr, "NODE_%llx -> NODE_%llx[label=%lld color=blue]\n",
+                 (long long) node->guid, (long long) callees->callee->guid,
+                 (long long) callees->count);
+      callees = callees->next_callee;
+    }
+}
+
+/* Dump dynamic call graph.  CUTOFF_COUNT is the computed hot edge threshold.  */
+
+static void
+gcov_dump_callgraph (gcov_type cutoff_count)
+{
+  struct gcov_info *gi_ptr;
+  unsigned m_ix;
+  int do_dump;
+
+  do_dump = do_cgraph_dump ();
+
+  if (do_dump == 0)
+    return;
+
+  fprintf (stderr,"digraph dyn_call_graph {\n");
+  fprintf (stderr,"node[shape=box]\nsize=\"11,8.5\"\n");
+
+  for (m_ix = 0; m_ix < the_dyn_call_graph.num_modules; m_ix++)
+    {
+      const struct gcov_fn_info *fi_ptr;
+      unsigned f_ix;
+
+      gi_ptr = the_dyn_call_graph.modules[m_ix];
+
+      for (f_ix = 0; f_ix < gi_ptr->n_functions; f_ix++)
+	{
+	  struct dyn_cgraph_node *node;
+
+	  fi_ptr = gi_ptr->functions[f_ix];
+	  node = *(pointer_set_find_or_insert
+		   (the_dyn_call_graph.call_graph_nodes[m_ix], fi_ptr->ident));
+	  gcc_assert (node);
+
+          /* skip dead functions  */
+          if (!node->callees && !node->callers)
+            continue;
+
+          if (do_dump == 1)
+            gcov_dump_cgraph_node (node, m_ix, fi_ptr->ident);
+          else
+            gcov_dump_cgraph_node_dot (node, m_ix, fi_ptr->ident,
+                                       cutoff_count);
+	}
+    }
+  fprintf (stderr,"}\n");
+}
+
+static int
+dump_imported_modules_1 (const void *value,
+                    void *data1 ATTRIBUTE_UNUSED,
+                    void *data2 ATTRIBUTE_UNUSED,
+                    void *data3 ATTRIBUTE_UNUSED)
+{
+  const struct dyn_imp_mod *d = (const struct dyn_imp_mod*) value;
+  fprintf (stderr, "%d ", get_module_ident (d->imp_mod));
+  return 1;
+}
+
+static int
+dump_exported_to_1 (const void *value,
+                    void *data1 ATTRIBUTE_UNUSED,
+                    void *data2 ATTRIBUTE_UNUSED,
+                    void *data3 ATTRIBUTE_UNUSED)
+{
+  const struct gcov_info *modu = (const struct gcov_info *) value;
+  fprintf (stderr, "%d ", get_module_ident (modu));
+  return 1;
+}
+
+static void ATTRIBUTE_UNUSED
+debug_dump_imported_modules (const struct dyn_pointer_set *p)
+{
+  fprintf (stderr, "imported: ");
+  pointer_set_traverse (p, dump_imported_modules_1, 0, 0, 0);
+  fprintf (stderr, "\n");
+}
+
+static void ATTRIBUTE_UNUSED
+debug_dump_exported_to (const struct dyn_pointer_set *p)
+{
+  fprintf (stderr, "exported: ");
+  pointer_set_traverse (p, dump_exported_to_1, 0, 0, 0);
+  fprintf (stderr, "\n");
+}
+#endif
diff --git a/libgcc/libgcov.c b/libgcc/libgcov.c
index a93eddb..4878e83 100644
--- a/libgcc/libgcov.c
+++ b/libgcc/libgcov.c
@@ -30,6 +30,12 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #include "libgcc_tm.h"
 #include "gthr.h"
 
+#if 1
+#define THREAD_PREFIX __thread
+#else
+#define THREAD_PREFIX
+#endif
+
 #if defined(inhibit_libc)
 #define IN_LIBGCOV (-1)
 #else
@@ -38,6 +44,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #define GCOV_LINKAGE /* nothing */
 #endif
 #endif
+
 #include "gcov-io.h"
 
 #if defined(inhibit_libc)
@@ -87,13 +94,67 @@ extern int gcov_dump_complete ATTRIBUTE_HIDDEN;
 #ifdef L_gcov
 #include "gcov-io.c"
 
-struct gcov_fn_buffer
+/* Create a strong reference to these symbols so that they are
+   unconditionally pulled into the instrumented binary, even when
+   the only reference is a weak reference. This is necessary because
+   we are using weak references to handle older compilers that
+   pre-date these new functions. A subtlety of the linker is that
+   it will only resolve weak references defined within archive libraries
+   when there is a string reference to something else defined within
+   the same object file. Since these two functions are defined within
+   their own object files (using L_gcov_reset and L_gcov_dump), they
+   would not get resolved. Since there are symbols within the main L_gcov
+   section that are strongly referenced during -fprofile-generate builds,
+   these symbols will always need to be resolved.  */
+void (*__gcov_dummy_ref1)() = &__gcov_reset;
+void (*__gcov_dummy_ref2)() = &__gcov_dump;
+
+
+/* Default callback function for profile instrumentation callback.  */
+__attribute__((weak)) void
+__coverage_callback (gcov_type funcdef_no __attribute__ ((unused)),
+                     int edge_no __attribute__ ((unused)))
 {
-  struct gcov_fn_buffer *next;
-  unsigned fn_ix;
-  struct gcov_fn_info info;
-  /* note gcov_fn_info ends in a trailing array.  */
-};
+   /* nothing */
+}
+
+
+/* Utility function for outputing errors.  */
+static int
+gcov_error (const char *fmt, ...)
+{
+  int ret;
+  va_list argp;
+  va_start (argp, fmt);
+  ret = vfprintf (stderr, fmt, argp);
+  va_end (argp);
+  return ret;
+}
+
+/* Emitted in coverage.c.  */
+
+/* Sampling period.  */
+extern gcov_unsigned_t __gcov_sampling_period;
+extern gcov_unsigned_t __gcov_has_sampling;
+static int gcov_sampling_period_initialized = 0;
+void __gcov_set_sampling_period (unsigned int period);
+unsigned int __gcov_sampling_enabled ();
+
+/* Set sampling period to PERIOD.  */
+
+void __gcov_set_sampling_period (unsigned int period)
+{
+  gcc_assert (__gcov_has_sampling);
+  __gcov_sampling_period = period;
+}
+
+unsigned int __gcov_sampling_enabled ()
+{
+  return __gcov_has_sampling;
+}
+
+/* Per thread sample counter.  */
+THREAD_PREFIX gcov_unsigned_t __gcov_sample_counter = 0;
 
 struct gcov_summary_buffer
 {
@@ -101,12 +162,69 @@ struct gcov_summary_buffer
   struct gcov_summary summary;
 };
 
+static struct gcov_summary_buffer *next_sum_buffer, *sum_buffer;
+static struct gcov_summary_buffer **sum_tail;
+
 /* Chain of per-object gcov structures.  */
-static struct gcov_info *gcov_list;
+extern struct gcov_info *__gcov_list;
+
+/* A program checksum allows us to distinguish program data for an
+   object file included in multiple programs.  */
+static gcov_unsigned_t gcov_crc32;
 
 /* Size of the longest file name. */
 static size_t gcov_max_filename = 0;
 
+/* Unique identifier assigned to each module (object file).  */
+static gcov_unsigned_t gcov_cur_module_id = 0;
+
+/* Pointer to the direct-call counters (per call-site counters).
+   Initialized by the caller.  */
+THREAD_PREFIX gcov_type *__gcov_direct_call_counters ATTRIBUTE_HIDDEN;
+
+/* Direct call callee address.  */
+THREAD_PREFIX void *__gcov_direct_call_callee ATTRIBUTE_HIDDEN;
+
+/* Pointer to the indirect-call counters (per call-site counters).
+   Initialized by the caller.  */
+THREAD_PREFIX gcov_type *__gcov_indirect_call_topn_counters ATTRIBUTE_HIDDEN;
+
+/* Indirect call callee address.  */
+THREAD_PREFIX void *__gcov_indirect_call_topn_callee ATTRIBUTE_HIDDEN;
+
+/* Dynamic call graph build and form module groups.  */
+void __gcov_compute_module_groups (void) ATTRIBUTE_HIDDEN;
+void __gcov_finalize_dyn_callgraph (void) ATTRIBUTE_HIDDEN;
+
+/* Profile summary for the gdca file, used in sanity check?  */
+static struct gcov_summary all;
+
+/* Profile summary for this program in current exeuction.  */
+static struct gcov_summary this_program;
+
+/* Merged profile summary for this program.  */
+static struct gcov_summary program;
+
+/* Record the position of summary info.  */
+static gcov_position_t summary_pos = 0;
+
+/* Record the postion of eof.  */
+static gcov_position_t eof_pos = 0;
+
+/* Number of chars in prefix to be stripped.  */
+static int gcov_prefix_strip = 0;
+
+/* The length of path prefix.  */
+static size_t prefix_length = 0;
+
+/* gi_filename is current object filename.
+   gi_filename_up points to the stripped filename.  */
+static char *gi_filename, *gi_filename_up;
+
+static int gcov_open_by_filename (char * gi_filename);
+static int gcov_exit_init (void);
+static void gcov_dump_one_gcov (struct gcov_info *gi_ptr);
+
 /* Flag when the profile has already been dumped via __gcov_dump().  */
 int gcov_dump_complete = 0;
 
@@ -157,86 +275,39 @@ create_file_directory (char *filename)
 #endif
 }
 
-static struct gcov_fn_buffer *
-free_fn_data (const struct gcov_info *gi_ptr, struct gcov_fn_buffer *buffer,
-	      unsigned limit)
-{
-  struct gcov_fn_buffer *next;
-  unsigned ix, n_ctr = 0;
-  
-  if (!buffer)
-    return 0;
-  next = buffer->next;
-
-  for (ix = 0; ix != limit; ix++)
-    if (gi_ptr->merge[ix])
-      free (buffer->info.ctrs[n_ctr++].values);
-  free (buffer);
-  return next;
-}
-  
-static struct gcov_fn_buffer **
-buffer_fn_data (const char *filename, const struct gcov_info *gi_ptr,
-		struct gcov_fn_buffer **end_ptr, unsigned fn_ix)
+/* Open a file with the specified name.  */
+
+static int
+gcov_open_by_filename (char * gi_filename)
 {
-  unsigned n_ctrs = 0, ix = 0;
-  struct gcov_fn_buffer *fn_buffer;
-  unsigned len;
-
-  for (ix = GCOV_COUNTERS; ix--;)
-    if (gi_ptr->merge[ix])
-      n_ctrs++;
-
-  len = sizeof (*fn_buffer) + sizeof (fn_buffer->info.ctrs[0]) * n_ctrs;
-  fn_buffer = (struct gcov_fn_buffer *)malloc (len);
-
-  if (!fn_buffer)
-    goto fail;
-  
-  fn_buffer->next = 0;
-  fn_buffer->fn_ix = fn_ix;
-  fn_buffer->info.ident = gcov_read_unsigned ();
-  fn_buffer->info.lineno_checksum = gcov_read_unsigned ();
-  fn_buffer->info.cfg_checksum = gcov_read_unsigned ();
-
-  for (n_ctrs = ix = 0; ix != GCOV_COUNTERS; ix++)
+  if (!gcov_open (gi_filename))
     {
-      gcov_unsigned_t length;
-      gcov_type *values;
-
-      if (!gi_ptr->merge[ix])
-	continue;
-      
-      if (gcov_read_unsigned () != GCOV_TAG_FOR_COUNTER (ix))
-	{
-	  len = 0;
-	  goto fail;
-	}
-
-      length = GCOV_TAG_COUNTER_NUM (gcov_read_unsigned ());
-      len = length * sizeof (gcov_type);
-      values = (gcov_type *)malloc (len);
-      if (!values)
-	goto fail;
-      
-      fn_buffer->info.ctrs[n_ctrs].num = length;
-      fn_buffer->info.ctrs[n_ctrs].values = values;
-
-      while (length--)
-	*values++ = gcov_read_counter ();
-      n_ctrs++;
+      /* Open failed likely due to missed directory.
+         Create directory and retry to open file.  */
+      if (create_file_directory (gi_filename))
+        {
+          gcov_error ("profiling:%s:Skip\n", gi_filename);
+          return -1;
+        }
+      if (!gcov_open (gi_filename))
+        {
+          gcov_error ("profiling:%s:Cannot open\n", gi_filename);
+          return -1;
+        }
     }
-  
-  *end_ptr = fn_buffer;
-  return &fn_buffer->next;
+  return 0;
+}
+
 
- fail:
-  fprintf (stderr, "profiling:%s:Function %u %s %u \n", filename, fn_ix,
-	   len ? "cannot allocate" : "counter mismatch", len ? len : ix);
+/* Determine whether a counter is active.  */
 
-  return (struct gcov_fn_buffer **)free_fn_data (gi_ptr, fn_buffer, ix);
+static inline int
+gcov_counter_active (const struct gcov_info *info, unsigned int type)
+{
+  return (info->merge[type] != 0);
 }
 
+
 /* Add an unsigned value to the current crc */
 
 static gcov_unsigned_t
@@ -262,8 +333,8 @@ crc32_unsigned (gcov_unsigned_t crc32, gcov_unsigned_t value)
    instead of value from the info block.  */
 
 static int
-gcov_version (struct gcov_info *ptr, gcov_unsigned_t version,
-	      const char *filename)
+gcov_version (struct gcov_info *ptr __attribute__ ((unused)), 
+              gcov_unsigned_t version, const char *filename)
 {
   if (version != GCOV_VERSION)
     {
@@ -272,14 +343,18 @@ gcov_version (struct gcov_info *ptr, gcov_unsigned_t version,
       GCOV_UNSIGNED2STRING (v, version);
       GCOV_UNSIGNED2STRING (e, GCOV_VERSION);
 
-      fprintf (stderr,
-	       "profiling:%s:Version mismatch - expected %.4s got %.4s\n",
-	       filename? filename : ptr->filename, e, v);
+      if (filename)
+        gcov_error ("profiling:%s:Version mismatch - expected %.4s got %.4s\n",
+                   filename, e, v);
+      else
+        gcov_error ("profiling:Version mismatch - expected %.4s got %.4s\n", e, v);
       return 0;
     }
   return 1;
 }
 
+#define GCOV_GET_FILENAME gcov_strip_leading_dirs
+
 /* Insert counter VALUE into HISTOGRAM.  */
 
 static void
@@ -323,7 +398,7 @@ gcov_compute_histogram (struct gcov_summary *sum)
 
   /* Walk through all the per-object structures and record each of
      the count values in histogram.  */
-  for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)
+  for (gi_ptr = __gcov_list; gi_ptr; gi_ptr = gi_ptr->next)
     {
       if (!gi_ptr->merge[t_ix])
         continue;
@@ -357,97 +432,78 @@ gcov_compute_histogram (struct gcov_summary *sum)
    in two separate programs, and we must keep the two program
    summaries separate.  */
 
-void
-gcov_exit (void)
+/* Strip GCOV_PREFIX_STRIP levels of leading '/' from FILENAME and
+   put the result into GI_FILENAME_UP.  */
+
+static void
+gcov_strip_leading_dirs (int prefix_length, int gcov_prefix_strip,
+			 const char *filename, char *gi_filename_up)
 {
-  struct gcov_info *gi_ptr;
-  const struct gcov_fn_info *gfi_ptr;
-  struct gcov_summary this_prg; /* summary for program.  */
-#if !GCOV_LOCKED
-  struct gcov_summary all_prg;  /* summary for all instances of program.  */
-#endif
-  struct gcov_ctr_summary *cs_ptr;
-  const struct gcov_ctr_info *ci_ptr;
-  unsigned t_ix;
-  int f_ix;
-  gcov_unsigned_t c_num;
-  const char *gcov_prefix;
-  int gcov_prefix_strip = 0;
-  size_t prefix_length;
-  char *gi_filename, *gi_filename_up;
-  gcov_unsigned_t crc32 = 0;
+  /* Avoid to add multiple drive letters into combined path.  */
+  if (prefix_length != 0 && HAS_DRIVE_SPEC(filename))
+    filename += 2;
 
-  /* Prevent the counters from being dumped a second time on exit when the
-     application already wrote out the profile using __gcov_dump().  */
-  if (gcov_dump_complete)
-    return;
+  /* Build relocated filename, stripping off leading
+     directories from the initial filename if requested. */
+  if (gcov_prefix_strip > 0)
+    {
+      int level = 0;
+      const char *s = filename;
+      if (IS_DIR_SEPARATOR(*s))
+	++s;
+
+      /* Skip selected directory levels. */
+      for (; (*s != '\0') && (level < gcov_prefix_strip); s++)
+        if (IS_DIR_SEPARATOR(*s))
+          {
+            filename = s;
+            level++;
+          }
+    }
 
-#if !GCOV_LOCKED
-  memset (&all_prg, 0, sizeof (all_prg));
-#endif
-  /* Find the totals for this execution.  */
-  memset (&this_prg, 0, sizeof (this_prg));
-  for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)
+  /* Update complete filename with stripped original. */
+  if (prefix_length != 0 && !IS_DIR_SEPARATOR (*filename))
     {
-      crc32 = crc32_unsigned (crc32, gi_ptr->stamp);
-      crc32 = crc32_unsigned (crc32, gi_ptr->n_functions);
-      
-      for (f_ix = 0; (unsigned)f_ix != gi_ptr->n_functions; f_ix++)
-	{
-	  gfi_ptr = gi_ptr->functions[f_ix];
-
-	  if (gfi_ptr && gfi_ptr->key != gi_ptr)
-	    gfi_ptr = 0;
-	  
-	  crc32 = crc32_unsigned (crc32, gfi_ptr ? gfi_ptr->cfg_checksum : 0);
-	  crc32 = crc32_unsigned (crc32,
-				  gfi_ptr ? gfi_ptr->lineno_checksum : 0);
-	  if (!gfi_ptr)
-	    continue;
+      /* If prefix is given, add directory separator.  */
+      strcpy (gi_filename_up, "/");
+      strcpy (gi_filename_up + 1, filename);
+    }
+  else
+    strcpy (gi_filename_up, filename);
+}
 
-	  ci_ptr = gfi_ptr->ctrs;
-	  for (t_ix = 0; t_ix != GCOV_COUNTERS_SUMMABLE; t_ix++)
-	    {
-	      if (!gi_ptr->merge[t_ix])
-		continue;
+/* This function allocates the space to store current file name.  */
 
-	      cs_ptr = &this_prg.ctrs[t_ix];
-	      cs_ptr->num += ci_ptr->num;
-	      crc32 = crc32_unsigned (crc32, ci_ptr->num);
-	      
-	      for (c_num = 0; c_num < ci_ptr->num; c_num++)
-		{
-		  cs_ptr->sum_all += ci_ptr->values[c_num];
-		  if (cs_ptr->run_max < ci_ptr->values[c_num])
-		    cs_ptr->run_max = ci_ptr->values[c_num];
-		}
-	      ci_ptr++;
-	    }
-	}
-    }
-  gcov_compute_histogram (&this_prg);
+static void
+gcov_alloc_filename (void)
+{
+  /* Get file name relocation prefix.  Non-absolute values are ignored.  */
+  const char *gcov_prefix = 0;
+
+  prefix_length = 0;
+  gcov_prefix_strip = 0;
 
   {
     /* Check if the level of dirs to strip off specified. */
-    char *tmp = getenv("GCOV_PREFIX_STRIP");
+    char *tmp = getenv ("GCOV_PREFIX_STRIP");
     if (tmp)
       {
-	gcov_prefix_strip = atoi (tmp);
-	/* Do not consider negative values. */
-	if (gcov_prefix_strip < 0)
-	  gcov_prefix_strip = 0;
+        gcov_prefix_strip = atoi (tmp);
+        /* Do not consider negative values. */
+        if (gcov_prefix_strip < 0)
+          gcov_prefix_strip = 0;
       }
   }
 
   /* Get file name relocation prefix.  Non-absolute values are ignored. */
-  gcov_prefix = getenv("GCOV_PREFIX");
+  gcov_prefix = getenv ("GCOV_PREFIX");
   if (gcov_prefix)
     {
       prefix_length = strlen(gcov_prefix);
 
       /* Remove an unnecessary trailing '/' */
       if (IS_DIR_SEPARATOR (gcov_prefix[prefix_length - 1]))
-	prefix_length--;
+        prefix_length--;
     }
   else
     prefix_length = 0;
@@ -459,371 +515,164 @@ gcov_exit (void)
       gcov_prefix = ".";
       prefix_length = 1;
     }
-  /* Allocate and initialize the filename scratch space plus one.  */
-  gi_filename = (char *) alloca (prefix_length + gcov_max_filename + 2);
+
+  /* Allocate and initialize the filename scratch space.  */
+  gi_filename = (char *) malloc (prefix_length + gcov_max_filename + 2);
   if (prefix_length)
     memcpy (gi_filename, gcov_prefix, prefix_length);
+
   gi_filename_up = gi_filename + prefix_length;
+}
 
-  /* Now merge each file.  */
-  for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)
+/* Sort N entries in VALUE_ARRAY in descending order.
+   Each entry in VALUE_ARRAY has two values. The sorting
+   is based on the second value.  */
+
+GCOV_LINKAGE  void
+gcov_sort_n_vals (gcov_type *value_array, int n)
+{
+  int j, k;
+  for (j = 2; j < n; j += 2)
     {
-      unsigned n_counts;
-      struct gcov_summary prg; /* summary for this object over all
-				  program.  */
-      struct gcov_ctr_summary *cs_prg, *cs_tprg;
-#if !GCOV_LOCKED
-      struct gcov_ctr_summary *cs_all;
-#endif
-      int error = 0;
-      gcov_unsigned_t tag, length;
-      gcov_position_t summary_pos = 0;
-      gcov_position_t eof_pos = 0;
-      const char *fname, *s;
-      struct gcov_fn_buffer *fn_buffer = 0;
-      struct gcov_fn_buffer **fn_tail = &fn_buffer;
-      struct gcov_summary_buffer *next_sum_buffer, *sum_buffer = 0;
-      struct gcov_summary_buffer **sum_tail = &sum_buffer;
-
-      fname = gi_ptr->filename;
-
-      /* Avoid to add multiple drive letters into combined path.  */
-      if (prefix_length != 0 && HAS_DRIVE_SPEC(fname))
-        fname += 2;
-
-      /* Build relocated filename, stripping off leading
-         directories from the initial filename if requested. */
-      if (gcov_prefix_strip > 0)
+      gcov_type cur_ent[2];
+      cur_ent[0] = value_array[j];
+      cur_ent[1] = value_array[j + 1];
+      k = j - 2;
+      while (k >= 0 && value_array[k + 1] < cur_ent[1])
         {
-          int level = 0;
-          s = fname;
-          if (IS_DIR_SEPARATOR(*s))
-            ++s;
-
-          /* Skip selected directory levels. */
-	  for (; (*s != '\0') && (level < gcov_prefix_strip); s++)
-	    if (IS_DIR_SEPARATOR(*s))
-	      {
-		fname = s;
-		level++;
-	      }
+          value_array[k + 2] = value_array[k];
+          value_array[k + 3] = value_array[k+1];
+          k -= 2;
         }
+      value_array[k + 2] = cur_ent[0];
+      value_array[k + 3] = cur_ent[1];
+    }
+}
 
-      /* Update complete filename with stripped original. */
-      if (prefix_length != 0 && !IS_DIR_SEPARATOR (*fname))
-        {
-          /* If prefix is given, add directory separator.  */
-	  strcpy (gi_filename_up, "/");
-	  strcpy (gi_filename_up + 1, fname);
-	}
-      else
-        strcpy (gi_filename_up, fname);
-
-      if (!gcov_open (gi_filename))
-	{
-	  /* Open failed likely due to missed directory.
-	     Create directory and retry to open file. */
-          if (create_file_directory (gi_filename))
-	    {
-	      fprintf (stderr, "profiling:%s:Skip\n", gi_filename);
-	      continue;
-	    }
-	  if (!gcov_open (gi_filename))
-	    {
-              fprintf (stderr, "profiling:%s:Cannot open\n", gi_filename);
-	      continue;
-	    }
-	}
-
-      tag = gcov_read_unsigned ();
-      if (tag)
-	{
-	  /* Merge data from file.  */
-	  if (tag != GCOV_DATA_MAGIC)
-	    {
-	      fprintf (stderr, "profiling:%s:Not a gcov data file\n",
-		       gi_filename);
-	      goto read_fatal;
-	    }
-	  length = gcov_read_unsigned ();
-	  if (!gcov_version (gi_ptr, length, gi_filename))
-	    goto read_fatal;
-
-	  length = gcov_read_unsigned ();
-	  if (length != gi_ptr->stamp)
-	    /* Read from a different compilation. Overwrite the file.  */
-	    goto rewrite;
-
-	  /* Look for program summary.  */
-	  for (f_ix = 0;;)
-	    {
-	      struct gcov_summary tmp;
-	      
-	      eof_pos = gcov_position ();
-	      tag = gcov_read_unsigned ();
-	      if (tag != GCOV_TAG_PROGRAM_SUMMARY)
-		break;
-
-	      f_ix--;
-	      length = gcov_read_unsigned ();
-	      gcov_read_summary (&tmp);
-	      if ((error = gcov_is_error ()))
-		goto read_error;
-	      if (summary_pos)
-                {
-                  /* Save all summaries after the one that will be
-                     merged into below. These will need to be rewritten
-                     as histogram merging may change the number of non-zero
-                     histogram entries that will be emitted, and thus the
-                     size of the merged summary.  */
-                  (*sum_tail) = (struct gcov_summary_buffer *)
-                      malloc (sizeof(struct gcov_summary_buffer));
-                  (*sum_tail)->summary = tmp;
-                  (*sum_tail)->next = 0;
-                  sum_tail = &((*sum_tail)->next);
-                  goto next_summary;
-                }
-	      if (tmp.checksum != crc32)
-                goto next_summary;
-	      
-	      for (t_ix = 0; t_ix != GCOV_COUNTERS_SUMMABLE; t_ix++)
-		if (tmp.ctrs[t_ix].num != this_prg.ctrs[t_ix].num)
-                  goto next_summary;
-	      prg = tmp;
-	      summary_pos = eof_pos;
-
-	    next_summary:;
-	    }
-	  
-	  /* Merge execution counts for each function.  */
-	  for (f_ix = 0; (unsigned)f_ix != gi_ptr->n_functions;
-	       f_ix++, tag = gcov_read_unsigned ())
-	    {
-	      gfi_ptr = gi_ptr->functions[f_ix];
-
-	      if (tag != GCOV_TAG_FUNCTION)
-		goto read_mismatch;
-
-	      length = gcov_read_unsigned ();
-	      if (!length)
-		/* This function did not appear in the other program.
-		   We have nothing to merge.  */
-		continue;
-
-	      if (length != GCOV_TAG_FUNCTION_LENGTH)
-		goto read_mismatch;
-	      
-	      if (!gfi_ptr || gfi_ptr->key != gi_ptr)
-		{
-		  /* This function appears in the other program.  We
-		     need to buffer the information in order to write
-		     it back out -- we'll be inserting data before
-		     this point, so cannot simply keep the data in the
-		     file.  */
-		  fn_tail = buffer_fn_data (gi_filename,
-					    gi_ptr, fn_tail, f_ix);
-		  if (!fn_tail)
-		    goto read_mismatch;
-		  continue;
-		}
-
-	      length = gcov_read_unsigned ();
-	      if (length != gfi_ptr->ident)
-		goto read_mismatch;
-	      
-	      length = gcov_read_unsigned ();
-	      if (length != gfi_ptr->lineno_checksum)
-		goto read_mismatch;
-	      
-	      length = gcov_read_unsigned ();
-	      if (length != gfi_ptr->cfg_checksum)
-		goto read_mismatch;
-	      
-	      ci_ptr = gfi_ptr->ctrs;
-	      for (t_ix = 0; t_ix < GCOV_COUNTERS; t_ix++)
-		{
-		  gcov_merge_fn merge = gi_ptr->merge[t_ix];
-
-		  if (!merge)
-		    continue;
-
-		  tag = gcov_read_unsigned ();
-		  length = gcov_read_unsigned ();
-		  if (tag != GCOV_TAG_FOR_COUNTER (t_ix)
-		      || length != GCOV_TAG_COUNTER_LENGTH (ci_ptr->num))
-		    goto read_mismatch;
-		  (*merge) (ci_ptr->values, ci_ptr->num);
-		  ci_ptr++;
-		}
-	      if ((error = gcov_is_error ()))
-		goto read_error;
-	    }
-
-	  if (tag)
-	    {
-	    read_mismatch:;
-	      fprintf (stderr, "profiling:%s:Merge mismatch for %s %u\n",
-		       gi_filename, f_ix >= 0 ? "function" : "summary",
-		       f_ix < 0 ? -1 - f_ix : f_ix);
-	      goto read_fatal;
-	    }
-	}
-      goto rewrite;
+/* Sort the profile counters for all indirect call sites. Counters
+   for each call site are allocated in array COUNTERS.  */
 
-    read_error:;
-      fprintf (stderr, "profiling:%s:%s merging\n", gi_filename,
-	       error < 0 ? "Overflow": "Error");
+static void
+gcov_sort_icall_topn_counter (const struct gcov_ctr_info *counters)
+{
+  int i;
+  gcov_type *values;
+  int n = counters->num;
+  gcc_assert (!(n % GCOV_ICALL_TOPN_NCOUNTS));
 
-      goto read_fatal;
+  values = counters->values;
 
-    rewrite:;
-      gcov_rewrite ();
-      if (!summary_pos)
-	{
-	  memset (&prg, 0, sizeof (prg));
-	  summary_pos = eof_pos;
-	}
-
-      /* Merge the summaries.  */
-      for (t_ix = 0; t_ix < GCOV_COUNTERS_SUMMABLE; t_ix++)
-	{
-	  cs_prg = &prg.ctrs[t_ix];
-	  cs_tprg = &this_prg.ctrs[t_ix];
+  for (i = 0; i < n; i += GCOV_ICALL_TOPN_NCOUNTS)
+    {
+      gcov_type *value_array = &values[i + 1];
+      gcov_sort_n_vals (value_array, GCOV_ICALL_TOPN_NCOUNTS - 1);
+    }
+}
 
-	  if (gi_ptr->merge[t_ix])
-	    {
-	      if (!cs_prg->runs++)
-	        cs_prg->num = cs_tprg->num;
-	      cs_prg->sum_all += cs_tprg->sum_all;
-	      if (cs_prg->run_max < cs_tprg->run_max)
-		cs_prg->run_max = cs_tprg->run_max;
-	      cs_prg->sum_max += cs_tprg->run_max;
-              if (cs_prg->runs == 1)
-                memcpy (cs_prg->histogram, cs_tprg->histogram,
-                        sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);
-              else
-                gcov_histogram_merge (cs_prg->histogram, cs_tprg->histogram);
-	    }
-	  else if (cs_prg->runs)
-	    goto read_mismatch;
+/* Write imported files (auxiliary modules) for primary module GI_PTR
+   into file GI_FILENAME.  */
 
-#if !GCOV_LOCKED
-	  cs_all = &all_prg.ctrs[t_ix];
-	  if (!cs_all->runs && cs_prg->runs)
-            {
-              cs_all->num = cs_prg->num;
-              cs_all->runs = cs_prg->runs;
-              cs_all->sum_all = cs_prg->sum_all;
-              cs_all->run_max = cs_prg->run_max;
-              cs_all->sum_max = cs_prg->sum_max;
-            }
-	  else if (!all_prg.checksum
-                   /* Don't compare the histograms, which may have slight
-                      variations depending on the order they were updated
-                      due to the truncating integer divides used in the
-                      merge.  */
-                   && (cs_all->num != cs_prg->num
-                       || cs_all->runs != cs_prg->runs
-                       || cs_all->sum_all != cs_prg->sum_all
-                       || cs_all->run_max != cs_prg->run_max
-                       || cs_all->sum_max != cs_prg->sum_max))
+static void
+gcov_write_import_file (char *gi_filename, struct gcov_info *gi_ptr)
+{
+  char  *gi_imports_filename;
+  const char *gcov_suffix;
+  FILE *imports_file;
+  size_t prefix_length, suffix_length;
+
+  gcov_suffix = getenv ("GCOV_IMPORTS_SUFFIX");
+  if (!gcov_suffix || !strlen (gcov_suffix))
+    gcov_suffix = ".imports";
+  suffix_length = strlen (gcov_suffix);
+  prefix_length = strlen (gi_filename);
+  gi_imports_filename = (char *) alloca (prefix_length + suffix_length + 1);
+  memset (gi_imports_filename, 0, prefix_length + suffix_length + 1);
+  memcpy (gi_imports_filename, gi_filename, prefix_length);
+  memcpy (gi_imports_filename + prefix_length, gcov_suffix, suffix_length);
+  imports_file = fopen (gi_imports_filename, "w");
+  if (imports_file)
+    {
+      const struct dyn_imp_mod **imp_mods;
+      unsigned i, imp_len;
+      imp_mods = gcov_get_sorted_import_module_array (gi_ptr, &imp_len);
+      if (imp_mods)
+        {
+          for (i = 0; i < imp_len; i++)
 	    {
-	      fprintf (stderr,
-                       "profiling:%s:Data file mismatch - some data files may "
-                       "have been concurrently updated without locking support\n",
-		       gi_filename);
-	      all_prg.checksum = ~0u;
+	      fprintf (imports_file, "%s\n",
+		       imp_mods[i]->imp_mod->mod_info->source_filename);
+	      fprintf (imports_file, "%s%s\n",
+		       imp_mods[i]->imp_mod->mod_info->da_filename, GCOV_DATA_SUFFIX);
 	    }
-#endif
-	}
-
-      prg.checksum = crc32;
-
-      /* Write out the data.  */
-      if (!eof_pos)
-	{
-	  gcov_write_tag_length (GCOV_DATA_MAGIC, GCOV_VERSION);
-	  gcov_write_unsigned (gi_ptr->stamp);
-	}
+          free (imp_mods);
+        }
+      fclose (imports_file);
+    }
+}
 
-      if (summary_pos)
-	gcov_seek (summary_pos);
+static void
+gcov_dump_module_info (void)
+{
+  struct gcov_info *gi_ptr;
 
-      /* Generate whole program statistics.  */
-      gcov_write_summary (GCOV_TAG_PROGRAM_SUMMARY, &prg);
+  __gcov_compute_module_groups ();
 
-      /* Rewrite all the summaries that were after the summary we merged
-         into. This is necessary as the merged summary may have a different
-         size due to the number of non-zero histogram entries changing after
-         merging.  */
-      
-      while (sum_buffer)
-        {
-          gcov_write_summary (GCOV_TAG_PROGRAM_SUMMARY, &sum_buffer->summary);
-          next_sum_buffer = sum_buffer->next;
-          free (sum_buffer);
-          sum_buffer = next_sum_buffer;
-        }
+  /* Now write out module group info.  */
+  for (gi_ptr = __gcov_list; gi_ptr; gi_ptr = gi_ptr->next)
+  {
+    int error;
+
+    GCOV_GET_FILENAME (prefix_length, gcov_prefix_strip, gi_ptr->filename,
+                       gi_filename_up);
+    error = gcov_open_by_filename (gi_filename);
+    if (error != 0)
+      continue;
+
+    /* Overwrite the zero word at the of the file.  */
+    gcov_rewrite ();
+    gcov_seek (gi_ptr->eof_pos);
+
+    gcov_write_module_infos (gi_ptr);
+    /* Write the end marker  */
+    gcov_write_unsigned (0);
+    gcov_truncate ();
+
+    if ((error = gcov_close ()))
+         gcov_error (error  < 0 ?  "profiling:%s:Overflow writing\n" :
+                                   "profiling:%s:Error writing\n",
+                                   gi_filename);
+    gcov_write_import_file (gi_filename, gi_ptr);
+  }
+  __gcov_finalize_dyn_callgraph ();
+}
 
-      /* Write execution counts for each function.  */
-      for (f_ix = 0; (unsigned)f_ix != gi_ptr->n_functions; f_ix++)
-	{
-	  unsigned buffered = 0;
+/* Dump the coverage counts. We merge with existing counts when
+   possible, to avoid growing the .da files ad infinitum. We use this
+   program's checksum to make sure we only accumulate whole program
+   statistics to the correct summary. An object file might be embedded
+   in two separate programs, and we must keep the two program
+   summaries separate.  */
 
-	  if (fn_buffer && fn_buffer->fn_ix == (unsigned)f_ix)
-	    {
-	      /* Buffered data from another program.  */
-	      buffered = 1;
-	      gfi_ptr = &fn_buffer->info;
-	      length = GCOV_TAG_FUNCTION_LENGTH;
-	    }
-	  else
-	    {
-	      gfi_ptr = gi_ptr->functions[f_ix];
-	      if (gfi_ptr && gfi_ptr->key == gi_ptr)
-		length = GCOV_TAG_FUNCTION_LENGTH;
-	      else
-		length = 0;
-	    }
-	  
-	  gcov_write_tag_length (GCOV_TAG_FUNCTION, length);
-	  if (!length)
-	    continue;
-	  
-	  gcov_write_unsigned (gfi_ptr->ident);
-	  gcov_write_unsigned (gfi_ptr->lineno_checksum);
-	  gcov_write_unsigned (gfi_ptr->cfg_checksum);
+void
+gcov_exit (void)
+{
+  struct gcov_info *gi_ptr;
+  int dump_module_info;
 
-	  ci_ptr = gfi_ptr->ctrs;
-	  for (t_ix = 0; t_ix < GCOV_COUNTERS; t_ix++)
-	    {
-	      if (!gi_ptr->merge[t_ix])
-		continue;
+  /* Prevent the counters from being dumped a second time on exit when the
+     application already wrote out the profile using __gcov_dump().  */
+  if (gcov_dump_complete)
+    return;
 
-	      n_counts = ci_ptr->num;
-	      gcov_write_tag_length (GCOV_TAG_FOR_COUNTER (t_ix),
-				     GCOV_TAG_COUNTER_LENGTH (n_counts));
-	      gcov_type *c_ptr = ci_ptr->values;
-	      while (n_counts--)
-		gcov_write_counter (*c_ptr++);
-	      ci_ptr++;
-	    }
-	  if (buffered)
-	    fn_buffer = free_fn_data (gi_ptr, fn_buffer, GCOV_COUNTERS);
-	}
+  dump_module_info = gcov_exit_init ();
 
-      gcov_write_unsigned (0);
+  for (gi_ptr = __gcov_list; gi_ptr; gi_ptr = gi_ptr->next)
+    gcov_dump_one_gcov (gi_ptr);
 
-    read_fatal:;
-      while (fn_buffer)
-	fn_buffer = free_fn_data (gi_ptr, fn_buffer, GCOV_COUNTERS);
+  if (dump_module_info)
+    gcov_dump_module_info ();
 
-      if ((error = gcov_close ()))
-	  fprintf (stderr, error  < 0 ?
-		   "profiling:%s:Overflow writing\n" :
-		   "profiling:%s:Error writing\n",
-		   gi_filename);
-    }
+  free (gi_filename);
 }
 
 /* Reset all counters to zero.  */
@@ -833,7 +682,7 @@ gcov_clear (void)
 {
   const struct gcov_info *gi_ptr;
 
-  for (gi_ptr = gcov_list; gi_ptr; gi_ptr = gi_ptr->next)
+  for (gi_ptr = __gcov_list; gi_ptr; gi_ptr = gi_ptr->next)
     {
       unsigned f_ix;
 
@@ -863,21 +712,43 @@ gcov_clear (void)
 void
 __gcov_init (struct gcov_info *info)
 {
+  if (!gcov_sampling_period_initialized)
+    {
+      const char* env_value_str = getenv ("GCOV_SAMPLING_PERIOD");
+      if (env_value_str)
+        {
+          int env_value_int = atoi(env_value_str);
+          if (env_value_int >= 1)
+            __gcov_sampling_period = env_value_int;
+        }
+      gcov_sampling_period_initialized = 1;
+    }
+
   if (!info->version || !info->n_functions)
     return;
+
   if (gcov_version (info, info->version, 0))
     {
-      size_t filename_length = strlen(info->filename);
+      const char *ptr = info->filename;
+      size_t filename_length = strlen (info->filename);
 
-      /* Refresh the longest file name information */
+      /* Refresh the longest file name information.  */
       if (filename_length > gcov_max_filename)
         gcov_max_filename = filename_length;
 
-      if (!gcov_list)
-	atexit (gcov_exit);
+      /* Assign the module ID (starting at 1).  */
+      info->mod_info->ident = (++gcov_cur_module_id);
+      gcc_assert (EXTRACT_MODULE_ID_FROM_GLOBAL_ID (GEN_FUNC_GLOBAL_ID (
+                                                       info->mod_info->ident, 0))
+                  == info->mod_info->ident);
 
-      info->next = gcov_list;
-      gcov_list = info;
+      if (!__gcov_list)
+        {
+          atexit (gcov_exit);
+        }
+
+      info->next = __gcov_list;
+      __gcov_list = info;
     }
   info->version = 0;
 }
@@ -917,6 +788,476 @@ __gcov_flush (void)
   __gthread_mutex_unlock (&__gcov_flush_mx);
 }
 
+static void
+gcov_sort_topn_counter_arrays (const struct gcov_info *gi_ptr)
+{
+  unsigned int i;
+  int f_ix;
+  const struct gcov_fn_info *gfi_ptr;
+  const struct gcov_ctr_info *ci_ptr;
+
+  for (f_ix = 0; (unsigned)f_ix != gi_ptr->n_functions; f_ix++)
+    {
+      gfi_ptr = gi_ptr->functions[f_ix];
+      ci_ptr = gfi_ptr->ctrs;
+      for (i = 0; i < GCOV_COUNTERS; i++)
+        {
+          if (!gcov_counter_active (gi_ptr, i))
+            continue;
+          if (i == GCOV_COUNTER_ICALL_TOPNV)
+            {
+              gcov_sort_icall_topn_counter (ci_ptr);
+              break;
+            }
+          ci_ptr++;
+        }
+     }
+}
+
+/* Compute object summary recored in gcov_info INFO. The result is
+   stored in OBJ_SUM. Note that the caller is responsible for
+   zeroing out OBJ_SUM, otherwise the summary is accumulated.  */
+
+static void
+gcov_object_summary (struct gcov_info *info, struct gcov_summary *obj_sum)
+{
+  const struct gcov_fn_info *gfi_ptr;
+  const struct gcov_ctr_info *ci_ptr;
+  struct gcov_ctr_summary *cs_ptr;
+  gcov_unsigned_t c_num;
+  unsigned t_ix;
+  int f_ix;
+  gcov_unsigned_t crc32 = gcov_crc32;
+
+  /* Totals for this object file.  */
+  crc32 = crc32_unsigned (crc32, info->stamp);
+  crc32 = crc32_unsigned (crc32, info->n_functions);
+
+  for (f_ix = 0; (unsigned) f_ix != info->n_functions; f_ix++)
+    {
+      gfi_ptr = info->functions[f_ix];
+
+      if (!gfi_ptr || gfi_ptr->key != info)
+        gfi_ptr = 0;
+
+      crc32 = crc32_unsigned (crc32, gfi_ptr ? gfi_ptr->cfg_checksum : 0);
+      crc32 = crc32_unsigned (crc32,
+                              gfi_ptr ? gfi_ptr->lineno_checksum : 0);
+
+      if (!gfi_ptr)
+        continue;
+
+      ci_ptr = gfi_ptr->ctrs;
+      for (t_ix = 0; t_ix < GCOV_COUNTERS_SUMMABLE; t_ix++)
+        {
+          if (!info->merge[t_ix])
+            continue;
+
+          cs_ptr = &(obj_sum->ctrs[t_ix]);
+          cs_ptr->num += ci_ptr->num;
+          crc32 = crc32_unsigned (crc32, ci_ptr->num);
+
+          for (c_num = 0; c_num < ci_ptr->num; c_num++)
+            {
+              cs_ptr->sum_all += ci_ptr->values[c_num];
+              if (cs_ptr->run_max < ci_ptr->values[c_num])
+                cs_ptr->run_max = ci_ptr->values[c_num];
+            }
+          ci_ptr++;
+        }
+    }
+  gcov_crc32 = crc32;
+}
+
+/* Merge with existing gcda file in the same directory to avoid
+   excessive growthe of the files.  */
+
+static int
+gcov_merge_gcda_file (struct gcov_info *gi_ptr)
+{
+  struct gcov_ctr_summary *cs_prg, *cs_tprg, *cs_all;
+  unsigned t_ix, f_ix = 0;
+
+  const struct gcov_fn_info *gfi_ptr;
+  int error = 0;
+  gcov_unsigned_t tag, length, version, stamp;
+
+  eof_pos = 0;
+  summary_pos = 0;
+  sum_buffer = 0;
+  sum_tail = &sum_buffer;
+
+  tag = gcov_read_unsigned ();
+  if (tag)
+    {
+      /* Merge data from file.  */
+      if (tag != GCOV_DATA_MAGIC)
+        {
+          gcov_error ("profiling:%s:Not a gcov data file\n", gi_filename);
+          goto read_fatal;
+        }
+     version = gcov_read_unsigned ();
+     if (!gcov_version (gi_ptr, version, gi_filename))
+       goto read_fatal;
+
+     stamp = gcov_read_unsigned ();
+     if (stamp != gi_ptr->stamp)
+       /* Read from a different compilation. Overwrite the file.  */
+       goto rewrite;
+
+      /* Look for program summary.  */
+     for (f_ix = ~0u;;)
+       {
+         struct gcov_summary tmp;
+
+         eof_pos = gcov_position ();
+         tag = gcov_read_unsigned ();
+         if (tag != GCOV_TAG_PROGRAM_SUMMARY)
+           break;
+
+         length = gcov_read_unsigned ();
+         gcov_read_summary (&tmp);
+         if ((error = gcov_is_error ()))
+           goto read_error;
+         if (summary_pos)
+             {
+               /* Save all summaries after the one that will be
+                  merged into below. These will need to be rewritten
+                  as histogram merging may change the number of non-zero
+                  histogram entries that will be emitted, and thus the
+                  size of the merged summary.  */
+               (*sum_tail) = (struct gcov_summary_buffer *)
+                   malloc (sizeof(struct gcov_summary_buffer));
+               (*sum_tail)->summary = tmp;
+               (*sum_tail)->next = 0;
+               sum_tail = &((*sum_tail)->next);
+               goto next_summary;
+             }
+           if (tmp.checksum != gcov_crc32)
+             goto next_summary;
+
+           for (t_ix = 0; t_ix != GCOV_COUNTERS_SUMMABLE; t_ix++)
+             if (tmp.ctrs[t_ix].num != this_program.ctrs[t_ix].num)
+               goto next_summary;
+           program = tmp;
+           summary_pos = eof_pos;
+
+         next_summary:;
+         }
+
+     /* Merge execution counts for each function.  */
+     for (f_ix = 0; f_ix != gi_ptr->n_functions;
+          f_ix++, tag = gcov_read_unsigned ())
+       {
+         const struct gcov_ctr_info *ci_ptr;
+
+         gfi_ptr = gi_ptr->functions[f_ix];
+
+         if (tag != GCOV_TAG_FUNCTION)
+           goto read_mismatch;
+         length = gcov_read_unsigned ();
+
+         if (!length)
+           /* This function did not appear in the other program.
+              We have nothing to merge.  */
+           continue;
+
+         /* Check function.  */
+         if (length != GCOV_TAG_FUNCTION_LENGTH)
+           goto read_mismatch;
+
+         gcc_assert (gfi_ptr && gfi_ptr->key == gi_ptr);
+
+         if (gcov_read_unsigned () != gfi_ptr->ident
+             || gcov_read_unsigned () != gfi_ptr->lineno_checksum
+             || gcov_read_unsigned () != gfi_ptr->cfg_checksum)
+            goto read_mismatch;
+
+         ci_ptr = gfi_ptr->ctrs;
+         for (t_ix = 0; t_ix < GCOV_COUNTERS; t_ix++)
+           {
+             gcov_merge_fn merge = gi_ptr->merge[t_ix];
+
+             if (!merge)
+               continue;
+
+             tag = gcov_read_unsigned ();
+             length = gcov_read_unsigned ();
+             if (tag != GCOV_TAG_FOR_COUNTER (t_ix)
+                 || length != GCOV_TAG_COUNTER_LENGTH (ci_ptr->num))
+               goto read_mismatch;
+             (*merge) (ci_ptr->values, ci_ptr->num);
+             ci_ptr++;
+           }
+           if ((error = gcov_is_error ()))
+             goto read_error;
+       }
+     if (tag && tag != GCOV_TAG_MODULE_INFO)
+       goto read_mismatch;
+    }
+  goto rewrite;
+
+read_error:;
+    gcov_error (error < 0 ? "profiling:%s:Overflow merging\n"
+                : "profiling:%s:Error merging\n", gi_filename);
+    goto read_fatal;
+
+    goto rewrite;
+
+read_mismatch:;
+    gcov_error ("profiling:%s:Merge mismatch for %s\n",
+                 gi_filename, f_ix + 1 ? "function" : "summaries");
+    goto read_fatal;
+
+read_fatal:;
+    gcov_close ();
+    return 1;
+
+rewrite:;
+    gcov_rewrite ();
+    if (!summary_pos)
+      {
+        memset (&program, 0, sizeof (program));
+        summary_pos = eof_pos;
+      }
+
+    /* Merge the summaries.  */
+    for (t_ix = 0; t_ix < GCOV_COUNTERS_SUMMABLE; t_ix++)
+      {
+        cs_prg = &program.ctrs[t_ix];
+        cs_tprg = &this_program.ctrs[t_ix];
+        cs_all = &all.ctrs[t_ix];
+
+        if (gi_ptr->merge[t_ix])
+          {
+            if (!cs_prg->runs++)
+              cs_prg->num = cs_tprg->num;
+            cs_prg->sum_all += cs_tprg->sum_all;
+            if (cs_prg->run_max < cs_tprg->run_max)
+              cs_prg->run_max = cs_tprg->run_max;
+            cs_prg->sum_max += cs_tprg->run_max;
+            if (cs_prg->runs == 1)
+              memcpy (cs_prg->histogram, cs_tprg->histogram,
+                      sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);
+            else
+              gcov_histogram_merge (cs_prg->histogram, cs_tprg->histogram);
+          }
+        else if (cs_prg->runs)
+          goto read_mismatch;
+
+        if (!cs_all->runs && cs_prg->runs)
+          memcpy (cs_all, cs_prg, sizeof (*cs_all));
+        else if (!all.checksum
+                 && (!GCOV_LOCKED || cs_all->runs == cs_prg->runs)
+                 /* Don't compare the histograms, which may have slight
+                     variations depending on the order they were updated
+                     due to the truncating integer divides used in the
+                     merge.  */
+                  && memcmp (cs_all, cs_prg,
+                             sizeof (*cs_all) - (sizeof (gcov_bucket_type)
+                                                 * GCOV_HISTOGRAM_SIZE)))
+          {
+            gcov_error ("profiling:%s:Invocation mismatch - "
+                "some data files may have been removed%s\n",
+            gi_filename, GCOV_LOCKED
+            ? "" : " or concurrent update without locking support");
+            all.checksum = ~0u;
+          }
+      }
+
+  program.checksum = gcov_crc32;
+
+  return 0;
+}
+
+/* This function returns the size of gcda file to be written. Note
+   the size is in units of gcov_type.  */
+
+GCOV_LINKAGE unsigned
+gcov_gcda_file_size (struct gcov_info *gi_ptr)
+{
+  unsigned size;
+  const struct gcov_fn_info *fi_ptr;
+  unsigned f_ix, t_ix, h_ix, h_cnt = 0;
+  unsigned n_counts;
+  const struct gcov_ctr_info *ci_ptr;
+  struct gcov_summary *sum = &this_program;
+  const struct gcov_ctr_summary *csum;
+
+  /* GCOV_DATA_MAGIC, GCOV_VERSION and time_stamp.  */
+  size = 3;
+
+  /* Program summary, which depends on the number of non-zero
+      histogram entries.  */
+   csum = &sum->ctrs[GCOV_COUNTER_ARCS];
+   for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)
+     {
+       if (csum->histogram[h_ix].num_counters > 0)
+         h_cnt++;
+     }
+   size += 2 + GCOV_TAG_SUMMARY_LENGTH(h_cnt);
+
+  /* size for each function.  */
+  for (f_ix = 0; f_ix < gi_ptr->n_functions; f_ix++)
+    {
+      fi_ptr = gi_ptr->functions[f_ix];
+
+      size += 2 /* tag_length itself */
+              + GCOV_TAG_FUNCTION_LENGTH; /* ident, lineno_cksum, cfg_cksm */
+
+      ci_ptr = fi_ptr->ctrs;
+      for (t_ix = 0; t_ix < GCOV_COUNTERS; t_ix++)
+        {
+          if (!gcov_counter_active (gi_ptr, t_ix))
+            continue;
+
+          n_counts = ci_ptr->num;
+          size += 2 + GCOV_TAG_COUNTER_LENGTH (n_counts);
+          ci_ptr++;
+        }
+    }
+
+  size += 1;
+
+  return size*4;
+}
+
+/* Write profile data (including summary and module grouping information,
+   if available, to file.  */
+
+static void
+gcov_write_gcda_file (struct gcov_info *gi_ptr)
+{
+  const struct gcov_fn_info *gfi_ptr;
+  const struct gcov_ctr_info *ci_ptr;
+  unsigned t_ix, f_ix, n_counts, length;
+  int error = 0;
+  gcov_position_t eof_pos1 = 0;
+
+  /* Write out the data.  */
+  gcov_seek (0);
+  gcov_write_tag_length (GCOV_DATA_MAGIC, GCOV_VERSION);
+  gcov_write_unsigned (gi_ptr->stamp);
+
+  if (summary_pos)
+     gcov_seek (summary_pos);
+  gcc_assert (!summary_pos || summary_pos == gcov_position ());
+
+  /* Generate whole program statistics.  */
+  gcov_write_summary (GCOV_TAG_PROGRAM_SUMMARY, &program);
+
+  /* Rewrite all the summaries that were after the summary we merged
+     into. This is necessary as the merged summary may have a different
+     size due to the number of non-zero histogram entries changing after
+     merging.  */
+
+  while (sum_buffer)
+    {
+      gcov_write_summary (GCOV_TAG_PROGRAM_SUMMARY, &sum_buffer->summary);
+      next_sum_buffer = sum_buffer->next;
+      free (sum_buffer);
+      sum_buffer = next_sum_buffer;
+    }
+
+  /* Write execution counts for each function.  */
+  for (f_ix = 0; f_ix < gi_ptr->n_functions; f_ix++)
+    {
+      gfi_ptr = gi_ptr->functions[f_ix];
+      gcc_assert (gfi_ptr && gfi_ptr->key == gi_ptr);
+      length = GCOV_TAG_FUNCTION_LENGTH;
+
+      gcov_write_tag_length (GCOV_TAG_FUNCTION, length);
+
+      gcov_write_unsigned (gfi_ptr->ident);
+      gcov_write_unsigned (gfi_ptr->lineno_checksum);
+      gcov_write_unsigned (gfi_ptr->cfg_checksum);
+
+      ci_ptr = gfi_ptr->ctrs;
+      for (t_ix = 0; t_ix < GCOV_COUNTERS; t_ix++)
+        {
+          if (!gi_ptr->merge[t_ix])
+            continue;
+
+          n_counts = ci_ptr->num;
+          gcov_write_tag_length (GCOV_TAG_FOR_COUNTER (t_ix),
+                                 GCOV_TAG_COUNTER_LENGTH (n_counts));
+          gcov_type *c_ptr = ci_ptr->values;
+          while (n_counts--)
+            gcov_write_counter (*c_ptr++);
+          ci_ptr++;
+        }
+      eof_pos1 = gcov_position ();
+    }
+
+    eof_pos = eof_pos1;
+    /* Write the end marker  */
+    gcov_write_unsigned (0);
+
+    gi_ptr->eof_pos = eof_pos;
+
+    if ((error = gcov_close ()))
+      gcov_error (error  < 0 ?
+                  "profiling:%s:Overflow writing\n" :
+                  "profiling:%s:Error writing\n",
+                   gi_filename);
+}
+
+/* Do some preparation work before calling the actual dumping
+   routine.
+   Return: 1 when module grouping info needs to be dumped,
+           0 otherwise.  */
+
+static int
+gcov_exit_init (void)
+{
+  struct gcov_info *gi_ptr;
+  int dump_module_info = 0;
+
+  dump_module_info = 0;
+  gcov_prefix_strip = 0;
+
+  memset (&all, 0, sizeof (all));
+
+  /* Find the totals for this execution.  */
+  memset (&this_program, 0, sizeof (this_program));
+  for (gi_ptr = __gcov_list; gi_ptr; gi_ptr = gi_ptr->next)
+    {
+      gcov_object_summary (gi_ptr, &this_program);
+
+      /* The IS_PRIMARY field is overloaded to indicate if this module
+         is FDO/LIPO.  */
+      dump_module_info |= gi_ptr->mod_info->is_primary;
+    }
+
+  gcov_compute_histogram (&this_program);
+
+  gcov_alloc_filename ();
+
+  return dump_module_info;
+}
+
+/* Dump one entry in the gcov_info list (for one object).  */
+
+static void
+gcov_dump_one_gcov (struct gcov_info *gi_ptr)
+{
+  int ret;
+
+  gcov_sort_topn_counter_arrays (gi_ptr);
+
+  GCOV_GET_FILENAME (prefix_length, gcov_prefix_strip, gi_ptr->filename,
+                     gi_filename_up);
+
+  if (gcov_open_by_filename (gi_filename) == -1)
+    return;
+
+  /* Now merge this file.  */
+  ret = gcov_merge_gcda_file (gi_ptr);
+  if (ret != 0 ) return;
+
+  gcov_write_gcda_file (gi_ptr);
+}
+
 #endif /* L_gcov */
 
 #ifdef L_gcov_reset
@@ -974,6 +1315,129 @@ __gcov_merge_ior (gcov_type *counters, unsigned n_counters)
 }
 #endif
 
+#ifdef L_gcov_merge_dc
+
+/* Returns 1 if the function global id GID is not valid.  */
+
+static int
+__gcov_is_gid_insane (gcov_type gid)
+{
+  if (EXTRACT_MODULE_ID_FROM_GLOBAL_ID (gid) == 0
+      || EXTRACT_FUNC_ID_FROM_GLOBAL_ID (gid) == 0)
+    return 1;
+  return 0;
+}
+
+/* The profile merging function used for merging direct call counts
+   This function is given array COUNTERS of N_COUNTERS old counters and it
+   reads the same number of counters from the gcov file.  */
+
+void
+__gcov_merge_dc (gcov_type *counters, unsigned n_counters)
+{
+  unsigned i;
+
+  gcc_assert (!(n_counters % 2));
+  for (i = 0; i < n_counters; i += 2)
+    {
+      gcov_type global_id = gcov_read_counter ();
+      gcov_type call_count = gcov_read_counter ();
+
+      /* Note that global id counter may never have been set if no calls were
+	 made from this call-site.  */
+      if (counters[i] && global_id)
+        {
+          /* TODO race condition requires us do the following correction.  */
+          if (__gcov_is_gid_insane (counters[i]))
+            counters[i] = global_id;
+          else if (__gcov_is_gid_insane (global_id))
+            global_id = counters[i];
+
+          gcc_assert (counters[i] == global_id);
+        }
+      else if (global_id)
+	counters[i] = global_id;
+
+      counters[i + 1] += call_count;
+
+      /* Reset. */
+      if (__gcov_is_gid_insane (counters[i]))
+        counters[i] = counters[i + 1] = 0;
+
+      /* Assert that the invariant (global_id == 0) <==> (call_count == 0)
+	 holds true after merging.  */
+      if (counters[i] == 0)
+        counters[i+1] = 0;
+      if (counters[i + 1] == 0)
+        counters[i] = 0;
+    }
+}
+#endif
+
+#ifdef L_gcov_merge_icall_topn
+/* The profile merging function used for merging indirect call counts
+   This function is given array COUNTERS of N_COUNTERS old counters and it
+   reads the same number of counters from the gcov file.  */
+
+void
+__gcov_merge_icall_topn (gcov_type *counters, unsigned n_counters)
+{
+  unsigned i, j, k, m;
+
+  gcc_assert (!(n_counters % GCOV_ICALL_TOPN_NCOUNTS));
+  for (i = 0; i < n_counters; i += GCOV_ICALL_TOPN_NCOUNTS)
+    {
+      gcov_type *value_array = &counters[i + 1];
+      unsigned tmp_size = 2 * (GCOV_ICALL_TOPN_NCOUNTS - 1);
+      gcov_type *tmp_array 
+          = (gcov_type *) alloca (tmp_size * sizeof (gcov_type));
+
+      for (j = 0; j < tmp_size; j++)
+        tmp_array[j] = 0;
+
+      for (j = 0; j < GCOV_ICALL_TOPN_NCOUNTS - 1; j += 2)
+        {
+          tmp_array[j] = value_array[j];
+          tmp_array[j + 1] = value_array [j + 1];
+        }
+
+      /* Skip the number_of_eviction entry.  */
+      gcov_read_counter ();
+      for (k = 0; k < GCOV_ICALL_TOPN_NCOUNTS - 1; k += 2)
+        {
+          int found = 0;
+          gcov_type global_id = gcov_read_counter ();
+          gcov_type call_count = gcov_read_counter ();
+          for (m = 0; m < j; m += 2)
+            {
+              if (tmp_array[m] == global_id)
+                {
+                  found = 1;
+                  tmp_array[m + 1] += call_count;
+                  break;
+                }
+            }
+          if (!found)
+            {
+              tmp_array[j] = global_id;
+              tmp_array[j + 1] = call_count;
+              j += 2;
+            }
+        }
+      /* Now sort the temp array */
+      gcov_sort_n_vals (tmp_array, j);
+
+      /* Now copy back the top half of the temp array */
+      for (k = 0; k < GCOV_ICALL_TOPN_NCOUNTS - 1; k += 2)
+        {
+          value_array[k] = tmp_array[k];
+          value_array[k + 1] = tmp_array[k + 1];
+        }
+    }
+}
+#endif
+
+
 #ifdef L_gcov_merge_single
 /* The profile merging function for choosing the most common value.
    It is given an array COUNTERS of N_COUNTERS old counters and it
@@ -1111,12 +1575,137 @@ __gcov_one_value_profiler_body (gcov_type *counters, gcov_type value)
   counters[2]++;
 }
 
+/* Atomic update version of __gcov_one_value_profile_body().  */
+static inline void
+__gcov_one_value_profiler_body_atomic (gcov_type *counters, gcov_type value)
+{
+  if (value == counters[0])
+    GCOV_TYPE_ATOMIC_FETCH_ADD_FN (&counters[1], 1, MEMMODEL_RELAXED);
+  else if (counters[1] == 0)
+    {
+      counters[1] = 1;
+      counters[0] = value;
+    }
+  else
+    GCOV_TYPE_ATOMIC_FETCH_ADD_FN (&counters[1], -1, MEMMODEL_RELAXED);
+  GCOV_TYPE_ATOMIC_FETCH_ADD_FN (&counters[2], 1, MEMMODEL_RELAXED);
+}
+
+#ifdef L_gcov_indirect_call_topn_profiler
+/* Tries to keep track the most frequent N values in the counters where
+   N is specified by parameter TOPN_VAL. To track top N values, 2*N counter
+   entries are used.
+   counter[0] --- the accumative count of the number of times one entry in
+                  in the counters gets evicted/replaced due to limited capacity.
+                  When this value reaches a threshold, the bottom N values are
+                  cleared.
+   counter[1] through counter[2*N] records the top 2*N values collected so far.
+   Each value is represented by two entries: count[2*i+1] is the ith value, and
+   count[2*i+2] is the number of times the value is seen.  */
+
+static void
+__gcov_topn_value_profiler_body (gcov_type *counters, gcov_type value,
+                                 gcov_unsigned_t topn_val)
+{
+   unsigned i, found = 0, have_zero_count = 0;
+
+   gcov_type *entry;
+   gcov_type *lfu_entry = &counters[1];
+   gcov_type *value_array = &counters[1];
+   gcov_type *num_eviction = &counters[0];
+
+   /* There are 2*topn_val values tracked, each value takes two slots in the
+      counter array */
+   for ( i = 0; i < (topn_val << 2); i += 2)
+     {
+       entry = &value_array[i];
+       if ( entry[0] == value)
+         {
+           entry[1]++ ;
+           found = 1;
+           break;
+         }
+       else if (entry[1] == 0)
+         {
+           lfu_entry = entry;
+           have_zero_count = 1;
+         }
+      else if (entry[1] < lfu_entry[1])
+        lfu_entry = entry;
+     }
+
+   if (found)
+     return;
+
+   /* lfu_entry is either an empty entry or an entry
+      with lowest count, which will be evicted.  */
+   lfu_entry[0] = value;
+   lfu_entry[1] = 1;
+
+#define GCOV_ICALL_COUNTER_CLEAR_THRESHOLD 3000
+
+   /* Too many evictions -- time to clear bottom entries to 
+      avoid hot values bumping each other out.  */
+   if ( !have_zero_count 
+        && ++*num_eviction >= GCOV_ICALL_COUNTER_CLEAR_THRESHOLD)
+     {
+       unsigned i, j;
+       gcov_type *p, minv;
+       gcov_type* tmp_cnts 
+           = (gcov_type *)alloca (topn_val * sizeof(gcov_type));
+
+       *num_eviction = 0;
+
+       for ( i = 0; i < topn_val; i++ )
+         tmp_cnts[i] = 0;
+
+       /* Find the largest topn_val values from the group of
+          2*topn_val values and put them into tmp_cnts. */
+
+       for ( i = 0; i < 2 * topn_val; i += 2 ) 
+         {
+           p = 0;
+           for ( j = 0; j < topn_val; j++ ) 
+             {
+               if ( !p || tmp_cnts[j] < *p ) 
+                  p = &tmp_cnts[j];
+             }
+            if ( value_array[i + 1] > *p )
+              *p = value_array[i + 1];
+         }
+
+       minv = tmp_cnts[0];
+       for ( j = 1; j < topn_val; j++ )
+         {
+           if (tmp_cnts[j] < minv)
+             minv = tmp_cnts[j];
+         }
+       /* Zero out low value entries  */
+       for ( i = 0; i < 2 * topn_val; i += 2 )
+         {
+           if (value_array[i + 1] < minv) 
+             {
+               value_array[i] = 0;
+               value_array[i + 1] = 0;
+             }
+         }
+     }
+}
+#endif
+
 #ifdef L_gcov_one_value_profiler
 void
 __gcov_one_value_profiler (gcov_type *counters, gcov_type value)
 {
   __gcov_one_value_profiler_body (counters, value);
 }
+
+void
+__gcov_one_value_profiler_atomic (gcov_type *counters, gcov_type value)
+{
+  __gcov_one_value_profiler_body_atomic (counters, value);
+}
+
 #endif
 
 #ifdef L_gcov_indirect_call_profiler
@@ -1151,6 +1740,71 @@ __gcov_indirect_call_profiler (gcov_type* counter, gcov_type value,
 	  && *(void **) cur_func == *(void **) callee_func))
     __gcov_one_value_profiler_body (counter, value);
 }
+
+/* Atomic update version of __gcov_indirect_call_profiler().  */
+void
+__gcov_indirect_call_profiler_atomic (gcov_type* counter, gcov_type value,
+                                      void* cur_func, void* callee_func)
+{
+  if (cur_func == callee_func
+      || (VTABLE_USES_DESCRIPTORS && callee_func
+          && *(void **) cur_func == *(void **) callee_func))
+    __gcov_one_value_profiler_body_atomic (counter, value);
+}
+#endif
+
+
+#ifdef L_gcov_indirect_call_topn_profiler
+extern THREAD_PREFIX gcov_type *__gcov_indirect_call_topn_counters ATTRIBUTE_HIDDEN;
+extern THREAD_PREFIX void *__gcov_indirect_call_topn_callee ATTRIBUTE_HIDDEN;
+#ifdef TARGET_VTABLE_USES_DESCRIPTORS
+#define VTABLE_USES_DESCRIPTORS 1
+#else
+#define VTABLE_USES_DESCRIPTORS 0
+#endif
+void
+__gcov_indirect_call_topn_profiler (void *cur_func,
+                                    void *cur_module_gcov_info,
+                                    gcov_unsigned_t cur_func_id)
+{
+  void *callee_func = __gcov_indirect_call_topn_callee;
+  gcov_type *counter = __gcov_indirect_call_topn_counters;
+  /* If the C++ virtual tables contain function descriptors then one
+     function may have multiple descriptors and we need to dereference
+     the descriptors to see if they point to the same function.  */
+  if (cur_func == callee_func
+      || (VTABLE_USES_DESCRIPTORS && callee_func
+	  && *(void **) cur_func == *(void **) callee_func))
+    {
+      gcov_type global_id 
+          = ((struct gcov_info *) cur_module_gcov_info)->mod_info->ident;
+      global_id = GEN_FUNC_GLOBAL_ID (global_id, cur_func_id);
+      __gcov_topn_value_profiler_body (counter, global_id, GCOV_ICALL_TOPN_VAL);
+      __gcov_indirect_call_topn_callee = 0;
+    }
+}
+
+#endif
+
+#ifdef L_gcov_direct_call_profiler
+extern THREAD_PREFIX gcov_type *__gcov_direct_call_counters ATTRIBUTE_HIDDEN;
+extern THREAD_PREFIX void *__gcov_direct_call_callee ATTRIBUTE_HIDDEN;
+/* Direct call profiler. */
+void
+__gcov_direct_call_profiler (void *cur_func,
+			     void *cur_module_gcov_info,
+			     gcov_unsigned_t cur_func_id)
+{
+  if (cur_func == __gcov_direct_call_callee)
+    {
+      gcov_type global_id 
+          = ((struct gcov_info *) cur_module_gcov_info)->mod_info->ident;
+      global_id = GEN_FUNC_GLOBAL_ID (global_id, cur_func_id);
+      __gcov_direct_call_counters[0] = global_id;
+      __gcov_direct_call_counters[1]++;
+      __gcov_direct_call_callee = 0;
+    }
+}
 #endif
 
 
@@ -1323,4 +1977,5 @@ __gcov_execve (const char *path, char *const argv[], char *const envp[])
   return execve (path, argv, envp);
 }
 #endif
+
 #endif /* inhibit_libc */
diff --git a/libgcc/pmu-profile.c b/libgcc/pmu-profile.c
new file mode 100644
index 0000000..14a5132
--- /dev/null
+++ b/libgcc/pmu-profile.c
@@ -0,0 +1,1552 @@
+/* Performance monitoring unit (PMU) profiler. If available, use an
+   external tool to collect hardware performance counter data and
+   write it in the .gcda files.
+
+   Copyright (C) 2011. Free Software Foundation, Inc.
+   Contributed by Sharad Singhai <singhai@google.com>.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#include "tconfig.h"
+#include "tsystem.h"
+#include "coretypes.h"
+#include "tm.h"
+#if (defined (__x86_64__) || defined (__i386__))
+#include "cpuid.h"
+#endif
+
+#if defined(inhibit_libc)
+#define IN_LIBGCOV (-1)
+#else
+#include <stdio.h>
+#include <stdlib.h>
+#define IN_LIBGCOV 1
+  #if defined(L_gcov)
+  #define GCOV_LINKAGE /* nothing */
+  #endif
+#endif
+#include "gcov-io.h"
+#ifdef TARGET_POSIX_IO
+  #include <fcntl.h>
+  #include <signal.h>
+  #include <sys/stat.h>
+  #include <sys/types.h>
+#endif
+
+#if defined(inhibit_libc)
+#else
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include <sys/types.h>
+#include <sys/wait.h>
+
+#define XNEWVEC(type,ne) (type *)calloc((ne),sizeof(type))
+#define XNEW(type) (type *)malloc(sizeof(type))
+#define XDELETEVEC(p) free(p)
+#define XDELETE(p) free(p)
+
+#define PFMON_CMD "/usr/bin/pfmon"
+#define ADDR2LINE_CMD "/usr/bin/addr2line"
+#define PMU_TOOL_MAX_ARGS (20)
+static char default_addr2line[] = "??:0";
+static const char pfmon_ll_header[] = "#     counts   %self    %cum     "
+    "<10     <32     <64    <256   <1024  >=1024  %wself          "
+    "code addr symbol\n";
+static const char pfmon_bm_header[] =
+    "#     counts   %self    %cum          code addr symbol\n";
+
+const char *pfmon_intel_ll_args[PMU_TOOL_MAX_ARGS] = {
+  PFMON_CMD,
+  "--aggregate-results",
+  "--follow-all",
+  "--with-header",
+  "--smpl-module=pebs-ll",
+  "--ld-lat-threshold=4",
+  "--pebs-ll-dcmiss-code",
+  "--resolve-addresses",
+  "-emem_inst_retired:LATENCY_ABOVE_THRESHOLD",
+  "--long-smpl-periods=10000",
+  0  /* terminating NULL must be present */
+};
+
+const char *pfmon_amd_ll_args[PMU_TOOL_MAX_ARGS] = {
+  PFMON_CMD,
+  "--aggregate-results",
+  "--follow-all",
+  "-uk",
+  "--with-header",
+  "--smpl-module=ibs",
+  "--resolve-addresses",
+  "-eibsop_event:uops",
+  "--ibs-dcmiss-code",
+  "--long-smpl-periods=0xffff0",
+  0  /* terminating NULL must be present */
+};
+
+const char *pfmon_intel_brm_args[PMU_TOOL_MAX_ARGS] = {
+  PFMON_CMD,
+  "--aggregate-results",
+  "--follow-all",
+  "--with-header",
+  "--resolve-addresses",
+  "-eMISPREDICTED_BRANCH_RETIRED",
+  "--long-smpl-periods=10000",
+  0  /* terminating NULL must be present */
+};
+
+const char *pfmon_amd_brm_args[PMU_TOOL_MAX_ARGS] = {
+  PFMON_CMD,
+  "--aggregate-results",
+  "--follow-all",
+  "--with-header",
+  "--resolve-addresses",
+  "-eRETIRED_MISPREDICTED_BRANCH_INSTRUCTIONS",
+  "--long-smpl-periods=10000",
+  0  /* terminating NULL must be present */
+};
+
+const char *addr2line_args[PMU_TOOL_MAX_ARGS] = {
+  ADDR2LINE_CMD,
+  "-e",
+  0  /* terminating NULL must be present */
+};
+
+
+enum pmu_tool_type
+{
+  PTT_PFMON,
+  PTT_LAST
+};
+
+enum pmu_event_type
+{
+  PET_INTEL_LOAD_LATENCY,
+  PET_AMD_LOAD_LATENCY,
+  PET_INTEL_BRANCH_MISPREDICT,
+  PET_AMD_BRANCH_MISPREDICT,
+  PET_LAST
+};
+
+typedef struct pmu_tool_fns {
+  const char *name;     /* name of the pmu tool */
+  /* pmu tool commandline argument.  */
+  const char **arg_array;
+  /* Initialize pmu module.  */
+  void *(*init_pmu_module) (void);
+  /* Start profililing.  */
+  void (*start_pmu_module) (pid_t ppid, char *tmpfile, const char **args);
+  /* Stop profililing.  */
+  void (*stop_pmu_module) (void);
+  /* How to parse the output generated by the PMU tool.  */
+  int (*parse_pmu_output) (char *filename, void *pmu_data);
+  /* How to write parsed pmu data into gcda file.  */
+  void (*gcov_write_pmu_data) (void *data);
+  /* How to cleanup any data structure created during parsing.  */
+  void (*cleanup_pmu_data) (void *data);
+  /* How to initialize symbolizer for the PPID.  */
+  int (*start_symbolizer) (pid_t ppid);
+  void (*end_symbolizer) (void);
+  char *(*symbolize) (void *addr);
+} pmu_tool_fns;
+
+enum pmu_state
+{
+  PMU_NONE,             /* Not configurated at all.  */
+  PMU_INITIALIZED,      /* Configured and initialized.  */
+  PMU_ERROR,            /* Configuration error. Cannot recover.  */
+  PMU_ON,               /* Currently profiling.  */
+  PMU_OFF               /* Currently stopped, but can be restarted.  */
+};
+
+enum cpu_vendor_signature
+{
+  CPU_VENDOR_UKNOWN = 0,
+  CPU_VENDOR_INTEL  = 0x756e6547, /* Genu */
+  CPU_VENDOR_AMD    = 0x68747541 /* Auth */
+};
+
+/* Info about pmu tool during the run time.  */
+struct pmu_tool_info
+{
+  /* Current pmu tool.  */
+  enum pmu_tool_type tool;
+  /* Current event.  */
+  enum pmu_event_type event;
+  /* filename for storing the pmu profile.  */
+  char *pmu_profile_filename;
+  /* Intermediate file where the tool stores the PMU data.  */
+  char *raw_pmu_profile_filename;
+  /* Where PMU tool's stderr should be stored.  */
+  char *tool_stderr_filename;
+  enum pmu_state pmu_profiling_state;
+  enum cpu_vendor_signature cpu_vendor; /* as discovered by cpuid */
+  pid_t pmu_tool_pid;   /* process id of the pmu tool */
+  pid_t symbolizer_pid; /* process id of the symbolizer */
+  int symbolizer_to_pipefd[2]; /* pipe for writing to the symbolizer */
+  int symbolizer_from_pipefd[2];  /* pipe for reading from the symbolizer */
+  void *pmu_data;       /* an opaque pointer for the tool to store pmu data */
+  int verbose;          /* turn on additional debugging */
+  unsigned top_n_address;  /* how many addresses to symbolize */
+  pmu_tool_fns *tool_details;  /* list of functions how to start/stop/parse */
+};
+
+/* Global struct for recordkeeping.  */
+static struct pmu_tool_info *the_pmu_tool_info;
+
+/* Additional info is printed if these are non-zero.  */
+static int tool_debug = 0;
+static int sym_debug = 0;
+
+static int parse_load_latency_line (char *line, gcov_pmu_ll_info_t *ll_info);
+static int parse_branch_mispredict_line (char *line,
+                                         gcov_pmu_brm_info_t *brm_info);
+static unsigned convert_pct_to_unsigned (float pct);
+static void start_pfmon_module (pid_t ppid, char *tmpfile, const char **pfmon_args);
+static void *init_pmu_load_latency (void);
+static void *init_pmu_branch_mispredict (void);
+static void destroy_load_latency_infos (void *info);
+static void destroy_branch_mispredict_infos (void *info);
+static int parse_pfmon_load_latency (char *filename, void *pmu_data);
+static int parse_pfmon_branch_mispredicts (char *filename, void *pmu_data);
+static gcov_unsigned_t gcov_tag_pmu_tool_header_length (gcov_pmu_tool_header_t
+                                                        *header);
+static void gcov_write_tool_header (gcov_pmu_tool_header_t *header);
+static void gcov_write_load_latency_infos (void *info);
+static void gcov_write_branch_mispredict_infos (void *info);
+static void gcov_write_ll_line (const gcov_pmu_ll_info_t *ll_info);
+static void gcov_write_branch_mispredict_line (const gcov_pmu_brm_info_t
+                                               *brm_info);
+static int start_addr2line_symbolizer (pid_t pid);
+static void end_addr2line_symbolizer (void);
+static char *symbolize_addr2line (void *p);
+static void reset_symbolizer_parent_pipes (void);
+static void reset_symbolizer_child_pipes (void);
+/* parse and cache relevant tool info.  */
+static int parse_pmu_profile_options (const char *options);
+static gcov_pmu_tool_header_t *parse_pfmon_tool_header (FILE *fp,
+                                                        const char *end_header);
+
+
+/* How to access the necessary functions for the PMU tools.  */
+pmu_tool_fns all_pmu_tool_fns[PTT_LAST][PET_LAST] = {
+  {
+    {
+      "intel-load-latency",             /* name */
+      pfmon_intel_ll_args,              /* tool args */
+      init_pmu_load_latency,            /* initialization */
+      start_pfmon_module,               /* start */
+      0,                                /* stop */
+      parse_pfmon_load_latency,         /* parse */
+      gcov_write_load_latency_infos,    /* write */
+      destroy_load_latency_infos,       /* cleanup */
+      start_addr2line_symbolizer,       /* start symbolizer */
+      end_addr2line_symbolizer,         /* end symbolizer */
+      symbolize_addr2line,              /* symbolize */
+    },
+    {
+      "amd-load-latency",               /* name */
+      pfmon_amd_ll_args,                /* tool args */
+      init_pmu_load_latency,            /* initialization */
+      start_pfmon_module,               /* start */
+      0,                                /* stop */
+      parse_pfmon_load_latency,         /* parse */
+      gcov_write_load_latency_infos,    /* write */
+      destroy_load_latency_infos,       /* cleanup */
+      start_addr2line_symbolizer,       /* start symbolizer */
+      end_addr2line_symbolizer,         /* end symbolizer */
+      symbolize_addr2line,              /* symbolize */
+    },
+    {
+      "intel-branch-mispredict",        /* name */
+      pfmon_intel_brm_args,             /* tool args */
+      init_pmu_branch_mispredict,       /* initialization */
+      start_pfmon_module,               /* start */
+      0,                                /* stop */
+      parse_pfmon_branch_mispredicts,   /* parse */
+      gcov_write_branch_mispredict_infos,/* write */
+      destroy_branch_mispredict_infos,  /* cleanup */
+      start_addr2line_symbolizer,       /* start symbolizer */
+      end_addr2line_symbolizer,         /* end symbolizer */
+      symbolize_addr2line,              /* symbolize */
+    },
+    {
+      "amd-branch-mispredict",          /* name */
+      pfmon_amd_brm_args,               /* tool args */
+      init_pmu_branch_mispredict,       /* initialization */
+      start_pfmon_module,               /* start */
+      0,                                /* stop */
+      parse_pfmon_branch_mispredicts,   /* parse */
+      gcov_write_branch_mispredict_infos,/* write */
+      destroy_branch_mispredict_infos,  /* cleanup */
+      start_addr2line_symbolizer,       /* start symbolizer */
+      end_addr2line_symbolizer,         /* end symbolizer */
+      symbolize_addr2line,              /* symbolize */
+    }
+  }
+};
+
+/* Determine the CPU vendor.  Currently only distinguishes x86 based
+   cpus where the vendor is either Intel or AMD.  Returns one of the
+   enum cpu_vendor_signatures.  */
+
+static unsigned int
+get_x86cpu_vendor (void)
+{
+  unsigned int vendor = CPU_VENDOR_UKNOWN;
+
+#if (defined (__x86_64__) || defined (__i386__))
+  if (__get_cpuid_max (0, &vendor) < 1)
+    return CPU_VENDOR_UKNOWN;      /* Cannot determine cpu type.  */
+#endif
+
+  if (vendor == CPU_VENDOR_INTEL || vendor == CPU_VENDOR_AMD)
+    return vendor;
+  else
+    return CPU_VENDOR_UKNOWN;
+}
+
+
+/* Parse PMU tool option string provided on the command line and store
+   information in global structure.  Return 0 on success, otherwise
+   return 1.  Any changes to this should be synced with
+   check_pmu_profile_options() which does compile time check.  */
+
+static int
+parse_pmu_profile_options (const char *options)
+{
+  enum pmu_tool_type ptt = the_pmu_tool_info->tool;
+  enum pmu_event_type pet = PET_LAST;
+  const char *pmutool_path;
+  the_pmu_tool_info->cpu_vendor =  get_x86cpu_vendor ();
+  /* Determine the platform we are running on.  */
+  if (the_pmu_tool_info->cpu_vendor == CPU_VENDOR_UKNOWN)
+    {
+      /* Cpuid failed or uknown vendor.  */
+      the_pmu_tool_info->pmu_profiling_state = PMU_ERROR;
+      return 1;
+    }
+
+  /* Validate the options.  */
+  if (strcmp(options, "load-latency") &&
+      strcmp(options, "load-latency-verbose") &&
+      strcmp(options, "branch-mispredict") &&
+      strcmp(options, "branch-mispredict-verbose"))
+    return 1;
+
+  /* Check if are aksed to collect load latency PMU data.  */
+  if (!strcmp(options, "load-latency") ||
+      !strcmp(options, "load-latency-verbose"))
+    {
+      if (the_pmu_tool_info->cpu_vendor == CPU_VENDOR_INTEL)
+        pet = PET_INTEL_LOAD_LATENCY;
+      else
+        pet = PET_AMD_LOAD_LATENCY;
+      if (!strcmp(options, "load-latency-verbose"))
+        the_pmu_tool_info->verbose = 1;
+    }
+
+  /* Check if are aksed to collect branch mispredict PMU data.  */
+  if (!strcmp(options, "branch-mispredict") ||
+      !strcmp(options, "branch-mispredict-verbose"))
+    {
+      if (the_pmu_tool_info->cpu_vendor == CPU_VENDOR_INTEL)
+        pet = PET_INTEL_BRANCH_MISPREDICT;
+      else
+        pet = PET_AMD_BRANCH_MISPREDICT;
+      if (!strcmp(options, "branch-mispredict-verbose"))
+        the_pmu_tool_info->verbose = 1;
+    }
+
+  the_pmu_tool_info->tool_details = &all_pmu_tool_fns[ptt][pet];
+  the_pmu_tool_info->event = pet;
+
+  /* Allow users to override the default tool path.  */
+  pmutool_path = getenv ("GCOV_PMUTOOL_PATH");
+  if (pmutool_path && strlen (pmutool_path))
+    the_pmu_tool_info->tool_details->arg_array[0] = pmutool_path;
+
+  return 0;
+}
+
+/* Do the initialization of addr2line symbolizer for the process id
+   given by TASK_PID.  It forks an addr2line process and creates two
+   pipes where addresses can be written and source_filename:line_num
+   entries can be read.  Returns 0 on success, non-zero otherwise.  */
+
+static int
+start_addr2line_symbolizer (pid_t task_pid)
+{
+  pid_t pid;
+  char *addr2line_path;
+
+  /* Allow users to override the default addr2line path.  */
+  addr2line_path = getenv ("GCOV_ADDR2LINE_PATH");
+  if (addr2line_path && strlen (addr2line_path))
+    addr2line_args[0] = addr2line_path;
+
+  if (pipe (the_pmu_tool_info->symbolizer_from_pipefd) == -1)
+    {
+      fprintf (stderr, "Cannot create symbolizer write pipe.\n");
+      return 1;
+    }
+  if (pipe (the_pmu_tool_info->symbolizer_to_pipefd) == -1)
+    {
+      fprintf (stderr, "Cannot create symbolizer read pipe.\n");
+      return 1;
+    }
+
+  pid = fork ();
+  if (pid == -1)
+    {
+      /* error condition */
+      fprintf (stderr, "Cannot create symbolizer process.\n");
+      reset_symbolizer_parent_pipes ();
+      reset_symbolizer_child_pipes ();
+      return 1;
+    }
+
+  if (pid == 0)
+    {
+      /* child does an exec and then connects to/from the pipe */
+      unsigned n_args = 0;
+      char proc_exe_buf[128];
+      int new_write_fd, new_read_fd;
+      int i;
+
+      /* Go over the current addr2line args.  */
+      for (i = 0; i < PMU_TOOL_MAX_ARGS && addr2line_args[i]; ++i)
+        n_args++;
+
+      /* We are going to add one more arg for the /proc/pid/exe */
+      if (n_args >= (PMU_TOOL_MAX_ARGS - 1))
+        {
+          fprintf (stderr, "too many addr2line args: %d\n", n_args);
+          _exit (0);
+        }
+      snprintf (proc_exe_buf, sizeof (proc_exe_buf), "/proc/%d/exe",
+                task_pid);
+
+      /* Add the extra arg for the process id.  */
+      addr2line_args[n_args] = proc_exe_buf;
+      n_args++;
+
+      addr2line_args[n_args] = (const char *)NULL;  /* terminating NULL */
+
+      if (sym_debug)
+        {
+          fprintf (stderr, "addr2line args:");
+          for (i = 0; i < PMU_TOOL_MAX_ARGS && addr2line_args[i]; ++i)
+            fprintf (stderr, " %s", addr2line_args[i]);
+          fprintf (stderr, "\n");
+        }
+
+      /* Close unused ends of the two pipes.  */
+      reset_symbolizer_child_pipes ();
+
+      /* Connect the pipes to stdin/stdout of the child process.  */
+      new_read_fd = dup2 (the_pmu_tool_info->symbolizer_to_pipefd[0], 0);
+      new_write_fd = dup2 (the_pmu_tool_info->symbolizer_from_pipefd[1], 1);
+      if (new_read_fd == -1 || new_write_fd == -1)
+        {
+          fprintf (stderr, "could not dup symbolizer fds\n");
+          reset_symbolizer_parent_pipes ();
+          reset_symbolizer_child_pipes ();
+          _exit (0);
+        }
+      the_pmu_tool_info->symbolizer_to_pipefd[0] = new_read_fd;
+      the_pmu_tool_info->symbolizer_from_pipefd[1] = new_write_fd;
+
+      /* Do execve with NULL env. */
+      execve (addr2line_args[0], (char * const*)addr2line_args,
+              (char * const*)NULL);
+      /* exec returned, an error condition.  */
+      fprintf (stderr, "could not create symbolizer process: %s\n",
+               addr2line_args[0]);
+      reset_symbolizer_parent_pipes ();
+      reset_symbolizer_child_pipes ();
+      _exit (0);
+    }
+  else
+    {
+      /* parent */
+      the_pmu_tool_info->symbolizer_pid = pid;
+      /* Close unused ends of the two pipes.  */
+      reset_symbolizer_parent_pipes ();
+      return 0;
+    }
+  return 0;
+}
+
+/* Close unused write end of the from-pipe and read end of the
+   to-pipe.  */
+
+static void
+reset_symbolizer_parent_pipes (void)
+{
+  if (the_pmu_tool_info->symbolizer_from_pipefd[1] != -1)
+    {
+      close (the_pmu_tool_info->symbolizer_from_pipefd[1]);
+      the_pmu_tool_info->symbolizer_from_pipefd[1] = -1;
+    }
+  if (the_pmu_tool_info->symbolizer_to_pipefd[0] != -1)
+    {
+      close (the_pmu_tool_info->symbolizer_to_pipefd[0]);
+      the_pmu_tool_info->symbolizer_to_pipefd[0] = -1;
+    }
+}
+
+/* Close unused write end of the to-pipe and read end of the
+   from-pipe.  */
+
+static void
+reset_symbolizer_child_pipes (void)
+{
+  if (the_pmu_tool_info->symbolizer_to_pipefd[1] != -1)
+    {
+      close (the_pmu_tool_info->symbolizer_to_pipefd[1]);
+      the_pmu_tool_info->symbolizer_to_pipefd[1] = -1;
+    }
+  if (the_pmu_tool_info->symbolizer_from_pipefd[0] != -1)
+    {
+      close (the_pmu_tool_info->symbolizer_from_pipefd[0]);
+      the_pmu_tool_info->symbolizer_from_pipefd[0] = -1;
+    }
+}
+
+
+/* Perform cleanup for the symbolizer process.  */
+
+static void
+end_addr2line_symbolizer (void)
+{
+  int pid_status;
+  int wait_status;
+  pid_t pid = the_pmu_tool_info->symbolizer_pid;
+
+  /* Symbolizer was not running.  */
+  if (!pid)
+    return;
+
+  reset_symbolizer_parent_pipes ();
+  reset_symbolizer_child_pipes ();
+  kill (pid, SIGTERM);
+  wait_status = waitpid (pid, &pid_status, 0);
+  if (sym_debug)
+  {
+    if (wait_status == pid)
+      fprintf (stderr, "Normal exit. symbolizer terminated.\n");
+    else
+      fprintf (stderr, "Abnormal exit. symbolizer status, %d.\n", pid_status);
+  }
+  the_pmu_tool_info->symbolizer_pid = 0;  /* Symoblizer no longer running.  */
+}
+
+
+/* Given an address ADDR, return a string containing
+   source_filename:line_num entries.  */
+
+static char *
+symbolize_addr2line (void *addr)
+{
+  char buf[32];  /* holds the ascii version of address */
+  int write_count;
+  int read_count;
+  char *srcfile_linenum;
+  size_t max_length = 1024;
+
+  if (!the_pmu_tool_info->symbolizer_pid)
+    return default_addr2line;    /* symbolizer is not running */
+
+  write_count = snprintf (buf, sizeof (buf), "%p\n", addr);
+
+  /* Write the address into the pipe.  */
+  if (write (the_pmu_tool_info->symbolizer_to_pipefd[1], buf, write_count)
+      < write_count)
+    {
+      if (sym_debug)
+        fprintf (stderr, "Cannot write symbolizer pipe.\n");
+      return default_addr2line;
+    }
+
+  srcfile_linenum = XNEWVEC (char, max_length);
+  read_count = read (the_pmu_tool_info->symbolizer_from_pipefd[0],
+                     srcfile_linenum, max_length);
+  if (read_count == -1)
+    {
+      if (sym_debug)
+        fprintf (stderr, "Cannot read symbolizer pipe.\n");
+      XDELETEVEC (srcfile_linenum);
+      return default_addr2line;
+    }
+
+  srcfile_linenum[read_count] = 0;
+  if (sym_debug)
+    fprintf (stderr, "symbolizer: for address %p, read_count %d, got %s\n",
+             addr, read_count, srcfile_linenum);
+  return srcfile_linenum;
+}
+
+/* Start monitoring PPID process via pfmon tool using TMPFILE as a
+   file to store the raw data and using PFMON_ARGS as the command line
+   arguments.  */
+
+static void
+start_pfmon_module (pid_t ppid, char *tmpfile, const char **pfmon_args)
+{
+  int i;
+  unsigned int n_args = 0;
+  unsigned n_chars;
+  char pid_buf[64];
+  char filename_buf[1024];
+  char top_n_buf[24];
+  unsigned extra_args;
+
+  /* Go over the current pfmon args */
+  for (i = 0; i < PMU_TOOL_MAX_ARGS && pfmon_args[i]; ++i)
+    n_args++;
+
+  if (the_pmu_tool_info->verbose)
+    extra_args = 4; /* account for additional --verbose */
+  else
+    extra_args = 3;
+
+  /* We are going to add args.  */
+  if (n_args >= (PMU_TOOL_MAX_ARGS - extra_args))
+    {
+      fprintf (stderr, "too many pfmon args: %d\n", n_args);
+      _exit (0);
+    }
+
+  n_chars = snprintf (pid_buf, sizeof (pid_buf), "--attach-task=%ld",
+                      (long)ppid);
+  if (n_chars >= sizeof (pid_buf))
+    {
+      fprintf (stderr, "pfmon task id too long: %s\n", pid_buf);
+      return;
+    }
+  pfmon_args[n_args] = pid_buf;
+  n_args++;
+
+  n_chars = snprintf (filename_buf, sizeof (filename_buf), "--smpl-outfile=%s",
+                      tmpfile);
+  if (n_chars >= sizeof (filename_buf))
+    {
+      fprintf (stderr, "pfmon filename too long: %s\n", filename_buf);
+      return;
+    }
+  pfmon_args[n_args] = filename_buf;
+  n_args++;
+
+  n_chars = snprintf (top_n_buf, sizeof (top_n_buf), "--smpl-show-top=%d",
+                      the_pmu_tool_info->top_n_address);
+  if (n_chars >= sizeof (top_n_buf))
+    {
+      fprintf (stderr, "pfmon option too long: %s\n", top_n_buf);
+      return;
+    }
+  pfmon_args[n_args] = top_n_buf;
+  n_args++;
+
+  if (the_pmu_tool_info->verbose) {
+    /* Add --verbose as well.  */
+    pfmon_args[n_args] = "--verbose";
+    n_args++;
+  }
+  pfmon_args[n_args] = (char *)NULL;
+
+  if (tool_debug)
+    {
+      fprintf (stderr, "pfmon args:");
+      for (i = 0; i < PMU_TOOL_MAX_ARGS && pfmon_args[i]; ++i)
+        fprintf (stderr, " %s", pfmon_args[i]);
+      fprintf (stderr, "\n");
+    }
+  /* Do execve with NULL env.  */
+  execve (pfmon_args[0], (char *const *)pfmon_args, (char * const*)NULL);
+  /* does not return */
+}
+
+/* Convert a fractional PCT to an unsigned integer after
+   muliplying by 100.  */
+
+static unsigned
+convert_pct_to_unsigned (float pct)
+{
+  return (unsigned)(pct * 100.0f);
+}
+
+/* Parse the load latency info pointed by LINE and save it into
+   LL_INFO. Returns 0 if the line was parsed successfully, non-zero
+   otherwise.
+
+   An example header+line look like these:
+   "counts   %self    %cum     <10     <32     <64    <256   <1024  >=1024
+   %wself          code addr symbol"
+   "218  24.06%  24.06% 100.00%   0.00%   0.00%   0.00%   0.00%   0.00%  22.70%
+   0x0000000000413e75 CalcSSIM(...)+965</tmp/psnr>"
+*/
+
+static int
+parse_load_latency_line (char *line, gcov_pmu_ll_info_t *ll_info)
+{
+  unsigned counts;
+  /* These are percentages parsed as floats, but then converted to
+     integers after multiplying by 100.  */
+  float self, cum, lt_10, lt_32, lt_64, lt_256, lt_1024, gt_1024, wself;
+  long unsigned int p;
+  int n_values;
+  pmu_tool_fns *tool_details = the_pmu_tool_info->tool_details;
+
+  n_values = sscanf (line, "%u%f%%%f%%%f%%%f%%%f%%%f%%%f%%%f%%%f%%%lx",
+                     &counts, &self, &cum, &lt_10, &lt_32, &lt_64, &lt_256,
+                     &lt_1024, &gt_1024, &wself, &p);
+  if (n_values != 11)
+    return 1;
+
+  /* Values read successfully. Do the assignment after converting
+   * percentages into ints.  */
+  ll_info->counts = counts;
+  ll_info->self = convert_pct_to_unsigned (self);
+  ll_info->cum = convert_pct_to_unsigned (cum);
+  ll_info->lt_10 = convert_pct_to_unsigned (lt_10);
+  ll_info->lt_32 = convert_pct_to_unsigned (lt_32);
+  ll_info->lt_64 = convert_pct_to_unsigned (lt_64);
+  ll_info->lt_256 = convert_pct_to_unsigned (lt_256);
+  ll_info->lt_1024 = convert_pct_to_unsigned (lt_1024);
+  ll_info->gt_1024 = convert_pct_to_unsigned (gt_1024);
+  ll_info->wself = convert_pct_to_unsigned (wself);
+  ll_info->code_addr = p;
+
+  /* Run the raw address through the symbolizer.  */
+  if (tool_details->symbolize)
+    {
+      char *sym_info = tool_details->symbolize ((void *)p);
+      /* sym_info is of the form src_filename:linenum.  Descriminator is
+         currently not supported by addr2line.  */
+      char *sep = strchr (sym_info, ':');
+      if (!sep)
+        {
+          /* Assume entire string is srcfile.  */
+          ll_info->filename = (char *)sym_info;
+          ll_info->line = 0;
+        }
+      else
+        {
+          /* Terminate the filename string at the separator.  */
+          *sep = 0;
+          ll_info->filename = (char *)sym_info;
+          /* Convert rest of the sym info to a line number.  */
+          ll_info->line = atol (sep+1);
+        }
+      ll_info->discriminator = 0;
+    }
+  else
+    {
+      /* No symbolizer available.  */
+      ll_info->filename = NULL;
+      ll_info->line = 0;
+      ll_info->discriminator = 0;
+    }
+  return 0;
+}
+
+/* Parse the branch mispredict info pointed by LINE and save it into
+   BRM_INFO. Returns 0 if the line was parsed successfully, non-zero
+   otherwise.
+
+   An example header+line look like these:
+   "counts   %self    %cum          code addr symbol"
+   "6869  37.67%  37.67% 0x00000000004007e5 sum(std::vector<int*,
+    std::allocator<int*> > const&)+51</root/tmp/array>"
+*/
+
+static int
+parse_branch_mispredict_line (char *line, gcov_pmu_brm_info_t *brm_info)
+{
+  unsigned counts;
+  /* These are percentages parsed as floats, but then converted to
+     ints after multiplying by 100.  */
+  float self, cum;
+  long unsigned int p;
+  int n_values;
+  pmu_tool_fns *tool_details = the_pmu_tool_info->tool_details;
+
+  n_values = sscanf (line, "%u%f%%%f%%%lx",
+                     &counts, &self, &cum, &p);
+  if (n_values != 4)
+    return 1;
+
+  /* Values read successfully. Do the assignment after converting
+   * percentages into ints.  */
+  brm_info->counts = counts;
+  brm_info->self = convert_pct_to_unsigned (self);
+  brm_info->cum = convert_pct_to_unsigned (cum);
+  brm_info->code_addr = p;
+
+  /* Run the raw address through the symbolizer.  */
+  if (tool_details->symbolize)
+    {
+      char *sym_info = tool_details->symbolize ((void *)p);
+      /* sym_info is of the form src_filename:linenum.  Descriminator is
+         currently not supported by addr2line.  */
+      char *sep = strchr (sym_info, ':');
+      if (!sep)
+        {
+          /* Assume entire string is srcfile.  */
+          brm_info->filename = sym_info;
+          brm_info->line = 0;
+        }
+      else
+        {
+          /* Terminate the filename string at the separator.  */
+          *sep = 0;
+          brm_info->filename = sym_info;
+          /* Convert rest of the sym info to a line number.  */
+          brm_info->line = atol (sep+1);
+        }
+      brm_info->discriminator = 0;
+    }
+  else
+    {
+      /* No symbolizer available.  */
+      brm_info->filename = NULL;
+      brm_info->line = 0;
+      brm_info->discriminator = 0;
+    }
+  return 0;
+}
+
+/* Delete load latency info structures INFO.  */
+
+static void
+destroy_load_latency_infos (void *info)
+{
+  unsigned i;
+  ll_infos_t* ll_infos = (ll_infos_t *)info;
+
+  /* delete each element */
+  for (i = 0; i < ll_infos->ll_count; ++i)
+    XDELETE (ll_infos->ll_array[i]);
+  /* delete the array itself */
+  XDELETE (ll_infos->ll_array);
+  __destroy_pmu_tool_header (ll_infos->pmu_tool_header);
+  free (ll_infos->pmu_tool_header);
+  ll_infos->ll_array = 0;
+  ll_infos->ll_count = 0;
+}
+
+/* Delete branch mispredict structure INFO.  */
+
+static void
+destroy_branch_mispredict_infos (void *info)
+{
+  unsigned i;
+  brm_infos_t* brm_infos = (brm_infos_t *)info;
+
+  /* delete each element */
+  for (i = 0; i < brm_infos->brm_count; ++i)
+    XDELETE (brm_infos->brm_array[i]);
+  /* delete the array itself */
+  XDELETE (brm_infos->brm_array);
+  __destroy_pmu_tool_header (brm_infos->pmu_tool_header);
+  free (brm_infos->pmu_tool_header);
+  brm_infos->brm_array = 0;
+  brm_infos->brm_count = 0;
+}
+
+/* Parse FILENAME for load latency lines into a structure
+   PMU_DATA. Returns 0 on on success.  Returns non-zero on
+   failure.  */
+
+static int
+parse_pfmon_load_latency (char *filename, void *pmu_data)
+{
+  FILE *fp;
+  size_t buflen = 2*1024;
+  char *buf;
+  ll_infos_t *load_latency_infos = (ll_infos_t *)pmu_data;
+  gcov_pmu_tool_header_t *tool_header = 0;
+
+  if ((fp = fopen (filename, "r")) == NULL)
+    {
+      fprintf (stderr, "cannot open pmu data file: %s\n", filename);
+      return 1;
+    }
+
+  if (!(tool_header = parse_pfmon_tool_header (fp, pfmon_ll_header)))
+    {
+      fprintf (stderr, "cannot parse pmu data file header: %s\n", filename);
+      return 1;
+    }
+
+  buf = XNEWVEC (char, buflen);
+  while (fgets (buf, buflen, fp))
+    {
+      gcov_pmu_ll_info_t *ll_info = XNEW (gcov_pmu_ll_info_t);
+      if (!parse_load_latency_line (buf, ll_info))
+        {
+          /* valid line, add to the array */
+          load_latency_infos->ll_count++;
+          if (load_latency_infos->ll_count >=
+              load_latency_infos->alloc_ll_count)
+            {
+              /* need to realloc */
+              load_latency_infos->ll_array =
+                realloc (load_latency_infos->ll_array,
+                         2 * load_latency_infos->alloc_ll_count);
+              if (load_latency_infos->ll_array == NULL)
+                {
+                  fprintf (stderr, "Cannot allocate load latency memory.\n");
+                  __destroy_pmu_tool_header (tool_header);
+                  free (buf);
+                  fclose (fp);
+                  return 1;
+                }
+            }
+          load_latency_infos->ll_array[load_latency_infos->ll_count - 1] =
+            ll_info;
+        }
+      else
+        /* Delete invalid line.  */
+        XDELETE (ll_info);
+    }
+  free (buf);
+  fclose (fp);
+  load_latency_infos->pmu_tool_header = tool_header;
+  return 0;
+}
+
+/* Parse open file FP until END_HEADER is seen. The data matching
+   gcov_pmu_tool_header_t fields is saved and returned in a new
+   struct. In case of failure, it returns NULL.  */
+
+static gcov_pmu_tool_header_t *
+parse_pfmon_tool_header (FILE *fp, const char *end_header)
+{
+  static const char tag_hostname[] = "# hostname: ";
+  static const char tag_kversion[] = "# kernel version: ";
+  static const char tag_hostcpu[] = "# host CPUs:  ";
+  static const char tag_column_desc_start[] = "# description of columns:";
+  static const char tag_column_desc_end[] =
+      "#	other columns are self-explanatory";
+  size_t buflen = 4*1024;
+  char *buf, *buf_start, *buf_end;
+  gcov_pmu_tool_header_t *tool_header = XNEWVEC (gcov_pmu_tool_header_t, 1);
+  char *hostname = 0;
+  char *kversion = 0;
+  char *hostcpu = 0;
+  char *column_description = 0;
+  char *column_desc_start = 0;
+  char *column_desc_end = 0;
+  const char *column_header = 0;
+  int got_hostname = 0;
+  int got_kversion = 0 ;
+  int got_hostcpu = 0;
+  int got_end_header = 0;
+  int got_column_description = 0;
+
+  buf = XNEWVEC (char, buflen);
+  buf_start = buf;
+  buf_end = buf + buflen;
+  while (buf < (buf_end - 1) && fgets (buf, buf_end - buf, fp))
+    {
+      if (strncmp (end_header, buf, buf_end - buf) == 0)
+      {
+        got_end_header = 1;
+        break;
+      }
+      if (!got_hostname &&
+          strncmp (buf, tag_hostname, strlen (tag_hostname)) == 0)
+        {
+          size_t len = strlen (buf) - strlen (tag_hostname);
+          hostname = XNEWVEC (char, len);
+          memcpy (hostname, buf + strlen (tag_hostname), len);
+          hostname[len - 1] = 0;
+          tool_header->hostname = hostname;
+          got_hostname = 1;
+        }
+
+      if (!got_kversion &&
+          strncmp (buf, tag_kversion, strlen (tag_kversion)) == 0)
+        {
+          size_t len = strlen (buf) - strlen (tag_kversion);
+          kversion = XNEWVEC (char, len);
+          memcpy (kversion, buf + strlen (tag_kversion), len);
+          kversion[len - 1] = 0;
+          tool_header->kernel_version = kversion;
+          got_kversion = 1;
+        }
+
+      if (!got_hostcpu &&
+          strncmp (buf, tag_hostcpu, strlen (tag_hostcpu)) == 0)
+        {
+          size_t len = strlen (buf) - strlen (tag_hostcpu);
+          hostcpu = XNEWVEC (char, len);
+          memcpy (hostcpu, buf + strlen (tag_hostcpu), len);
+          hostcpu[len - 1] = 0;
+          tool_header->host_cpu = hostcpu;
+          got_hostcpu = 1;
+        }
+      if (!got_column_description &&
+          strncmp (buf, tag_column_desc_start, strlen (tag_column_desc_start))
+          == 0)
+        {
+          column_desc_start = buf;
+          column_desc_end = 0;
+          /* Continue reading until end of the column descriptor.  */
+          while (buf < (buf_end - 1) && fgets (buf, buf_end - buf, fp))
+            {
+              if (strncmp (buf, tag_column_desc_end,
+                           strlen (tag_column_desc_end)) == 0)
+                {
+                  column_desc_end = buf + strlen (tag_column_desc_end);
+                  break;
+                }
+              buf += strlen (buf);
+            }
+          if (column_desc_end)
+            {
+              /* Found the end, copy it into a new string.  */
+              column_description = XNEWVEC (char, column_desc_end -
+                                            column_desc_start + 1);
+              got_column_description = 1;
+              strcpy (column_description, column_desc_start);
+              tool_header->column_description = column_description;
+            }
+        }
+      buf += strlen (buf);
+    }
+
+  /* If we are missing any of the fields, return NULL.  */
+  if (!got_end_header || !got_hostname || !got_kversion || !got_hostcpu
+      || !got_column_description)
+    {
+      free (hostname);
+      free (kversion);
+      free (hostcpu);
+      free (column_description);
+      free (buf_start);
+      free (tool_header);
+      return NULL;
+    }
+
+  switch (the_pmu_tool_info->event)
+    {
+    case PET_INTEL_LOAD_LATENCY:
+    case PET_AMD_LOAD_LATENCY:
+      column_header = pfmon_ll_header;
+      break;
+    case PET_INTEL_BRANCH_MISPREDICT:
+    case PET_AMD_BRANCH_MISPREDICT:
+      column_header = pfmon_bm_header;
+      break;
+    default:
+      break;
+    }
+  tool_header->column_header = strdup (column_header);
+  tool_header->full_header = buf_start;
+  return tool_header;
+}
+
+
+/* Parse FILENAME for branch mispredict lines into a structure
+   PMU_DATA. Returns 0 on on success.  Returns non-zero on
+   failure.  */
+
+static int
+parse_pfmon_branch_mispredicts (char *filename, void *pmu_data)
+{
+  FILE *fp;
+  size_t buflen = 2*1024;
+  char *buf;
+  brm_infos_t *brm_infos = (brm_infos_t *)pmu_data;
+  gcov_pmu_tool_header_t *tool_header = 0;
+
+  if ((fp = fopen (filename, "r")) == NULL)
+    {
+      fprintf (stderr, "cannot open pmu data file: %s\n", filename);
+      return 1;
+    }
+
+  if (!(tool_header = parse_pfmon_tool_header (fp, pfmon_bm_header)))
+    {
+      fprintf (stderr, "cannot parse pmu data file header: %s\n", filename);
+      return 1;
+    }
+
+  buf = XNEWVEC (char, buflen);
+  while (fgets (buf, buflen, fp))
+    {
+      gcov_pmu_brm_info_t *brm = XNEW (gcov_pmu_brm_info_t);
+      if (!parse_branch_mispredict_line (buf, brm))
+        {
+          /* Valid line, add to the array.  */
+          brm_infos->brm_count++;
+          if (brm_infos->brm_count >= brm_infos->alloc_brm_count)
+            {
+              /* Do we need to realloc? */
+              brm_infos->brm_array =
+                realloc (brm_infos->brm_array,
+                         2 * brm_infos->alloc_brm_count);
+              if (brm_infos->brm_array == NULL) {
+                fprintf (stderr,
+                         "Cannot allocate memory for br mispredicts.\n");
+                __destroy_pmu_tool_header (tool_header);
+                free (buf);
+                fclose (fp);
+                return 1;
+              }
+            }
+          brm_infos->brm_array[brm_infos->brm_count - 1] = brm;
+        }
+      else
+        /* Delete invalid line.  */
+        XDELETE (brm);
+    }
+  free (buf);
+  fclose (fp);
+  brm_infos->pmu_tool_header = tool_header;
+  return 0;
+}
+
+/* Start the monitoring process using pmu tool. Return 0 on success,
+   non-zero otherwise.  */
+
+static int
+pmu_start (void)
+{
+  pid_t pid;
+
+  /* no start function */
+  if (!the_pmu_tool_info->tool_details->start_pmu_module)
+    return 1;
+
+  pid = fork ();
+  if (pid == -1)
+    {
+      /* error condition */
+      fprintf (stderr, "Cannot create PMU profiling process, exiting.\n");
+      return 1;
+    }
+  else if (pid == 0)
+    {
+      /* child */
+      pid_t ppid = getppid();
+      char *tmpfile = the_pmu_tool_info->raw_pmu_profile_filename;
+      const char **pfmon_args = the_pmu_tool_info->tool_details->arg_array;
+      int new_stderr_fd;
+
+      /* Redirect stderr from the child process into a separate file.  */
+      new_stderr_fd = creat (the_pmu_tool_info->tool_stderr_filename,
+                             S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
+      if (new_stderr_fd != -1)
+          dup2 (new_stderr_fd, 2);
+      /* The following does an exec and thus is not expected to return.  */
+      the_pmu_tool_info->tool_details->start_pmu_module(ppid, tmpfile,
+                                                        pfmon_args);
+      /* exec returned, an error condition.  */
+      fprintf (stderr, "could not create profiling process: %s\n",
+               the_pmu_tool_info->tool_details->arg_array[0]);
+      _exit (0);
+    }
+  else
+    {
+      /* parent */
+      the_pmu_tool_info->pmu_tool_pid = pid;
+      return 0;
+    }
+}
+
+/* Allocate and initialize pmu load latency structure.  */
+
+static void *
+init_pmu_load_latency (void)
+{
+  ll_infos_t *load_latency = XNEWVEC (ll_infos_t, 1);
+  load_latency->ll_count = 0;
+  load_latency->alloc_ll_count = 64;
+  load_latency->ll_array = XNEWVEC (gcov_pmu_ll_info_t *,
+                                    load_latency->alloc_ll_count);
+  return (void *)load_latency;
+}
+
+/* Allocate and initialize pmu branch mispredict structure.  */
+
+static void *
+init_pmu_branch_mispredict (void)
+{
+  brm_infos_t *brm_info = XNEWVEC (brm_infos_t, 1);
+  brm_info->brm_count = 0;
+  brm_info->alloc_brm_count = 64;
+  brm_info->brm_array = XNEWVEC (gcov_pmu_brm_info_t *,
+                                 brm_info->alloc_brm_count);
+  return (void *)brm_info;
+}
+
+/* Initialize pmu tool based upon PMU_INFO. Sets the appropriate tool
+   type in the global the_pmu_tool_info.  */
+
+static int
+init_pmu_tool (struct gcov_pmu_info *pmu_info)
+{
+  the_pmu_tool_info->pmu_profiling_state = PMU_NONE;
+  the_pmu_tool_info->verbose = 0;
+  the_pmu_tool_info->tool = PTT_PFMON;  /* we support only pfmon */
+  the_pmu_tool_info->pmu_tool_pid = 0;
+  the_pmu_tool_info->top_n_address = pmu_info->pmu_top_n_address;
+  the_pmu_tool_info->symbolizer_pid = 0;
+  the_pmu_tool_info->symbolizer_to_pipefd[0] = -1;
+  the_pmu_tool_info->symbolizer_to_pipefd[1] = -1;
+  the_pmu_tool_info->symbolizer_from_pipefd[0] = -1;
+  the_pmu_tool_info->symbolizer_from_pipefd[1] = -1;
+
+  if (parse_pmu_profile_options (pmu_info->pmu_tool))
+    return 1;
+
+  if (the_pmu_tool_info->pmu_profiling_state == PMU_ERROR)
+    {
+      fprintf (stderr, "Unsupported PMU module: %s, disabling PMU profiling.\n",
+               pmu_info->pmu_tool);
+      return 1;
+    }
+
+  if (the_pmu_tool_info->tool_details->init_pmu_module)
+    /* initialize module */
+    the_pmu_tool_info->pmu_data =
+      the_pmu_tool_info->tool_details->init_pmu_module();
+  return 0;
+}
+
+/* Initialize PMU profiling based upon the information passed in
+   PMU_INFO and use pmu_profile_filename as the file to store the PMU
+   profile.  This is called multiple times from libgcov, once per
+   object file.  We need to make sure to do the necessary
+   initialization only the first time.  For subsequent invocations it
+   behaves as a NOOP.  */
+
+void
+__gcov_init_pmu_profiler (struct gcov_pmu_info *pmu_info)
+{
+  char *raw_pmu_profile_filename;
+  char *tool_stderr_filename;
+  if (!pmu_info || !pmu_info->pmu_profile_filename || !pmu_info->pmu_tool)
+    return;
+
+  /* Allocate the global structure on first invocation.  */
+  if (!the_pmu_tool_info)
+    {
+      the_pmu_tool_info = XNEWVEC (struct pmu_tool_info, 1);
+      if (!the_pmu_tool_info)
+        {
+          fprintf (stderr, "Error allocating memory for PMU tool\n");
+          return;
+        }
+      if (init_pmu_tool (pmu_info))
+        {
+          /* Initialization error.  */
+          XDELETE (the_pmu_tool_info);
+          the_pmu_tool_info = 0;
+          return;
+        }
+    }
+
+  switch (the_pmu_tool_info->pmu_profiling_state)
+    {
+    case PMU_NONE:
+      the_pmu_tool_info->pmu_profile_filename =
+        strdup (pmu_info->pmu_profile_filename);
+      /* Construct an intermediate filename by substituting trailing
+         '.gcda' with '.pmud'.  */
+      raw_pmu_profile_filename = strdup (pmu_info->pmu_profile_filename);
+      if (raw_pmu_profile_filename == NULL)
+        {
+          fprintf (stderr, "Cannot allocate memory\n");
+          exit (1);
+        }
+      strcpy (raw_pmu_profile_filename + strlen (raw_pmu_profile_filename) - 4,
+              "pmud");
+
+      /* Construct a filename for collecting PMU tool's stderr by
+         substituting trailing '.gcda' with '.stderr'.  */
+      tool_stderr_filename =
+        XNEWVEC (char, strlen (pmu_info->pmu_profile_filename) + 1 + 2);
+      strcpy (tool_stderr_filename, pmu_info->pmu_profile_filename);
+      strcpy (tool_stderr_filename + strlen (tool_stderr_filename) - 4,
+              "stderr");
+      the_pmu_tool_info->raw_pmu_profile_filename = raw_pmu_profile_filename;
+      the_pmu_tool_info->tool_stderr_filename = tool_stderr_filename;
+      the_pmu_tool_info->pmu_profiling_state = PMU_INITIALIZED;
+      break;
+
+    case PMU_INITIALIZED:
+    case PMU_OFF:
+    case PMU_ON:
+    case PMU_ERROR:
+      break;
+    default:
+      break;
+    }
+}
+
+/* Start PMU profiling.  It updates the current state.  */
+
+void
+__gcov_start_pmu_profiler (void)
+{
+  if (!the_pmu_tool_info)
+    return;
+
+  switch (the_pmu_tool_info->pmu_profiling_state)
+    {
+    case PMU_INITIALIZED:
+      if (!pmu_start ())
+        the_pmu_tool_info->pmu_profiling_state = PMU_ON;
+      else
+        the_pmu_tool_info->pmu_profiling_state = PMU_ERROR;
+      break;
+
+    case PMU_NONE:
+      /* PMU was not properly initialized, don't attempt start it.  */
+      the_pmu_tool_info->pmu_profiling_state = PMU_ERROR;
+      break;
+
+    case PMU_OFF:
+      /* Restarting PMU is not yet supported.  */
+    case PMU_ON:
+      /* Do nothing.  */
+    case PMU_ERROR:
+      break;
+
+    default:
+      break;
+    }
+}
+
+/* Stop PMU profiling.  Currently it doesn't do anything except
+   bookkeeping.  */
+
+void
+__gcov_stop_pmu_profiler (void)
+{
+  if (!the_pmu_tool_info)
+    return;
+
+  if (the_pmu_tool_info->tool_details->stop_pmu_module)
+    the_pmu_tool_info->tool_details->stop_pmu_module();
+  if (the_pmu_tool_info->pmu_profiling_state == PMU_ON)
+    the_pmu_tool_info->pmu_profiling_state = PMU_OFF;
+}
+
+/* Write the load latency information LL_INFO into the gcda file.  */
+
+static void
+gcov_write_ll_line (const gcov_pmu_ll_info_t *ll_info)
+{
+  gcov_unsigned_t len = GCOV_TAG_PMU_LOAD_LATENCY_LENGTH (ll_info->filename);
+  gcov_write_tag_length (GCOV_TAG_PMU_LOAD_LATENCY_INFO, len);
+  gcov_write_unsigned (ll_info->counts);
+  gcov_write_unsigned (ll_info->self);
+  gcov_write_unsigned (ll_info->cum);
+  gcov_write_unsigned (ll_info->lt_10);
+  gcov_write_unsigned (ll_info->lt_32);
+  gcov_write_unsigned (ll_info->lt_64);
+  gcov_write_unsigned (ll_info->lt_256);
+  gcov_write_unsigned (ll_info->lt_1024);
+  gcov_write_unsigned (ll_info->gt_1024);
+  gcov_write_unsigned (ll_info->wself);
+  gcov_write_counter (ll_info->code_addr);
+  gcov_write_unsigned (ll_info->line);
+  gcov_write_unsigned (ll_info->discriminator);
+  gcov_write_string (ll_info->filename);
+}
+
+
+/* Write the branch mispredict information BRM_INFO into the gcda file.  */
+
+static void
+gcov_write_branch_mispredict_line (const gcov_pmu_brm_info_t *brm_info)
+{
+  gcov_unsigned_t len = GCOV_TAG_PMU_BRANCH_MISPREDICT_LENGTH (
+      brm_info->filename);
+  gcov_write_tag_length (GCOV_TAG_PMU_BRANCH_MISPREDICT_INFO, len);
+  gcov_write_unsigned (brm_info->counts);
+  gcov_write_unsigned (brm_info->self);
+  gcov_write_unsigned (brm_info->cum);
+  gcov_write_counter (brm_info->code_addr);
+  gcov_write_unsigned (brm_info->line);
+  gcov_write_unsigned (brm_info->discriminator);
+  gcov_write_string (brm_info->filename);
+}
+
+/* Write load latency information INFO into the gcda file.  The gcda
+   file has already been opened and is available for writing.  */
+
+static void
+gcov_write_load_latency_infos (void *info)
+{
+  unsigned i;
+  const ll_infos_t *ll_infos = (const ll_infos_t *)info;
+  gcov_unsigned_t stamp = 0;  /* Don't use stamp as we don't support merge.  */
+  /* We don't support merge, and instead always rewrite the file.  But
+     to rewrite a gcov file we must first read it, however the read
+     value is ignored.  */
+  gcov_read_unsigned ();
+  gcov_rewrite ();
+  gcov_write_tag_length (GCOV_DATA_MAGIC, GCOV_VERSION);
+  gcov_write_unsigned (stamp);
+  if (ll_infos->pmu_tool_header)
+    gcov_write_tool_header (ll_infos->pmu_tool_header);
+  for (i = 0; i < ll_infos->ll_count; ++i)
+    {
+      /* Write each line.  */
+      gcov_write_ll_line (ll_infos->ll_array[i]);
+    }
+  gcov_truncate ();
+}
+
+/* Write branch mispredict information INFO into the gcda file.  The
+   gcda file has already been opened and is available for writing.  */
+
+static void
+gcov_write_branch_mispredict_infos (void *info)
+{
+  unsigned i;
+  const brm_infos_t *brm_infos = (const brm_infos_t *)info;
+  gcov_unsigned_t stamp = 0;  /* Don't use stamp as we don't support merge. */
+  /* We don't support merge, and instead always rewrite the file.  */
+  gcov_rewrite ();
+  gcov_write_tag_length (GCOV_DATA_MAGIC, GCOV_VERSION);
+  gcov_write_unsigned (stamp);
+  if (brm_infos->pmu_tool_header)
+    gcov_write_tool_header (brm_infos->pmu_tool_header);
+  for (i = 0; i < brm_infos->brm_count; ++i)
+    {
+      /* Write each line.  */
+      gcov_write_branch_mispredict_line (brm_infos->brm_array[i]);
+    }
+  gcov_truncate ();
+}
+
+/* Compute TOOL_HEADER length for writing into the gcov file.  */
+
+static gcov_unsigned_t
+gcov_tag_pmu_tool_header_length (gcov_pmu_tool_header_t *header)
+{
+  gcov_unsigned_t len = 0;
+  if (header)
+    {
+      len += gcov_string_length (header->host_cpu);
+      len += gcov_string_length (header->hostname);
+      len += gcov_string_length (header->kernel_version);
+      len += gcov_string_length (header->column_header);
+      len += gcov_string_length (header->column_description);
+      len += gcov_string_length (header->full_header);
+    }
+  return len;
+}
+
+/* Write tool header into the gcda file. It assumes that the gcda file
+   has already been opened and is available for writing.  */
+
+static void
+gcov_write_tool_header (gcov_pmu_tool_header_t *header)
+{
+  gcov_unsigned_t len = gcov_tag_pmu_tool_header_length (header);
+  gcov_write_tag_length (GCOV_TAG_PMU_TOOL_HEADER, len);
+  gcov_write_string (header->host_cpu);
+  gcov_write_string (header->hostname);
+  gcov_write_string (header->kernel_version);
+  gcov_write_string (header->column_header);
+  gcov_write_string (header->column_description);
+  gcov_write_string (header->full_header);
+}
+
+
+/* End PMU profiling. If GCDA_ERROR is non-zero then write profiling data into
+   already open gcda file */
+
+void
+__gcov_end_pmu_profiler (int gcda_error)
+{
+  int pid_status;
+  int wait_status;
+  pid_t pid;
+  pmu_tool_fns *tool_details;
+
+  if (!the_pmu_tool_info)
+    return;
+
+  tool_details = the_pmu_tool_info->tool_details;
+  pid = the_pmu_tool_info->pmu_tool_pid;
+  if (pid)
+    {
+      if (tool_debug)
+        fprintf (stderr, "terminating PMU profiling process %ld\n", (long)pid);
+      kill (pid, SIGTERM);
+      if (tool_debug)
+        fprintf (stderr, "parent: waiting for pmu process to end\n");
+      wait_status = waitpid (pid, &pid_status, 0);
+      if (tool_debug) {
+        if (wait_status == pid)
+          fprintf (stderr, "Normal exit. Child terminated.\n");
+        else
+          fprintf (stderr, "Abnormal exit. child status, %d.\n", pid_status);
+      }
+    }
+
+  if (the_pmu_tool_info->pmu_profiling_state != PMU_OFF)
+    {
+      /* nothing to do */
+      fprintf (stderr,
+               "__gcov_dump_pmu_profile: incorrect pmu state: %d, pid: %ld\n",
+               the_pmu_tool_info->pmu_profiling_state,
+               (unsigned long)pid);
+      return;
+    }
+
+  if (!tool_details->parse_pmu_output)
+    return;
+
+  /* Since we are going to parse the output, we also need symbolizer.  */
+  if (tool_details->start_symbolizer)
+    tool_details->start_symbolizer (getpid ());
+
+  if (!tool_details->parse_pmu_output
+      (the_pmu_tool_info->raw_pmu_profile_filename,
+       the_pmu_tool_info->pmu_data))
+    {
+      if (!gcda_error && tool_details->gcov_write_pmu_data)
+        /* Write tool output into the gcda file.  */
+        tool_details->gcov_write_pmu_data (the_pmu_tool_info->pmu_data);
+    }
+
+  if (tool_details->end_symbolizer)
+    tool_details->end_symbolizer ();
+
+  if (tool_details->cleanup_pmu_data)
+    tool_details->cleanup_pmu_data (the_pmu_tool_info->pmu_data);
+}
+
+#endif
diff --git a/libgfortran/configure b/libgfortran/configure
index 8385e96..bd937db 100755
--- a/libgfortran/configure
+++ b/libgfortran/configure
@@ -8907,7 +8907,22 @@ fi
 
 # Check whether --with-pic was given.
 if test "${with_pic+set}" = set; then :
-  withval=$with_pic; pic_mode="$withval"
+  withval=$with_pic; p=${PACKAGE-default}
+    case "$withval" in
+    yes|no) pic_mode="$withval" ;;
+    *)
+      pic_mode=default
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $withval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  pic_mode=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
 else
   pic_mode=default
 fi
@@ -12333,7 +12348,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 12336 "configure"
+#line 12351 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -12439,7 +12454,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 12442 "configure"
+#line 12457 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
diff --git a/libgomp/configure b/libgomp/configure
index b48979b..db084a8 100755
--- a/libgomp/configure
+++ b/libgomp/configure
@@ -7689,7 +7689,22 @@ fi
 
 # Check whether --with-pic was given.
 if test "${with_pic+set}" = set; then :
-  withval=$with_pic; pic_mode="$withval"
+  withval=$with_pic; p=${PACKAGE-default}
+    case "$withval" in
+    yes|no) pic_mode="$withval" ;;
+    *)
+      pic_mode=default
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $withval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  pic_mode=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
 else
   pic_mode=default
 fi
@@ -11088,7 +11103,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11091 "configure"
+#line 11106 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11194,7 +11209,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11197 "configure"
+#line 11212 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -16326,6 +16341,8 @@ ac_config_files="$ac_config_files omp.h omp_lib.h omp_lib.f90 libgomp_f.h"
 
 ac_config_files="$ac_config_files Makefile testsuite/Makefile libgomp.spec"
 
+ac_config_files="$ac_config_files testsuite/gompconfig.exp"
+
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
 # tests run on this system so they can be shared between configure
@@ -17466,6 +17483,7 @@ do
     "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
     "testsuite/Makefile") CONFIG_FILES="$CONFIG_FILES testsuite/Makefile" ;;
     "libgomp.spec") CONFIG_FILES="$CONFIG_FILES libgomp.spec" ;;
+    "testsuite/gompconfig.exp") CONFIG_FILES="$CONFIG_FILES testsuite/gompconfig.exp" ;;
 
   *) as_fn_error "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
   esac
diff --git a/libgomp/configure.ac b/libgomp/configure.ac
index 292db2a..6db8054 100644
--- a/libgomp/configure.ac
+++ b/libgomp/configure.ac
@@ -354,4 +354,5 @@ CFLAGS="$save_CFLAGS"
 
 AC_CONFIG_FILES(omp.h omp_lib.h omp_lib.f90 libgomp_f.h)
 AC_CONFIG_FILES(Makefile testsuite/Makefile libgomp.spec)
+AC_CONFIG_FILES(testsuite/gompconfig.exp)
 AC_OUTPUT
diff --git a/libgomp/configure.tgt b/libgomp/configure.tgt
index 2eecc93..fd86282 100644
--- a/libgomp/configure.tgt
+++ b/libgomp/configure.tgt
@@ -10,16 +10,6 @@
 #  XCFLAGS		Add extra compile flags to use.
 #  XLDFLAGS		Add extra link flags to use.
 
-# Optimize TLS usage by avoiding the overhead of dynamic allocation.
-if test $gcc_cv_have_tls = yes ; then
-  case "${target}" in
-
-    *-*-linux*)
-	XCFLAGS="${XCFLAGS} -ftls-model=initial-exec"
-	;;
-  esac
-fi
-
 # Since we require POSIX threads, assume a POSIX system by default.
 config_path="posix"
 
diff --git a/libgomp/testsuite/config/default.exp b/libgomp/testsuite/config/default.exp
index b0e8910..a6e665a 100644
--- a/libgomp/testsuite/config/default.exp
+++ b/libgomp/testsuite/config/default.exp
@@ -15,3 +15,4 @@
 # <http://www.gnu.org/licenses/>.
 
 load_lib "standard.exp"
+load_lib "gompconfig.exp"
diff --git a/libgomp/testsuite/gompconfig.exp.in b/libgomp/testsuite/gompconfig.exp.in
new file mode 100644
index 0000000..5a5b7cc
--- /dev/null
+++ b/libgomp/testsuite/gompconfig.exp.in
@@ -0,0 +1,2 @@
+global GCC_UNDER_TEST
+set GCC_UNDER_TEST "@CC@"
diff --git a/libgomp/testsuite/lib/libgomp.exp b/libgomp/testsuite/lib/libgomp.exp
index cd561bf..15b2a6b 100644
--- a/libgomp/testsuite/lib/libgomp.exp
+++ b/libgomp/testsuite/lib/libgomp.exp
@@ -111,10 +111,9 @@ proc libgomp_init { args } {
 	    append always_ld_library_path ":${gccdir}/pthread"
 	}
 	append always_ld_library_path ":${gccdir}"
-	set compiler [lindex $GCC_UNDER_TEST 0]
 
-	if { [is_remote host] == 0 && [which $compiler] != 0 } {
-	  foreach i "[exec $compiler --print-multi-lib]" {
+	if { [is_remote host] == 0 } {
+	  foreach i "[eval "exec $GCC_UNDER_TEST --print-multi-lib"]" {
 	    set mldir ""
 	    regexp -- "\[a-z0-9=_/\.-\]*;" $i mldir
 	    set mldir [string trimright $mldir "\;@"]
diff --git a/libjava/classpath/configure b/libjava/classpath/configure
index 23341df..bf2daf9 100755
--- a/libjava/classpath/configure
+++ b/libjava/classpath/configure
@@ -8394,7 +8394,22 @@ fi
 
 # Check whether --with-pic was given.
 if test "${with_pic+set}" = set; then :
-  withval=$with_pic; pic_mode="$withval"
+  withval=$with_pic; p=${PACKAGE-default}
+    case "$withval" in
+    yes|no) pic_mode="$withval" ;;
+    *)
+      pic_mode=default
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $withval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  pic_mode=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
 else
   pic_mode=default
 fi
@@ -11820,7 +11835,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11823 "configure"
+#line 11838 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11926,7 +11941,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11929 "configure"
+#line 11944 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
diff --git a/libjava/configure b/libjava/configure
index 16b76b4..6988502 100755
--- a/libjava/configure
+++ b/libjava/configure
@@ -9956,7 +9956,22 @@ fi
 
 # Check whether --with-pic was given.
 if test "${with_pic+set}" = set; then :
-  withval=$with_pic; pic_mode="$withval"
+  withval=$with_pic; p=${PACKAGE-default}
+    case "$withval" in
+    yes|no) pic_mode="$withval" ;;
+    *)
+      pic_mode=default
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $withval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  pic_mode=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
 else
   pic_mode=default
 fi
diff --git a/libmudflap/configure b/libmudflap/configure
index b3a0178..a022415 100755
--- a/libmudflap/configure
+++ b/libmudflap/configure
@@ -612,6 +612,7 @@ MF_HAVE_UINTPTR_T
 MF_HAVE_STDINT_H
 enable_static
 enable_shared
+CXXCPP
 OTOOL64
 OTOOL
 LIPO
@@ -630,6 +631,12 @@ SED
 LIBTOOL
 EGREP
 GREP
+am__fastdepCXX_FALSE
+am__fastdepCXX_TRUE
+CXXDEPMODE
+ac_ct_CXX
+CXXFLAGS
+CXX
 CPP
 am__fastdepCC_FALSE
 am__fastdepCC_TRUE
@@ -744,7 +751,13 @@ enable_tls
 host_alias
 target_alias
 CPP
-CPPFLAGS'
+CPPFLAGS
+CXX
+CXXFLAGS
+LDFLAGS
+LIBS
+CCC
+CXXCPP'
 
 
 # Initialize some variables set by options.
@@ -1394,6 +1407,9 @@ Some influential environment variables:
   CPPFLAGS    C/C++/Objective C preprocessor flags, e.g. -I<include dir> if
               you have headers in a nonstandard directory <include dir>
   CPP         C preprocessor
+  CXX         C++ compiler command
+  CXXFLAGS    C++ compiler flags
+  CXXCPP      C++ preprocessor
 
 Use these variables to override the choices made by `configure' or to help
 it to find libraries and programs with nonstandard names/locations.
@@ -1550,6 +1566,44 @@ fi
 
 } # ac_fn_c_try_cpp
 
+# ac_fn_cxx_try_compile LINENO
+# ----------------------------
+# Try to compile conftest.$ac_ext, and return whether this succeeded.
+ac_fn_cxx_try_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext
+  if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1
+fi
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  return $ac_retval
+
+} # ac_fn_cxx_try_compile
+
 # ac_fn_c_check_header_mongrel LINENO HEADER VAR INCLUDES
 # -------------------------------------------------------
 # Tests whether HEADER exists, giving a warning if it cannot be compiled using
@@ -1822,6 +1876,89 @@ $as_echo "$ac_res" >&6; }
   eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
 
 } # ac_fn_c_check_func
+
+# ac_fn_cxx_try_cpp LINENO
+# ------------------------
+# Try to preprocess conftest.$ac_ext, and return whether this succeeded.
+ac_fn_cxx_try_cpp ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if { { ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } >/dev/null && {
+	 test -z "$ac_cxx_preproc_warn_flag$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+    ac_retval=1
+fi
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  return $ac_retval
+
+} # ac_fn_cxx_try_cpp
+
+# ac_fn_cxx_try_link LINENO
+# -------------------------
+# Try to link conftest.$ac_ext, and return whether this succeeded.
+ac_fn_cxx_try_link ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext conftest$ac_exeext
+  if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1
+fi
+  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information
+  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would
+  # interfere with the next link command; also delete a directory that is
+  # left behind by Apple's compiler.  We do this before executing the actions.
+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  return $ac_retval
+
+} # ac_fn_cxx_try_link
 cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
@@ -4005,672 +4142,444 @@ ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
-# Some hosts don't have dlsym(RTLD_NEXT, "symbol") for use in
-# symbol interposition.  We disable shared libraries for these.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether dlsym(RTLD_NEXT,...) is available" >&5
-$as_echo_n "checking whether dlsym(RTLD_NEXT,...) is available... " >&6; }
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-#define _GNU_SOURCE
-#include <dlfcn.h>
+# We use the C++ compiler during testing.
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+if test -z "$CXX"; then
+  if test -n "$CCC"; then
+    CXX=$CCC
+  else
+    if test -n "$ac_tool_prefix"; then
+  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CXX+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CXX"; then
+  ac_cv_prog_CXX="$CXX" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CXX="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
 
-int
-main ()
-{
-void *foo = dlsym (RTLD_NEXT, "exit");
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
+fi
+fi
+CXX=$ac_cv_prog_CXX
+if test -n "$CXX"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CXX" >&5
+$as_echo "$CXX" >&6; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
-enable_shared=no
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
-$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
-if test "${ac_cv_path_GREP+set}" = set; then :
+    test -n "$CXX" && break
+  done
+fi
+if test -z "$CXX"; then
+  ac_ct_CXX=$CXX
+  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_CXX+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -z "$GREP"; then
-  ac_path_GREP_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+  if test -n "$ac_ct_CXX"; then
+  ac_cv_prog_ac_ct_CXX="$ac_ct_CXX" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-    for ac_prog in grep ggrep; do
     for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
-# Check for GNU ac_path_GREP and select it if it is found.
-  # Check for GNU $ac_path_GREP
-case `"$ac_path_GREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo 'GREP' >> "conftest.nl"
-    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_GREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_GREP="$ac_path_GREP"
-      ac_path_GREP_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-      $ac_path_GREP_found && break 3
-    done
-  done
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_CXX="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
   done
 IFS=$as_save_IFS
-  if test -z "$ac_cv_path_GREP"; then
-    as_fn_error "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
-  fi
+
+fi
+fi
+ac_ct_CXX=$ac_cv_prog_ac_ct_CXX
+if test -n "$ac_ct_CXX"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CXX" >&5
+$as_echo "$ac_ct_CXX" >&6; }
 else
-  ac_cv_path_GREP=$GREP
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
 fi
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP" >&5
-$as_echo "$ac_cv_path_GREP" >&6; }
- GREP="$ac_cv_path_GREP"
 
+  test -n "$ac_ct_CXX" && break
+done
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
-$as_echo_n "checking for egrep... " >&6; }
-if test "${ac_cv_path_EGREP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
-   then ac_cv_path_EGREP="$GREP -E"
-   else
-     if test -z "$EGREP"; then
-  ac_path_EGREP_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in egrep; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
-# Check for GNU ac_path_EGREP and select it if it is found.
-  # Check for GNU $ac_path_EGREP
-case `"$ac_path_EGREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo 'EGREP' >> "conftest.nl"
-    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_EGREP="$ac_path_EGREP"
-      ac_path_EGREP_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+  if test "x$ac_ct_CXX" = x; then
+    CXX="g++"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
 esac
-
-      $ac_path_EGREP_found && break 3
-    done
-  done
-  done
-IFS=$as_save_IFS
-  if test -z "$ac_cv_path_EGREP"; then
-    as_fn_error "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+    CXX=$ac_ct_CXX
   fi
-else
-  ac_cv_path_EGREP=$EGREP
 fi
 
-   fi
+  fi
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP" >&5
-$as_echo "$ac_cv_path_EGREP" >&6; }
- EGREP="$ac_cv_path_EGREP"
-
+# Provide some information about the compiler.
+$as_echo "$as_me:${as_lineno-$LINENO}: checking for C++ compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+for ac_option in --version -v -V -qversion; do
+  { { ac_try="$ac_compiler $ac_option >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    sed '10a\
+... rest of stderr output deleted ...
+         10q' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    rm -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+done
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
-$as_echo_n "checking for ANSI C header files... " >&6; }
-if test "${ac_cv_header_stdc+set}" = set; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C++ compiler" >&5
+$as_echo_n "checking whether we are using the GNU C++ compiler... " >&6; }
+if test "${ac_cv_cxx_compiler_gnu+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-#include <stdlib.h>
-#include <stdarg.h>
-#include <string.h>
-#include <float.h>
 
 int
 main ()
 {
+#ifndef __GNUC__
+       choke me
+#endif
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_header_stdc=yes
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  ac_compiler_gnu=yes
 else
-  ac_cv_header_stdc=no
+  ac_compiler_gnu=no
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-if test $ac_cv_header_stdc = yes; then
-  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <string.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "memchr" >/dev/null 2>&1; then :
-
-else
-  ac_cv_header_stdc=no
-fi
-rm -f conftest*
+ac_cv_cxx_compiler_gnu=$ac_compiler_gnu
 
 fi
-
-if test $ac_cv_header_stdc = yes; then
-  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdlib.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "free" >/dev/null 2>&1; then :
-
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cxx_compiler_gnu" >&5
+$as_echo "$ac_cv_cxx_compiler_gnu" >&6; }
+if test $ac_compiler_gnu = yes; then
+  GXX=yes
 else
-  ac_cv_header_stdc=no
-fi
-rm -f conftest*
-
+  GXX=
 fi
-
-if test $ac_cv_header_stdc = yes; then
-  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
-  if test "$cross_compiling" = yes; then :
-  :
+ac_test_CXXFLAGS=${CXXFLAGS+set}
+ac_save_CXXFLAGS=$CXXFLAGS
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CXX accepts -g" >&5
+$as_echo_n "checking whether $CXX accepts -g... " >&6; }
+if test "${ac_cv_prog_cxx_g+set}" = set; then :
+  $as_echo_n "(cached) " >&6
 else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+  ac_save_cxx_werror_flag=$ac_cxx_werror_flag
+   ac_cxx_werror_flag=yes
+   ac_cv_prog_cxx_g=no
+   CXXFLAGS="-g"
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-#include <ctype.h>
-#include <stdlib.h>
-#if ((' ' & 0x0FF) == 0x020)
-# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
-# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
-#else
-# define ISLOWER(c) \
-		   (('a' <= (c) && (c) <= 'i') \
-		     || ('j' <= (c) && (c) <= 'r') \
-		     || ('s' <= (c) && (c) <= 'z'))
-# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
-#endif
 
-#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
 int
 main ()
 {
-  int i;
-  for (i = 0; i < 256; i++)
-    if (XOR (islower (i), ISLOWER (i))
-	|| toupper (i) != TOUPPER (i))
-      return 2;
+
+  ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_run "$LINENO"; then :
-
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  ac_cv_prog_cxx_g=yes
 else
-  ac_cv_header_stdc=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
-  conftest.$ac_objext conftest.beam conftest.$ac_ext
-fi
-
-fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc" >&5
-$as_echo "$ac_cv_header_stdc" >&6; }
-if test $ac_cv_header_stdc = yes; then
-
-$as_echo "#define STDC_HEADERS 1" >>confdefs.h
+  CXXFLAGS=""
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
-fi
+int
+main ()
+{
 
-# On IRIX 5.3, sys/types and inttypes.h are conflicting.
-for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
-		  inttypes.h stdint.h unistd.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
-"
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+  ;
+  return 0;
+}
 _ACEOF
+if ac_fn_cxx_try_compile "$LINENO"; then :
 
-fi
-
-done
+else
+  ac_cxx_werror_flag=$ac_save_cxx_werror_flag
+	 CXXFLAGS="-g"
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
+int
+main ()
+{
 
-for ac_header in stdint.h execinfo.h signal.h dlfcn.h dirent.h pwd.h grp.h \
-  netdb.h sys/ipc.h sys/sem.h sys/shm.h sys/wait.h ctype.h mntent.h \
-  sys/mnttab.h sys/socket.h netinet/in.h arpa/inet.h dlfcn.h sys/mman.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+  ;
+  return 0;
+}
 _ACEOF
-
+if ac_fn_cxx_try_compile "$LINENO"; then :
+  ac_cv_prog_cxx_g=yes
 fi
-
-done
-
-
-for ac_func in backtrace backtrace_symbols gettimeofday signal
-do :
-  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-done
-
-for ac_func in fopen64 fseeko64 ftello64 stat64 freopen64
-do :
-  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-done
-
-for ac_func in setbuf setbuffer setlinebuf setvbuf
-do :
-  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_cxx_werror_flag=$ac_save_cxx_werror_flag
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cxx_g" >&5
+$as_echo "$ac_cv_prog_cxx_g" >&6; }
+if test "$ac_test_CXXFLAGS" = set; then
+  CXXFLAGS=$ac_save_CXXFLAGS
+elif test $ac_cv_prog_cxx_g = yes; then
+  if test "$GXX" = yes; then
+    CXXFLAGS="-g -O2"
+  else
+    CXXFLAGS="-g"
+  fi
+else
+  if test "$GXX" = yes; then
+    CXXFLAGS="-O2"
+  else
+    CXXFLAGS=
+  fi
 fi
-done
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
-for ac_func in strnlen memrchr strncpy memmem sethostname
-do :
-  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
+depcc="$CXX"  am_compiler_list=
 
-fi
-done
-
-for ac_func in __ctype_b_loc __ctype_tolower_loc __ctype_toupper_loc
-do :
-  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-done
-
-for ac_func in getlogin cuserid getpwnam getpwuid getpwent getgrnam getgrgid getgrent
-do :
-  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-done
-
-for ac_func in getlogin_r getpwnam_r getpwuid_r getgrnam_r getgrgid_r
-do :
-  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-done
-
-for ac_func in getservent getservbyname getservbyport getaddrinfo gai_strerror
-do :
-  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-done
-
-for ac_func in getprotoent getprotobyname getprotobynumber
-do :
-  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-done
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking dependency style of $depcc" >&5
+$as_echo_n "checking dependency style of $depcc... " >&6; }
+if test "${am_cv_CXX_dependencies_compiler_type+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
+  # We make a subdir and do the tests there.  Otherwise we can end up
+  # making bogus files that we don't know about and never remove.  For
+  # instance it was reported that on HP-UX the gcc test will end up
+  # making a dummy file named `D' -- because `-MD' means `put the output
+  # in D'.
+  mkdir conftest.dir
+  # Copy depcomp to subdir because otherwise we won't find it if we're
+  # using a relative directory.
+  cp "$am_depcomp" conftest.dir
+  cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
 
-for ac_func in getmntent setmntent addmntent
-do :
-  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
+  am_cv_CXX_dependencies_compiler_type=none
+  if test "$am_compiler_list" = ""; then
+     am_compiler_list=`sed -n 's/^#*\([a-zA-Z0-9]*\))$/\1/p' < ./depcomp`
+  fi
+  am__universal=false
+  case " $depcc " in #(
+     *\ -arch\ *\ -arch\ *) am__universal=true ;;
+     esac
 
-fi
-done
+  for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
+    # We need to recreate these files for each test, as the compiler may
+    # overwrite some of them when testing with obscure command lines.
+    # This happens at least with the AIX C compiler.
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
+      # Solaris 8's {/usr,}/bin/sh.
+      touch sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
 
-for ac_func in inet_ntoa mmap munmap
-do :
-  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
+    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle `-M -o', and we need to detect this.  Also, some Intel
+    # versions had trouble with output in subdirs
+    am__obj=sub/conftest.${OBJEXT-o}
+    am__minus_obj="-o $am__obj"
+    case $depmode in
+    gcc)
+      # This depmode causes a compiler race in universal mode.
+      test "$am__universal" = false || continue
+      ;;
+    nosideeffect)
+      # after this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested
+      if test "x$enable_dependency_tracking" = xyes; then
+	continue
+      else
+	break
+      fi
+      ;;
+    msvisualcpp | msvcmsys)
+      # This compiler won't grok `-c -o', but also, the minuso test has
+      # not run yet.  These depmodes are late enough in the game, and
+      # so weak that their functioning should not be impacted.
+      am__obj=conftest.${OBJEXT-o}
+      am__minus_obj=
+      ;;
+    none) break ;;
+    esac
+    if depmode=$depmode \
+       source=sub/conftest.c object=$am__obj \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \
+         >/dev/null 2>conftest.err &&
+       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&
+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
+      # icc doesn't choke on unknown options, it will just issue warnings
+      # or remarks (even with -Werror).  So we grep stderr for any message
+      # that says an option was ignored or not supported.
+      # When given -MP, icc 7.0 and 7.1 complain thusly:
+      #   icc: Command line warning: ignoring option '-M'; no argument required
+      # The diagnosis changed in icc 8.0:
+      #   icc: Command line remark: option '-MP' not supported
+      if (grep 'ignoring option' conftest.err ||
+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
+        am_cv_CXX_dependencies_compiler_type=$depmode
+        break
+      fi
+    fi
+  done
 
+  cd ..
+  rm -rf conftest.dir
+else
+  am_cv_CXX_dependencies_compiler_type=none
 fi
-done
-
-for ac_func in mmap64
-do :
-  ac_fn_c_check_func "$LINENO" "mmap64" "ac_cv_func_mmap64"
-if test "x$ac_cv_func_mmap64" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_MMAP64 1
-_ACEOF
 
 fi
-done
-
-for ac_func in __libc_freeres
-do :
-  ac_fn_c_check_func "$LINENO" "__libc_freeres" "ac_cv_func___libc_freeres"
-if test "x$ac_cv_func___libc_freeres" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE___LIBC_FREERES 1
-_ACEOF
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_CXX_dependencies_compiler_type" >&5
+$as_echo "$am_cv_CXX_dependencies_compiler_type" >&6; }
+CXXDEPMODE=depmode=$am_cv_CXX_dependencies_compiler_type
 
+ if
+  test "x$enable_dependency_tracking" != xno \
+  && test "$am_cv_CXX_dependencies_compiler_type" = gcc3; then
+  am__fastdepCXX_TRUE=
+  am__fastdepCXX_FALSE='#'
+else
+  am__fastdepCXX_TRUE='#'
+  am__fastdepCXX_FALSE=
 fi
-done
 
-for ac_func in rawmemchr stpcpy mempcpy
-do :
-  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
 
-fi
-done
 
+# Some hosts don't have dlsym(RTLD_NEXT, "symbol") for use in
+# symbol interposition.  We disable shared libraries for these.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether dlsym(RTLD_NEXT,...) is available" >&5
+$as_echo_n "checking whether dlsym(RTLD_NEXT,...) is available... " >&6; }
 
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-#include <sys/types.h>
-#include <sys/ipc.h>
-#include <sys/sem.h>
+
+#define _GNU_SOURCE
+#include <dlfcn.h>
+
 int
 main ()
 {
-union semun foo;
+void *foo = dlsym (RTLD_NEXT, "exit");
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_compile "$LINENO"; then :
-  mf_have_semun=1
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
 else
-  mf_have_semun=0
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+enable_shared=no
 fi
 rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-if test $mf_have_semun = 1
-then
-
-$as_echo "#define HAVE_UNION_SEMUN 1" >>confdefs.h
-
-fi
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for socklen_t in sys/socket.h" >&5
-$as_echo_n "checking for socklen_t in sys/socket.h... " >&6; }
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#define _POSIX_PII_SOCKET
-#include <sys/types.h>
-#include <sys/socket.h>
-int
-main ()
-{
-socklen_t x = 5;
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-$as_echo "#define HAVE_SOCKLEN_T 1" >>confdefs.h
-
-   { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-enable_dlopen=yes
-
-
-
-case `pwd` in
-  *\ * | *\	*)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&5
-$as_echo "$as_me: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&2;} ;;
-esac
-
-
-
-macro_version='2.2.7a'
-macro_revision='1.3134'
-
-
-
-
-
-
-
-
-
-
-
-
-
-ltmain="$ac_aux_dir/ltmain.sh"
-
-# Backslashify metacharacters that are still active within
-# double-quoted strings.
-sed_quote_subst='s/\(["`$\\]\)/\\\1/g'
-
-# Same as above, but do not quote variable references.
-double_quote_subst='s/\(["`\\]\)/\\\1/g'
-
-# Sed substitution to delay expansion of an escaped shell variable in a
-# double_quote_subst'ed string.
-delay_variable_subst='s/\\\\\\\\\\\$/\\\\\\$/g'
-
-# Sed substitution to delay expansion of an escaped single quote.
-delay_single_quote_subst='s/'\''/'\'\\\\\\\'\''/g'
-
-# Sed substitution to avoid accidental globbing in evaled expressions
-no_glob_subst='s/\*/\\\*/g'
-
-ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
-ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO
-ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to print strings" >&5
-$as_echo_n "checking how to print strings... " >&6; }
-# Test print first, because it will be a builtin if present.
-if test "X`print -r -- -n 2>/dev/null`" = X-n && \
-   test "X`print -r -- $ECHO 2>/dev/null`" = "X$ECHO"; then
-  ECHO='print -r --'
-elif test "X`printf %s $ECHO 2>/dev/null`" = "X$ECHO"; then
-  ECHO='printf %s\n'
-else
-  # Use this function as a fallback that always works.
-  func_fallback_echo ()
-  {
-    eval 'cat <<_LTECHO_EOF
-$1
-_LTECHO_EOF'
-  }
-  ECHO='func_fallback_echo'
-fi
-
-# func_echo_all arg...
-# Invoke $ECHO with all args, space-separated.
-func_echo_all ()
-{
-    $ECHO ""
-}
-
-case "$ECHO" in
-  printf*) { $as_echo "$as_me:${as_lineno-$LINENO}: result: printf" >&5
-$as_echo "printf" >&6; } ;;
-  print*) { $as_echo "$as_me:${as_lineno-$LINENO}: result: print -r" >&5
-$as_echo "print -r" >&6; } ;;
-  *) { $as_echo "$as_me:${as_lineno-$LINENO}: result: cat" >&5
-$as_echo "cat" >&6; } ;;
-esac
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a sed that does not truncate output" >&5
-$as_echo_n "checking for a sed that does not truncate output... " >&6; }
-if test "${ac_cv_path_SED+set}" = set; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
+$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
+if test "${ac_cv_path_GREP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-            ac_script=s/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/
-     for ac_i in 1 2 3 4 5 6 7; do
-       ac_script="$ac_script$as_nl$ac_script"
-     done
-     echo "$ac_script" 2>/dev/null | sed 99q >conftest.sed
-     { ac_script=; unset ac_script;}
-     if test -z "$SED"; then
-  ac_path_SED_found=false
+  if test -z "$GREP"; then
+  ac_path_GREP_found=false
   # Loop through the user's path and test for each of PROGNAME-LIST
   as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-    for ac_prog in sed gsed; do
+    for ac_prog in grep ggrep; do
     for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_SED="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_SED" && $as_test_x "$ac_path_SED"; } || continue
-# Check for GNU ac_path_SED and select it if it is found.
-  # Check for GNU $ac_path_SED
-case `"$ac_path_SED" --version 2>&1` in
+      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
+# Check for GNU ac_path_GREP and select it if it is found.
+  # Check for GNU $ac_path_GREP
+case `"$ac_path_GREP" --version 2>&1` in
 *GNU*)
-  ac_cv_path_SED="$ac_path_SED" ac_path_SED_found=:;;
+  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
 *)
   ac_count=0
   $as_echo_n 0123456789 >"conftest.in"
@@ -4679,14 +4588,14 @@ case `"$ac_path_SED" --version 2>&1` in
     cat "conftest.in" "conftest.in" >"conftest.tmp"
     mv "conftest.tmp" "conftest.in"
     cp "conftest.in" "conftest.nl"
-    $as_echo '' >> "conftest.nl"
-    "$ac_path_SED" -f conftest.sed < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    $as_echo 'GREP' >> "conftest.nl"
+    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
     diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
     as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_SED_max-0}; then
+    if test $ac_count -gt ${ac_path_GREP_max-0}; then
       # Best one so far, save it but keep looking for a better one
-      ac_cv_path_SED="$ac_path_SED"
-      ac_path_SED_max=$ac_count
+      ac_cv_path_GREP="$ac_path_GREP"
+      ac_path_GREP_max=$ac_count
     fi
     # 10*(2^10) chars as input seems more than enough
     test $ac_count -gt 10 && break
@@ -4694,62 +4603,49 @@ case `"$ac_path_SED" --version 2>&1` in
   rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
 esac
 
-      $ac_path_SED_found && break 3
+      $ac_path_GREP_found && break 3
     done
   done
   done
 IFS=$as_save_IFS
-  if test -z "$ac_cv_path_SED"; then
-    as_fn_error "no acceptable sed could be found in \$PATH" "$LINENO" 5
+  if test -z "$ac_cv_path_GREP"; then
+    as_fn_error "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
   fi
 else
-  ac_cv_path_SED=$SED
+  ac_cv_path_GREP=$GREP
 fi
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_SED" >&5
-$as_echo "$ac_cv_path_SED" >&6; }
- SED="$ac_cv_path_SED"
-  rm -f conftest.sed
-
-test -z "$SED" && SED=sed
-Xsed="$SED -e 1s/^X//"
-
-
-
-
-
-
-
-
-
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP" >&5
+$as_echo "$ac_cv_path_GREP" >&6; }
+ GREP="$ac_cv_path_GREP"
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for fgrep" >&5
-$as_echo_n "checking for fgrep... " >&6; }
-if test "${ac_cv_path_FGREP+set}" = set; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
+$as_echo_n "checking for egrep... " >&6; }
+if test "${ac_cv_path_EGREP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if echo 'ab*c' | $GREP -F 'ab*c' >/dev/null 2>&1
-   then ac_cv_path_FGREP="$GREP -F"
+  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
+   then ac_cv_path_EGREP="$GREP -E"
    else
-     if test -z "$FGREP"; then
-  ac_path_FGREP_found=false
+     if test -z "$EGREP"; then
+  ac_path_EGREP_found=false
   # Loop through the user's path and test for each of PROGNAME-LIST
   as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-    for ac_prog in fgrep; do
+    for ac_prog in egrep; do
     for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_FGREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_FGREP" && $as_test_x "$ac_path_FGREP"; } || continue
-# Check for GNU ac_path_FGREP and select it if it is found.
-  # Check for GNU $ac_path_FGREP
-case `"$ac_path_FGREP" --version 2>&1` in
+      ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
+# Check for GNU ac_path_EGREP and select it if it is found.
+  # Check for GNU $ac_path_EGREP
+case `"$ac_path_EGREP" --version 2>&1` in
 *GNU*)
-  ac_cv_path_FGREP="$ac_path_FGREP" ac_path_FGREP_found=:;;
+  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
 *)
   ac_count=0
   $as_echo_n 0123456789 >"conftest.in"
@@ -4758,14 +4654,14 @@ case `"$ac_path_FGREP" --version 2>&1` in
     cat "conftest.in" "conftest.in" >"conftest.tmp"
     mv "conftest.tmp" "conftest.in"
     cp "conftest.in" "conftest.nl"
-    $as_echo 'FGREP' >> "conftest.nl"
-    "$ac_path_FGREP" FGREP < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    $as_echo 'EGREP' >> "conftest.nl"
+    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
     diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
     as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_FGREP_max-0}; then
+    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
       # Best one so far, save it but keep looking for a better one
-      ac_cv_path_FGREP="$ac_path_FGREP"
-      ac_path_FGREP_max=$ac_count
+      ac_cv_path_EGREP="$ac_path_EGREP"
+      ac_path_EGREP_max=$ac_count
     fi
     # 10*(2^10) chars as input seems more than enough
     test $ac_count -gt 10 && break
@@ -4773,590 +4669,488 @@ case `"$ac_path_FGREP" --version 2>&1` in
   rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
 esac
 
-      $ac_path_FGREP_found && break 3
+      $ac_path_EGREP_found && break 3
     done
   done
   done
 IFS=$as_save_IFS
-  if test -z "$ac_cv_path_FGREP"; then
-    as_fn_error "no acceptable fgrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  if test -z "$ac_cv_path_EGREP"; then
+    as_fn_error "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
   fi
 else
-  ac_cv_path_FGREP=$FGREP
+  ac_cv_path_EGREP=$EGREP
 fi
 
    fi
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_FGREP" >&5
-$as_echo "$ac_cv_path_FGREP" >&6; }
- FGREP="$ac_cv_path_FGREP"
-
-
-test -z "$GREP" && GREP=grep
-
-
-
-
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP" >&5
+$as_echo "$ac_cv_path_EGREP" >&6; }
+ EGREP="$ac_cv_path_EGREP"
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
+$as_echo_n "checking for ANSI C header files... " >&6; }
+if test "${ac_cv_header_stdc+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
 
+int
+main ()
+{
 
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_header_stdc=yes
+else
+  ac_cv_header_stdc=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <string.h>
 
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then :
 
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
 
+fi
 
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
 
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then :
 
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
 
+fi
 
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then :
+  :
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ctype.h>
+#include <stdlib.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
 
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+	|| toupper (i) != TOUPPER (i))
+      return 2;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
 
-# Check whether --with-gnu-ld was given.
-if test "${with_gnu_ld+set}" = set; then :
-  withval=$with_gnu_ld; test "$withval" = no || with_gnu_ld=yes
 else
-  with_gnu_ld=no
+  ac_cv_header_stdc=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
-ac_prog=ld
-if test "$GCC" = yes; then
-  # Check if gcc -print-prog-name=ld gives a path.
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
-$as_echo_n "checking for ld used by $CC... " >&6; }
-  case $host in
-  *-*-mingw*)
-    # gcc leaves a trailing carriage return which upsets mingw
-    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
-  *)
-    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
-  esac
-  case $ac_prog in
-    # Accept absolute paths.
-    [\\/]* | ?:[\\/]*)
-      re_direlt='/[^/][^/]*/\.\./'
-      # Canonicalize the pathname of ld
-      ac_prog=`$ECHO "$ac_prog"| $SED 's%\\\\%/%g'`
-      while $ECHO "$ac_prog" | $GREP "$re_direlt" > /dev/null 2>&1; do
-	ac_prog=`$ECHO $ac_prog| $SED "s%$re_direlt%/%"`
-      done
-      test -z "$LD" && LD="$ac_prog"
-      ;;
-  "")
-    # If it fails, then pretend we aren't using GCC.
-    ac_prog=ld
-    ;;
-  *)
-    # If it is relative, then search for the first ld in PATH.
-    with_gnu_ld=unknown
-    ;;
-  esac
-elif test "$with_gnu_ld" = yes; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNU ld" >&5
-$as_echo_n "checking for GNU ld... " >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for non-GNU ld" >&5
-$as_echo_n "checking for non-GNU ld... " >&6; }
 fi
-if test "${lt_cv_path_LD+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -z "$LD"; then
-  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
-  for ac_dir in $PATH; do
-    IFS="$lt_save_ifs"
-    test -z "$ac_dir" && ac_dir=.
-    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
-      lt_cv_path_LD="$ac_dir/$ac_prog"
-      # Check to see if the program is GNU ld.  I'd rather use --version,
-      # but apparently some variants of GNU ld only accept -v.
-      # Break only if it was the GNU/non-GNU ld that we prefer.
-      case `"$lt_cv_path_LD" -v 2>&1 </dev/null` in
-      *GNU* | *'with BFD'*)
-	test "$with_gnu_ld" != no && break
-	;;
-      *)
-	test "$with_gnu_ld" != yes && break
-	;;
-      esac
-    fi
-  done
-  IFS="$lt_save_ifs"
-else
-  lt_cv_path_LD="$LD" # Let the user override the test with a path.
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc" >&5
+$as_echo "$ac_cv_header_stdc" >&6; }
+if test $ac_cv_header_stdc = yes; then
+
+$as_echo "#define STDC_HEADERS 1" >>confdefs.h
+
 fi
 
-LD="$lt_cv_path_LD"
-if test -n "$LD"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LD" >&5
-$as_echo "$LD" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+# On IRIX 5.3, sys/types and inttypes.h are conflicting.
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+		  inttypes.h stdint.h unistd.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
+"
+eval as_val=\$$as_ac_Header
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
 fi
-test -z "$LD" && as_fn_error "no acceptable ld found in \$PATH" "$LINENO" 5
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if the linker ($LD) is GNU ld" >&5
-$as_echo_n "checking if the linker ($LD) is GNU ld... " >&6; }
-if test "${lt_cv_prog_gnu_ld+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  # I'd rather use --version here, but apparently some GNU lds only accept -v.
-case `$LD -v 2>&1 </dev/null` in
-*GNU* | *'with BFD'*)
-  lt_cv_prog_gnu_ld=yes
-  ;;
-*)
-  lt_cv_prog_gnu_ld=no
-  ;;
-esac
+
+done
+
+
+for ac_header in stdint.h execinfo.h signal.h dlfcn.h dirent.h pwd.h grp.h \
+  netdb.h sys/ipc.h sys/sem.h sys/shm.h sys/wait.h ctype.h mntent.h \
+  sys/mnttab.h sys/socket.h netinet/in.h arpa/inet.h dlfcn.h sys/mman.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+eval as_val=\$$as_ac_Header
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_gnu_ld" >&5
-$as_echo "$lt_cv_prog_gnu_ld" >&6; }
-with_gnu_ld=$lt_cv_prog_gnu_ld
 
+done
 
 
+for ac_func in backtrace backtrace_symbols gettimeofday signal
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
 
+fi
+done
 
+for ac_func in fopen64 fseeko64 ftello64 stat64 freopen64
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
 
+fi
+done
 
+for ac_func in setbuf setbuffer setlinebuf setvbuf
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
 
+fi
+done
+
+for ac_func in strnlen memrchr strncpy memmem sethostname
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for BSD- or MS-compatible name lister (nm)" >&5
-$as_echo_n "checking for BSD- or MS-compatible name lister (nm)... " >&6; }
-if test "${lt_cv_path_NM+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$NM"; then
-  # Let the user override the test.
-  lt_cv_path_NM="$NM"
-else
-  lt_nm_to_check="${ac_tool_prefix}nm"
-  if test -n "$ac_tool_prefix" && test "$build" = "$host"; then
-    lt_nm_to_check="$lt_nm_to_check nm"
-  fi
-  for lt_tmp_nm in $lt_nm_to_check; do
-    lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
-    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do
-      IFS="$lt_save_ifs"
-      test -z "$ac_dir" && ac_dir=.
-      tmp_nm="$ac_dir/$lt_tmp_nm"
-      if test -f "$tmp_nm" || test -f "$tmp_nm$ac_exeext" ; then
-	# Check to see if the nm accepts a BSD-compat flag.
-	# Adding the `sed 1q' prevents false positives on HP-UX, which says:
-	#   nm: unknown option "B" ignored
-	# Tru64's nm complains that /dev/null is an invalid object file
-	case `"$tmp_nm" -B /dev/null 2>&1 | sed '1q'` in
-	*/dev/null* | *'Invalid file or object type'*)
-	  lt_cv_path_NM="$tmp_nm -B"
-	  break
-	  ;;
-	*)
-	  case `"$tmp_nm" -p /dev/null 2>&1 | sed '1q'` in
-	  */dev/null*)
-	    lt_cv_path_NM="$tmp_nm -p"
-	    break
-	    ;;
-	  *)
-	    lt_cv_path_NM=${lt_cv_path_NM="$tmp_nm"} # keep the first match, but
-	    continue # so that we can try to find one that supports BSD flags
-	    ;;
-	  esac
-	  ;;
-	esac
-      fi
-    done
-    IFS="$lt_save_ifs"
-  done
-  : ${lt_cv_path_NM=no}
-fi
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_path_NM" >&5
-$as_echo "$lt_cv_path_NM" >&6; }
-if test "$lt_cv_path_NM" != "no"; then
-  NM="$lt_cv_path_NM"
-else
-  # Didn't find any BSD compatible name lister, look for dumpbin.
-  if test -n "$DUMPBIN"; then :
-    # Let the user override the test.
-  else
-    if test -n "$ac_tool_prefix"; then
-  for ac_prog in dumpbin "link -dump"
-  do
-    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
-set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_DUMPBIN+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$DUMPBIN"; then
-  ac_cv_prog_DUMPBIN="$DUMPBIN" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_DUMPBIN="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
 done
-  done
-IFS=$as_save_IFS
+
+for ac_func in __ctype_b_loc __ctype_tolower_loc __ctype_toupper_loc
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
 
 fi
-fi
-DUMPBIN=$ac_cv_prog_DUMPBIN
-if test -n "$DUMPBIN"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DUMPBIN" >&5
-$as_echo "$DUMPBIN" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
+done
 
+for ac_func in getlogin cuserid getpwnam getpwuid getpwent getgrnam getgrgid getgrent
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
 
-    test -n "$DUMPBIN" && break
-  done
 fi
-if test -z "$DUMPBIN"; then
-  ac_ct_DUMPBIN=$DUMPBIN
-  for ac_prog in dumpbin "link -dump"
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_DUMPBIN+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_DUMPBIN"; then
-  ac_cv_prog_ac_ct_DUMPBIN="$ac_ct_DUMPBIN" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_DUMPBIN="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
 done
-  done
-IFS=$as_save_IFS
+
+for ac_func in getlogin_r getpwnam_r getpwuid_r getgrnam_r getgrgid_r
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
 
 fi
-fi
-ac_ct_DUMPBIN=$ac_cv_prog_ac_ct_DUMPBIN
-if test -n "$ac_ct_DUMPBIN"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DUMPBIN" >&5
-$as_echo "$ac_ct_DUMPBIN" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
+done
 
+for ac_func in getservent getservbyname getservbyport getaddrinfo gai_strerror
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
 
-  test -n "$ac_ct_DUMPBIN" && break
+fi
 done
 
-  if test "x$ac_ct_DUMPBIN" = x; then
-    DUMPBIN=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    DUMPBIN=$ac_ct_DUMPBIN
-  fi
+for ac_func in getprotoent getprotobyname getprotobynumber
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
 fi
+done
 
-    case `$DUMPBIN -symbols /dev/null 2>&1 | sed '1q'` in
-    *COFF*)
-      DUMPBIN="$DUMPBIN -symbols"
-      ;;
-    *)
-      DUMPBIN=:
-      ;;
-    esac
-  fi
+for ac_func in getmntent setmntent addmntent
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
 
-  if test "$DUMPBIN" != ":"; then
-    NM="$DUMPBIN"
-  fi
 fi
-test -z "$NM" && NM=nm
+done
 
+for ac_func in inet_ntoa mmap munmap
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
 
+fi
+done
 
+for ac_func in mmap64
+do :
+  ac_fn_c_check_func "$LINENO" "mmap64" "ac_cv_func_mmap64"
+if test "x$ac_cv_func_mmap64" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_MMAP64 1
+_ACEOF
 
+fi
+done
 
+for ac_func in __libc_freeres
+do :
+  ac_fn_c_check_func "$LINENO" "__libc_freeres" "ac_cv_func___libc_freeres"
+if test "x$ac_cv_func___libc_freeres" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE___LIBC_FREERES 1
+_ACEOF
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the name lister ($NM) interface" >&5
-$as_echo_n "checking the name lister ($NM) interface... " >&6; }
-if test "${lt_cv_nm_interface+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_nm_interface="BSD nm"
-  echo "int some_variable = 0;" > conftest.$ac_ext
-  (eval echo "\"\$as_me:$LINENO: $ac_compile\"" >&5)
-  (eval "$ac_compile" 2>conftest.err)
-  cat conftest.err >&5
-  (eval echo "\"\$as_me:$LINENO: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
-  (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
-  cat conftest.err >&5
-  (eval echo "\"\$as_me:$LINENO: output\"" >&5)
-  cat conftest.out >&5
-  if $GREP 'External.*some_variable' conftest.out > /dev/null; then
-    lt_cv_nm_interface="MS dumpbin"
-  fi
-  rm -f conftest*
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_nm_interface" >&5
-$as_echo "$lt_cv_nm_interface" >&6; }
+done
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ln -s works" >&5
-$as_echo_n "checking whether ln -s works... " >&6; }
-LN_S=$as_ln_s
-if test "$LN_S" = "ln -s"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no, using $LN_S" >&5
-$as_echo "no, using $LN_S" >&6; }
-fi
-
-# find the maximum length of command line arguments
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the maximum length of command line arguments" >&5
-$as_echo_n "checking the maximum length of command line arguments... " >&6; }
-if test "${lt_cv_sys_max_cmd_len+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-    i=0
-  teststring="ABCD"
-
-  case $build_os in
-  msdosdjgpp*)
-    # On DJGPP, this test can blow up pretty badly due to problems in libc
-    # (any single argument exceeding 2000 bytes causes a buffer overrun
-    # during glob expansion).  Even if it were fixed, the result of this
-    # check would be larger than it should be.
-    lt_cv_sys_max_cmd_len=12288;    # 12K is about right
-    ;;
+for ac_func in rawmemchr stpcpy mempcpy
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
 
-  gnu*)
-    # Under GNU Hurd, this test is not required because there is
-    # no limit to the length of command line arguments.
-    # Libtool will interpret -1 as no limit whatsoever
-    lt_cv_sys_max_cmd_len=-1;
-    ;;
+fi
+done
 
-  cygwin* | mingw* | cegcc*)
-    # On Win9x/ME, this test blows up -- it succeeds, but takes
-    # about 5 minutes as the teststring grows exponentially.
-    # Worse, since 9x/ME are not pre-emptively multitasking,
-    # you end up with a "frozen" computer, even though with patience
-    # the test eventually succeeds (with a max line length of 256k).
-    # Instead, let's just punt: use the minimum linelength reported by
-    # all of the supported platforms: 8192 (on NT/2K/XP).
-    lt_cv_sys_max_cmd_len=8192;
-    ;;
 
-  mint*)
-    # On MiNT this can take a long time and run out of memory.
-    lt_cv_sys_max_cmd_len=8192;
-    ;;
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <sys/ipc.h>
+#include <sys/sem.h>
+int
+main ()
+{
+union semun foo;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  mf_have_semun=1
+else
+  mf_have_semun=0
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+if test $mf_have_semun = 1
+then
 
-  amigaos*)
-    # On AmigaOS with pdksh, this test takes hours, literally.
-    # So we just punt and use a minimum line length of 8192.
-    lt_cv_sys_max_cmd_len=8192;
-    ;;
+$as_echo "#define HAVE_UNION_SEMUN 1" >>confdefs.h
 
-  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
-    # This has been around since 386BSD, at least.  Likely further.
-    if test -x /sbin/sysctl; then
-      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`
-    elif test -x /usr/sbin/sysctl; then
-      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`
-    else
-      lt_cv_sys_max_cmd_len=65536	# usable default for all BSDs
-    fi
-    # And add a safety zone
-    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
-    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
-    ;;
+fi
 
-  interix*)
-    # We know the value 262144 and hardcode it with a safety zone (like BSD)
-    lt_cv_sys_max_cmd_len=196608
-    ;;
 
-  osf*)
-    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure
-    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not
-    # nice to cause kernel panics so lets avoid the loop below.
-    # First set a reasonable default.
-    lt_cv_sys_max_cmd_len=16384
-    #
-    if test -x /sbin/sysconfig; then
-      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in
-        *1*) lt_cv_sys_max_cmd_len=-1 ;;
-      esac
-    fi
-    ;;
-  sco3.2v5*)
-    lt_cv_sys_max_cmd_len=102400
-    ;;
-  sysv5* | sco5v6* | sysv4.2uw2*)
-    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`
-    if test -n "$kargmax"; then
-      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[	 ]//'`
-    else
-      lt_cv_sys_max_cmd_len=32768
-    fi
-    ;;
-  *)
-    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`
-    if test -n "$lt_cv_sys_max_cmd_len"; then
-      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
-      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
-    else
-      # Make teststring a little bigger before we do anything with it.
-      # a 1K string should be a reasonable start.
-      for i in 1 2 3 4 5 6 7 8 ; do
-        teststring=$teststring$teststring
-      done
-      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}
-      # If test is not a shell built-in, we'll probably end up computing a
-      # maximum length that is only half of the actual maximum length, but
-      # we can't tell.
-      while { test "X"`func_fallback_echo "$teststring$teststring" 2>/dev/null` \
-	         = "X$teststring$teststring"; } >/dev/null 2>&1 &&
-	      test $i != 17 # 1/2 MB should be enough
-      do
-        i=`expr $i + 1`
-        teststring=$teststring$teststring
-      done
-      # Only check the string length outside the loop.
-      lt_cv_sys_max_cmd_len=`expr "X$teststring" : ".*" 2>&1`
-      teststring=
-      # Add a significant safety factor because C++ compilers can tack on
-      # massive amounts of additional arguments before passing them to the
-      # linker.  It appears as though 1/2 is a usable value.
-      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 2`
-    fi
-    ;;
-  esac
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for socklen_t in sys/socket.h" >&5
+$as_echo_n "checking for socklen_t in sys/socket.h... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#define _POSIX_PII_SOCKET
+#include <sys/types.h>
+#include <sys/socket.h>
+int
+main ()
+{
+socklen_t x = 5;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
 
-fi
+$as_echo "#define HAVE_SOCKLEN_T 1" >>confdefs.h
 
-if test -n $lt_cv_sys_max_cmd_len ; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_sys_max_cmd_len" >&5
-$as_echo "$lt_cv_sys_max_cmd_len" >&6; }
+   { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: none" >&5
-$as_echo "none" >&6; }
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
 fi
-max_cmd_len=$lt_cv_sys_max_cmd_len
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
+enable_dlopen=yes
 
 
 
+case `pwd` in
+  *\ * | *\	*)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&5
+$as_echo "$as_me: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&2;} ;;
+esac
 
 
-: ${CP="cp -f"}
-: ${MV="mv -f"}
-: ${RM="rm -f"}
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands some XSI constructs" >&5
-$as_echo_n "checking whether the shell understands some XSI constructs... " >&6; }
-# Try some XSI features
-xsi_shell=no
-( _lt_dummy="a/b/c"
-  test "${_lt_dummy##*/},${_lt_dummy%/*},"${_lt_dummy%"$_lt_dummy"}, \
-      = c,a/b,, \
-    && eval 'test $(( 1 + 1 )) -eq 2 \
-    && test "${#_lt_dummy}" -eq 5' ) >/dev/null 2>&1 \
-  && xsi_shell=yes
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $xsi_shell" >&5
-$as_echo "$xsi_shell" >&6; }
+macro_version='2.2.7a'
+macro_revision='1.3134'
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands \"+=\"" >&5
-$as_echo_n "checking whether the shell understands \"+=\"... " >&6; }
-lt_shell_append=no
-( foo=bar; set foo baz; eval "$1+=\$2" && test "$foo" = barbaz ) \
-    >/dev/null 2>&1 \
-  && lt_shell_append=yes
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_shell_append" >&5
-$as_echo "$lt_shell_append" >&6; }
 
 
-if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
-  lt_unset=unset
-else
-  lt_unset=false
-fi
 
 
 
 
 
-# test EBCDIC or ASCII
-case `echo X|tr X '\101'` in
- A) # ASCII based system
-    # \n is not interpreted correctly by Solaris 8 /usr/ucb/tr
-  lt_SP2NL='tr \040 \012'
-  lt_NL2SP='tr \015\012 \040\040'
-  ;;
- *) # EBCDIC based system
-  lt_SP2NL='tr \100 \n'
-  lt_NL2SP='tr \r\n \100\100'
-  ;;
-esac
 
 
 
 
+ltmain="$ac_aux_dir/ltmain.sh"
 
+# Backslashify metacharacters that are still active within
+# double-quoted strings.
+sed_quote_subst='s/\(["`$\\]\)/\\\1/g'
 
+# Same as above, but do not quote variable references.
+double_quote_subst='s/\(["`\\]\)/\\\1/g'
 
+# Sed substitution to delay expansion of an escaped shell variable in a
+# double_quote_subst'ed string.
+delay_variable_subst='s/\\\\\\\\\\\$/\\\\\\$/g'
 
+# Sed substitution to delay expansion of an escaped single quote.
+delay_single_quote_subst='s/'\''/'\'\\\\\\\'\''/g'
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $LD option to reload object files" >&5
-$as_echo_n "checking for $LD option to reload object files... " >&6; }
-if test "${lt_cv_ld_reload_flag+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_ld_reload_flag='-r'
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_reload_flag" >&5
-$as_echo "$lt_cv_ld_reload_flag" >&6; }
-reload_flag=$lt_cv_ld_reload_flag
-case $reload_flag in
-"" | " "*) ;;
-*) reload_flag=" $reload_flag" ;;
-esac
-reload_cmds='$LD$reload_flag -o $output$reload_objs'
-case $host_os in
-  darwin*)
-    if test "$GCC" = yes; then
-      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'
-    else
-      reload_cmds='$LD$reload_flag -o $output$reload_objs'
-    fi
-    ;;
+# Sed substitution to avoid accidental globbing in evaled expressions
+no_glob_subst='s/\*/\\\*/g'
+
+ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO
+ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to print strings" >&5
+$as_echo_n "checking how to print strings... " >&6; }
+# Test print first, because it will be a builtin if present.
+if test "X`print -r -- -n 2>/dev/null`" = X-n && \
+   test "X`print -r -- $ECHO 2>/dev/null`" = "X$ECHO"; then
+  ECHO='print -r --'
+elif test "X`printf %s $ECHO 2>/dev/null`" = "X$ECHO"; then
+  ECHO='printf %s\n'
+else
+  # Use this function as a fallback that always works.
+  func_fallback_echo ()
+  {
+    eval 'cat <<_LTECHO_EOF
+$1
+_LTECHO_EOF'
+  }
+  ECHO='func_fallback_echo'
+fi
+
+# func_echo_all arg...
+# Invoke $ECHO with all args, space-separated.
+func_echo_all ()
+{
+    $ECHO ""
+}
+
+case "$ECHO" in
+  printf*) { $as_echo "$as_me:${as_lineno-$LINENO}: result: printf" >&5
+$as_echo "printf" >&6; } ;;
+  print*) { $as_echo "$as_me:${as_lineno-$LINENO}: result: print -r" >&5
+$as_echo "print -r" >&6; } ;;
+  *) { $as_echo "$as_me:${as_lineno-$LINENO}: result: cat" >&5
+$as_echo "cat" >&6; } ;;
 esac
 
 
@@ -5367,100 +5161,161 @@ esac
 
 
 
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}objdump", so it can be a program name with args.
-set dummy ${ac_tool_prefix}objdump; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_OBJDUMP+set}" = set; then :
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a sed that does not truncate output" >&5
+$as_echo_n "checking for a sed that does not truncate output... " >&6; }
+if test "${ac_cv_path_SED+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$OBJDUMP"; then
-  ac_cv_prog_OBJDUMP="$OBJDUMP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+            ac_script=s/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/
+     for ac_i in 1 2 3 4 5 6 7; do
+       ac_script="$ac_script$as_nl$ac_script"
+     done
+     echo "$ac_script" 2>/dev/null | sed 99q >conftest.sed
+     { ac_script=; unset ac_script;}
+     if test -z "$SED"; then
+  ac_path_SED_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
+    for ac_prog in sed gsed; do
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_OBJDUMP="${ac_tool_prefix}objdump"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
+      ac_path_SED="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_SED" && $as_test_x "$ac_path_SED"; } || continue
+# Check for GNU ac_path_SED and select it if it is found.
+  # Check for GNU $ac_path_SED
+case `"$ac_path_SED" --version 2>&1` in
+*GNU*)
+  ac_cv_path_SED="$ac_path_SED" ac_path_SED_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo '' >> "conftest.nl"
+    "$ac_path_SED" -f conftest.sed < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_SED_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_SED="$ac_path_SED"
+      ac_path_SED_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
   done
-IFS=$as_save_IFS
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
 
-fi
-fi
-OBJDUMP=$ac_cv_prog_OBJDUMP
-if test -n "$OBJDUMP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OBJDUMP" >&5
-$as_echo "$OBJDUMP" >&6; }
+      $ac_path_SED_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_SED"; then
+    as_fn_error "no acceptable sed could be found in \$PATH" "$LINENO" 5
+  fi
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  ac_cv_path_SED=$SED
 fi
 
-
 fi
-if test -z "$ac_cv_prog_OBJDUMP"; then
-  ac_ct_OBJDUMP=$OBJDUMP
-  # Extract the first word of "objdump", so it can be a program name with args.
-set dummy objdump; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_OBJDUMP+set}" = set; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_SED" >&5
+$as_echo "$ac_cv_path_SED" >&6; }
+ SED="$ac_cv_path_SED"
+  rm -f conftest.sed
+
+test -z "$SED" && SED=sed
+Xsed="$SED -e 1s/^X//"
+
+
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for fgrep" >&5
+$as_echo_n "checking for fgrep... " >&6; }
+if test "${ac_cv_path_FGREP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$ac_ct_OBJDUMP"; then
-  ac_cv_prog_ac_ct_OBJDUMP="$ac_ct_OBJDUMP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
+  if echo 'ab*c' | $GREP -F 'ab*c' >/dev/null 2>&1
+   then ac_cv_path_FGREP="$GREP -F"
+   else
+     if test -z "$FGREP"; then
+  ac_path_FGREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
+    for ac_prog in fgrep; do
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_OBJDUMP="objdump"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
+      ac_path_FGREP="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_FGREP" && $as_test_x "$ac_path_FGREP"; } || continue
+# Check for GNU ac_path_FGREP and select it if it is found.
+  # Check for GNU $ac_path_FGREP
+case `"$ac_path_FGREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_FGREP="$ac_path_FGREP" ac_path_FGREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'FGREP' >> "conftest.nl"
+    "$ac_path_FGREP" FGREP < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_FGREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_FGREP="$ac_path_FGREP"
+      ac_path_FGREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
   done
-IFS=$as_save_IFS
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
 
-fi
-fi
-ac_ct_OBJDUMP=$ac_cv_prog_ac_ct_OBJDUMP
-if test -n "$ac_ct_OBJDUMP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OBJDUMP" >&5
-$as_echo "$ac_ct_OBJDUMP" >&6; }
+      $ac_path_FGREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_FGREP"; then
+    as_fn_error "no acceptable fgrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  ac_cv_path_FGREP=$FGREP
 fi
 
-  if test "x$ac_ct_OBJDUMP" = x; then
-    OBJDUMP="false"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    OBJDUMP=$ac_ct_OBJDUMP
-  fi
-else
-  OBJDUMP="$ac_cv_prog_OBJDUMP"
+   fi
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_FGREP" >&5
+$as_echo "$ac_cv_path_FGREP" >&6; }
+ FGREP="$ac_cv_path_FGREP"
 
-test -z "$OBJDUMP" && OBJDUMP=objdump
 
+test -z "$GREP" && GREP=grep
 
 
 
@@ -5469,274 +5324,198 @@ test -z "$OBJDUMP" && OBJDUMP=objdump
 
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to recognize dependent libraries" >&5
-$as_echo_n "checking how to recognize dependent libraries... " >&6; }
-if test "${lt_cv_deplibs_check_method+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_file_magic_cmd='$MAGIC_CMD'
-lt_cv_file_magic_test_file=
-lt_cv_deplibs_check_method='unknown'
-# Need to set the preceding variable on all platforms that support
-# interlibrary dependencies.
-# 'none' -- dependencies not supported.
-# `unknown' -- same as none, but documents that we really don't know.
-# 'pass_all' -- all dependencies passed with no checks.
-# 'test_compile' -- check by making test program.
-# 'file_magic [[regex]]' -- check by looking for files in library path
-# which responds to the $file_magic_cmd with a given extended regex.
-# If you have `file' or equivalent on your system and you're not sure
-# whether `pass_all' will *always* work, you probably want this one.
 
-case $host_os in
-aix[4-9]*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
 
-beos*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
 
-bsdi[45]*)
-  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib)'
-  lt_cv_file_magic_cmd='/usr/bin/file -L'
-  lt_cv_file_magic_test_file=/shlib/libc.so
-  ;;
 
-cygwin*)
-  # func_win32_libid is a shell function defined in ltmain.sh
-  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
-  lt_cv_file_magic_cmd='func_win32_libid'
-  ;;
 
-mingw* | pw32*)
-  # Base MSYS/MinGW do not provide the 'file' command needed by
-  # func_win32_libid shell function, so use a weaker test based on 'objdump',
-  # unless we find 'file', for example because we are cross-compiling.
-  # func_win32_libid assumes BSD nm, so disallow it if using MS dumpbin.
-  if ( test "$lt_cv_nm_interface" = "BSD nm" && file / ) >/dev/null 2>&1; then
-    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
-    lt_cv_file_magic_cmd='func_win32_libid'
-  else
-    lt_cv_deplibs_check_method='file_magic file format pei*-i386(.*architecture: i386)?'
-    lt_cv_file_magic_cmd='$OBJDUMP -f'
-  fi
-  ;;
 
-cegcc*)
-  # use the weaker test based on 'objdump'. See mingw*.
-  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'
-  lt_cv_file_magic_cmd='$OBJDUMP -f'
-  ;;
 
-darwin* | rhapsody*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
 
-freebsd* | dragonfly*)
-  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
-    case $host_cpu in
-    i*86 )
-      # Not sure whether the presence of OpenBSD here was a mistake.
-      # Let's accept both of them until this is cleared up.
-      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[3-9]86 (compact )?demand paged shared library'
-      lt_cv_file_magic_cmd=/usr/bin/file
-      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`
-      ;;
-    esac
-  else
-    lt_cv_deplibs_check_method=pass_all
-  fi
-  ;;
 
-gnu*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
 
-haiku*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
 
-hpux10.20* | hpux11*)
-  lt_cv_file_magic_cmd=/usr/bin/file
-  case $host_cpu in
-  ia64*)
-    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF-[0-9][0-9]) shared object file - IA64'
-    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so
-    ;;
-  hppa*64*)
-    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF[ -][0-9][0-9])(-bit)?( [LM]SB)? shared object( file)?[, -]* PA-RISC [0-9]\.[0-9]'
-    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl
+# Check whether --with-gnu-ld was given.
+if test "${with_gnu_ld+set}" = set; then :
+  withval=$with_gnu_ld; test "$withval" = no || with_gnu_ld=yes
+else
+  with_gnu_ld=no
+fi
+
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
+$as_echo_n "checking for ld used by $CC... " >&6; }
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [\\/]* | ?:[\\/]*)
+      re_direlt='/[^/][^/]*/\.\./'
+      # Canonicalize the pathname of ld
+      ac_prog=`$ECHO "$ac_prog"| $SED 's%\\\\%/%g'`
+      while $ECHO "$ac_prog" | $GREP "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`$ECHO $ac_prog| $SED "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
     ;;
   *)
-    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|PA-RISC[0-9]\.[0-9]) shared library'
-    lt_cv_file_magic_test_file=/usr/lib/libc.sl
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
     ;;
   esac
-  ;;
-
-interix[3-9]*)
-  # PIC code is broken on Interix 3.x, that's why |\.a not |_pic\.a here
-  lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so|\.a)$'
-  ;;
-
-irix5* | irix6* | nonstopux*)
-  case $LD in
-  *-32|*"-32 ") libmagic=32-bit;;
-  *-n32|*"-n32 ") libmagic=N32;;
-  *-64|*"-64 ") libmagic=64-bit;;
-  *) libmagic=never-match;;
-  esac
-  lt_cv_deplibs_check_method=pass_all
-  ;;
+elif test "$with_gnu_ld" = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNU ld" >&5
+$as_echo_n "checking for GNU ld... " >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for non-GNU ld" >&5
+$as_echo_n "checking for non-GNU ld... " >&6; }
+fi
+if test "${lt_cv_path_LD+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$LD"; then
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  for ac_dir in $PATH; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      lt_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some variants of GNU ld only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      case `"$lt_cv_path_LD" -v 2>&1 </dev/null` in
+      *GNU* | *'with BFD'*)
+	test "$with_gnu_ld" != no && break
+	;;
+      *)
+	test "$with_gnu_ld" != yes && break
+	;;
+      esac
+    fi
+  done
+  IFS="$lt_save_ifs"
+else
+  lt_cv_path_LD="$LD" # Let the user override the test with a path.
+fi
+fi
 
-# This must be Linux ELF.
-linux* | k*bsd*-gnu | kopensolaris*-gnu)
-  lt_cv_deplibs_check_method=pass_all
+LD="$lt_cv_path_LD"
+if test -n "$LD"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LD" >&5
+$as_echo "$LD" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+test -z "$LD" && as_fn_error "no acceptable ld found in \$PATH" "$LINENO" 5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if the linker ($LD) is GNU ld" >&5
+$as_echo_n "checking if the linker ($LD) is GNU ld... " >&6; }
+if test "${lt_cv_prog_gnu_ld+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  # I'd rather use --version here, but apparently some GNU lds only accept -v.
+case `$LD -v 2>&1 </dev/null` in
+*GNU* | *'with BFD'*)
+  lt_cv_prog_gnu_ld=yes
   ;;
-
-netbsd*)
-  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
-    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
-  else
-    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so|_pic\.a)$'
-  fi
+*)
+  lt_cv_prog_gnu_ld=no
   ;;
+esac
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_gnu_ld" >&5
+$as_echo "$lt_cv_prog_gnu_ld" >&6; }
+with_gnu_ld=$lt_cv_prog_gnu_ld
 
-newos6*)
-  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (executable|dynamic lib)'
-  lt_cv_file_magic_cmd=/usr/bin/file
-  lt_cv_file_magic_test_file=/usr/lib/libnls.so
-  ;;
 
-*nto* | *qnx*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
 
-openbsd*)
-  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
-    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|\.so|_pic\.a)$'
-  else
-    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
-  fi
-  ;;
 
-osf3* | osf4* | osf5*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
 
-rdos*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
 
-solaris*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
 
-sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
 
-sysv4 | sysv4.3*)
-  case $host_vendor in
-  motorola)
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib) M[0-9][0-9]* Version [0-9]'
-    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`
-    ;;
-  ncr)
-    lt_cv_deplibs_check_method=pass_all
-    ;;
-  sequent)
-    lt_cv_file_magic_cmd='/bin/file'
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )'
-    ;;
-  sni)
-    lt_cv_file_magic_cmd='/bin/file'
-    lt_cv_deplibs_check_method="file_magic ELF [0-9][0-9]*-bit [LM]SB dynamic lib"
-    lt_cv_file_magic_test_file=/lib/libc.so
-    ;;
-  siemens)
-    lt_cv_deplibs_check_method=pass_all
-    ;;
-  pc)
-    lt_cv_deplibs_check_method=pass_all
-    ;;
-  esac
-  ;;
 
-tpf*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-esac
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_deplibs_check_method" >&5
-$as_echo "$lt_cv_deplibs_check_method" >&6; }
-file_magic_cmd=$lt_cv_file_magic_cmd
-deplibs_check_method=$lt_cv_deplibs_check_method
-test -z "$deplibs_check_method" && deplibs_check_method=unknown
-
-
-
-
-
-
-
-
-
-
-
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}ar", so it can be a program name with args.
-set dummy ${ac_tool_prefix}ar; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_AR+set}" = set; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for BSD- or MS-compatible name lister (nm)" >&5
+$as_echo_n "checking for BSD- or MS-compatible name lister (nm)... " >&6; }
+if test "${lt_cv_path_NM+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$AR"; then
-  ac_cv_prog_AR="$AR" # Let the user override the test.
+  if test -n "$NM"; then
+  # Let the user override the test.
+  lt_cv_path_NM="$NM"
 else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_AR="${ac_tool_prefix}ar"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
+  lt_nm_to_check="${ac_tool_prefix}nm"
+  if test -n "$ac_tool_prefix" && test "$build" = "$host"; then
+    lt_nm_to_check="$lt_nm_to_check nm"
   fi
-done
+  for lt_tmp_nm in $lt_nm_to_check; do
+    lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do
+      IFS="$lt_save_ifs"
+      test -z "$ac_dir" && ac_dir=.
+      tmp_nm="$ac_dir/$lt_tmp_nm"
+      if test -f "$tmp_nm" || test -f "$tmp_nm$ac_exeext" ; then
+	# Check to see if the nm accepts a BSD-compat flag.
+	# Adding the `sed 1q' prevents false positives on HP-UX, which says:
+	#   nm: unknown option "B" ignored
+	# Tru64's nm complains that /dev/null is an invalid object file
+	case `"$tmp_nm" -B /dev/null 2>&1 | sed '1q'` in
+	*/dev/null* | *'Invalid file or object type'*)
+	  lt_cv_path_NM="$tmp_nm -B"
+	  break
+	  ;;
+	*)
+	  case `"$tmp_nm" -p /dev/null 2>&1 | sed '1q'` in
+	  */dev/null*)
+	    lt_cv_path_NM="$tmp_nm -p"
+	    break
+	    ;;
+	  *)
+	    lt_cv_path_NM=${lt_cv_path_NM="$tmp_nm"} # keep the first match, but
+	    continue # so that we can try to find one that supports BSD flags
+	    ;;
+	  esac
+	  ;;
+	esac
+      fi
+    done
+    IFS="$lt_save_ifs"
   done
-IFS=$as_save_IFS
-
+  : ${lt_cv_path_NM=no}
 fi
 fi
-AR=$ac_cv_prog_AR
-if test -n "$AR"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AR" >&5
-$as_echo "$AR" >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_path_NM" >&5
+$as_echo "$lt_cv_path_NM" >&6; }
+if test "$lt_cv_path_NM" != "no"; then
+  NM="$lt_cv_path_NM"
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_AR"; then
-  ac_ct_AR=$AR
-  # Extract the first word of "ar", so it can be a program name with args.
-set dummy ar; ac_word=$2
+  # Didn't find any BSD compatible name lister, look for dumpbin.
+  if test -n "$DUMPBIN"; then :
+    # Let the user override the test.
+  else
+    if test -n "$ac_tool_prefix"; then
+  for ac_prog in dumpbin "link -dump"
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_AR+set}" = set; then :
+if test "${ac_cv_prog_DUMPBIN+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$ac_ct_AR"; then
-  ac_cv_prog_ac_ct_AR="$ac_ct_AR" # Let the user override the test.
+  if test -n "$DUMPBIN"; then
+  ac_cv_prog_DUMPBIN="$DUMPBIN" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
@@ -5745,7 +5524,7 @@ do
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_AR="ar"
+    ac_cv_prog_DUMPBIN="$ac_tool_prefix$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
@@ -5755,53 +5534,32 @@ IFS=$as_save_IFS
 
 fi
 fi
-ac_ct_AR=$ac_cv_prog_ac_ct_AR
-if test -n "$ac_ct_AR"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_AR" >&5
-$as_echo "$ac_ct_AR" >&6; }
+DUMPBIN=$ac_cv_prog_DUMPBIN
+if test -n "$DUMPBIN"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DUMPBIN" >&5
+$as_echo "$DUMPBIN" >&6; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
-  if test "x$ac_ct_AR" = x; then
-    AR="false"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    AR=$ac_ct_AR
-  fi
-else
-  AR="$ac_cv_prog_AR"
-fi
-
-test -z "$AR" && AR=ar
-test -z "$AR_FLAGS" && AR_FLAGS=cru
-
-
-
-
-
-
-
 
-
-
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
-set dummy ${ac_tool_prefix}strip; ac_word=$2
+    test -n "$DUMPBIN" && break
+  done
+fi
+if test -z "$DUMPBIN"; then
+  ac_ct_DUMPBIN=$DUMPBIN
+  for ac_prog in dumpbin "link -dump"
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_STRIP+set}" = set; then :
+if test "${ac_cv_prog_ac_ct_DUMPBIN+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$STRIP"; then
-  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
+  if test -n "$ac_ct_DUMPBIN"; then
+  ac_cv_prog_ac_ct_DUMPBIN="$ac_ct_DUMPBIN" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
@@ -5810,7 +5568,7 @@ do
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
+    ac_cv_prog_ac_ct_DUMPBIN="$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
@@ -5820,57 +5578,21 @@ IFS=$as_save_IFS
 
 fi
 fi
-STRIP=$ac_cv_prog_STRIP
-if test -n "$STRIP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
-$as_echo "$STRIP" >&6; }
+ac_ct_DUMPBIN=$ac_cv_prog_ac_ct_DUMPBIN
+if test -n "$ac_ct_DUMPBIN"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DUMPBIN" >&5
+$as_echo "$ac_ct_DUMPBIN" >&6; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
 
-fi
-if test -z "$ac_cv_prog_STRIP"; then
-  ac_ct_STRIP=$STRIP
-  # Extract the first word of "strip", so it can be a program name with args.
-set dummy strip; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_STRIP"; then
-  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_STRIP="strip"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
+  test -n "$ac_ct_DUMPBIN" && break
 done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
-if test -n "$ac_ct_STRIP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
-$as_echo "$ac_ct_STRIP" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
 
-  if test "x$ac_ct_STRIP" = x; then
-    STRIP=":"
+  if test "x$ac_ct_DUMPBIN" = x; then
+    DUMPBIN=":"
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
@@ -5878,158 +5600,254 @@ yes:)
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
-    STRIP=$ac_ct_STRIP
+    DUMPBIN=$ac_ct_DUMPBIN
   fi
-else
-  STRIP="$ac_cv_prog_STRIP"
 fi
 
-test -z "$STRIP" && STRIP=:
+    case `$DUMPBIN -symbols /dev/null 2>&1 | sed '1q'` in
+    *COFF*)
+      DUMPBIN="$DUMPBIN -symbols"
+      ;;
+    *)
+      DUMPBIN=:
+      ;;
+    esac
+  fi
+
+  if test "$DUMPBIN" != ":"; then
+    NM="$DUMPBIN"
+  fi
+fi
+test -z "$NM" && NM=nm
 
 
 
 
 
 
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
-set dummy ${ac_tool_prefix}ranlib; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_RANLIB+set}" = set; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the name lister ($NM) interface" >&5
+$as_echo_n "checking the name lister ($NM) interface... " >&6; }
+if test "${lt_cv_nm_interface+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$RANLIB"; then
-  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
+  lt_cv_nm_interface="BSD nm"
+  echo "int some_variable = 0;" > conftest.$ac_ext
+  (eval echo "\"\$as_me:$LINENO: $ac_compile\"" >&5)
+  (eval "$ac_compile" 2>conftest.err)
+  cat conftest.err >&5
+  (eval echo "\"\$as_me:$LINENO: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
+  (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
+  cat conftest.err >&5
+  (eval echo "\"\$as_me:$LINENO: output\"" >&5)
+  cat conftest.out >&5
+  if $GREP 'External.*some_variable' conftest.out > /dev/null; then
+    lt_cv_nm_interface="MS dumpbin"
   fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-RANLIB=$ac_cv_prog_RANLIB
-if test -n "$RANLIB"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RANLIB" >&5
-$as_echo "$RANLIB" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
+  rm -f conftest*
 fi
-if test -z "$ac_cv_prog_RANLIB"; then
-  ac_ct_RANLIB=$RANLIB
-  # Extract the first word of "ranlib", so it can be a program name with args.
-set dummy ranlib; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_RANLIB"; then
-  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_RANLIB="ranlib"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_nm_interface" >&5
+$as_echo "$lt_cv_nm_interface" >&6; }
 
-fi
-fi
-ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
-if test -n "$ac_ct_RANLIB"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_RANLIB" >&5
-$as_echo "$ac_ct_RANLIB" >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ln -s works" >&5
+$as_echo_n "checking whether ln -s works... " >&6; }
+LN_S=$as_ln_s
+if test "$LN_S" = "ln -s"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no, using $LN_S" >&5
+$as_echo "no, using $LN_S" >&6; }
 fi
 
-  if test "x$ac_ct_RANLIB" = x; then
-    RANLIB=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    RANLIB=$ac_ct_RANLIB
-  fi
+# find the maximum length of command line arguments
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the maximum length of command line arguments" >&5
+$as_echo_n "checking the maximum length of command line arguments... " >&6; }
+if test "${lt_cv_sys_max_cmd_len+set}" = set; then :
+  $as_echo_n "(cached) " >&6
 else
-  RANLIB="$ac_cv_prog_RANLIB"
-fi
+    i=0
+  teststring="ABCD"
 
-test -z "$RANLIB" && RANLIB=:
+  case $build_os in
+  msdosdjgpp*)
+    # On DJGPP, this test can blow up pretty badly due to problems in libc
+    # (any single argument exceeding 2000 bytes causes a buffer overrun
+    # during glob expansion).  Even if it were fixed, the result of this
+    # check would be larger than it should be.
+    lt_cv_sys_max_cmd_len=12288;    # 12K is about right
+    ;;
 
+  gnu*)
+    # Under GNU Hurd, this test is not required because there is
+    # no limit to the length of command line arguments.
+    # Libtool will interpret -1 as no limit whatsoever
+    lt_cv_sys_max_cmd_len=-1;
+    ;;
 
+  cygwin* | mingw* | cegcc*)
+    # On Win9x/ME, this test blows up -- it succeeds, but takes
+    # about 5 minutes as the teststring grows exponentially.
+    # Worse, since 9x/ME are not pre-emptively multitasking,
+    # you end up with a "frozen" computer, even though with patience
+    # the test eventually succeeds (with a max line length of 256k).
+    # Instead, let's just punt: use the minimum linelength reported by
+    # all of the supported platforms: 8192 (on NT/2K/XP).
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
 
+  mint*)
+    # On MiNT this can take a long time and run out of memory.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
 
+  amigaos*)
+    # On AmigaOS with pdksh, this test takes hours, literally.
+    # So we just punt and use a minimum line length of 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
 
+  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
+    # This has been around since 386BSD, at least.  Likely further.
+    if test -x /sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`
+    elif test -x /usr/sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`
+    else
+      lt_cv_sys_max_cmd_len=65536	# usable default for all BSDs
+    fi
+    # And add a safety zone
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
+    ;;
 
-# Determine commands to create old-style static archives.
-old_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'
-old_postinstall_cmds='chmod 644 $oldlib'
-old_postuninstall_cmds=
+  interix*)
+    # We know the value 262144 and hardcode it with a safety zone (like BSD)
+    lt_cv_sys_max_cmd_len=196608
+    ;;
 
-if test -n "$RANLIB"; then
-  case $host_os in
-  openbsd*)
-    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB -t \$oldlib"
+  osf*)
+    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure
+    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not
+    # nice to cause kernel panics so lets avoid the loop below.
+    # First set a reasonable default.
+    lt_cv_sys_max_cmd_len=16384
+    #
+    if test -x /sbin/sysconfig; then
+      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in
+        *1*) lt_cv_sys_max_cmd_len=-1 ;;
+      esac
+    fi
+    ;;
+  sco3.2v5*)
+    lt_cv_sys_max_cmd_len=102400
+    ;;
+  sysv5* | sco5v6* | sysv4.2uw2*)
+    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`
+    if test -n "$kargmax"; then
+      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[	 ]//'`
+    else
+      lt_cv_sys_max_cmd_len=32768
+    fi
     ;;
   *)
-    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB \$oldlib"
+    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`
+    if test -n "$lt_cv_sys_max_cmd_len"; then
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
+    else
+      # Make teststring a little bigger before we do anything with it.
+      # a 1K string should be a reasonable start.
+      for i in 1 2 3 4 5 6 7 8 ; do
+        teststring=$teststring$teststring
+      done
+      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}
+      # If test is not a shell built-in, we'll probably end up computing a
+      # maximum length that is only half of the actual maximum length, but
+      # we can't tell.
+      while { test "X"`func_fallback_echo "$teststring$teststring" 2>/dev/null` \
+	         = "X$teststring$teststring"; } >/dev/null 2>&1 &&
+	      test $i != 17 # 1/2 MB should be enough
+      do
+        i=`expr $i + 1`
+        teststring=$teststring$teststring
+      done
+      # Only check the string length outside the loop.
+      lt_cv_sys_max_cmd_len=`expr "X$teststring" : ".*" 2>&1`
+      teststring=
+      # Add a significant safety factor because C++ compilers can tack on
+      # massive amounts of additional arguments before passing them to the
+      # linker.  It appears as though 1/2 is a usable value.
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 2`
+    fi
     ;;
   esac
-  old_archive_cmds="$old_archive_cmds~\$RANLIB \$oldlib"
-fi
 
-case $host_os in
-  darwin*)
-    lock_old_archive_extraction=yes ;;
-  *)
-    lock_old_archive_extraction=no ;;
-esac
+fi
 
+if test -n $lt_cv_sys_max_cmd_len ; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_sys_max_cmd_len" >&5
+$as_echo "$lt_cv_sys_max_cmd_len" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: none" >&5
+$as_echo "none" >&6; }
+fi
+max_cmd_len=$lt_cv_sys_max_cmd_len
 
 
 
 
 
 
+: ${CP="cp -f"}
+: ${MV="mv -f"}
+: ${RM="rm -f"}
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands some XSI constructs" >&5
+$as_echo_n "checking whether the shell understands some XSI constructs... " >&6; }
+# Try some XSI features
+xsi_shell=no
+( _lt_dummy="a/b/c"
+  test "${_lt_dummy##*/},${_lt_dummy%/*},"${_lt_dummy%"$_lt_dummy"}, \
+      = c,a/b,, \
+    && eval 'test $(( 1 + 1 )) -eq 2 \
+    && test "${#_lt_dummy}" -eq 5' ) >/dev/null 2>&1 \
+  && xsi_shell=yes
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $xsi_shell" >&5
+$as_echo "$xsi_shell" >&6; }
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands \"+=\"" >&5
+$as_echo_n "checking whether the shell understands \"+=\"... " >&6; }
+lt_shell_append=no
+( foo=bar; set foo baz; eval "$1+=\$2" && test "$foo" = barbaz ) \
+    >/dev/null 2>&1 \
+  && lt_shell_append=yes
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_shell_append" >&5
+$as_echo "$lt_shell_append" >&6; }
 
 
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  lt_unset=unset
+else
+  lt_unset=false
+fi
 
 
 
 
 
+# test EBCDIC or ASCII
+case `echo X|tr X '\101'` in
+ A) # ASCII based system
+    # \n is not interpreted correctly by Solaris 8 /usr/ucb/tr
+  lt_SP2NL='tr \040 \012'
+  lt_NL2SP='tr \015\012 \040\040'
+  ;;
+ *) # EBCDIC based system
+  lt_SP2NL='tr \100 \n'
+  lt_NL2SP='tr \r\n \100\100'
+  ;;
+esac
 
 
 
@@ -6039,6 +5857,30 @@ esac
 
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $LD option to reload object files" >&5
+$as_echo_n "checking for $LD option to reload object files... " >&6; }
+if test "${lt_cv_ld_reload_flag+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_ld_reload_flag='-r'
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_reload_flag" >&5
+$as_echo "$lt_cv_ld_reload_flag" >&6; }
+reload_flag=$lt_cv_ld_reload_flag
+case $reload_flag in
+"" | " "*) ;;
+*) reload_flag=" $reload_flag" ;;
+esac
+reload_cmds='$LD$reload_flag -o $output$reload_objs'
+case $host_os in
+  darwin*)
+    if test "$GCC" = yes; then
+      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'
+    else
+      reload_cmds='$LD$reload_flag -o $output$reload_objs'
+    fi
+    ;;
+esac
 
 
 
@@ -6048,255 +5890,314 @@ esac
 
 
 
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}objdump", so it can be a program name with args.
+set dummy ${ac_tool_prefix}objdump; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_OBJDUMP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$OBJDUMP"; then
+  ac_cv_prog_OBJDUMP="$OBJDUMP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_OBJDUMP="${ac_tool_prefix}objdump"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
 
+fi
+fi
+OBJDUMP=$ac_cv_prog_OBJDUMP
+if test -n "$OBJDUMP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OBJDUMP" >&5
+$as_echo "$OBJDUMP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
 
 
+fi
+if test -z "$ac_cv_prog_OBJDUMP"; then
+  ac_ct_OBJDUMP=$OBJDUMP
+  # Extract the first word of "objdump", so it can be a program name with args.
+set dummy objdump; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_OBJDUMP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_OBJDUMP"; then
+  ac_cv_prog_ac_ct_OBJDUMP="$ac_ct_OBJDUMP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_OBJDUMP="objdump"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
 
-# If no C compiler was specified, use CC.
-LTCC=${LTCC-"$CC"}
+fi
+fi
+ac_ct_OBJDUMP=$ac_cv_prog_ac_ct_OBJDUMP
+if test -n "$ac_ct_OBJDUMP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OBJDUMP" >&5
+$as_echo "$ac_ct_OBJDUMP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
 
-# If no C compiler flags were specified, use CFLAGS.
-LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
+  if test "x$ac_ct_OBJDUMP" = x; then
+    OBJDUMP="false"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    OBJDUMP=$ac_ct_OBJDUMP
+  fi
+else
+  OBJDUMP="$ac_cv_prog_OBJDUMP"
+fi
 
-# Allow CC to be a program name with arguments.
-compiler=$CC
+test -z "$OBJDUMP" && OBJDUMP=objdump
 
 
-# Check for command to grab the raw symbol name followed by C symbol from nm.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking command to parse $NM output from $compiler object" >&5
-$as_echo_n "checking command to parse $NM output from $compiler object... " >&6; }
-if test "${lt_cv_sys_global_symbol_pipe+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
 
-# These are sane defaults that work on at least a few old systems.
-# [They come from Ultrix.  What could be older than Ultrix?!! ;)]
 
-# Character class describing NM global symbol codes.
-symcode='[BCDEGRST]'
 
-# Regexp to match symbols that can be accessed directly from C.
-sympat='\([_A-Za-z][_A-Za-z0-9]*\)'
 
-# Define system-specific variables.
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to recognize dependent libraries" >&5
+$as_echo_n "checking how to recognize dependent libraries... " >&6; }
+if test "${lt_cv_deplibs_check_method+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_file_magic_cmd='$MAGIC_CMD'
+lt_cv_file_magic_test_file=
+lt_cv_deplibs_check_method='unknown'
+# Need to set the preceding variable on all platforms that support
+# interlibrary dependencies.
+# 'none' -- dependencies not supported.
+# `unknown' -- same as none, but documents that we really don't know.
+# 'pass_all' -- all dependencies passed with no checks.
+# 'test_compile' -- check by making test program.
+# 'file_magic [[regex]]' -- check by looking for files in library path
+# which responds to the $file_magic_cmd with a given extended regex.
+# If you have `file' or equivalent on your system and you're not sure
+# whether `pass_all' will *always* work, you probably want this one.
+
 case $host_os in
-aix*)
-  symcode='[BCDT]'
-  ;;
-cygwin* | mingw* | pw32* | cegcc*)
-  symcode='[ABCDGISTW]'
+aix[4-9]*)
+  lt_cv_deplibs_check_method=pass_all
   ;;
-hpux*)
-  if test "$host_cpu" = ia64; then
-    symcode='[ABCDEGRST]'
-  fi
+
+beos*)
+  lt_cv_deplibs_check_method=pass_all
   ;;
-irix* | nonstopux*)
-  symcode='[BCDEGRST]'
+
+bsdi[45]*)
+  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib)'
+  lt_cv_file_magic_cmd='/usr/bin/file -L'
+  lt_cv_file_magic_test_file=/shlib/libc.so
   ;;
-osf*)
-  symcode='[BCDEGQRST]'
+
+cygwin*)
+  # func_win32_libid is a shell function defined in ltmain.sh
+  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
+  lt_cv_file_magic_cmd='func_win32_libid'
   ;;
-solaris*)
-  symcode='[BDRT]'
+
+mingw* | pw32*)
+  # Base MSYS/MinGW do not provide the 'file' command needed by
+  # func_win32_libid shell function, so use a weaker test based on 'objdump',
+  # unless we find 'file', for example because we are cross-compiling.
+  # func_win32_libid assumes BSD nm, so disallow it if using MS dumpbin.
+  if ( test "$lt_cv_nm_interface" = "BSD nm" && file / ) >/dev/null 2>&1; then
+    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
+    lt_cv_file_magic_cmd='func_win32_libid'
+  else
+    lt_cv_deplibs_check_method='file_magic file format pei*-i386(.*architecture: i386)?'
+    lt_cv_file_magic_cmd='$OBJDUMP -f'
+  fi
   ;;
-sco3.2v5*)
-  symcode='[DT]'
+
+cegcc*)
+  # use the weaker test based on 'objdump'. See mingw*.
+  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'
+  lt_cv_file_magic_cmd='$OBJDUMP -f'
   ;;
-sysv4.2uw2*)
-  symcode='[DT]'
+
+darwin* | rhapsody*)
+  lt_cv_deplibs_check_method=pass_all
   ;;
-sysv5* | sco5v6* | unixware* | OpenUNIX*)
-  symcode='[ABDT]'
+
+freebsd* | dragonfly*)
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+    case $host_cpu in
+    i*86 )
+      # Not sure whether the presence of OpenBSD here was a mistake.
+      # Let's accept both of them until this is cleared up.
+      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[3-9]86 (compact )?demand paged shared library'
+      lt_cv_file_magic_cmd=/usr/bin/file
+      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`
+      ;;
+    esac
+  else
+    lt_cv_deplibs_check_method=pass_all
+  fi
   ;;
-sysv4)
-  symcode='[DFNSTU]'
+
+gnu*)
+  lt_cv_deplibs_check_method=pass_all
   ;;
-esac
 
-# If we're using GNU nm, then use its standard symbol codes.
-case `$NM -V 2>&1` in
-*GNU* | *'with BFD'*)
-  symcode='[ABCDGIRSTW]' ;;
-esac
+haiku*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
 
-# Transform an extracted symbol line into a proper C declaration.
-# Some systems (esp. on ia64) link data and code symbols differently,
-# so use this general approach.
-lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern int \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
-
-# Transform an extracted symbol line into symbol name and symbol address
-lt_cv_sys_global_symbol_to_c_name_address="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"\2\", (void *) \&\2},/p'"
-lt_cv_sys_global_symbol_to_c_name_address_lib_prefix="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \(lib[^ ]*\)$/  {\"\2\", (void *) \&\2},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"lib\2\", (void *) \&\2},/p'"
+hpux10.20* | hpux11*)
+  lt_cv_file_magic_cmd=/usr/bin/file
+  case $host_cpu in
+  ia64*)
+    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF-[0-9][0-9]) shared object file - IA64'
+    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so
+    ;;
+  hppa*64*)
+    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF[ -][0-9][0-9])(-bit)?( [LM]SB)? shared object( file)?[, -]* PA-RISC [0-9]\.[0-9]'
+    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl
+    ;;
+  *)
+    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|PA-RISC[0-9]\.[0-9]) shared library'
+    lt_cv_file_magic_test_file=/usr/lib/libc.sl
+    ;;
+  esac
+  ;;
 
-# Handle CRLF in mingw tool chain
-opt_cr=
-case $build_os in
-mingw*)
-  opt_cr=`$ECHO 'x\{0,1\}' | tr x '\015'` # option cr in regexp
+interix[3-9]*)
+  # PIC code is broken on Interix 3.x, that's why |\.a not |_pic\.a here
+  lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so|\.a)$'
   ;;
-esac
 
-# Try without a prefix underscore, then with it.
-for ac_symprfx in "" "_"; do
+irix5* | irix6* | nonstopux*)
+  case $LD in
+  *-32|*"-32 ") libmagic=32-bit;;
+  *-n32|*"-n32 ") libmagic=N32;;
+  *-64|*"-64 ") libmagic=64-bit;;
+  *) libmagic=never-match;;
+  esac
+  lt_cv_deplibs_check_method=pass_all
+  ;;
 
-  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.
-  symxfrm="\\1 $ac_symprfx\\2 \\2"
+# This must be Linux ELF.
+linux* | k*bsd*-gnu | kopensolaris*-gnu)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
 
-  # Write the raw and C identifiers.
-  if test "$lt_cv_nm_interface" = "MS dumpbin"; then
-    # Fake it for dumpbin and say T for any non-static function
-    # and D for any global variable.
-    # Also find C++ and __fastcall symbols from MSVC++,
-    # which start with @ or ?.
-    lt_cv_sys_global_symbol_pipe="$AWK '"\
-"     {last_section=section; section=\$ 3};"\
-"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};"\
-"     \$ 0!~/External *\|/{next};"\
-"     / 0+ UNDEF /{next}; / UNDEF \([^|]\)*()/{next};"\
-"     {if(hide[section]) next};"\
-"     {f=0}; \$ 0~/\(\).*\|/{f=1}; {printf f ? \"T \" : \"D \"};"\
-"     {split(\$ 0, a, /\||\r/); split(a[2], s)};"\
-"     s[1]~/^[@?]/{print s[1], s[1]; next};"\
-"     s[1]~prfx {split(s[1],t,\"@\"); print t[1], substr(t[1],length(prfx))}"\
-"     ' prfx=^$ac_symprfx"
+netbsd*)
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
   else
-    lt_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[	 ]\($symcode$symcode*\)[	 ][	 ]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'"
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so|_pic\.a)$'
   fi
+  ;;
 
-  # Check to see that the pipe works correctly.
-  pipe_works=no
-
-  rm -f conftest*
-  cat > conftest.$ac_ext <<_LT_EOF
-#ifdef __cplusplus
-extern "C" {
-#endif
-char nm_test_var;
-void nm_test_func(void);
-void nm_test_func(void){}
-#ifdef __cplusplus
-}
-#endif
-int main(){nm_test_var='a';nm_test_func();return(0);}
-_LT_EOF
-
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    # Now try to grab the symbols.
-    nlist=conftest.nm
-    if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$NM conftest.$ac_objext \| "$lt_cv_sys_global_symbol_pipe" \> $nlist\""; } >&5
-  (eval $NM conftest.$ac_objext \| "$lt_cv_sys_global_symbol_pipe" \> $nlist) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && test -s "$nlist"; then
-      # Try sorting and uniquifying the output.
-      if sort "$nlist" | uniq > "$nlist"T; then
-	mv -f "$nlist"T "$nlist"
-      else
-	rm -f "$nlist"T
-      fi
-
-      # Make sure that we snagged all the symbols we need.
-      if $GREP ' nm_test_var$' "$nlist" >/dev/null; then
-	if $GREP ' nm_test_func$' "$nlist" >/dev/null; then
-	  cat <<_LT_EOF > conftest.$ac_ext
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-_LT_EOF
-	  # Now generate the symbol file.
-	  eval "$lt_cv_sys_global_symbol_to_cdecl"' < "$nlist" | $GREP -v main >> conftest.$ac_ext'
-
-	  cat <<_LT_EOF >> conftest.$ac_ext
-
-/* The mapping between symbol names and symbols.  */
-const struct {
-  const char *name;
-  void       *address;
-}
-lt__PROGRAM__LTX_preloaded_symbols[] =
-{
-  { "@PROGRAM@", (void *) 0 },
-_LT_EOF
-	  $SED "s/^$symcode$symcode* \(.*\) \(.*\)$/  {\"\2\", (void *) \&\2},/" < "$nlist" | $GREP -v main >> conftest.$ac_ext
-	  cat <<\_LT_EOF >> conftest.$ac_ext
-  {0, (void *) 0}
-};
-
-/* This works around a problem in FreeBSD linker */
-#ifdef FREEBSD_WORKAROUND
-static const void *lt_preloaded_setup() {
-  return lt__PROGRAM__LTX_preloaded_symbols;
-}
-#endif
+newos6*)
+  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (executable|dynamic lib)'
+  lt_cv_file_magic_cmd=/usr/bin/file
+  lt_cv_file_magic_test_file=/usr/lib/libnls.so
+  ;;
 
-#ifdef __cplusplus
-}
-#endif
-_LT_EOF
-	  # Now try linking the two files.
-	  mv conftest.$ac_objext conftstm.$ac_objext
-	  lt_save_LIBS="$LIBS"
-	  lt_save_CFLAGS="$CFLAGS"
-	  LIBS="conftstm.$ac_objext"
-	  CFLAGS="$CFLAGS$lt_prog_compiler_no_builtin_flag"
-	  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && test -s conftest${ac_exeext}; then
-	    pipe_works=yes
-	  fi
-	  LIBS="$lt_save_LIBS"
-	  CFLAGS="$lt_save_CFLAGS"
-	else
-	  echo "cannot find nm_test_func in $nlist" >&5
-	fi
-      else
-	echo "cannot find nm_test_var in $nlist" >&5
-      fi
-    else
-      echo "cannot run $lt_cv_sys_global_symbol_pipe" >&5
-    fi
-  else
-    echo "$progname: failed program was:" >&5
-    cat conftest.$ac_ext >&5
-  fi
-  rm -rf conftest* conftst*
+*nto* | *qnx*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
 
-  # Do not use the global_symbol_pipe unless it works.
-  if test "$pipe_works" = yes; then
-    break
+openbsd*)
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|\.so|_pic\.a)$'
   else
-    lt_cv_sys_global_symbol_pipe=
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
   fi
-done
-
-fi
-
-if test -z "$lt_cv_sys_global_symbol_pipe"; then
-  lt_cv_sys_global_symbol_to_cdecl=
-fi
-if test -z "$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: failed" >&5
-$as_echo "failed" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: ok" >&5
-$as_echo "ok" >&6; }
-fi
-
+  ;;
 
+osf3* | osf4* | osf5*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
 
+rdos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
 
+solaris*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
 
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
 
+sysv4 | sysv4.3*)
+  case $host_vendor in
+  motorola)
+    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib) M[0-9][0-9]* Version [0-9]'
+    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`
+    ;;
+  ncr)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  sequent)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )'
+    ;;
+  sni)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method="file_magic ELF [0-9][0-9]*-bit [LM]SB dynamic lib"
+    lt_cv_file_magic_test_file=/lib/libc.so
+    ;;
+  siemens)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  pc)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  esac
+  ;;
 
+tpf*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+esac
 
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_deplibs_check_method" >&5
+$as_echo "$lt_cv_deplibs_check_method" >&6; }
+file_magic_cmd=$lt_cv_file_magic_cmd
+deplibs_check_method=$lt_cv_deplibs_check_method
+test -z "$deplibs_check_method" && deplibs_check_method=unknown
 
 
 
@@ -6309,221 +6210,16 @@ fi
 
 
 
-
-
-# Check whether --enable-libtool-lock was given.
-if test "${enable_libtool_lock+set}" = set; then :
-  enableval=$enable_libtool_lock;
-fi
-
-test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
-
-# Some flags need to be propagated to the compiler or linker for good
-# libtool support.
-case $host in
-ia64-*-hpux*)
-  # Find out which ABI we are using.
-  echo 'int i;' > conftest.$ac_ext
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    case `/usr/bin/file conftest.$ac_objext` in
-      *ELF-32*)
-	HPUX_IA64_MODE="32"
-	;;
-      *ELF-64*)
-	HPUX_IA64_MODE="64"
-	;;
-    esac
-  fi
-  rm -rf conftest*
-  ;;
-*-*-irix6*)
-  # Find out which ABI we are using.
-  echo '#line '$LINENO' "configure"' > conftest.$ac_ext
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    if test "$lt_cv_prog_gnu_ld" = yes; then
-      case `/usr/bin/file conftest.$ac_objext` in
-	*32-bit*)
-	  LD="${LD-ld} -melf32bsmip"
-	  ;;
-	*N32*)
-	  LD="${LD-ld} -melf32bmipn32"
-	  ;;
-	*64-bit*)
-	  LD="${LD-ld} -melf64bmip"
-	;;
-      esac
-    else
-      case `/usr/bin/file conftest.$ac_objext` in
-	*32-bit*)
-	  LD="${LD-ld} -32"
-	  ;;
-	*N32*)
-	  LD="${LD-ld} -n32"
-	  ;;
-	*64-bit*)
-	  LD="${LD-ld} -64"
-	  ;;
-      esac
-    fi
-  fi
-  rm -rf conftest*
-  ;;
-
-x86_64-*kfreebsd*-gnu|x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*| \
-s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
-  # Find out which ABI we are using.
-  echo 'int i;' > conftest.$ac_ext
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    case `/usr/bin/file conftest.o` in
-      *32-bit*)
-	case $host in
-	  x86_64-*kfreebsd*-gnu)
-	    LD="${LD-ld} -m elf_i386_fbsd"
-	    ;;
-	  x86_64-*linux*)
-	    case `/usr/bin/file conftest.o` in
-	      *x86-64*)
-		LD="${LD-ld} -m elf32_x86_64"
-		;;
-	      *)
-		LD="${LD-ld} -m elf_i386"
-		;;
-	    esac
-	    ;;
-	  ppc64-*linux*|powerpc64-*linux*)
-	    LD="${LD-ld} -m elf32ppclinux"
-	    ;;
-	  s390x-*linux*)
-	    LD="${LD-ld} -m elf_s390"
-	    ;;
-	  sparc64-*linux*)
-	    LD="${LD-ld} -m elf32_sparc"
-	    ;;
-	esac
-	;;
-      *64-bit*)
-	case $host in
-	  x86_64-*kfreebsd*-gnu)
-	    LD="${LD-ld} -m elf_x86_64_fbsd"
-	    ;;
-	  x86_64-*linux*)
-	    LD="${LD-ld} -m elf_x86_64"
-	    ;;
-	  ppc*-*linux*|powerpc*-*linux*)
-	    LD="${LD-ld} -m elf64ppc"
-	    ;;
-	  s390*-*linux*|s390*-*tpf*)
-	    LD="${LD-ld} -m elf64_s390"
-	    ;;
-	  sparc*-*linux*)
-	    LD="${LD-ld} -m elf64_sparc"
-	    ;;
-	esac
-	;;
-    esac
-  fi
-  rm -rf conftest*
-  ;;
-
-*-*-sco3.2v5*)
-  # On SCO OpenServer 5, we need -belf to get full-featured binaries.
-  SAVE_CFLAGS="$CFLAGS"
-  CFLAGS="$CFLAGS -belf"
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler needs -belf" >&5
-$as_echo_n "checking whether the C compiler needs -belf... " >&6; }
-if test "${lt_cv_cc_needs_belf+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  lt_cv_cc_needs_belf=yes
-else
-  lt_cv_cc_needs_belf=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-     ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_cc_needs_belf" >&5
-$as_echo "$lt_cv_cc_needs_belf" >&6; }
-  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
-    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
-    CFLAGS="$SAVE_CFLAGS"
-  fi
-  ;;
-sparc*-*solaris*)
-  # Find out which ABI we are using.
-  echo 'int i;' > conftest.$ac_ext
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    case `/usr/bin/file conftest.o` in
-    *64-bit*)
-      case $lt_cv_prog_gnu_ld in
-      yes*) LD="${LD-ld} -m elf64_sparc" ;;
-      *)
-	if ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then
-	  LD="${LD-ld} -64"
-	fi
-	;;
-      esac
-      ;;
-    esac
-  fi
-  rm -rf conftest*
-  ;;
-esac
-
-need_locks="$enable_libtool_lock"
-
-
-  case $host_os in
-    rhapsody* | darwin*)
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}dsymutil", so it can be a program name with args.
-set dummy ${ac_tool_prefix}dsymutil; ac_word=$2
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ar", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ar; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_DSYMUTIL+set}" = set; then :
+if test "${ac_cv_prog_AR+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$DSYMUTIL"; then
-  ac_cv_prog_DSYMUTIL="$DSYMUTIL" # Let the user override the test.
+  if test -n "$AR"; then
+  ac_cv_prog_AR="$AR" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
@@ -6532,7 +6228,7 @@ do
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_DSYMUTIL="${ac_tool_prefix}dsymutil"
+    ac_cv_prog_AR="${ac_tool_prefix}ar"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
@@ -6542,10 +6238,10 @@ IFS=$as_save_IFS
 
 fi
 fi
-DSYMUTIL=$ac_cv_prog_DSYMUTIL
-if test -n "$DSYMUTIL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DSYMUTIL" >&5
-$as_echo "$DSYMUTIL" >&6; }
+AR=$ac_cv_prog_AR
+if test -n "$AR"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AR" >&5
+$as_echo "$AR" >&6; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
@@ -6553,17 +6249,17 @@ fi
 
 
 fi
-if test -z "$ac_cv_prog_DSYMUTIL"; then
-  ac_ct_DSYMUTIL=$DSYMUTIL
-  # Extract the first word of "dsymutil", so it can be a program name with args.
-set dummy dsymutil; ac_word=$2
+if test -z "$ac_cv_prog_AR"; then
+  ac_ct_AR=$AR
+  # Extract the first word of "ar", so it can be a program name with args.
+set dummy ar; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_DSYMUTIL+set}" = set; then :
+if test "${ac_cv_prog_ac_ct_AR+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$ac_ct_DSYMUTIL"; then
-  ac_cv_prog_ac_ct_DSYMUTIL="$ac_ct_DSYMUTIL" # Let the user override the test.
+  if test -n "$ac_ct_AR"; then
+  ac_cv_prog_ac_ct_AR="$ac_ct_AR" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
@@ -6572,7 +6268,7 @@ do
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_DSYMUTIL="dsymutil"
+    ac_cv_prog_ac_ct_AR="ar"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
@@ -6582,17 +6278,17 @@ IFS=$as_save_IFS
 
 fi
 fi
-ac_ct_DSYMUTIL=$ac_cv_prog_ac_ct_DSYMUTIL
-if test -n "$ac_ct_DSYMUTIL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DSYMUTIL" >&5
-$as_echo "$ac_ct_DSYMUTIL" >&6; }
+ac_ct_AR=$ac_cv_prog_ac_ct_AR
+if test -n "$ac_ct_AR"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_AR" >&5
+$as_echo "$ac_ct_AR" >&6; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
-  if test "x$ac_ct_DSYMUTIL" = x; then
-    DSYMUTIL=":"
+  if test "x$ac_ct_AR" = x; then
+    AR="false"
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
@@ -6600,114 +6296,35 @@ yes:)
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
-    DSYMUTIL=$ac_ct_DSYMUTIL
+    AR=$ac_ct_AR
   fi
 else
-  DSYMUTIL="$ac_cv_prog_DSYMUTIL"
+  AR="$ac_cv_prog_AR"
 fi
 
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}nmedit", so it can be a program name with args.
-set dummy ${ac_tool_prefix}nmedit; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_NMEDIT+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$NMEDIT"; then
-  ac_cv_prog_NMEDIT="$NMEDIT" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_NMEDIT="${ac_tool_prefix}nmedit"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
+test -z "$AR" && AR=ar
+test -z "$AR_FLAGS" && AR_FLAGS=cru
 
-fi
-fi
-NMEDIT=$ac_cv_prog_NMEDIT
-if test -n "$NMEDIT"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $NMEDIT" >&5
-$as_echo "$NMEDIT" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
 
 
-fi
-if test -z "$ac_cv_prog_NMEDIT"; then
-  ac_ct_NMEDIT=$NMEDIT
-  # Extract the first word of "nmedit", so it can be a program name with args.
-set dummy nmedit; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_NMEDIT+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_NMEDIT"; then
-  ac_cv_prog_ac_ct_NMEDIT="$ac_ct_NMEDIT" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_NMEDIT="nmedit"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
 
-fi
-fi
-ac_ct_NMEDIT=$ac_cv_prog_ac_ct_NMEDIT
-if test -n "$ac_ct_NMEDIT"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_NMEDIT" >&5
-$as_echo "$ac_ct_NMEDIT" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
 
-  if test "x$ac_ct_NMEDIT" = x; then
-    NMEDIT=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    NMEDIT=$ac_ct_NMEDIT
-  fi
-else
-  NMEDIT="$ac_cv_prog_NMEDIT"
-fi
 
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}lipo", so it can be a program name with args.
-set dummy ${ac_tool_prefix}lipo; ac_word=$2
+
+
+
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
+set dummy ${ac_tool_prefix}strip; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_LIPO+set}" = set; then :
+if test "${ac_cv_prog_STRIP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$LIPO"; then
-  ac_cv_prog_LIPO="$LIPO" # Let the user override the test.
+  if test -n "$STRIP"; then
+  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
@@ -6716,7 +6333,7 @@ do
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_LIPO="${ac_tool_prefix}lipo"
+    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
@@ -6726,10 +6343,10 @@ IFS=$as_save_IFS
 
 fi
 fi
-LIPO=$ac_cv_prog_LIPO
-if test -n "$LIPO"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LIPO" >&5
-$as_echo "$LIPO" >&6; }
+STRIP=$ac_cv_prog_STRIP
+if test -n "$STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
+$as_echo "$STRIP" >&6; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
@@ -6737,17 +6354,17 @@ fi
 
 
 fi
-if test -z "$ac_cv_prog_LIPO"; then
-  ac_ct_LIPO=$LIPO
-  # Extract the first word of "lipo", so it can be a program name with args.
-set dummy lipo; ac_word=$2
+if test -z "$ac_cv_prog_STRIP"; then
+  ac_ct_STRIP=$STRIP
+  # Extract the first word of "strip", so it can be a program name with args.
+set dummy strip; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_LIPO+set}" = set; then :
+if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$ac_ct_LIPO"; then
-  ac_cv_prog_ac_ct_LIPO="$ac_ct_LIPO" # Let the user override the test.
+  if test -n "$ac_ct_STRIP"; then
+  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
@@ -6756,7 +6373,7 @@ do
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_LIPO="lipo"
+    ac_cv_prog_ac_ct_STRIP="strip"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
@@ -6766,17 +6383,17 @@ IFS=$as_save_IFS
 
 fi
 fi
-ac_ct_LIPO=$ac_cv_prog_ac_ct_LIPO
-if test -n "$ac_ct_LIPO"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_LIPO" >&5
-$as_echo "$ac_ct_LIPO" >&6; }
+ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
+if test -n "$ac_ct_STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
+$as_echo "$ac_ct_STRIP" >&6; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
-  if test "x$ac_ct_LIPO" = x; then
-    LIPO=":"
+  if test "x$ac_ct_STRIP" = x; then
+    STRIP=":"
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
@@ -6784,22 +6401,29 @@ yes:)
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
-    LIPO=$ac_ct_LIPO
+    STRIP=$ac_ct_STRIP
   fi
 else
-  LIPO="$ac_cv_prog_LIPO"
+  STRIP="$ac_cv_prog_STRIP"
 fi
 
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}otool", so it can be a program name with args.
-set dummy ${ac_tool_prefix}otool; ac_word=$2
+test -z "$STRIP" && STRIP=:
+
+
+
+
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ranlib; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_OTOOL+set}" = set; then :
+if test "${ac_cv_prog_RANLIB+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$OTOOL"; then
-  ac_cv_prog_OTOOL="$OTOOL" # Let the user override the test.
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
@@ -6808,7 +6432,7 @@ do
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_OTOOL="${ac_tool_prefix}otool"
+    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
@@ -6818,10 +6442,10 @@ IFS=$as_save_IFS
 
 fi
 fi
-OTOOL=$ac_cv_prog_OTOOL
-if test -n "$OTOOL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OTOOL" >&5
-$as_echo "$OTOOL" >&6; }
+RANLIB=$ac_cv_prog_RANLIB
+if test -n "$RANLIB"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RANLIB" >&5
+$as_echo "$RANLIB" >&6; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
@@ -6829,17 +6453,17 @@ fi
 
 
 fi
-if test -z "$ac_cv_prog_OTOOL"; then
-  ac_ct_OTOOL=$OTOOL
-  # Extract the first word of "otool", so it can be a program name with args.
-set dummy otool; ac_word=$2
+if test -z "$ac_cv_prog_RANLIB"; then
+  ac_ct_RANLIB=$RANLIB
+  # Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_OTOOL+set}" = set; then :
+if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$ac_ct_OTOOL"; then
-  ac_cv_prog_ac_ct_OTOOL="$ac_ct_OTOOL" # Let the user override the test.
+  if test -n "$ac_ct_RANLIB"; then
+  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
@@ -6848,7 +6472,7 @@ do
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_OTOOL="otool"
+    ac_cv_prog_ac_ct_RANLIB="ranlib"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
@@ -6858,17 +6482,17 @@ IFS=$as_save_IFS
 
 fi
 fi
-ac_ct_OTOOL=$ac_cv_prog_ac_ct_OTOOL
-if test -n "$ac_ct_OTOOL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL" >&5
-$as_echo "$ac_ct_OTOOL" >&6; }
+ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
+if test -n "$ac_ct_RANLIB"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_RANLIB" >&5
+$as_echo "$ac_ct_RANLIB" >&6; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
-  if test "x$ac_ct_OTOOL" = x; then
-    OTOOL=":"
+  if test "x$ac_ct_RANLIB" = x; then
+    RANLIB=":"
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
@@ -6876,110 +6500,42 @@ yes:)
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
-    OTOOL=$ac_ct_OTOOL
+    RANLIB=$ac_ct_RANLIB
   fi
 else
-  OTOOL="$ac_cv_prog_OTOOL"
+  RANLIB="$ac_cv_prog_RANLIB"
 fi
 
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}otool64", so it can be a program name with args.
-set dummy ${ac_tool_prefix}otool64; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_OTOOL64+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$OTOOL64"; then
-  ac_cv_prog_OTOOL64="$OTOOL64" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_OTOOL64="${ac_tool_prefix}otool64"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
+test -z "$RANLIB" && RANLIB=:
 
-fi
-fi
-OTOOL64=$ac_cv_prog_OTOOL64
-if test -n "$OTOOL64"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OTOOL64" >&5
-$as_echo "$OTOOL64" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_OTOOL64"; then
-  ac_ct_OTOOL64=$OTOOL64
-  # Extract the first word of "otool64", so it can be a program name with args.
-set dummy otool64; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_OTOOL64+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_OTOOL64"; then
-  ac_cv_prog_ac_ct_OTOOL64="$ac_ct_OTOOL64" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_OTOOL64="otool64"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_OTOOL64=$ac_cv_prog_ac_ct_OTOOL64
-if test -n "$ac_ct_OTOOL64"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL64" >&5
-$as_echo "$ac_ct_OTOOL64" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_OTOOL64" = x; then
-    OTOOL64=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    OTOOL64=$ac_ct_OTOOL64
-  fi
-else
-  OTOOL64="$ac_cv_prog_OTOOL64"
-fi
 
 
 
 
 
+# Determine commands to create old-style static archives.
+old_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'
+old_postinstall_cmds='chmod 644 $oldlib'
+old_postuninstall_cmds=
 
+if test -n "$RANLIB"; then
+  case $host_os in
+  openbsd*)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB -t \$oldlib"
+    ;;
+  *)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB \$oldlib"
+    ;;
+  esac
+  old_archive_cmds="$old_archive_cmds~\$RANLIB \$oldlib"
+fi
 
+case $host_os in
+  darwin*)
+    lock_old_archive_extraction=yes ;;
+  *)
+    lock_old_archive_extraction=no ;;
+esac
 
 
 
@@ -7000,257 +6556,261 @@ fi
 
 
 
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -single_module linker flag" >&5
-$as_echo_n "checking for -single_module linker flag... " >&6; }
-if test "${lt_cv_apple_cc_single_mod+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_apple_cc_single_mod=no
-      if test -z "${LT_MULTI_MODULE}"; then
-	# By default we will add the -single_module flag. You can override
-	# by either setting the environment variable LT_MULTI_MODULE
-	# non-empty at configure time, or by adding -multi_module to the
-	# link flags.
-	rm -rf libconftest.dylib*
-	echo "int foo(void){return 1;}" > conftest.c
-	echo "$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
--dynamiclib -Wl,-single_module conftest.c" >&5
-	$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
-	  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err
-        _lt_result=$?
-	if test -f libconftest.dylib && test ! -s conftest.err && test $_lt_result = 0; then
-	  lt_cv_apple_cc_single_mod=yes
-	else
-	  cat conftest.err >&5
-	fi
-	rm -rf libconftest.dylib*
-	rm -f conftest.*
-      fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_apple_cc_single_mod" >&5
-$as_echo "$lt_cv_apple_cc_single_mod" >&6; }
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -exported_symbols_list linker flag" >&5
-$as_echo_n "checking for -exported_symbols_list linker flag... " >&6; }
-if test "${lt_cv_ld_exported_symbols_list+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_ld_exported_symbols_list=no
-      save_LDFLAGS=$LDFLAGS
-      echo "_main" > conftest.sym
-      LDFLAGS="$LDFLAGS -Wl,-exported_symbols_list,conftest.sym"
-      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
 
-int
-main ()
-{
 
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  lt_cv_ld_exported_symbols_list=yes
-else
-  lt_cv_ld_exported_symbols_list=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-	LDFLAGS="$save_LDFLAGS"
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_exported_symbols_list" >&5
-$as_echo "$lt_cv_ld_exported_symbols_list" >&6; }
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -force_load linker flag" >&5
-$as_echo_n "checking for -force_load linker flag... " >&6; }
-if test "${lt_cv_ld_force_load+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_ld_force_load=no
-      cat > conftest.c << _LT_EOF
-int forced_loaded() { return 2;}
-_LT_EOF
-      echo "$LTCC $LTCFLAGS -c -o conftest.o conftest.c" >&5
-      $LTCC $LTCFLAGS -c -o conftest.o conftest.c 2>&5
-      echo "$AR cru libconftest.a conftest.o" >&5
-      $AR cru libconftest.a conftest.o 2>&5
-      cat > conftest.c << _LT_EOF
-int main() { return 0;}
-_LT_EOF
-      echo "$LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a" >&5
-      $LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a 2>conftest.err
-      _lt_result=$?
-      if test -f conftest && test ! -s conftest.err && test $_lt_result = 0 && $GREP forced_load conftest 2>&1 >/dev/null; then
-	lt_cv_ld_force_load=yes
-      else
-	cat conftest.err >&5
-      fi
-        rm -f conftest.err libconftest.a conftest conftest.c
-        rm -rf conftest.dSYM
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_force_load" >&5
-$as_echo "$lt_cv_ld_force_load" >&6; }
-    case $host_os in
-    rhapsody* | darwin1.[012])
-      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;
-    darwin1.*)
-      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
-    darwin*) # darwin 5.x on
-      # if running on 10.5 or later, the deployment target defaults
-      # to the OS version, if on x86, and 10.4, the deployment
-      # target defaults to 10.4. Don't you love it?
-      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in
-	10.0,*86*-darwin8*|10.0,*-darwin[91]*)
-	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
-	10.[012]*)
-	  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
-	10.*)
-	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
-      esac
-    ;;
-  esac
-    if test "$lt_cv_apple_cc_single_mod" = "yes"; then
-      _lt_dar_single_mod='$single_module'
-    fi
-    if test "$lt_cv_ld_exported_symbols_list" = "yes"; then
-      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
-    else
-      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'
-    fi
-    if test "$DSYMUTIL" != ":" && test "$lt_cv_ld_force_load" = "no"; then
-      _lt_dsymutil='~$DSYMUTIL $lib || :'
-    else
-      _lt_dsymutil=
-    fi
-    ;;
-  esac
 
-for ac_header in dlfcn.h
-do :
-  ac_fn_c_check_header_compile "$LINENO" "dlfcn.h" "ac_cv_header_dlfcn_h" "$ac_includes_default
-"
-if test "x$ac_cv_header_dlfcn_h" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_DLFCN_H 1
-_ACEOF
 
-fi
 
-done
 
 
 
 
 
-# Set options
 
 
 
 
-  enable_win32_dll=no
 
 
-            # Check whether --enable-shared was given.
-if test "${enable_shared+set}" = set; then :
-  enableval=$enable_shared; p=${PACKAGE-default}
-    case $enableval in
-    yes) enable_shared=yes ;;
-    no) enable_shared=no ;;
-    *)
-      enable_shared=no
-      # Look at the argument we got.  We use all the common list separators.
-      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
-      for pkg in $enableval; do
-	IFS="$lt_save_ifs"
-	if test "X$pkg" = "X$p"; then
-	  enable_shared=yes
-	fi
-      done
-      IFS="$lt_save_ifs"
-      ;;
-    esac
-else
-  enable_shared=yes
-fi
 
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
 
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
 
+# Allow CC to be a program name with arguments.
+compiler=$CC
 
 
+# Check for command to grab the raw symbol name followed by C symbol from nm.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking command to parse $NM output from $compiler object" >&5
+$as_echo_n "checking command to parse $NM output from $compiler object... " >&6; }
+if test "${lt_cv_sys_global_symbol_pipe+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
 
+# These are sane defaults that work on at least a few old systems.
+# [They come from Ultrix.  What could be older than Ultrix?!! ;)]
 
+# Character class describing NM global symbol codes.
+symcode='[BCDEGRST]'
 
+# Regexp to match symbols that can be accessed directly from C.
+sympat='\([_A-Za-z][_A-Za-z0-9]*\)'
 
-  # Check whether --enable-static was given.
-if test "${enable_static+set}" = set; then :
-  enableval=$enable_static; p=${PACKAGE-default}
-    case $enableval in
-    yes) enable_static=yes ;;
-    no) enable_static=no ;;
-    *)
-     enable_static=no
-      # Look at the argument we got.  We use all the common list separators.
-      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
-      for pkg in $enableval; do
-	IFS="$lt_save_ifs"
-	if test "X$pkg" = "X$p"; then
-	  enable_static=yes
-	fi
-      done
-      IFS="$lt_save_ifs"
-      ;;
-    esac
-else
-  enable_static=yes
-fi
+# Define system-specific variables.
+case $host_os in
+aix*)
+  symcode='[BCDT]'
+  ;;
+cygwin* | mingw* | pw32* | cegcc*)
+  symcode='[ABCDGISTW]'
+  ;;
+hpux*)
+  if test "$host_cpu" = ia64; then
+    symcode='[ABCDEGRST]'
+  fi
+  ;;
+irix* | nonstopux*)
+  symcode='[BCDEGRST]'
+  ;;
+osf*)
+  symcode='[BCDEGQRST]'
+  ;;
+solaris*)
+  symcode='[BDRT]'
+  ;;
+sco3.2v5*)
+  symcode='[DT]'
+  ;;
+sysv4.2uw2*)
+  symcode='[DT]'
+  ;;
+sysv5* | sco5v6* | unixware* | OpenUNIX*)
+  symcode='[ABDT]'
+  ;;
+sysv4)
+  symcode='[DFNSTU]'
+  ;;
+esac
 
+# If we're using GNU nm, then use its standard symbol codes.
+case `$NM -V 2>&1` in
+*GNU* | *'with BFD'*)
+  symcode='[ABCDGIRSTW]' ;;
+esac
 
+# Transform an extracted symbol line into a proper C declaration.
+# Some systems (esp. on ia64) link data and code symbols differently,
+# so use this general approach.
+lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern int \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
 
+# Transform an extracted symbol line into symbol name and symbol address
+lt_cv_sys_global_symbol_to_c_name_address="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"\2\", (void *) \&\2},/p'"
+lt_cv_sys_global_symbol_to_c_name_address_lib_prefix="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \(lib[^ ]*\)$/  {\"\2\", (void *) \&\2},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"lib\2\", (void *) \&\2},/p'"
 
+# Handle CRLF in mingw tool chain
+opt_cr=
+case $build_os in
+mingw*)
+  opt_cr=`$ECHO 'x\{0,1\}' | tr x '\015'` # option cr in regexp
+  ;;
+esac
 
+# Try without a prefix underscore, then with it.
+for ac_symprfx in "" "_"; do
 
+  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.
+  symxfrm="\\1 $ac_symprfx\\2 \\2"
 
+  # Write the raw and C identifiers.
+  if test "$lt_cv_nm_interface" = "MS dumpbin"; then
+    # Fake it for dumpbin and say T for any non-static function
+    # and D for any global variable.
+    # Also find C++ and __fastcall symbols from MSVC++,
+    # which start with @ or ?.
+    lt_cv_sys_global_symbol_pipe="$AWK '"\
+"     {last_section=section; section=\$ 3};"\
+"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};"\
+"     \$ 0!~/External *\|/{next};"\
+"     / 0+ UNDEF /{next}; / UNDEF \([^|]\)*()/{next};"\
+"     {if(hide[section]) next};"\
+"     {f=0}; \$ 0~/\(\).*\|/{f=1}; {printf f ? \"T \" : \"D \"};"\
+"     {split(\$ 0, a, /\||\r/); split(a[2], s)};"\
+"     s[1]~/^[@?]/{print s[1], s[1]; next};"\
+"     s[1]~prfx {split(s[1],t,\"@\"); print t[1], substr(t[1],length(prfx))}"\
+"     ' prfx=^$ac_symprfx"
+  else
+    lt_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[	 ]\($symcode$symcode*\)[	 ][	 ]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'"
+  fi
 
+  # Check to see that the pipe works correctly.
+  pipe_works=no
 
+  rm -f conftest*
+  cat > conftest.$ac_ext <<_LT_EOF
+#ifdef __cplusplus
+extern "C" {
+#endif
+char nm_test_var;
+void nm_test_func(void);
+void nm_test_func(void){}
+#ifdef __cplusplus
+}
+#endif
+int main(){nm_test_var='a';nm_test_func();return(0);}
+_LT_EOF
 
-# Check whether --with-pic was given.
-if test "${with_pic+set}" = set; then :
-  withval=$with_pic; pic_mode="$withval"
-else
-  pic_mode=default
-fi
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    # Now try to grab the symbols.
+    nlist=conftest.nm
+    if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$NM conftest.$ac_objext \| "$lt_cv_sys_global_symbol_pipe" \> $nlist\""; } >&5
+  (eval $NM conftest.$ac_objext \| "$lt_cv_sys_global_symbol_pipe" \> $nlist) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s "$nlist"; then
+      # Try sorting and uniquifying the output.
+      if sort "$nlist" | uniq > "$nlist"T; then
+	mv -f "$nlist"T "$nlist"
+      else
+	rm -f "$nlist"T
+      fi
 
+      # Make sure that we snagged all the symbols we need.
+      if $GREP ' nm_test_var$' "$nlist" >/dev/null; then
+	if $GREP ' nm_test_func$' "$nlist" >/dev/null; then
+	  cat <<_LT_EOF > conftest.$ac_ext
+#ifdef __cplusplus
+extern "C" {
+#endif
 
-test -z "$pic_mode" && pic_mode=default
+_LT_EOF
+	  # Now generate the symbol file.
+	  eval "$lt_cv_sys_global_symbol_to_cdecl"' < "$nlist" | $GREP -v main >> conftest.$ac_ext'
 
+	  cat <<_LT_EOF >> conftest.$ac_ext
 
+/* The mapping between symbol names and symbols.  */
+const struct {
+  const char *name;
+  void       *address;
+}
+lt__PROGRAM__LTX_preloaded_symbols[] =
+{
+  { "@PROGRAM@", (void *) 0 },
+_LT_EOF
+	  $SED "s/^$symcode$symcode* \(.*\) \(.*\)$/  {\"\2\", (void *) \&\2},/" < "$nlist" | $GREP -v main >> conftest.$ac_ext
+	  cat <<\_LT_EOF >> conftest.$ac_ext
+  {0, (void *) 0}
+};
 
+/* This works around a problem in FreeBSD linker */
+#ifdef FREEBSD_WORKAROUND
+static const void *lt_preloaded_setup() {
+  return lt__PROGRAM__LTX_preloaded_symbols;
+}
+#endif
 
+#ifdef __cplusplus
+}
+#endif
+_LT_EOF
+	  # Now try linking the two files.
+	  mv conftest.$ac_objext conftstm.$ac_objext
+	  lt_save_LIBS="$LIBS"
+	  lt_save_CFLAGS="$CFLAGS"
+	  LIBS="conftstm.$ac_objext"
+	  CFLAGS="$CFLAGS$lt_prog_compiler_no_builtin_flag"
+	  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s conftest${ac_exeext}; then
+	    pipe_works=yes
+	  fi
+	  LIBS="$lt_save_LIBS"
+	  CFLAGS="$lt_save_CFLAGS"
+	else
+	  echo "cannot find nm_test_func in $nlist" >&5
+	fi
+      else
+	echo "cannot find nm_test_var in $nlist" >&5
+      fi
+    else
+      echo "cannot run $lt_cv_sys_global_symbol_pipe" >&5
+    fi
+  else
+    echo "$progname: failed program was:" >&5
+    cat conftest.$ac_ext >&5
+  fi
+  rm -rf conftest* conftst*
 
+  # Do not use the global_symbol_pipe unless it works.
+  if test "$pipe_works" = yes; then
+    break
+  else
+    lt_cv_sys_global_symbol_pipe=
+  fi
+done
 
+fi
 
-  # Check whether --enable-fast-install was given.
-if test "${enable_fast_install+set}" = set; then :
-  enableval=$enable_fast_install; p=${PACKAGE-default}
-    case $enableval in
-    yes) enable_fast_install=yes ;;
-    no) enable_fast_install=no ;;
-    *)
-      enable_fast_install=no
-      # Look at the argument we got.  We use all the common list separators.
-      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
-      for pkg in $enableval; do
-	IFS="$lt_save_ifs"
-	if test "X$pkg" = "X$p"; then
-	  enable_fast_install=yes
-	fi
-      done
-      IFS="$lt_save_ifs"
-      ;;
-    esac
+if test -z "$lt_cv_sys_global_symbol_pipe"; then
+  lt_cv_sys_global_symbol_to_cdecl=
+fi
+if test -z "$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: failed" >&5
+$as_echo "failed" >&6; }
 else
-  enable_fast_install=yes
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: ok" >&5
+$as_echo "ok" >&6; }
 fi
 
 
@@ -7263,38 +6823,6 @@ fi
 
 
 
-# This can be used to rebuild libtool when needed
-LIBTOOL_DEPS="$ltmain"
-
-# Always use our own libtool.
-LIBTOOL='$(SHELL) $(top_builddir)/libtool'
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-test -z "$LN_S" && LN_S="ln -s"
 
 
 
@@ -7306,882 +6834,868 @@ test -z "$LN_S" && LN_S="ln -s"
 
 
 
+# Check whether --enable-libtool-lock was given.
+if test "${enable_libtool_lock+set}" = set; then :
+  enableval=$enable_libtool_lock;
+fi
 
+test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
 
+# Some flags need to be propagated to the compiler or linker for good
+# libtool support.
+case $host in
+ia64-*-hpux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    case `/usr/bin/file conftest.$ac_objext` in
+      *ELF-32*)
+	HPUX_IA64_MODE="32"
+	;;
+      *ELF-64*)
+	HPUX_IA64_MODE="64"
+	;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+*-*-irix6*)
+  # Find out which ABI we are using.
+  echo '#line '$LINENO' "configure"' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    if test "$lt_cv_prog_gnu_ld" = yes; then
+      case `/usr/bin/file conftest.$ac_objext` in
+	*32-bit*)
+	  LD="${LD-ld} -melf32bsmip"
+	  ;;
+	*N32*)
+	  LD="${LD-ld} -melf32bmipn32"
+	  ;;
+	*64-bit*)
+	  LD="${LD-ld} -melf64bmip"
+	;;
+      esac
+    else
+      case `/usr/bin/file conftest.$ac_objext` in
+	*32-bit*)
+	  LD="${LD-ld} -32"
+	  ;;
+	*N32*)
+	  LD="${LD-ld} -n32"
+	  ;;
+	*64-bit*)
+	  LD="${LD-ld} -64"
+	  ;;
+      esac
+    fi
+  fi
+  rm -rf conftest*
+  ;;
 
-if test -n "${ZSH_VERSION+set}" ; then
-   setopt NO_GLOB_SUBST
-fi
+x86_64-*kfreebsd*-gnu|x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*| \
+s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    case `/usr/bin/file conftest.o` in
+      *32-bit*)
+	case $host in
+	  x86_64-*kfreebsd*-gnu)
+	    LD="${LD-ld} -m elf_i386_fbsd"
+	    ;;
+	  x86_64-*linux*)
+	    case `/usr/bin/file conftest.o` in
+	      *x86-64*)
+		LD="${LD-ld} -m elf32_x86_64"
+		;;
+	      *)
+		LD="${LD-ld} -m elf_i386"
+		;;
+	    esac
+	    ;;
+	  ppc64-*linux*|powerpc64-*linux*)
+	    LD="${LD-ld} -m elf32ppclinux"
+	    ;;
+	  s390x-*linux*)
+	    LD="${LD-ld} -m elf_s390"
+	    ;;
+	  sparc64-*linux*)
+	    LD="${LD-ld} -m elf32_sparc"
+	    ;;
+	esac
+	;;
+      *64-bit*)
+	case $host in
+	  x86_64-*kfreebsd*-gnu)
+	    LD="${LD-ld} -m elf_x86_64_fbsd"
+	    ;;
+	  x86_64-*linux*)
+	    LD="${LD-ld} -m elf_x86_64"
+	    ;;
+	  ppc*-*linux*|powerpc*-*linux*)
+	    LD="${LD-ld} -m elf64ppc"
+	    ;;
+	  s390*-*linux*|s390*-*tpf*)
+	    LD="${LD-ld} -m elf64_s390"
+	    ;;
+	  sparc*-*linux*)
+	    LD="${LD-ld} -m elf64_sparc"
+	    ;;
+	esac
+	;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for objdir" >&5
-$as_echo_n "checking for objdir... " >&6; }
-if test "${lt_cv_objdir+set}" = set; then :
+*-*-sco3.2v5*)
+  # On SCO OpenServer 5, we need -belf to get full-featured binaries.
+  SAVE_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS -belf"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler needs -belf" >&5
+$as_echo_n "checking whether the C compiler needs -belf... " >&6; }
+if test "${lt_cv_cc_needs_belf+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  rm -f .libs 2>/dev/null
-mkdir .libs 2>/dev/null
-if test -d .libs; then
-  lt_cv_objdir=.libs
-else
-  # MS-DOS does not allow filenames that begin with a dot.
-  lt_cv_objdir=_libs
-fi
-rmdir .libs 2>/dev/null
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_objdir" >&5
-$as_echo "$lt_cv_objdir" >&6; }
-objdir=$lt_cv_objdir
-
-
+  ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
+     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
+int
+main ()
+{
 
-cat >>confdefs.h <<_ACEOF
-#define LT_OBJDIR "$lt_cv_objdir/"
+  ;
+  return 0;
+}
 _ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  lt_cv_cc_needs_belf=yes
+else
+  lt_cv_cc_needs_belf=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+     ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
-
-
-
-case $host_os in
-aix3*)
-  # AIX sometimes has problems with the GCC collect2 program.  For some
-  # reason, if we set the COLLECT_NAMES environment variable, the problems
-  # vanish in a puff of smoke.
-  if test "X${COLLECT_NAMES+set}" != Xset; then
-    COLLECT_NAMES=
-    export COLLECT_NAMES
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_cc_needs_belf" >&5
+$as_echo "$lt_cv_cc_needs_belf" >&6; }
+  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
+    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
+    CFLAGS="$SAVE_CFLAGS"
   fi
   ;;
+sparc*-*solaris*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    case `/usr/bin/file conftest.o` in
+    *64-bit*)
+      case $lt_cv_prog_gnu_ld in
+      yes*) LD="${LD-ld} -m elf64_sparc" ;;
+      *)
+	if ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then
+	  LD="${LD-ld} -64"
+	fi
+	;;
+      esac
+      ;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
 esac
 
-# Global variables:
-ofile=libtool
-can_build_shared=yes
-
-# All known linkers require a `.a' archive for static linking (except MSVC,
-# which needs '.lib').
-libext=a
+need_locks="$enable_libtool_lock"
 
-with_gnu_ld="$lt_cv_prog_gnu_ld"
 
-old_CC="$CC"
-old_CFLAGS="$CFLAGS"
+  case $host_os in
+    rhapsody* | darwin*)
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}dsymutil", so it can be a program name with args.
+set dummy ${ac_tool_prefix}dsymutil; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_DSYMUTIL+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$DSYMUTIL"; then
+  ac_cv_prog_DSYMUTIL="$DSYMUTIL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_DSYMUTIL="${ac_tool_prefix}dsymutil"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
 
-# Set sane defaults for various variables
-test -z "$CC" && CC=cc
-test -z "$LTCC" && LTCC=$CC
-test -z "$LTCFLAGS" && LTCFLAGS=$CFLAGS
-test -z "$LD" && LD=ld
-test -z "$ac_objext" && ac_objext=o
-
-for cc_temp in $compiler""; do
-  case $cc_temp in
-    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
-    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
-    \-*) ;;
-    *) break;;
-  esac
-done
-cc_basename=`$ECHO "$cc_temp" | $SED "s%.*/%%; s%^$host_alias-%%"`
+fi
+fi
+DSYMUTIL=$ac_cv_prog_DSYMUTIL
+if test -n "$DSYMUTIL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DSYMUTIL" >&5
+$as_echo "$DSYMUTIL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
 
 
-# Only perform the check for file, if the check method requires it
-test -z "$MAGIC_CMD" && MAGIC_CMD=file
-case $deplibs_check_method in
-file_magic*)
-  if test "$file_magic_cmd" = '$MAGIC_CMD'; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${ac_tool_prefix}file" >&5
-$as_echo_n "checking for ${ac_tool_prefix}file... " >&6; }
-if test "${lt_cv_path_MAGIC_CMD+set}" = set; then :
+fi
+if test -z "$ac_cv_prog_DSYMUTIL"; then
+  ac_ct_DSYMUTIL=$DSYMUTIL
+  # Extract the first word of "dsymutil", so it can be a program name with args.
+set dummy dsymutil; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_DSYMUTIL+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  case $MAGIC_CMD in
-[\\/*] |  ?:[\\/]*)
-  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
-  ;;
-*)
-  lt_save_MAGIC_CMD="$MAGIC_CMD"
-  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
-  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
-  for ac_dir in $ac_dummy; do
-    IFS="$lt_save_ifs"
-    test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/${ac_tool_prefix}file; then
-      lt_cv_path_MAGIC_CMD="$ac_dir/${ac_tool_prefix}file"
-      if test -n "$file_magic_test_file"; then
-	case $deplibs_check_method in
-	"file_magic "*)
-	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
-	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
-	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
-	    $EGREP "$file_magic_regex" > /dev/null; then
-	    :
-	  else
-	    cat <<_LT_EOF 1>&2
-
-*** Warning: the command libtool uses to detect shared libraries,
-*** $file_magic_cmd, produces output that libtool cannot recognize.
-*** The result is that libtool may fail to recognize shared libraries
-*** as such.  This will affect the creation of libtool libraries that
-*** depend on shared libraries, but programs linked with such libtool
-*** libraries will work regardless of this problem.  Nevertheless, you
-*** may want to report the problem to your system manager and/or to
-*** bug-libtool@gnu.org
-
-_LT_EOF
-	  fi ;;
-	esac
-      fi
-      break
-    fi
+  if test -n "$ac_ct_DSYMUTIL"; then
+  ac_cv_prog_ac_ct_DSYMUTIL="$ac_ct_DSYMUTIL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_DSYMUTIL="dsymutil"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
   done
-  IFS="$lt_save_ifs"
-  MAGIC_CMD="$lt_save_MAGIC_CMD"
-  ;;
-esac
-fi
+IFS=$as_save_IFS
 
-MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
-if test -n "$MAGIC_CMD"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
-$as_echo "$MAGIC_CMD" >&6; }
+fi
+fi
+ac_ct_DSYMUTIL=$ac_cv_prog_ac_ct_DSYMUTIL
+if test -n "$ac_ct_DSYMUTIL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DSYMUTIL" >&5
+$as_echo "$ac_ct_DSYMUTIL" >&6; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
+  if test "x$ac_ct_DSYMUTIL" = x; then
+    DSYMUTIL=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    DSYMUTIL=$ac_ct_DSYMUTIL
+  fi
+else
+  DSYMUTIL="$ac_cv_prog_DSYMUTIL"
+fi
 
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}nmedit", so it can be a program name with args.
+set dummy ${ac_tool_prefix}nmedit; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_NMEDIT+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$NMEDIT"; then
+  ac_cv_prog_NMEDIT="$NMEDIT" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_NMEDIT="${ac_tool_prefix}nmedit"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
 
+fi
+fi
+NMEDIT=$ac_cv_prog_NMEDIT
+if test -n "$NMEDIT"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $NMEDIT" >&5
+$as_echo "$NMEDIT" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
 
 
-if test -z "$lt_cv_path_MAGIC_CMD"; then
-  if test -n "$ac_tool_prefix"; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for file" >&5
-$as_echo_n "checking for file... " >&6; }
-if test "${lt_cv_path_MAGIC_CMD+set}" = set; then :
+fi
+if test -z "$ac_cv_prog_NMEDIT"; then
+  ac_ct_NMEDIT=$NMEDIT
+  # Extract the first word of "nmedit", so it can be a program name with args.
+set dummy nmedit; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_NMEDIT+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  case $MAGIC_CMD in
-[\\/*] |  ?:[\\/]*)
-  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
-  ;;
-*)
-  lt_save_MAGIC_CMD="$MAGIC_CMD"
-  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
-  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
-  for ac_dir in $ac_dummy; do
-    IFS="$lt_save_ifs"
-    test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/file; then
-      lt_cv_path_MAGIC_CMD="$ac_dir/file"
-      if test -n "$file_magic_test_file"; then
-	case $deplibs_check_method in
-	"file_magic "*)
-	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
-	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
-	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
-	    $EGREP "$file_magic_regex" > /dev/null; then
-	    :
-	  else
-	    cat <<_LT_EOF 1>&2
-
-*** Warning: the command libtool uses to detect shared libraries,
-*** $file_magic_cmd, produces output that libtool cannot recognize.
-*** The result is that libtool may fail to recognize shared libraries
-*** as such.  This will affect the creation of libtool libraries that
-*** depend on shared libraries, but programs linked with such libtool
-*** libraries will work regardless of this problem.  Nevertheless, you
-*** may want to report the problem to your system manager and/or to
-*** bug-libtool@gnu.org
-
-_LT_EOF
-	  fi ;;
-	esac
-      fi
-      break
-    fi
+  if test -n "$ac_ct_NMEDIT"; then
+  ac_cv_prog_ac_ct_NMEDIT="$ac_ct_NMEDIT" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_NMEDIT="nmedit"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
   done
-  IFS="$lt_save_ifs"
-  MAGIC_CMD="$lt_save_MAGIC_CMD"
-  ;;
-esac
-fi
+IFS=$as_save_IFS
 
-MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
-if test -n "$MAGIC_CMD"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
-$as_echo "$MAGIC_CMD" >&6; }
+fi
+fi
+ac_ct_NMEDIT=$ac_cv_prog_ac_ct_NMEDIT
+if test -n "$ac_ct_NMEDIT"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_NMEDIT" >&5
+$as_echo "$ac_ct_NMEDIT" >&6; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
-
+  if test "x$ac_ct_NMEDIT" = x; then
+    NMEDIT=":"
   else
-    MAGIC_CMD=:
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    NMEDIT=$ac_ct_NMEDIT
   fi
+else
+  NMEDIT="$ac_cv_prog_NMEDIT"
 fi
 
-  fi
-  ;;
-esac
-
-# Use C for the default configuration in the libtool script
-
-lt_save_CC="$CC"
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-
-# Source file extension for C test sources.
-ac_ext=c
-
-# Object file extension for compiled C test sources.
-objext=o
-objext=$objext
-
-# Code to be used in simple compile tests
-lt_simple_compile_test_code="int some_variable = 0;"
-
-# Code to be used in simple link tests
-lt_simple_link_test_code='int main(){return(0);}'
-
-
-
-
-
-
-
-# If no C compiler was specified, use CC.
-LTCC=${LTCC-"$CC"}
-
-# If no C compiler flags were specified, use CFLAGS.
-LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
-
-# Allow CC to be a program name with arguments.
-compiler=$CC
-
-# Save the default compiler, since it gets overwritten when the other
-# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.
-compiler_DEFAULT=$CC
-
-# save warnings/boilerplate of simple test code
-ac_outfile=conftest.$ac_objext
-echo "$lt_simple_compile_test_code" >conftest.$ac_ext
-eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
-_lt_compiler_boilerplate=`cat conftest.err`
-$RM conftest*
-
-ac_outfile=conftest.$ac_objext
-echo "$lt_simple_link_test_code" >conftest.$ac_ext
-eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
-_lt_linker_boilerplate=`cat conftest.err`
-$RM -r conftest*
-
-
-## CAVEAT EMPTOR:
-## There is no encapsulation within the following macros, do not change
-## the running order or otherwise move them around unless you know exactly
-## what you are doing...
-if test -n "$compiler"; then
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}lipo", so it can be a program name with args.
+set dummy ${ac_tool_prefix}lipo; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_LIPO+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$LIPO"; then
+  ac_cv_prog_LIPO="$LIPO" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_LIPO="${ac_tool_prefix}lipo"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
 
-lt_prog_compiler_no_builtin_flag=
+fi
+fi
+LIPO=$ac_cv_prog_LIPO
+if test -n "$LIPO"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LIPO" >&5
+$as_echo "$LIPO" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
 
-if test "$GCC" = yes; then
-  case $cc_basename in
-  nvcc*)
-    lt_prog_compiler_no_builtin_flag=' -Xcompiler -fno-builtin' ;;
-  *)
-    lt_prog_compiler_no_builtin_flag=' -fno-builtin' ;;
-  esac
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -fno-rtti -fno-exceptions" >&5
-$as_echo_n "checking if $compiler supports -fno-rtti -fno-exceptions... " >&6; }
-if test "${lt_cv_prog_compiler_rtti_exceptions+set}" = set; then :
+fi
+if test -z "$ac_cv_prog_LIPO"; then
+  ac_ct_LIPO=$LIPO
+  # Extract the first word of "lipo", so it can be a program name with args.
+set dummy lipo; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_LIPO+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  lt_cv_prog_compiler_rtti_exceptions=no
-   ac_outfile=conftest.$ac_objext
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-   lt_compiler_flag="-fno-rtti -fno-exceptions"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   # The option is referenced via a variable to avoid confusing sed.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>conftest.err)
-   ac_status=$?
-   cat conftest.err >&5
-   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s "$ac_outfile"; then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings other than the usual output.
-     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
-     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
-     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_rtti_exceptions=yes
-     fi
-   fi
-   $RM conftest*
+  if test -n "$ac_ct_LIPO"; then
+  ac_cv_prog_ac_ct_LIPO="$ac_ct_LIPO" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_LIPO="lipo"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_rtti_exceptions" >&5
-$as_echo "$lt_cv_prog_compiler_rtti_exceptions" >&6; }
-
-if test x"$lt_cv_prog_compiler_rtti_exceptions" = xyes; then
-    lt_prog_compiler_no_builtin_flag="$lt_prog_compiler_no_builtin_flag -fno-rtti -fno-exceptions"
+fi
+ac_ct_LIPO=$ac_cv_prog_ac_ct_LIPO
+if test -n "$ac_ct_LIPO"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_LIPO" >&5
+$as_echo "$ac_ct_LIPO" >&6; }
 else
-    :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
 fi
 
+  if test "x$ac_ct_LIPO" = x; then
+    LIPO=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    LIPO=$ac_ct_LIPO
+  fi
+else
+  LIPO="$ac_cv_prog_LIPO"
 fi
 
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}otool", so it can be a program name with args.
+set dummy ${ac_tool_prefix}otool; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_OTOOL+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$OTOOL"; then
+  ac_cv_prog_OTOOL="$OTOOL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_OTOOL="${ac_tool_prefix}otool"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
 
+fi
+fi
+OTOOL=$ac_cv_prog_OTOOL
+if test -n "$OTOOL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OTOOL" >&5
+$as_echo "$OTOOL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
 
 
+fi
+if test -z "$ac_cv_prog_OTOOL"; then
+  ac_ct_OTOOL=$OTOOL
+  # Extract the first word of "otool", so it can be a program name with args.
+set dummy otool; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_OTOOL+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_OTOOL"; then
+  ac_cv_prog_ac_ct_OTOOL="$ac_ct_OTOOL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_OTOOL="otool"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
 
+fi
+fi
+ac_ct_OTOOL=$ac_cv_prog_ac_ct_OTOOL
+if test -n "$ac_ct_OTOOL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL" >&5
+$as_echo "$ac_ct_OTOOL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
 
-  lt_prog_compiler_wl=
-lt_prog_compiler_pic=
-lt_prog_compiler_static=
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $compiler option to produce PIC" >&5
-$as_echo_n "checking for $compiler option to produce PIC... " >&6; }
-
-  if test "$GCC" = yes; then
-    lt_prog_compiler_wl='-Wl,'
-    lt_prog_compiler_static='-static'
+  if test "x$ac_ct_OTOOL" = x; then
+    OTOOL=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    OTOOL=$ac_ct_OTOOL
+  fi
+else
+  OTOOL="$ac_cv_prog_OTOOL"
+fi
 
-    case $host_os in
-      aix*)
-      # All AIX code is PIC.
-      if test "$host_cpu" = ia64; then
-	# AIX 5 now supports IA64 processor
-	lt_prog_compiler_static='-Bstatic'
-      fi
-      lt_prog_compiler_pic='-fPIC'
-      ;;
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}otool64", so it can be a program name with args.
+set dummy ${ac_tool_prefix}otool64; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_OTOOL64+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$OTOOL64"; then
+  ac_cv_prog_OTOOL64="$OTOOL64" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_OTOOL64="${ac_tool_prefix}otool64"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
 
-    amigaos*)
-      case $host_cpu in
-      powerpc)
-            # see comment about AmigaOS4 .so support
-            lt_prog_compiler_pic='-fPIC'
-        ;;
-      m68k)
-            # FIXME: we need at least 68020 code to build shared libraries, but
-            # adding the `-m68020' flag to GCC prevents building anything better,
-            # like `-m68040'.
-            lt_prog_compiler_pic='-m68020 -resident32 -malways-restore-a4'
-        ;;
-      esac
-      ;;
+fi
+fi
+OTOOL64=$ac_cv_prog_OTOOL64
+if test -n "$OTOOL64"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OTOOL64" >&5
+$as_echo "$OTOOL64" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
 
-    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
-      # PIC is the default for these OSes.
-      ;;
 
-    mingw* | cygwin* | pw32* | os2* | cegcc*)
-      # This hack is so that the source file can tell whether it is being
-      # built for inclusion in a dll (and should export symbols for example).
-      # Although the cygwin gcc ignores -fPIC, still need this for old-style
-      # (--disable-auto-import) libraries
-      lt_prog_compiler_pic='-DDLL_EXPORT'
-      ;;
+fi
+if test -z "$ac_cv_prog_OTOOL64"; then
+  ac_ct_OTOOL64=$OTOOL64
+  # Extract the first word of "otool64", so it can be a program name with args.
+set dummy otool64; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_OTOOL64+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_OTOOL64"; then
+  ac_cv_prog_ac_ct_OTOOL64="$ac_ct_OTOOL64" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_OTOOL64="otool64"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
 
-    darwin* | rhapsody*)
-      # PIC is the default on this platform
-      # Common symbols not allowed in MH_DYLIB files
-      lt_prog_compiler_pic='-fno-common'
-      ;;
+fi
+fi
+ac_ct_OTOOL64=$ac_cv_prog_ac_ct_OTOOL64
+if test -n "$ac_ct_OTOOL64"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL64" >&5
+$as_echo "$ac_ct_OTOOL64" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
 
-    haiku*)
-      # PIC is the default for Haiku.
-      # The "-static" flag exists, but is broken.
-      lt_prog_compiler_static=
-      ;;
+  if test "x$ac_ct_OTOOL64" = x; then
+    OTOOL64=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    OTOOL64=$ac_ct_OTOOL64
+  fi
+else
+  OTOOL64="$ac_cv_prog_OTOOL64"
+fi
 
-    hpux*)
-      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
-      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
-      # sets the default TLS model and affects inlining.
-      case $host_cpu in
-      hppa*64*)
-	# +Z the default
-	;;
-      *)
-	lt_prog_compiler_pic='-fPIC'
-	;;
-      esac
-      ;;
 
-    interix[3-9]*)
-      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
-      # Instead, we relocate shared libraries at runtime.
-      ;;
 
-    msdosdjgpp*)
-      # Just because we use GCC doesn't mean we suddenly get shared libraries
-      # on systems that don't support them.
-      lt_prog_compiler_can_build_shared=no
-      enable_shared=no
-      ;;
 
-    *nto* | *qnx*)
-      # QNX uses GNU C++, but need to define -shared option too, otherwise
-      # it will coredump.
-      lt_prog_compiler_pic='-fPIC -shared'
-      ;;
 
-    sysv4*MP*)
-      if test -d /usr/nec; then
-	lt_prog_compiler_pic=-Kconform_pic
-      fi
-      ;;
 
-    *)
-      lt_prog_compiler_pic='-fPIC'
-      ;;
-    esac
 
-    case $cc_basename in
-    nvcc*) # Cuda Compiler Driver 2.2
-      lt_prog_compiler_wl='-Xlinker '
-      lt_prog_compiler_pic='-Xcompiler -fPIC'
-      ;;
-    esac
-  else
-    # PORTME Check for flag to pass linker flags through the system compiler.
-    case $host_os in
-    aix*)
-      lt_prog_compiler_wl='-Wl,'
-      if test "$host_cpu" = ia64; then
-	# AIX 5 now supports IA64 processor
-	lt_prog_compiler_static='-Bstatic'
-      else
-	lt_prog_compiler_static='-bnso -bI:/lib/syscalls.exp'
-      fi
-      ;;
 
-    mingw* | cygwin* | pw32* | os2* | cegcc*)
-      # This hack is so that the source file can tell whether it is being
-      # built for inclusion in a dll (and should export symbols for example).
-      lt_prog_compiler_pic='-DDLL_EXPORT'
-      ;;
 
-    hpux9* | hpux10* | hpux11*)
-      lt_prog_compiler_wl='-Wl,'
-      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but
-      # not for PA HP-UX.
-      case $host_cpu in
-      hppa*64*|ia64*)
-	# +Z the default
-	;;
-      *)
-	lt_prog_compiler_pic='+Z'
-	;;
-      esac
-      # Is there a better lt_prog_compiler_static that works with the bundled CC?
-      lt_prog_compiler_static='${wl}-a ${wl}archive'
-      ;;
 
-    irix5* | irix6* | nonstopux*)
-      lt_prog_compiler_wl='-Wl,'
-      # PIC (with -KPIC) is the default.
-      lt_prog_compiler_static='-non_shared'
-      ;;
 
-    linux* | k*bsd*-gnu | kopensolaris*-gnu)
-      case $cc_basename in
-      # old Intel for x86_64 which still supported -KPIC.
-      ecc*)
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='-KPIC'
-	lt_prog_compiler_static='-static'
-        ;;
-      # icc used to be incompatible with GCC.
-      # ICC 10 doesn't accept -KPIC any more.
-      icc* | ifort*)
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='-fPIC'
-	lt_prog_compiler_static='-static'
-        ;;
-      # Lahey Fortran 8.1.
-      lf95*)
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='--shared'
-	lt_prog_compiler_static='--static'
-	;;
-      pgcc* | pgf77* | pgf90* | pgf95* | pgfortran*)
-        # Portland Group compilers (*not* the Pentium gcc compiler,
-	# which looks to be a dead project)
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='-fpic'
-	lt_prog_compiler_static='-Bstatic'
-        ;;
-      ccc*)
-        lt_prog_compiler_wl='-Wl,'
-        # All Alpha code is PIC.
-        lt_prog_compiler_static='-non_shared'
-        ;;
-      xl* | bgxl* | bgf* | mpixl*)
-	# IBM XL C 8.0/Fortran 10.1, 11.1 on PPC and BlueGene
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='-qpic'
-	lt_prog_compiler_static='-qstaticlink'
-	;;
-      *)
-	case `$CC -V 2>&1 | sed 5q` in
-	*Sun\ F* | *Sun*Fortran*)
-	  # Sun Fortran 8.3 passes all unrecognized flags to the linker
-	  lt_prog_compiler_pic='-KPIC'
-	  lt_prog_compiler_static='-Bstatic'
-	  lt_prog_compiler_wl=''
-	  ;;
-	*Sun\ C*)
-	  # Sun C 5.9
-	  lt_prog_compiler_pic='-KPIC'
-	  lt_prog_compiler_static='-Bstatic'
-	  lt_prog_compiler_wl='-Wl,'
-	  ;;
-	esac
-	;;
-      esac
-      ;;
-
-    newsos6)
-      lt_prog_compiler_pic='-KPIC'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
-
-    *nto* | *qnx*)
-      # QNX uses GNU C++, but need to define -shared option too, otherwise
-      # it will coredump.
-      lt_prog_compiler_pic='-fPIC -shared'
-      ;;
-
-    osf3* | osf4* | osf5*)
-      lt_prog_compiler_wl='-Wl,'
-      # All OSF/1 code is PIC.
-      lt_prog_compiler_static='-non_shared'
-      ;;
 
-    rdos*)
-      lt_prog_compiler_static='-non_shared'
-      ;;
 
-    solaris*)
-      lt_prog_compiler_pic='-KPIC'
-      lt_prog_compiler_static='-Bstatic'
-      case $cc_basename in
-      f77* | f90* | f95*)
-	lt_prog_compiler_wl='-Qoption ld ';;
-      *)
-	lt_prog_compiler_wl='-Wl,';;
-      esac
-      ;;
 
-    sunos4*)
-      lt_prog_compiler_wl='-Qoption ld '
-      lt_prog_compiler_pic='-PIC'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
 
-    sysv4 | sysv4.2uw2* | sysv4.3*)
-      lt_prog_compiler_wl='-Wl,'
-      lt_prog_compiler_pic='-KPIC'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
 
-    sysv4*MP*)
-      if test -d /usr/nec ;then
-	lt_prog_compiler_pic='-Kconform_pic'
-	lt_prog_compiler_static='-Bstatic'
-      fi
-      ;;
 
-    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
-      lt_prog_compiler_wl='-Wl,'
-      lt_prog_compiler_pic='-KPIC'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
 
-    unicos*)
-      lt_prog_compiler_wl='-Wl,'
-      lt_prog_compiler_can_build_shared=no
-      ;;
 
-    uts4*)
-      lt_prog_compiler_pic='-pic'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
 
-    *)
-      lt_prog_compiler_can_build_shared=no
-      ;;
-    esac
-  fi
 
-case $host_os in
-  # For platforms which do not support PIC, -DPIC is meaningless:
-  *djgpp*)
-    lt_prog_compiler_pic=
-    ;;
-  *)
-    lt_prog_compiler_pic="$lt_prog_compiler_pic -DPIC"
-    ;;
-esac
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_prog_compiler_pic" >&5
-$as_echo "$lt_prog_compiler_pic" >&6; }
 
 
 
 
 
 
-#
-# Check to make sure the PIC flag actually works.
-#
-if test -n "$lt_prog_compiler_pic"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler PIC flag $lt_prog_compiler_pic works" >&5
-$as_echo_n "checking if $compiler PIC flag $lt_prog_compiler_pic works... " >&6; }
-if test "${lt_cv_prog_compiler_pic_works+set}" = set; then :
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -single_module linker flag" >&5
+$as_echo_n "checking for -single_module linker flag... " >&6; }
+if test "${lt_cv_apple_cc_single_mod+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  lt_cv_prog_compiler_pic_works=no
-   ac_outfile=conftest.$ac_objext
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-   lt_compiler_flag="$lt_prog_compiler_pic -DPIC"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   # The option is referenced via a variable to avoid confusing sed.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>conftest.err)
-   ac_status=$?
-   cat conftest.err >&5
-   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s "$ac_outfile"; then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings other than the usual output.
-     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
-     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
-     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_pic_works=yes
-     fi
-   fi
-   $RM conftest*
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_pic_works" >&5
-$as_echo "$lt_cv_prog_compiler_pic_works" >&6; }
-
-if test x"$lt_cv_prog_compiler_pic_works" = xyes; then
-    case $lt_prog_compiler_pic in
-     "" | " "*) ;;
-     *) lt_prog_compiler_pic=" $lt_prog_compiler_pic" ;;
-     esac
-else
-    lt_prog_compiler_pic=
-     lt_prog_compiler_can_build_shared=no
-fi
-
+  lt_cv_apple_cc_single_mod=no
+      if test -z "${LT_MULTI_MODULE}"; then
+	# By default we will add the -single_module flag. You can override
+	# by either setting the environment variable LT_MULTI_MODULE
+	# non-empty at configure time, or by adding -multi_module to the
+	# link flags.
+	rm -rf libconftest.dylib*
+	echo "int foo(void){return 1;}" > conftest.c
+	echo "$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
+-dynamiclib -Wl,-single_module conftest.c" >&5
+	$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
+	  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err
+        _lt_result=$?
+	if test -f libconftest.dylib && test ! -s conftest.err && test $_lt_result = 0; then
+	  lt_cv_apple_cc_single_mod=yes
+	else
+	  cat conftest.err >&5
+	fi
+	rm -rf libconftest.dylib*
+	rm -f conftest.*
+      fi
 fi
-
-
-
-
-
-
-#
-# Check to make sure the static flag actually works.
-#
-wl=$lt_prog_compiler_wl eval lt_tmp_static_flag=\"$lt_prog_compiler_static\"
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler static flag $lt_tmp_static_flag works" >&5
-$as_echo_n "checking if $compiler static flag $lt_tmp_static_flag works... " >&6; }
-if test "${lt_cv_prog_compiler_static_works+set}" = set; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_apple_cc_single_mod" >&5
+$as_echo "$lt_cv_apple_cc_single_mod" >&6; }
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -exported_symbols_list linker flag" >&5
+$as_echo_n "checking for -exported_symbols_list linker flag... " >&6; }
+if test "${lt_cv_ld_exported_symbols_list+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  lt_cv_prog_compiler_static_works=no
-   save_LDFLAGS="$LDFLAGS"
-   LDFLAGS="$LDFLAGS $lt_tmp_static_flag"
-   echo "$lt_simple_link_test_code" > conftest.$ac_ext
-   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
-     # The linker can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     if test -s conftest.err; then
-       # Append any errors to the config.log.
-       cat conftest.err 1>&5
-       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
-       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
-       if diff conftest.exp conftest.er2 >/dev/null; then
-         lt_cv_prog_compiler_static_works=yes
-       fi
-     else
-       lt_cv_prog_compiler_static_works=yes
-     fi
-   fi
-   $RM -r conftest*
-   LDFLAGS="$save_LDFLAGS"
+  lt_cv_ld_exported_symbols_list=no
+      save_LDFLAGS=$LDFLAGS
+      echo "_main" > conftest.sym
+      LDFLAGS="$LDFLAGS -Wl,-exported_symbols_list,conftest.sym"
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_static_works" >&5
-$as_echo "$lt_cv_prog_compiler_static_works" >&6; }
+int
+main ()
+{
 
-if test x"$lt_cv_prog_compiler_static_works" = xyes; then
-    :
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  lt_cv_ld_exported_symbols_list=yes
 else
-    lt_prog_compiler_static=
+  lt_cv_ld_exported_symbols_list=no
 fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+	LDFLAGS="$save_LDFLAGS"
 
-
-
-
-
-
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
-$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
-if test "${lt_cv_prog_compiler_c_o+set}" = set; then :
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_exported_symbols_list" >&5
+$as_echo "$lt_cv_ld_exported_symbols_list" >&6; }
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -force_load linker flag" >&5
+$as_echo_n "checking for -force_load linker flag... " >&6; }
+if test "${lt_cv_ld_force_load+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  lt_cv_prog_compiler_c_o=no
-   $RM -r conftest 2>/dev/null
-   mkdir conftest
-   cd conftest
-   mkdir out
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+  lt_cv_ld_force_load=no
+      cat > conftest.c << _LT_EOF
+int forced_loaded() { return 2;}
+_LT_EOF
+      echo "$LTCC $LTCFLAGS -c -o conftest.o conftest.c" >&5
+      $LTCC $LTCFLAGS -c -o conftest.o conftest.c 2>&5
+      echo "$AR cru libconftest.a conftest.o" >&5
+      $AR cru libconftest.a conftest.o 2>&5
+      cat > conftest.c << _LT_EOF
+int main() { return 0;}
+_LT_EOF
+      echo "$LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a" >&5
+      $LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a 2>conftest.err
+      _lt_result=$?
+      if test -f conftest && test ! -s conftest.err && test $_lt_result = 0 && $GREP forced_load conftest 2>&1 >/dev/null; then
+	lt_cv_ld_force_load=yes
+      else
+	cat conftest.err >&5
+      fi
+        rm -f conftest.err libconftest.a conftest conftest.c
+        rm -rf conftest.dSYM
 
-   lt_compiler_flag="-o out/conftest2.$ac_objext"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>out/conftest.err)
-   ac_status=$?
-   cat out/conftest.err >&5
-   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s out/conftest2.$ac_objext
-   then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
-     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
-     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_c_o=yes
-     fi
-   fi
-   chmod u+w . 2>&5
-   $RM conftest*
-   # SGI C++ compiler will create directory out/ii_files/ for
-   # template instantiation
-   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
-   $RM out/* && rmdir out
-   cd ..
-   $RM -r conftest
-   $RM conftest*
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_force_load" >&5
+$as_echo "$lt_cv_ld_force_load" >&6; }
+    case $host_os in
+    rhapsody* | darwin1.[012])
+      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;
+    darwin1.*)
+      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+    darwin*) # darwin 5.x on
+      # if running on 10.5 or later, the deployment target defaults
+      # to the OS version, if on x86, and 10.4, the deployment
+      # target defaults to 10.4. Don't you love it?
+      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in
+	10.0,*86*-darwin8*|10.0,*-darwin[91]*)
+	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+	10.[012]*)
+	  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+	10.*)
+	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+      esac
+    ;;
+  esac
+    if test "$lt_cv_apple_cc_single_mod" = "yes"; then
+      _lt_dar_single_mod='$single_module'
+    fi
+    if test "$lt_cv_ld_exported_symbols_list" = "yes"; then
+      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
+    else
+      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'
+    fi
+    if test "$DSYMUTIL" != ":" && test "$lt_cv_ld_force_load" = "no"; then
+      _lt_dsymutil='~$DSYMUTIL $lib || :'
+    else
+      _lt_dsymutil=
+    fi
+    ;;
+  esac
+
+for ac_header in dlfcn.h
+do :
+  ac_fn_c_check_header_compile "$LINENO" "dlfcn.h" "ac_cv_header_dlfcn_h" "$ac_includes_default
+"
+if test "x$ac_cv_header_dlfcn_h" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_DLFCN_H 1
+_ACEOF
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o" >&5
-$as_echo "$lt_cv_prog_compiler_c_o" >&6; }
 
+done
 
 
 
 
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
-$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
-if test "${lt_cv_prog_compiler_c_o+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_c_o=no
-   $RM -r conftest 2>/dev/null
-   mkdir conftest
-   cd conftest
-   mkdir out
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
 
-   lt_compiler_flag="-o out/conftest2.$ac_objext"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>out/conftest.err)
-   ac_status=$?
-   cat out/conftest.err >&5
-   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s out/conftest2.$ac_objext
-   then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
-     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
-     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_c_o=yes
-     fi
-   fi
-   chmod u+w . 2>&5
-   $RM conftest*
-   # SGI C++ compiler will create directory out/ii_files/ for
-   # template instantiation
-   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
-   $RM out/* && rmdir out
-   cd ..
-   $RM -r conftest
-   $RM conftest*
+# Set options
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o" >&5
-$as_echo "$lt_cv_prog_compiler_c_o" >&6; }
 
 
 
+  enable_win32_dll=no
 
-hard_links="nottested"
-if test "$lt_cv_prog_compiler_c_o" = no && test "$need_locks" != no; then
-  # do not overwrite the value of need_locks provided by the user
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if we can lock with hard links" >&5
-$as_echo_n "checking if we can lock with hard links... " >&6; }
-  hard_links=yes
-  $RM conftest*
-  ln conftest.a conftest.b 2>/dev/null && hard_links=no
-  touch conftest.a
-  ln conftest.a conftest.b 2>&5 || hard_links=no
-  ln conftest.a conftest.b 2>/dev/null && hard_links=no
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $hard_links" >&5
-$as_echo "$hard_links" >&6; }
-  if test "$hard_links" = no; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
-$as_echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
-    need_locks=warn
-  fi
+
+            # Check whether --enable-shared was given.
+if test "${enable_shared+set}" = set; then :
+  enableval=$enable_shared; p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_shared=yes ;;
+    no) enable_shared=no ;;
+    *)
+      enable_shared=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_shared=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
 else
-  need_locks=no
+  enable_shared=yes
 fi
 
 
@@ -8189,1172 +7703,391 @@ fi
 
 
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $compiler linker ($LD) supports shared libraries" >&5
-$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
 
-  runpath_var=
-  allow_undefined_flag=
-  always_export_symbols=no
-  archive_cmds=
-  archive_expsym_cmds=
-  compiler_needs_object=no
-  enable_shared_with_static_runtimes=no
-  export_dynamic_flag_spec=
-  export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
-  hardcode_automatic=no
-  hardcode_direct=no
-  hardcode_direct_absolute=no
-  hardcode_libdir_flag_spec=
-  hardcode_libdir_flag_spec_ld=
-  hardcode_libdir_separator=
-  hardcode_minus_L=no
-  hardcode_shlibpath_var=unsupported
-  inherit_rpath=no
-  link_all_deplibs=unknown
-  module_cmds=
-  module_expsym_cmds=
-  old_archive_from_new_cmds=
-  old_archive_from_expsyms_cmds=
-  thread_safe_flag_spec=
-  whole_archive_flag_spec=
-  # include_expsyms should be a list of space-separated symbols to be *always*
-  # included in the symbol list
-  include_expsyms=
-  # exclude_expsyms can be an extended regexp of symbols to exclude
-  # it will be wrapped by ` (' and `)$', so one must not match beginning or
-  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
-  # as well as any symbol that contains `d'.
-  exclude_expsyms='_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*'
-  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
-  # platforms (ab)use it in PIC code, but their linkers get confused if
-  # the symbol is explicitly referenced.  Since portable code cannot
-  # rely on this symbol name, it's probably fine to never include it in
-  # preloaded symbol tables.
-  # Exclude shared library initialization/finalization symbols.
-  extract_expsyms_cmds=
 
-  case $host_os in
-  cygwin* | mingw* | pw32* | cegcc*)
-    # FIXME: the MSVC++ port hasn't been tested in a loooong time
-    # When not using gcc, we currently assume that we are using
-    # Microsoft Visual C++.
-    if test "$GCC" != yes; then
-      with_gnu_ld=no
-    fi
-    ;;
-  interix*)
-    # we just hope/assume this is gcc and not c89 (= MSVC++)
-    with_gnu_ld=yes
-    ;;
-  openbsd*)
-    with_gnu_ld=no
-    ;;
-  esac
-
-  ld_shlibs=yes
 
-  # On some targets, GNU ld is compatible enough with the native linker
-  # that we're better off using the native interface for both.
-  lt_use_gnu_ld_interface=no
-  if test "$with_gnu_ld" = yes; then
-    case $host_os in
-      aix*)
-	# The AIX port of GNU ld has always aspired to compatibility
-	# with the native linker.  However, as the warning in the GNU ld
-	# block says, versions before 2.19.5* couldn't really create working
-	# shared libraries, regardless of the interface used.
-	case `$LD -v 2>&1` in
-	  *\ \(GNU\ Binutils\)\ 2.19.5*) ;;
-	  *\ \(GNU\ Binutils\)\ 2.[2-9]*) ;;
-	  *\ \(GNU\ Binutils\)\ [3-9]*) ;;
-	  *)
-	    lt_use_gnu_ld_interface=yes
-	    ;;
-	esac
-	;;
-      *)
-	lt_use_gnu_ld_interface=yes
-	;;
+  # Check whether --enable-static was given.
+if test "${enable_static+set}" = set; then :
+  enableval=$enable_static; p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_static=yes ;;
+    no) enable_static=no ;;
+    *)
+     enable_static=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_static=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
     esac
-  fi
+else
+  enable_static=yes
+fi
 
-  if test "$lt_use_gnu_ld_interface" = yes; then
-    # If archive_cmds runs LD, not CC, wlarc should be empty
-    wlarc='${wl}'
 
-    # Set some defaults for GNU ld with shared library support. These
-    # are reset later if shared libraries are not supported. Putting them
-    # here allows them to be overridden if necessary.
-    runpath_var=LD_RUN_PATH
-    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-    export_dynamic_flag_spec='${wl}--export-dynamic'
-    # ancient GNU ld didn't support --whole-archive et. al.
-    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then
-      whole_archive_flag_spec="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
-    else
-      whole_archive_flag_spec=
-    fi
-    supports_anon_versioning=no
-    case `$LD -v 2>&1` in
-      *GNU\ gold*) supports_anon_versioning=yes ;;
-      *\ [01].* | *\ 2.[0-9].* | *\ 2.10.*) ;; # catch versions < 2.11
-      *\ 2.11.93.0.2\ *) supports_anon_versioning=yes ;; # RH7.3 ...
-      *\ 2.11.92.0.12\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...
-      *\ 2.11.*) ;; # other 2.11 versions
-      *) supports_anon_versioning=yes ;;
-    esac
 
-    # See if GNU ld supports shared libraries.
-    case $host_os in
-    aix[3-9]*)
-      # On AIX/PPC, the GNU linker is very broken
-      if test "$host_cpu" != ia64; then
-	ld_shlibs=no
-	cat <<_LT_EOF 1>&2
 
-*** Warning: the GNU linker, at least up to release 2.19, is reported
-*** to be unable to reliably create shared libraries on AIX.
-*** Therefore, libtool is disabling shared libraries support.  If you
-*** really care for shared libraries, you may want to install binutils
-*** 2.20 or above, or modify your PATH so that a non-GNU linker is found.
-*** You will then need to restart the configuration process.
 
-_LT_EOF
-      fi
-      ;;
 
-    amigaos*)
-      case $host_cpu in
-      powerpc)
-            # see comment about AmigaOS4 .so support
-            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-            archive_expsym_cmds=''
-        ;;
-      m68k)
-            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
-            hardcode_libdir_flag_spec='-L$libdir'
-            hardcode_minus_L=yes
-        ;;
-      esac
-      ;;
 
-    beos*)
-      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	allow_undefined_flag=unsupported
-	# Joseph Beckenbach <jrb3@best.com> says some releases of gcc
-	# support --undefined.  This deserves some investigation.  FIXME
-	archive_cmds='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-      else
-	ld_shlibs=no
-      fi
-      ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
-      # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
-      # as there is no search path for DLLs.
-      hardcode_libdir_flag_spec='-L$libdir'
-      export_dynamic_flag_spec='${wl}--export-all-symbols'
-      allow_undefined_flag=unsupported
-      always_export_symbols=no
-      enable_shared_with_static_runtimes=yes
-      export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[BCDGRS][ ]/s/.*[ ]\([^ ]*\)/\1 DATA/'\'' | $SED -e '\''/^[AITW][ ]/s/.*[ ]//'\'' | sort | uniq > $export_symbols'
 
-      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
-        archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
-	# If the export-symbols file already is a .def file (1st line
-	# is EXPORTS), use it as is; otherwise, prepend...
-	archive_expsym_cmds='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
-	  cp $export_symbols $output_objdir/$soname.def;
-	else
-	  echo EXPORTS > $output_objdir/$soname.def;
-	  cat $export_symbols >> $output_objdir/$soname.def;
-	fi~
-	$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
-      else
-	ld_shlibs=no
-      fi
-      ;;
 
-    haiku*)
-      archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-      link_all_deplibs=yes
+# Check whether --with-pic was given.
+if test "${with_pic+set}" = set; then :
+  withval=$with_pic; p=${PACKAGE-default}
+    case "$withval" in
+    yes|no) pic_mode="$withval" ;;
+    *)
+      pic_mode=default
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $withval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  pic_mode=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
       ;;
+    esac
+else
+  pic_mode=default
+fi
 
-    interix[3-9]*)
-      hardcode_direct=no
-      hardcode_shlibpath_var=no
-      hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
-      export_dynamic_flag_spec='${wl}-E'
-      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
-      # Instead, shared libraries are loaded at an image base (0x10000000 by
-      # default) and relocated if they conflict, which is a slow very memory
-      # consuming and fragmenting process.  To avoid this, we pick a random,
-      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
-      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
-      archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
-      archive_expsym_cmds='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
-      ;;
 
-    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)
-      tmp_diet=no
-      if test "$host_os" = linux-dietlibc; then
-	case $cc_basename in
-	  diet\ *) tmp_diet=yes;;	# linux-dietlibc with static linking (!diet-dyn)
-	esac
-      fi
-      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \
-	 && test "$tmp_diet" = no
-      then
-	tmp_addflag=
-	tmp_sharedflag='-shared'
-	case $cc_basename,$host_cpu in
-        pgcc*)				# Portland Group C compiler
-	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
-	  tmp_addflag=' $pic_flag'
-	  ;;
-	pgf77* | pgf90* | pgf95* | pgfortran*)
-					# Portland Group f77 and f90 compilers
-	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
-	  tmp_addflag=' $pic_flag -Mnomain' ;;
-	ecc*,ia64* | icc*,ia64*)	# Intel C compiler on ia64
-	  tmp_addflag=' -i_dynamic' ;;
-	efc*,ia64* | ifort*,ia64*)	# Intel Fortran compiler on ia64
-	  tmp_addflag=' -i_dynamic -nofor_main' ;;
-	ifc* | ifort*)			# Intel Fortran compiler
-	  tmp_addflag=' -nofor_main' ;;
-	lf95*)				# Lahey Fortran 8.1
-	  whole_archive_flag_spec=
-	  tmp_sharedflag='--shared' ;;
-	xl[cC]* | bgxl[cC]* | mpixl[cC]*) # IBM XL C 8.0 on PPC (deal with xlf below)
-	  tmp_sharedflag='-qmkshrobj'
-	  tmp_addflag= ;;
-	nvcc*)	# Cuda Compiler Driver 2.2
-	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
-	  compiler_needs_object=yes
-	  ;;
-	esac
-	case `$CC -V 2>&1 | sed 5q` in
-	*Sun\ C*)			# Sun C 5.9
-	  whole_archive_flag_spec='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
-	  compiler_needs_object=yes
-	  tmp_sharedflag='-G' ;;
-	*Sun\ F*)			# Sun Fortran 8.3
-	  tmp_sharedflag='-G' ;;
-	esac
-	archive_cmds='$CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+test -z "$pic_mode" && pic_mode=default
 
-        if test "x$supports_anon_versioning" = xyes; then
-          archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
-	    cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
-	    echo "local: *; };" >> $output_objdir/$libname.ver~
-	    $CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
-        fi
 
-	case $cc_basename in
-	xlf* | bgf* | bgxlf* | mpixlf*)
-	  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself
-	  whole_archive_flag_spec='--whole-archive$convenience --no-whole-archive'
-	  hardcode_libdir_flag_spec=
-	  hardcode_libdir_flag_spec_ld='-rpath $libdir'
-	  archive_cmds='$LD -shared $libobjs $deplibs $compiler_flags -soname $soname -o $lib'
-	  if test "x$supports_anon_versioning" = xyes; then
-	    archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
-	      cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
-	      echo "local: *; };" >> $output_objdir/$libname.ver~
-	      $LD -shared $libobjs $deplibs $compiler_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'
-	  fi
-	  ;;
-	esac
-      else
-        ld_shlibs=no
-      fi
-      ;;
 
-    netbsd*)
-      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
-	archive_cmds='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
-	wlarc=
-      else
-	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-      fi
-      ;;
 
-    solaris*)
-      if $LD -v 2>&1 | $GREP 'BFD 2\.8' > /dev/null; then
-	ld_shlibs=no
-	cat <<_LT_EOF 1>&2
 
-*** Warning: The releases 2.8.* of the GNU linker cannot reliably
-*** create shared libraries on Solaris systems.  Therefore, libtool
-*** is disabling shared libraries support.  We urge you to upgrade GNU
-*** binutils to release 2.9.1 or newer.  Another option is to modify
-*** your PATH or compiler configuration so that the native linker is
-*** used, and then restart.
 
-_LT_EOF
-      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-      else
-	ld_shlibs=no
-      fi
+
+  # Check whether --enable-fast-install was given.
+if test "${enable_fast_install+set}" = set; then :
+  enableval=$enable_fast_install; p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_fast_install=yes ;;
+    no) enable_fast_install=no ;;
+    *)
+      enable_fast_install=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_fast_install=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
       ;;
+    esac
+else
+  enable_fast_install=yes
+fi
 
-    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
-      case `$LD -v 2>&1` in
-        *\ [01].* | *\ 2.[0-9].* | *\ 2.1[0-5].*)
-	ld_shlibs=no
-	cat <<_LT_EOF 1>&2
 
-*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not
-*** reliably create shared libraries on SCO systems.  Therefore, libtool
-*** is disabling shared libraries support.  We urge you to upgrade GNU
-*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify
-*** your PATH or compiler configuration so that the native linker is
-*** used, and then restart.
 
-_LT_EOF
-	;;
-	*)
-	  # For security reasons, it is highly recommended that you always
-	  # use absolute paths for naming shared libraries, and exclude the
-	  # DT_RUNPATH tag from executables and libraries.  But doing so
-	  # requires that you compile everything twice, which is a pain.
-	  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-	    archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	    archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-	  else
-	    ld_shlibs=no
-	  fi
-	;;
-      esac
-      ;;
 
-    sunos4*)
-      archive_cmds='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
-      wlarc=
-      hardcode_direct=yes
-      hardcode_shlibpath_var=no
-      ;;
 
-    *)
-      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-      else
-	ld_shlibs=no
-      fi
-      ;;
-    esac
 
-    if test "$ld_shlibs" = no; then
-      runpath_var=
-      hardcode_libdir_flag_spec=
-      export_dynamic_flag_spec=
-      whole_archive_flag_spec=
-    fi
-  else
-    # PORTME fill in a description of your system's linker (not GNU ld)
-    case $host_os in
-    aix3*)
-      allow_undefined_flag=unsupported
-      always_export_symbols=yes
-      archive_expsym_cmds='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'
-      # Note: this linker hardcodes the directories in LIBPATH if there
-      # are no directories specified by -L.
-      hardcode_minus_L=yes
-      if test "$GCC" = yes && test -z "$lt_prog_compiler_static"; then
-	# Neither direct hardcoding nor static linking is supported with a
-	# broken collect2.
-	hardcode_direct=unsupported
-      fi
-      ;;
 
-    aix[4-9]*)
-      if test "$host_cpu" = ia64; then
-	# On IA64, the linker does run time linking by default, so we don't
-	# have to do anything special.
-	aix_use_runtimelinking=no
-	exp_sym_flag='-Bexport'
-	no_entry_flag=""
-      else
-	# If we're using GNU nm, then we don't want the "-C" option.
-	# -C means demangle to AIX nm, but means don't demangle with GNU nm
-	# Also, AIX nm treats weak defined symbols like other global
-	# defined symbols, whereas GNU nm marks them as "W".
-	if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
-	  export_symbols_cmds='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
-	else
-	  export_symbols_cmds='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
-	fi
-	aix_use_runtimelinking=no
 
-	# Test if we are trying to use run time linking or normal
-	# AIX style linking. If -brtl is somewhere in LDFLAGS, we
-	# need to do runtime linking.
-	case $host_os in aix4.[23]|aix4.[23].*|aix[5-9]*)
-	  for ld_flag in $LDFLAGS; do
-	  if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
-	    aix_use_runtimelinking=yes
-	    break
-	  fi
-	  done
-	  ;;
-	esac
 
-	exp_sym_flag='-bexport'
-	no_entry_flag='-bnoentry'
-      fi
 
-      # When large executables or shared objects are built, AIX ld can
-      # have problems creating the table of contents.  If linking a library
-      # or program results in "error TOC overflow" add -mminimal-toc to
-      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
-      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
 
-      archive_cmds=''
-      hardcode_direct=yes
-      hardcode_direct_absolute=yes
-      hardcode_libdir_separator=':'
-      link_all_deplibs=yes
-      file_list_spec='${wl}-f,'
+# This can be used to rebuild libtool when needed
+LIBTOOL_DEPS="$ltmain"
 
-      if test "$GCC" = yes; then
-	case $host_os in aix4.[012]|aix4.[012].*)
-	# We only want to do this on AIX 4.2 and lower, the check
-	# below for broken collect2 doesn't work under 4.3+
-	  collect2name=`${CC} -print-prog-name=collect2`
-	  if test -f "$collect2name" &&
-	   strings "$collect2name" | $GREP resolve_lib_name >/dev/null
-	  then
-	  # We have reworked collect2
-	  :
-	  else
-	  # We have old collect2
-	  hardcode_direct=unsupported
-	  # It fails to find uninstalled libraries when the uninstalled
-	  # path is not listed in the libpath.  Setting hardcode_minus_L
-	  # to unsupported forces relinking
-	  hardcode_minus_L=yes
-	  hardcode_libdir_flag_spec='-L$libdir'
-	  hardcode_libdir_separator=
-	  fi
-	  ;;
-	esac
-	shared_flag='-shared'
-	if test "$aix_use_runtimelinking" = yes; then
-	  shared_flag="$shared_flag "'${wl}-G'
-	fi
-      else
-	# not using gcc
-	if test "$host_cpu" = ia64; then
-	# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
-	# chokes on -Wl,-G. The following line is correct:
-	  shared_flag='-G'
-	else
-	  if test "$aix_use_runtimelinking" = yes; then
-	    shared_flag='${wl}-G'
-	  else
-	    shared_flag='${wl}-bM:SRE'
-	  fi
-	fi
-      fi
+# Always use our own libtool.
+LIBTOOL='$(SHELL) $(top_builddir)/libtool'
 
-      export_dynamic_flag_spec='${wl}-bexpall'
-      # It seems that -bexpall does not export symbols beginning with
-      # underscore (_), so it is better to generate a list of symbols to export.
-      always_export_symbols=yes
-      if test "$aix_use_runtimelinking" = yes; then
-	# Warning - without using the other runtime loading flags (-brtl),
-	# -berok will link without error, but may produce a broken library.
-	allow_undefined_flag='-berok'
-        # Determine the default libpath from the value encoded in an
-        # empty executable.
-        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
 
-int
-main ()
-{
 
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
 
-lt_aix_libpath_sed='
-    /Import File Strings/,/^$/ {
-	/^0/ {
-	    s/^0  *\(.*\)$/\1/
-	    p
-	}
-    }'
-aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-# Check for a 64-bit object if we didn't find anything.
-if test -z "$aix_libpath"; then
-  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-fi
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
 
-        hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
-        archive_expsym_cmds='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then func_echo_all "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
-      else
-	if test "$host_cpu" = ia64; then
-	  hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
-	  allow_undefined_flag="-z nodefs"
-	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
-	else
-	 # Determine the default libpath from the value encoded in an
-	 # empty executable.
-	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
 
-int
-main ()
-{
 
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
 
-lt_aix_libpath_sed='
-    /Import File Strings/,/^$/ {
-	/^0/ {
-	    s/^0  *\(.*\)$/\1/
-	    p
-	}
-    }'
-aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-# Check for a 64-bit object if we didn't find anything.
-if test -z "$aix_libpath"; then
-  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-fi
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
 
-	 hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
-	  # Warning - without using the other run time loading flags,
-	  # -berok will link without error, but may produce a broken library.
-	  no_undefined_flag=' ${wl}-bernotok'
-	  allow_undefined_flag=' ${wl}-berok'
-	  if test "$with_gnu_ld" = yes; then
-	    # We only use this code for GNU lds that support --whole-archive.
-	    whole_archive_flag_spec='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
-	  else
-	    # Exported symbols can be pulled into shared objects from archives
-	    whole_archive_flag_spec='$convenience'
-	  fi
-	  archive_cmds_need_lc=yes
-	  # This is similar to how AIX traditionally builds its shared libraries.
-	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
-	fi
-      fi
-      ;;
 
-    amigaos*)
-      case $host_cpu in
-      powerpc)
-            # see comment about AmigaOS4 .so support
-            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-            archive_expsym_cmds=''
-        ;;
-      m68k)
-            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
-            hardcode_libdir_flag_spec='-L$libdir'
-            hardcode_minus_L=yes
-        ;;
-      esac
-      ;;
 
-    bsdi[45]*)
-      export_dynamic_flag_spec=-rdynamic
-      ;;
 
-    cygwin* | mingw* | pw32* | cegcc*)
-      # When not using gcc, we currently assume that we are using
-      # Microsoft Visual C++.
-      # hardcode_libdir_flag_spec is actually meaningless, as there is
-      # no search path for DLLs.
-      hardcode_libdir_flag_spec=' '
-      allow_undefined_flag=unsupported
-      # Tell ltmain to make .lib files, not .a files.
-      libext=lib
-      # Tell ltmain to make .dll files, not .so files.
-      shrext_cmds=".dll"
-      # FIXME: Setting linknames here is a bad hack.
-      archive_cmds='$CC -o $lib $libobjs $compiler_flags `func_echo_all "$deplibs" | $SED '\''s/ -lc$//'\''` -link -dll~linknames='
-      # The linker will automatically build a .lib file if we build a DLL.
-      old_archive_from_new_cmds='true'
-      # FIXME: Should let the user specify the lib program.
-      old_archive_cmds='lib -OUT:$oldlib$oldobjs$old_deplibs'
-      fix_srcfile_path='`cygpath -w "$srcfile"`'
-      enable_shared_with_static_runtimes=yes
-      ;;
 
-    darwin* | rhapsody*)
 
 
-  archive_cmds_need_lc=no
-  hardcode_direct=no
-  hardcode_automatic=yes
-  hardcode_shlibpath_var=unsupported
-  if test "$lt_cv_ld_force_load" = "yes"; then
-    whole_archive_flag_spec='`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience ${wl}-force_load,$conv\"; done; func_echo_all \"$new_convenience\"`'
-  else
-    whole_archive_flag_spec=''
-  fi
-  link_all_deplibs=yes
-  allow_undefined_flag="$_lt_dar_allow_undefined"
-  case $cc_basename in
-     ifort*) _lt_dar_can_shared=yes ;;
-     *) _lt_dar_can_shared=$GCC ;;
-  esac
-  if test "$_lt_dar_can_shared" = "yes"; then
-    output_verbose_link_cmd=func_echo_all
-    archive_cmds="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
-    module_cmds="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
-    archive_expsym_cmds="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
-    module_expsym_cmds="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
 
-  else
-  ld_shlibs=no
-  fi
 
-      ;;
 
-    dgux*)
-      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_shlibpath_var=no
-      ;;
 
-    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor
-    # support.  Future versions do this automatically, but an explicit c++rt0.o
-    # does not break anything, and helps significantly (at the cost of a little
-    # extra space).
-    freebsd2.2*)
-      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_direct=yes
-      hardcode_shlibpath_var=no
-      ;;
 
-    # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2.*)
-      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_direct=yes
-      hardcode_minus_L=yes
-      hardcode_shlibpath_var=no
-      ;;
 
-    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
-    freebsd* | dragonfly*)
-      archive_cmds='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_direct=yes
-      hardcode_shlibpath_var=no
-      ;;
 
-    hpux9*)
-      if test "$GCC" = yes; then
-	archive_cmds='$RM $output_objdir/$soname~$CC -shared -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
-      else
-	archive_cmds='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
-      fi
-      hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
-      hardcode_libdir_separator=:
-      hardcode_direct=yes
 
-      # hardcode_minus_L: Not really in the search PATH,
-      # but as the default location of the library.
-      hardcode_minus_L=yes
-      export_dynamic_flag_spec='${wl}-E'
-      ;;
 
-    hpux10*)
-      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
-	archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
-      else
-	archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
-      fi
-      if test "$with_gnu_ld" = no; then
-	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
-	hardcode_libdir_flag_spec_ld='+b $libdir'
-	hardcode_libdir_separator=:
-	hardcode_direct=yes
-	hardcode_direct_absolute=yes
-	export_dynamic_flag_spec='${wl}-E'
-	# hardcode_minus_L: Not really in the search PATH,
-	# but as the default location of the library.
-	hardcode_minus_L=yes
-      fi
-      ;;
 
-    hpux11*)
-      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
-	case $host_cpu in
-	hppa*64*)
-	  archive_cmds='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	ia64*)
-	  archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	*)
-	  archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	esac
-      else
-	case $host_cpu in
-	hppa*64*)
-	  archive_cmds='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	ia64*)
-	  archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	*)
 
-	  # Older versions of the 11.00 compiler do not understand -b yet
-	  # (HP92453-01 A.11.01.20 doesn't, HP92453-01 B.11.X.35175-35176.GP does)
-	  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $CC understands -b" >&5
-$as_echo_n "checking if $CC understands -b... " >&6; }
-if test "${lt_cv_prog_compiler__b+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler__b=no
-   save_LDFLAGS="$LDFLAGS"
-   LDFLAGS="$LDFLAGS -b"
-   echo "$lt_simple_link_test_code" > conftest.$ac_ext
-   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
-     # The linker can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     if test -s conftest.err; then
-       # Append any errors to the config.log.
-       cat conftest.err 1>&5
-       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
-       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
-       if diff conftest.exp conftest.er2 >/dev/null; then
-         lt_cv_prog_compiler__b=yes
-       fi
-     else
-       lt_cv_prog_compiler__b=yes
-     fi
-   fi
-   $RM -r conftest*
-   LDFLAGS="$save_LDFLAGS"
+test -z "$LN_S" && LN_S="ln -s"
+
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler__b" >&5
-$as_echo "$lt_cv_prog_compiler__b" >&6; }
 
-if test x"$lt_cv_prog_compiler__b" = xyes; then
-    archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
-else
-    archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
-fi
 
-	  ;;
-	esac
-      fi
-      if test "$with_gnu_ld" = no; then
-	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
-	hardcode_libdir_separator=:
 
-	case $host_cpu in
-	hppa*64*|ia64*)
-	  hardcode_direct=no
-	  hardcode_shlibpath_var=no
-	  ;;
-	*)
-	  hardcode_direct=yes
-	  hardcode_direct_absolute=yes
-	  export_dynamic_flag_spec='${wl}-E'
 
-	  # hardcode_minus_L: Not really in the search PATH,
-	  # but as the default location of the library.
-	  hardcode_minus_L=yes
-	  ;;
-	esac
-      fi
-      ;;
 
-    irix5* | irix6* | nonstopux*)
-      if test "$GCC" = yes; then
-	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
-	# Try to use the -exported_symbol ld option, if it does not
-	# work, assume that -exports_file does not work either and
-	# implicitly export all symbols.
-        save_LDFLAGS="$LDFLAGS"
-        LDFLAGS="$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null"
-        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int foo(void) {}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'
 
+
+
+
+
+
+
+if test -n "${ZSH_VERSION+set}" ; then
+   setopt NO_GLOB_SUBST
 fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-        LDFLAGS="$save_LDFLAGS"
-      else
-	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
-	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'
-      fi
-      archive_cmds_need_lc='no'
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      hardcode_libdir_separator=:
-      inherit_rpath=yes
-      link_all_deplibs=yes
-      ;;
 
-    netbsd*)
-      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
-	archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
-      else
-	archive_cmds='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF
-      fi
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_direct=yes
-      hardcode_shlibpath_var=no
-      ;;
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for objdir" >&5
+$as_echo_n "checking for objdir... " >&6; }
+if test "${lt_cv_objdir+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  rm -f .libs 2>/dev/null
+mkdir .libs 2>/dev/null
+if test -d .libs; then
+  lt_cv_objdir=.libs
+else
+  # MS-DOS does not allow filenames that begin with a dot.
+  lt_cv_objdir=_libs
+fi
+rmdir .libs 2>/dev/null
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_objdir" >&5
+$as_echo "$lt_cv_objdir" >&6; }
+objdir=$lt_cv_objdir
 
-    newsos6)
-      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_direct=yes
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      hardcode_libdir_separator=:
-      hardcode_shlibpath_var=no
-      ;;
 
-    *nto* | *qnx*)
-      ;;
 
-    openbsd*)
-      if test -f /usr/libexec/ld.so; then
-	hardcode_direct=yes
-	hardcode_shlibpath_var=no
-	hardcode_direct_absolute=yes
-	if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
-	  archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
-	  archive_expsym_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'
-	  hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
-	  export_dynamic_flag_spec='${wl}-E'
-	else
-	  case $host_os in
-	   openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
-	     archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
-	     hardcode_libdir_flag_spec='-R$libdir'
-	     ;;
-	   *)
-	     archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
-	     hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
-	     ;;
-	  esac
-	fi
-      else
-	ld_shlibs=no
-      fi
-      ;;
 
-    os2*)
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_minus_L=yes
-      allow_undefined_flag=unsupported
-      archive_cmds='$ECHO "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~echo DATA >> $output_objdir/$libname.def~echo " SINGLE NONSHARED" >> $output_objdir/$libname.def~echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
-      old_archive_from_new_cmds='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
-      ;;
 
-    osf3*)
-      if test "$GCC" = yes; then
-	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
-      else
-	allow_undefined_flag=' -expect_unresolved \*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
-      fi
-      archive_cmds_need_lc='no'
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      hardcode_libdir_separator=:
-      ;;
+cat >>confdefs.h <<_ACEOF
+#define LT_OBJDIR "$lt_cv_objdir/"
+_ACEOF
 
-    osf4* | osf5*)	# as osf3* with the addition of -msym flag
-      if test "$GCC" = yes; then
-	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
-	hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      else
-	allow_undefined_flag=' -expect_unresolved \*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
-	archive_expsym_cmds='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done; printf "%s\\n" "-hidden">> $lib.exp~
-	$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'
 
-	# Both c and cxx compiler support -rpath directly
-	hardcode_libdir_flag_spec='-rpath $libdir'
-      fi
-      archive_cmds_need_lc='no'
-      hardcode_libdir_separator=:
-      ;;
 
-    solaris*)
-      no_undefined_flag=' -z defs'
-      if test "$GCC" = yes; then
-	wlarc='${wl}'
-	archive_cmds='$CC -shared ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	  $CC -shared ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
-      else
-	case `$CC -V 2>&1` in
-	*"Compilers 5.0"*)
-	  wlarc=''
-	  archive_cmds='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
-	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'
-	  ;;
-	*)
-	  wlarc='${wl}'
-	  archive_cmds='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'
-	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
-	  ;;
-	esac
-      fi
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_shlibpath_var=no
-      case $host_os in
-      solaris2.[0-5] | solaris2.[0-5].*) ;;
-      *)
-	# The compiler driver will combine and reorder linker options,
-	# but understands `-z linker_flag'.  GCC discards it without `$wl',
-	# but is careful enough not to reorder.
-	# Supported since Solaris 2.6 (maybe 2.5.1?)
-	if test "$GCC" = yes; then
-	  whole_archive_flag_spec='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
-	else
-	  whole_archive_flag_spec='-z allextract$convenience -z defaultextract'
-	fi
-	;;
-      esac
-      link_all_deplibs=yes
-      ;;
 
-    sunos4*)
-      if test "x$host_vendor" = xsequent; then
-	# Use $CC to link under sequent, because it throws in some extra .o
-	# files that make .init and .fini sections work.
-	archive_cmds='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'
-      else
-	archive_cmds='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
-      fi
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_direct=yes
-      hardcode_minus_L=yes
-      hardcode_shlibpath_var=no
-      ;;
+case $host_os in
+aix3*)
+  # AIX sometimes has problems with the GCC collect2 program.  For some
+  # reason, if we set the COLLECT_NAMES environment variable, the problems
+  # vanish in a puff of smoke.
+  if test "X${COLLECT_NAMES+set}" != Xset; then
+    COLLECT_NAMES=
+    export COLLECT_NAMES
+  fi
+  ;;
+esac
 
-    sysv4)
-      case $host_vendor in
-	sni)
-	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-	  hardcode_direct=yes # is this really true???
-	;;
-	siemens)
-	  ## LD is ld it makes a PLAMLIB
-	  ## CC just makes a GrossModule.
-	  archive_cmds='$LD -G -o $lib $libobjs $deplibs $linker_flags'
-	  reload_cmds='$CC -r -o $output$reload_objs'
-	  hardcode_direct=no
-        ;;
-	motorola)
-	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-	  hardcode_direct=no #Motorola manual says yes, but my tests say they lie
-	;;
-      esac
-      runpath_var='LD_RUN_PATH'
-      hardcode_shlibpath_var=no
-      ;;
+# Global variables:
+ofile=libtool
+can_build_shared=yes
 
-    sysv4.3*)
-      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_shlibpath_var=no
-      export_dynamic_flag_spec='-Bexport'
-      ;;
+# All known linkers require a `.a' archive for static linking (except MSVC,
+# which needs '.lib').
+libext=a
 
-    sysv4*MP*)
-      if test -d /usr/nec; then
-	archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-	hardcode_shlibpath_var=no
-	runpath_var=LD_RUN_PATH
-	hardcode_runpath_var=yes
-	ld_shlibs=yes
-      fi
-      ;;
+with_gnu_ld="$lt_cv_prog_gnu_ld"
 
-    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)
-      no_undefined_flag='${wl}-z,text'
-      archive_cmds_need_lc=no
-      hardcode_shlibpath_var=no
-      runpath_var='LD_RUN_PATH'
+old_CC="$CC"
+old_CFLAGS="$CFLAGS"
 
-      if test "$GCC" = yes; then
-	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-      else
-	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-      fi
-      ;;
+# Set sane defaults for various variables
+test -z "$CC" && CC=cc
+test -z "$LTCC" && LTCC=$CC
+test -z "$LTCFLAGS" && LTCFLAGS=$CFLAGS
+test -z "$LD" && LD=ld
+test -z "$ac_objext" && ac_objext=o
 
-    sysv5* | sco3.2v5* | sco5v6*)
-      # Note: We can NOT use -z defs as we might desire, because we do not
-      # link with -lc, and that would cause any symbols used from libc to
-      # always be unresolved, which means just about no library would
-      # ever link correctly.  If we're not using GNU ld we use -z text
-      # though, which does catch some bad symbols but isn't as heavy-handed
-      # as -z defs.
-      no_undefined_flag='${wl}-z,text'
-      allow_undefined_flag='${wl}-z,nodefs'
-      archive_cmds_need_lc=no
-      hardcode_shlibpath_var=no
-      hardcode_libdir_flag_spec='${wl}-R,$libdir'
-      hardcode_libdir_separator=':'
-      link_all_deplibs=yes
-      export_dynamic_flag_spec='${wl}-Bexport'
-      runpath_var='LD_RUN_PATH'
+for cc_temp in $compiler""; do
+  case $cc_temp in
+    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
+    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
+done
+cc_basename=`$ECHO "$cc_temp" | $SED "s%.*/%%; s%^$host_alias-%%"`
 
-      if test "$GCC" = yes; then
-	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-      else
-	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-      fi
-      ;;
 
-    uts4*)
-      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_shlibpath_var=no
-      ;;
+# Only perform the check for file, if the check method requires it
+test -z "$MAGIC_CMD" && MAGIC_CMD=file
+case $deplibs_check_method in
+file_magic*)
+  if test "$file_magic_cmd" = '$MAGIC_CMD'; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${ac_tool_prefix}file" >&5
+$as_echo_n "checking for ${ac_tool_prefix}file... " >&6; }
+if test "${lt_cv_path_MAGIC_CMD+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $MAGIC_CMD in
+[\\/*] |  ?:[\\/]*)
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  ;;
+*)
+  lt_save_MAGIC_CMD="$MAGIC_CMD"
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
+  for ac_dir in $ac_dummy; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/${ac_tool_prefix}file; then
+      lt_cv_path_MAGIC_CMD="$ac_dir/${ac_tool_prefix}file"
+      if test -n "$file_magic_test_file"; then
+	case $deplibs_check_method in
+	"file_magic "*)
+	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
+	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
+	    $EGREP "$file_magic_regex" > /dev/null; then
+	    :
+	  else
+	    cat <<_LT_EOF 1>&2
 
-    *)
-      ld_shlibs=no
-      ;;
-    esac
+*** Warning: the command libtool uses to detect shared libraries,
+*** $file_magic_cmd, produces output that libtool cannot recognize.
+*** The result is that libtool may fail to recognize shared libraries
+*** as such.  This will affect the creation of libtool libraries that
+*** depend on shared libraries, but programs linked with such libtool
+*** libraries will work regardless of this problem.  Nevertheless, you
+*** may want to report the problem to your system manager and/or to
+*** bug-libtool@gnu.org
 
-    if test x$host_vendor = xsni; then
-      case $host in
-      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
-	export_dynamic_flag_spec='${wl}-Blargedynsym'
-	;;
-      esac
+_LT_EOF
+	  fi ;;
+	esac
+      fi
+      break
     fi
-  fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs" >&5
-$as_echo "$ld_shlibs" >&6; }
-test "$ld_shlibs" = no && can_build_shared=no
-
-with_gnu_ld=$with_gnu_ld
-
-
-
-
-
-
-
+  done
+  IFS="$lt_save_ifs"
+  MAGIC_CMD="$lt_save_MAGIC_CMD"
+  ;;
+esac
+fi
 
+MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+if test -n "$MAGIC_CMD"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
+$as_echo "$MAGIC_CMD" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
 
 
 
 
 
+if test -z "$lt_cv_path_MAGIC_CMD"; then
+  if test -n "$ac_tool_prefix"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for file" >&5
+$as_echo_n "checking for file... " >&6; }
+if test "${lt_cv_path_MAGIC_CMD+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $MAGIC_CMD in
+[\\/*] |  ?:[\\/]*)
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  ;;
+*)
+  lt_save_MAGIC_CMD="$MAGIC_CMD"
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
+  for ac_dir in $ac_dummy; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/file; then
+      lt_cv_path_MAGIC_CMD="$ac_dir/file"
+      if test -n "$file_magic_test_file"; then
+	case $deplibs_check_method in
+	"file_magic "*)
+	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
+	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
+	    $EGREP "$file_magic_regex" > /dev/null; then
+	    :
+	  else
+	    cat <<_LT_EOF 1>&2
 
+*** Warning: the command libtool uses to detect shared libraries,
+*** $file_magic_cmd, produces output that libtool cannot recognize.
+*** The result is that libtool may fail to recognize shared libraries
+*** as such.  This will affect the creation of libtool libraries that
+*** depend on shared libraries, but programs linked with such libtool
+*** libraries will work regardless of this problem.  Nevertheless, you
+*** may want to report the problem to your system manager and/or to
+*** bug-libtool@gnu.org
 
-#
-# Do we need to explicitly link libc?
-#
-case "x$archive_cmds_need_lc" in
-x|xyes)
-  # Assume -lc should be added
-  archive_cmds_need_lc=yes
+_LT_EOF
+	  fi ;;
+	esac
+      fi
+      break
+    fi
+  done
+  IFS="$lt_save_ifs"
+  MAGIC_CMD="$lt_save_MAGIC_CMD"
+  ;;
+esac
+fi
 
-  if test "$enable_shared" = yes && test "$GCC" = yes; then
-    case $archive_cmds in
-    *'~'*)
-      # FIXME: we may have to deal with multi-command sequences.
-      ;;
-    '$CC '*)
-      # Test whether the compiler implicitly links with -lc since on some
-      # systems, -lgcc has to come before -lc. If gcc already passes -lc
-      # to ld, don't add -lc before -lgcc.
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -lc should be explicitly linked in" >&5
-$as_echo_n "checking whether -lc should be explicitly linked in... " >&6; }
-if test "${lt_cv_archive_cmds_need_lc+set}" = set; then :
-  $as_echo_n "(cached) " >&6
+MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+if test -n "$MAGIC_CMD"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
+$as_echo "$MAGIC_CMD" >&6; }
 else
-  $RM conftest*
-	echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
 
-	if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } 2>conftest.err; then
-	  soname=conftest
-	  lib=conftest
-	  libobjs=conftest.$ac_objext
-	  deplibs=
-	  wl=$lt_prog_compiler_wl
-	  pic_flag=$lt_prog_compiler_pic
-	  compiler_flags=-v
-	  linker_flags=-v
-	  verstring=
-	  output_objdir=.
-	  libname=conftest
-	  lt_save_allow_undefined_flag=$allow_undefined_flag
-	  allow_undefined_flag=
-	  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1\""; } >&5
-  (eval $archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }
-	  then
-	    lt_cv_archive_cmds_need_lc=no
-	  else
-	    lt_cv_archive_cmds_need_lc=yes
-	  fi
-	  allow_undefined_flag=$lt_save_allow_undefined_flag
-	else
-	  cat conftest.err 1>&5
-	fi
-	$RM conftest*
 
+  else
+    MAGIC_CMD=:
+  fi
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_archive_cmds_need_lc" >&5
-$as_echo "$lt_cv_archive_cmds_need_lc" >&6; }
-      archive_cmds_need_lc=$lt_cv_archive_cmds_need_lc
-      ;;
-    esac
+
   fi
   ;;
 esac
 
+# Use C for the default configuration in the libtool script
 
+lt_save_CC="$CC"
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
+# Source file extension for C test sources.
+ac_ext=c
 
+# Object file extension for compiled C test sources.
+objext=o
+objext=$objext
 
+# Code to be used in simple compile tests
+lt_simple_compile_test_code="int some_variable = 0;"
 
+# Code to be used in simple link tests
+lt_simple_link_test_code='int main(){return(0);}'
 
 
 
@@ -9362,74 +8095,497 @@ esac
 
 
 
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
 
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
 
+# Allow CC to be a program name with arguments.
+compiler=$CC
 
+# Save the default compiler, since it gets overwritten when the other
+# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.
+compiler_DEFAULT=$CC
 
+# save warnings/boilerplate of simple test code
+ac_outfile=conftest.$ac_objext
+echo "$lt_simple_compile_test_code" >conftest.$ac_ext
+eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_compiler_boilerplate=`cat conftest.err`
+$RM conftest*
 
+ac_outfile=conftest.$ac_objext
+echo "$lt_simple_link_test_code" >conftest.$ac_ext
+eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_linker_boilerplate=`cat conftest.err`
+$RM -r conftest*
 
 
+## CAVEAT EMPTOR:
+## There is no encapsulation within the following macros, do not change
+## the running order or otherwise move them around unless you know exactly
+## what you are doing...
+if test -n "$compiler"; then
 
+lt_prog_compiler_no_builtin_flag=
 
+if test "$GCC" = yes; then
+  case $cc_basename in
+  nvcc*)
+    lt_prog_compiler_no_builtin_flag=' -Xcompiler -fno-builtin' ;;
+  *)
+    lt_prog_compiler_no_builtin_flag=' -fno-builtin' ;;
+  esac
 
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -fno-rtti -fno-exceptions" >&5
+$as_echo_n "checking if $compiler supports -fno-rtti -fno-exceptions... " >&6; }
+if test "${lt_cv_prog_compiler_rtti_exceptions+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_rtti_exceptions=no
+   ac_outfile=conftest.$ac_objext
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="-fno-rtti -fno-exceptions"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&5
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_rtti_exceptions=yes
+     fi
+   fi
+   $RM conftest*
 
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_rtti_exceptions" >&5
+$as_echo "$lt_cv_prog_compiler_rtti_exceptions" >&6; }
 
+if test x"$lt_cv_prog_compiler_rtti_exceptions" = xyes; then
+    lt_prog_compiler_no_builtin_flag="$lt_prog_compiler_no_builtin_flag -fno-rtti -fno-exceptions"
+else
+    :
+fi
 
+fi
 
 
 
 
 
 
+  lt_prog_compiler_wl=
+lt_prog_compiler_pic=
+lt_prog_compiler_static=
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $compiler option to produce PIC" >&5
+$as_echo_n "checking for $compiler option to produce PIC... " >&6; }
 
+  if test "$GCC" = yes; then
+    lt_prog_compiler_wl='-Wl,'
+    lt_prog_compiler_static='-static'
 
+    case $host_os in
+      aix*)
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	lt_prog_compiler_static='-Bstatic'
+      fi
+      lt_prog_compiler_pic='-fPIC'
+      ;;
 
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            lt_prog_compiler_pic='-fPIC'
+        ;;
+      m68k)
+            # FIXME: we need at least 68020 code to build shared libraries, but
+            # adding the `-m68020' flag to GCC prevents building anything better,
+            # like `-m68040'.
+            lt_prog_compiler_pic='-m68020 -resident32 -malways-restore-a4'
+        ;;
+      esac
+      ;;
 
+    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
 
+    mingw* | cygwin* | pw32* | os2* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      # Although the cygwin gcc ignores -fPIC, still need this for old-style
+      # (--disable-auto-import) libraries
+      lt_prog_compiler_pic='-DDLL_EXPORT'
+      ;;
 
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      lt_prog_compiler_pic='-fno-common'
+      ;;
 
+    haiku*)
+      # PIC is the default for Haiku.
+      # The "-static" flag exists, but is broken.
+      lt_prog_compiler_static=
+      ;;
 
+    hpux*)
+      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
+      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
+      # sets the default TLS model and affects inlining.
+      case $host_cpu in
+      hppa*64*)
+	# +Z the default
+	;;
+      *)
+	lt_prog_compiler_pic='-fPIC'
+	;;
+      esac
+      ;;
 
+    interix[3-9]*)
+      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
+      # Instead, we relocate shared libraries at runtime.
+      ;;
 
+    msdosdjgpp*)
+      # Just because we use GCC doesn't mean we suddenly get shared libraries
+      # on systems that don't support them.
+      lt_prog_compiler_can_build_shared=no
+      enable_shared=no
+      ;;
 
+    *nto* | *qnx*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      lt_prog_compiler_pic='-fPIC -shared'
+      ;;
 
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	lt_prog_compiler_pic=-Kconform_pic
+      fi
+      ;;
 
+    *)
+      lt_prog_compiler_pic='-fPIC'
+      ;;
+    esac
 
+    case $cc_basename in
+    nvcc*) # Cuda Compiler Driver 2.2
+      lt_prog_compiler_wl='-Xlinker '
+      lt_prog_compiler_pic='-Xcompiler -fPIC'
+      ;;
+    esac
+  else
+    # PORTME Check for flag to pass linker flags through the system compiler.
+    case $host_os in
+    aix*)
+      lt_prog_compiler_wl='-Wl,'
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	lt_prog_compiler_static='-Bstatic'
+      else
+	lt_prog_compiler_static='-bnso -bI:/lib/syscalls.exp'
+      fi
+      ;;
 
+    mingw* | cygwin* | pw32* | os2* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      lt_prog_compiler_pic='-DDLL_EXPORT'
+      ;;
 
+    hpux9* | hpux10* | hpux11*)
+      lt_prog_compiler_wl='-Wl,'
+      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but
+      # not for PA HP-UX.
+      case $host_cpu in
+      hppa*64*|ia64*)
+	# +Z the default
+	;;
+      *)
+	lt_prog_compiler_pic='+Z'
+	;;
+      esac
+      # Is there a better lt_prog_compiler_static that works with the bundled CC?
+      lt_prog_compiler_static='${wl}-a ${wl}archive'
+      ;;
 
+    irix5* | irix6* | nonstopux*)
+      lt_prog_compiler_wl='-Wl,'
+      # PIC (with -KPIC) is the default.
+      lt_prog_compiler_static='-non_shared'
+      ;;
 
+    linux* | k*bsd*-gnu | kopensolaris*-gnu)
+      case $cc_basename in
+      # old Intel for x86_64 which still supported -KPIC.
+      ecc*)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-KPIC'
+	lt_prog_compiler_static='-static'
+        ;;
+      # icc used to be incompatible with GCC.
+      # ICC 10 doesn't accept -KPIC any more.
+      icc* | ifort*)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-fPIC'
+	lt_prog_compiler_static='-static'
+        ;;
+      # Lahey Fortran 8.1.
+      lf95*)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='--shared'
+	lt_prog_compiler_static='--static'
+	;;
+      pgcc* | pgf77* | pgf90* | pgf95* | pgfortran*)
+        # Portland Group compilers (*not* the Pentium gcc compiler,
+	# which looks to be a dead project)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-fpic'
+	lt_prog_compiler_static='-Bstatic'
+        ;;
+      ccc*)
+        lt_prog_compiler_wl='-Wl,'
+        # All Alpha code is PIC.
+        lt_prog_compiler_static='-non_shared'
+        ;;
+      xl* | bgxl* | bgf* | mpixl*)
+	# IBM XL C 8.0/Fortran 10.1, 11.1 on PPC and BlueGene
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-qpic'
+	lt_prog_compiler_static='-qstaticlink'
+	;;
+      *)
+	case `$CC -V 2>&1 | sed 5q` in
+	*Sun\ F* | *Sun*Fortran*)
+	  # Sun Fortran 8.3 passes all unrecognized flags to the linker
+	  lt_prog_compiler_pic='-KPIC'
+	  lt_prog_compiler_static='-Bstatic'
+	  lt_prog_compiler_wl=''
+	  ;;
+	*Sun\ C*)
+	  # Sun C 5.9
+	  lt_prog_compiler_pic='-KPIC'
+	  lt_prog_compiler_static='-Bstatic'
+	  lt_prog_compiler_wl='-Wl,'
+	  ;;
+	esac
+	;;
+      esac
+      ;;
 
+    newsos6)
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
 
+    *nto* | *qnx*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      lt_prog_compiler_pic='-fPIC -shared'
+      ;;
 
+    osf3* | osf4* | osf5*)
+      lt_prog_compiler_wl='-Wl,'
+      # All OSF/1 code is PIC.
+      lt_prog_compiler_static='-non_shared'
+      ;;
 
+    rdos*)
+      lt_prog_compiler_static='-non_shared'
+      ;;
 
+    solaris*)
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      case $cc_basename in
+      f77* | f90* | f95*)
+	lt_prog_compiler_wl='-Qoption ld ';;
+      *)
+	lt_prog_compiler_wl='-Wl,';;
+      esac
+      ;;
 
+    sunos4*)
+      lt_prog_compiler_wl='-Qoption ld '
+      lt_prog_compiler_pic='-PIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
 
+    sysv4 | sysv4.2uw2* | sysv4.3*)
+      lt_prog_compiler_wl='-Wl,'
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
 
+    sysv4*MP*)
+      if test -d /usr/nec ;then
+	lt_prog_compiler_pic='-Kconform_pic'
+	lt_prog_compiler_static='-Bstatic'
+      fi
+      ;;
 
+    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+      lt_prog_compiler_wl='-Wl,'
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
 
+    unicos*)
+      lt_prog_compiler_wl='-Wl,'
+      lt_prog_compiler_can_build_shared=no
+      ;;
 
+    uts4*)
+      lt_prog_compiler_pic='-pic'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
 
+    *)
+      lt_prog_compiler_can_build_shared=no
+      ;;
+    esac
+  fi
 
+case $host_os in
+  # For platforms which do not support PIC, -DPIC is meaningless:
+  *djgpp*)
+    lt_prog_compiler_pic=
+    ;;
+  *)
+    lt_prog_compiler_pic="$lt_prog_compiler_pic -DPIC"
+    ;;
+esac
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_prog_compiler_pic" >&5
+$as_echo "$lt_prog_compiler_pic" >&6; }
 
 
 
 
 
 
+#
+# Check to make sure the PIC flag actually works.
+#
+if test -n "$lt_prog_compiler_pic"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler PIC flag $lt_prog_compiler_pic works" >&5
+$as_echo_n "checking if $compiler PIC flag $lt_prog_compiler_pic works... " >&6; }
+if test "${lt_cv_prog_compiler_pic_works+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_pic_works=no
+   ac_outfile=conftest.$ac_objext
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="$lt_prog_compiler_pic -DPIC"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&5
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_pic_works=yes
+     fi
+   fi
+   $RM conftest*
 
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_pic_works" >&5
+$as_echo "$lt_cv_prog_compiler_pic_works" >&6; }
 
+if test x"$lt_cv_prog_compiler_pic_works" = xyes; then
+    case $lt_prog_compiler_pic in
+     "" | " "*) ;;
+     *) lt_prog_compiler_pic=" $lt_prog_compiler_pic" ;;
+     esac
+else
+    lt_prog_compiler_pic=
+     lt_prog_compiler_can_build_shared=no
+fi
 
+fi
 
 
 
 
 
 
+#
+# Check to make sure the static flag actually works.
+#
+wl=$lt_prog_compiler_wl eval lt_tmp_static_flag=\"$lt_prog_compiler_static\"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler static flag $lt_tmp_static_flag works" >&5
+$as_echo_n "checking if $compiler static flag $lt_tmp_static_flag works... " >&6; }
+if test "${lt_cv_prog_compiler_static_works+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_static_works=no
+   save_LDFLAGS="$LDFLAGS"
+   LDFLAGS="$LDFLAGS $lt_tmp_static_flag"
+   echo "$lt_simple_link_test_code" > conftest.$ac_ext
+   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
+     # The linker can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     if test -s conftest.err; then
+       # Append any errors to the config.log.
+       cat conftest.err 1>&5
+       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
+       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+       if diff conftest.exp conftest.er2 >/dev/null; then
+         lt_cv_prog_compiler_static_works=yes
+       fi
+     else
+       lt_cv_prog_compiler_static_works=yes
+     fi
+   fi
+   $RM -r conftest*
+   LDFLAGS="$save_LDFLAGS"
 
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_static_works" >&5
+$as_echo "$lt_cv_prog_compiler_static_works" >&6; }
 
+if test x"$lt_cv_prog_compiler_static_works" = xyes; then
+    :
+else
+    lt_prog_compiler_static=
+fi
 
 
 
@@ -9437,777 +8593,5119 @@ esac
 
 
 
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
+$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
+if test "${lt_cv_prog_compiler_c_o+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_c_o=no
+   $RM -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
 
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&5
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_c_o=yes
+     fi
+   fi
+   chmod u+w . 2>&5
+   $RM conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
+   $RM out/* && rmdir out
+   cd ..
+   $RM -r conftest
+   $RM conftest*
 
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o" >&5
+$as_echo "$lt_cv_prog_compiler_c_o" >&6; }
 
 
 
 
 
 
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
+$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
+if test "${lt_cv_prog_compiler_c_o+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_c_o=no
+   $RM -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
 
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&5
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_c_o=yes
+     fi
+   fi
+   chmod u+w . 2>&5
+   $RM conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
+   $RM out/* && rmdir out
+   cd ..
+   $RM -r conftest
+   $RM conftest*
 
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o" >&5
+$as_echo "$lt_cv_prog_compiler_c_o" >&6; }
 
 
 
 
+hard_links="nottested"
+if test "$lt_cv_prog_compiler_c_o" = no && test "$need_locks" != no; then
+  # do not overwrite the value of need_locks provided by the user
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if we can lock with hard links" >&5
+$as_echo_n "checking if we can lock with hard links... " >&6; }
+  hard_links=yes
+  $RM conftest*
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  touch conftest.a
+  ln conftest.a conftest.b 2>&5 || hard_links=no
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $hard_links" >&5
+$as_echo "$hard_links" >&6; }
+  if test "$hard_links" = no; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
+$as_echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
+    need_locks=warn
+  fi
+else
+  need_locks=no
+fi
 
 
 
 
 
 
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $compiler linker ($LD) supports shared libraries" >&5
+$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
 
+  runpath_var=
+  allow_undefined_flag=
+  always_export_symbols=no
+  archive_cmds=
+  archive_expsym_cmds=
+  compiler_needs_object=no
+  enable_shared_with_static_runtimes=no
+  export_dynamic_flag_spec=
+  export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  hardcode_automatic=no
+  hardcode_direct=no
+  hardcode_direct_absolute=no
+  hardcode_libdir_flag_spec=
+  hardcode_libdir_flag_spec_ld=
+  hardcode_libdir_separator=
+  hardcode_minus_L=no
+  hardcode_shlibpath_var=unsupported
+  inherit_rpath=no
+  link_all_deplibs=unknown
+  module_cmds=
+  module_expsym_cmds=
+  old_archive_from_new_cmds=
+  old_archive_from_expsyms_cmds=
+  thread_safe_flag_spec=
+  whole_archive_flag_spec=
+  # include_expsyms should be a list of space-separated symbols to be *always*
+  # included in the symbol list
+  include_expsyms=
+  # exclude_expsyms can be an extended regexp of symbols to exclude
+  # it will be wrapped by ` (' and `)$', so one must not match beginning or
+  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
+  # as well as any symbol that contains `d'.
+  exclude_expsyms='_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*'
+  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
+  # platforms (ab)use it in PIC code, but their linkers get confused if
+  # the symbol is explicitly referenced.  Since portable code cannot
+  # rely on this symbol name, it's probably fine to never include it in
+  # preloaded symbol tables.
+  # Exclude shared library initialization/finalization symbols.
+  extract_expsyms_cmds=
 
+  case $host_os in
+  cygwin* | mingw* | pw32* | cegcc*)
+    # FIXME: the MSVC++ port hasn't been tested in a loooong time
+    # When not using gcc, we currently assume that we are using
+    # Microsoft Visual C++.
+    if test "$GCC" != yes; then
+      with_gnu_ld=no
+    fi
+    ;;
+  interix*)
+    # we just hope/assume this is gcc and not c89 (= MSVC++)
+    with_gnu_ld=yes
+    ;;
+  openbsd*)
+    with_gnu_ld=no
+    ;;
+  esac
 
+  ld_shlibs=yes
 
+  # On some targets, GNU ld is compatible enough with the native linker
+  # that we're better off using the native interface for both.
+  lt_use_gnu_ld_interface=no
+  if test "$with_gnu_ld" = yes; then
+    case $host_os in
+      aix*)
+	# The AIX port of GNU ld has always aspired to compatibility
+	# with the native linker.  However, as the warning in the GNU ld
+	# block says, versions before 2.19.5* couldn't really create working
+	# shared libraries, regardless of the interface used.
+	case `$LD -v 2>&1` in
+	  *\ \(GNU\ Binutils\)\ 2.19.5*) ;;
+	  *\ \(GNU\ Binutils\)\ 2.[2-9]*) ;;
+	  *\ \(GNU\ Binutils\)\ [3-9]*) ;;
+	  *)
+	    lt_use_gnu_ld_interface=yes
+	    ;;
+	esac
+	;;
+      *)
+	lt_use_gnu_ld_interface=yes
+	;;
+    esac
+  fi
 
+  if test "$lt_use_gnu_ld_interface" = yes; then
+    # If archive_cmds runs LD, not CC, wlarc should be empty
+    wlarc='${wl}'
 
+    # Set some defaults for GNU ld with shared library support. These
+    # are reset later if shared libraries are not supported. Putting them
+    # here allows them to be overridden if necessary.
+    runpath_var=LD_RUN_PATH
+    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+    export_dynamic_flag_spec='${wl}--export-dynamic'
+    # ancient GNU ld didn't support --whole-archive et. al.
+    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then
+      whole_archive_flag_spec="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+    else
+      whole_archive_flag_spec=
+    fi
+    supports_anon_versioning=no
+    case `$LD -v 2>&1` in
+      *GNU\ gold*) supports_anon_versioning=yes ;;
+      *\ [01].* | *\ 2.[0-9].* | *\ 2.10.*) ;; # catch versions < 2.11
+      *\ 2.11.93.0.2\ *) supports_anon_versioning=yes ;; # RH7.3 ...
+      *\ 2.11.92.0.12\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...
+      *\ 2.11.*) ;; # other 2.11 versions
+      *) supports_anon_versioning=yes ;;
+    esac
 
+    # See if GNU ld supports shared libraries.
+    case $host_os in
+    aix[3-9]*)
+      # On AIX/PPC, the GNU linker is very broken
+      if test "$host_cpu" != ia64; then
+	ld_shlibs=no
+	cat <<_LT_EOF 1>&2
 
+*** Warning: the GNU linker, at least up to release 2.19, is reported
+*** to be unable to reliably create shared libraries on AIX.
+*** Therefore, libtool is disabling shared libraries support.  If you
+*** really care for shared libraries, you may want to install binutils
+*** 2.20 or above, or modify your PATH so that a non-GNU linker is found.
+*** You will then need to restart the configuration process.
 
+_LT_EOF
+      fi
+      ;;
 
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            archive_expsym_cmds=''
+        ;;
+      m68k)
+            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+            hardcode_libdir_flag_spec='-L$libdir'
+            hardcode_minus_L=yes
+        ;;
+      esac
+      ;;
 
+    beos*)
+      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	allow_undefined_flag=unsupported
+	# Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+	# support --undefined.  This deserves some investigation.  FIXME
+	archive_cmds='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
 
+    cygwin* | mingw* | pw32* | cegcc*)
+      # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
+      # as there is no search path for DLLs.
+      hardcode_libdir_flag_spec='-L$libdir'
+      export_dynamic_flag_spec='${wl}--export-all-symbols'
+      allow_undefined_flag=unsupported
+      always_export_symbols=no
+      enable_shared_with_static_runtimes=yes
+      export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[BCDGRS][ ]/s/.*[ ]\([^ ]*\)/\1 DATA/'\'' | $SED -e '\''/^[AITW][ ]/s/.*[ ]//'\'' | sort | uniq > $export_symbols'
 
+      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
+        archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	# If the export-symbols file already is a .def file (1st line
+	# is EXPORTS), use it as is; otherwise, prepend...
+	archive_expsym_cmds='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	  cp $export_symbols $output_objdir/$soname.def;
+	else
+	  echo EXPORTS > $output_objdir/$soname.def;
+	  cat $export_symbols >> $output_objdir/$soname.def;
+	fi~
+	$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
 
+    haiku*)
+      archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      link_all_deplibs=yes
+      ;;
 
+    interix[3-9]*)
+      hardcode_direct=no
+      hardcode_shlibpath_var=no
+      hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+      export_dynamic_flag_spec='${wl}-E'
+      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
+      # Instead, shared libraries are loaded at an image base (0x10000000 by
+      # default) and relocated if they conflict, which is a slow very memory
+      # consuming and fragmenting process.  To avoid this, we pick a random,
+      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
+      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
+      archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      archive_expsym_cmds='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      ;;
 
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking dynamic linker characteristics" >&5
-$as_echo_n "checking dynamic linker characteristics... " >&6; }
-
-if test "$GCC" = yes; then
-  case $host_os in
-    darwin*) lt_awk_arg="/^libraries:/,/LR/" ;;
-    *) lt_awk_arg="/^libraries:/" ;;
-  esac
-  case $host_os in
-    mingw* | cegcc*) lt_sed_strip_eq="s,=\([A-Za-z]:\),\1,g" ;;
-    *) lt_sed_strip_eq="s,=/,/,g" ;;
-  esac
-  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e "s/^libraries://" -e $lt_sed_strip_eq`
-  case $lt_search_path_spec in
-  *\;*)
-    # if the path contains ";" then we assume it to be the separator
-    # otherwise default to the standard path separator (i.e. ":") - it is
-    # assumed that no part of a normal pathname contains ";" but that should
-    # okay in the real world where ";" in dirpaths is itself problematic.
+    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)
+      tmp_diet=no
+      if test "$host_os" = linux-dietlibc; then
+	case $cc_basename in
+	  diet\ *) tmp_diet=yes;;	# linux-dietlibc with static linking (!diet-dyn)
+	esac
+      fi
+      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \
+	 && test "$tmp_diet" = no
+      then
+	tmp_addflag=
+	tmp_sharedflag='-shared'
+	case $cc_basename,$host_cpu in
+        pgcc*)				# Portland Group C compiler
+	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag'
+	  ;;
+	pgf77* | pgf90* | pgf95* | pgfortran*)
+					# Portland Group f77 and f90 compilers
+	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag -Mnomain' ;;
+	ecc*,ia64* | icc*,ia64*)	# Intel C compiler on ia64
+	  tmp_addflag=' -i_dynamic' ;;
+	efc*,ia64* | ifort*,ia64*)	# Intel Fortran compiler on ia64
+	  tmp_addflag=' -i_dynamic -nofor_main' ;;
+	ifc* | ifort*)			# Intel Fortran compiler
+	  tmp_addflag=' -nofor_main' ;;
+	lf95*)				# Lahey Fortran 8.1
+	  whole_archive_flag_spec=
+	  tmp_sharedflag='--shared' ;;
+	xl[cC]* | bgxl[cC]* | mpixl[cC]*) # IBM XL C 8.0 on PPC (deal with xlf below)
+	  tmp_sharedflag='-qmkshrobj'
+	  tmp_addflag= ;;
+	nvcc*)	# Cuda Compiler Driver 2.2
+	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  compiler_needs_object=yes
+	  ;;
+	esac
+	case `$CC -V 2>&1 | sed 5q` in
+	*Sun\ C*)			# Sun C 5.9
+	  whole_archive_flag_spec='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  compiler_needs_object=yes
+	  tmp_sharedflag='-G' ;;
+	*Sun\ F*)			# Sun Fortran 8.3
+	  tmp_sharedflag='-G' ;;
+	esac
+	archive_cmds='$CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+
+        if test "x$supports_anon_versioning" = xyes; then
+          archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
+	    cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+	    echo "local: *; };" >> $output_objdir/$libname.ver~
+	    $CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+        fi
+
+	case $cc_basename in
+	xlf* | bgf* | bgxlf* | mpixlf*)
+	  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself
+	  whole_archive_flag_spec='--whole-archive$convenience --no-whole-archive'
+	  hardcode_libdir_flag_spec=
+	  hardcode_libdir_flag_spec_ld='-rpath $libdir'
+	  archive_cmds='$LD -shared $libobjs $deplibs $compiler_flags -soname $soname -o $lib'
+	  if test "x$supports_anon_versioning" = xyes; then
+	    archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
+	      cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+	      echo "local: *; };" >> $output_objdir/$libname.ver~
+	      $LD -shared $libobjs $deplibs $compiler_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'
+	  fi
+	  ;;
+	esac
+      else
+        ld_shlibs=no
+      fi
+      ;;
+
+    netbsd*)
+      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	archive_cmds='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
+	wlarc=
+      else
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      fi
+      ;;
+
+    solaris*)
+      if $LD -v 2>&1 | $GREP 'BFD 2\.8' > /dev/null; then
+	ld_shlibs=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: The releases 2.8.* of the GNU linker cannot reliably
+*** create shared libraries on Solaris systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.9.1 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+_LT_EOF
+      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
+
+    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
+      case `$LD -v 2>&1` in
+        *\ [01].* | *\ 2.[0-9].* | *\ 2.1[0-5].*)
+	ld_shlibs=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not
+*** reliably create shared libraries on SCO systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+_LT_EOF
+	;;
+	*)
+	  # For security reasons, it is highly recommended that you always
+	  # use absolute paths for naming shared libraries, and exclude the
+	  # DT_RUNPATH tag from executables and libraries.  But doing so
+	  # requires that you compile everything twice, which is a pain.
+	  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+	    archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	  else
+	    ld_shlibs=no
+	  fi
+	;;
+      esac
+      ;;
+
+    sunos4*)
+      archive_cmds='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      wlarc=
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    *)
+      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
+    esac
+
+    if test "$ld_shlibs" = no; then
+      runpath_var=
+      hardcode_libdir_flag_spec=
+      export_dynamic_flag_spec=
+      whole_archive_flag_spec=
+    fi
+  else
+    # PORTME fill in a description of your system's linker (not GNU ld)
+    case $host_os in
+    aix3*)
+      allow_undefined_flag=unsupported
+      always_export_symbols=yes
+      archive_expsym_cmds='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'
+      # Note: this linker hardcodes the directories in LIBPATH if there
+      # are no directories specified by -L.
+      hardcode_minus_L=yes
+      if test "$GCC" = yes && test -z "$lt_prog_compiler_static"; then
+	# Neither direct hardcoding nor static linking is supported with a
+	# broken collect2.
+	hardcode_direct=unsupported
+      fi
+      ;;
+
+    aix[4-9]*)
+      if test "$host_cpu" = ia64; then
+	# On IA64, the linker does run time linking by default, so we don't
+	# have to do anything special.
+	aix_use_runtimelinking=no
+	exp_sym_flag='-Bexport'
+	no_entry_flag=""
+      else
+	# If we're using GNU nm, then we don't want the "-C" option.
+	# -C means demangle to AIX nm, but means don't demangle with GNU nm
+	# Also, AIX nm treats weak defined symbols like other global
+	# defined symbols, whereas GNU nm marks them as "W".
+	if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
+	  export_symbols_cmds='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	else
+	  export_symbols_cmds='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	fi
+	aix_use_runtimelinking=no
+
+	# Test if we are trying to use run time linking or normal
+	# AIX style linking. If -brtl is somewhere in LDFLAGS, we
+	# need to do runtime linking.
+	case $host_os in aix4.[23]|aix4.[23].*|aix[5-9]*)
+	  for ld_flag in $LDFLAGS; do
+	  if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
+	    aix_use_runtimelinking=yes
+	    break
+	  fi
+	  done
+	  ;;
+	esac
+
+	exp_sym_flag='-bexport'
+	no_entry_flag='-bnoentry'
+      fi
+
+      # When large executables or shared objects are built, AIX ld can
+      # have problems creating the table of contents.  If linking a library
+      # or program results in "error TOC overflow" add -mminimal-toc to
+      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
+
+      archive_cmds=''
+      hardcode_direct=yes
+      hardcode_direct_absolute=yes
+      hardcode_libdir_separator=':'
+      link_all_deplibs=yes
+      file_list_spec='${wl}-f,'
+
+      if test "$GCC" = yes; then
+	case $host_os in aix4.[012]|aix4.[012].*)
+	# We only want to do this on AIX 4.2 and lower, the check
+	# below for broken collect2 doesn't work under 4.3+
+	  collect2name=`${CC} -print-prog-name=collect2`
+	  if test -f "$collect2name" &&
+	   strings "$collect2name" | $GREP resolve_lib_name >/dev/null
+	  then
+	  # We have reworked collect2
+	  :
+	  else
+	  # We have old collect2
+	  hardcode_direct=unsupported
+	  # It fails to find uninstalled libraries when the uninstalled
+	  # path is not listed in the libpath.  Setting hardcode_minus_L
+	  # to unsupported forces relinking
+	  hardcode_minus_L=yes
+	  hardcode_libdir_flag_spec='-L$libdir'
+	  hardcode_libdir_separator=
+	  fi
+	  ;;
+	esac
+	shared_flag='-shared'
+	if test "$aix_use_runtimelinking" = yes; then
+	  shared_flag="$shared_flag "'${wl}-G'
+	fi
+      else
+	# not using gcc
+	if test "$host_cpu" = ia64; then
+	# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
+	# chokes on -Wl,-G. The following line is correct:
+	  shared_flag='-G'
+	else
+	  if test "$aix_use_runtimelinking" = yes; then
+	    shared_flag='${wl}-G'
+	  else
+	    shared_flag='${wl}-bM:SRE'
+	  fi
+	fi
+      fi
+
+      export_dynamic_flag_spec='${wl}-bexpall'
+      # It seems that -bexpall does not export symbols beginning with
+      # underscore (_), so it is better to generate a list of symbols to export.
+      always_export_symbols=yes
+      if test "$aix_use_runtimelinking" = yes; then
+	# Warning - without using the other runtime loading flags (-brtl),
+	# -berok will link without error, but may produce a broken library.
+	allow_undefined_flag='-berok'
+        # Determine the default libpath from the value encoded in an
+        # empty executable.
+        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+
+lt_aix_libpath_sed='
+    /Import File Strings/,/^$/ {
+	/^0/ {
+	    s/^0  *\(.*\)$/\1/
+	    p
+	}
+    }'
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then
+  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
+
+        hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+        archive_expsym_cmds='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then func_echo_all "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+      else
+	if test "$host_cpu" = ia64; then
+	  hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
+	  allow_undefined_flag="-z nodefs"
+	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+	else
+	 # Determine the default libpath from the value encoded in an
+	 # empty executable.
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+
+lt_aix_libpath_sed='
+    /Import File Strings/,/^$/ {
+	/^0/ {
+	    s/^0  *\(.*\)$/\1/
+	    p
+	}
+    }'
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then
+  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
+
+	 hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+	  # Warning - without using the other run time loading flags,
+	  # -berok will link without error, but may produce a broken library.
+	  no_undefined_flag=' ${wl}-bernotok'
+	  allow_undefined_flag=' ${wl}-berok'
+	  if test "$with_gnu_ld" = yes; then
+	    # We only use this code for GNU lds that support --whole-archive.
+	    whole_archive_flag_spec='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	  else
+	    # Exported symbols can be pulled into shared objects from archives
+	    whole_archive_flag_spec='$convenience'
+	  fi
+	  archive_cmds_need_lc=yes
+	  # This is similar to how AIX traditionally builds its shared libraries.
+	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+	fi
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            archive_expsym_cmds=''
+        ;;
+      m68k)
+            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+            hardcode_libdir_flag_spec='-L$libdir'
+            hardcode_minus_L=yes
+        ;;
+      esac
+      ;;
+
+    bsdi[45]*)
+      export_dynamic_flag_spec=-rdynamic
+      ;;
+
+    cygwin* | mingw* | pw32* | cegcc*)
+      # When not using gcc, we currently assume that we are using
+      # Microsoft Visual C++.
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      hardcode_libdir_flag_spec=' '
+      allow_undefined_flag=unsupported
+      # Tell ltmain to make .lib files, not .a files.
+      libext=lib
+      # Tell ltmain to make .dll files, not .so files.
+      shrext_cmds=".dll"
+      # FIXME: Setting linknames here is a bad hack.
+      archive_cmds='$CC -o $lib $libobjs $compiler_flags `func_echo_all "$deplibs" | $SED '\''s/ -lc$//'\''` -link -dll~linknames='
+      # The linker will automatically build a .lib file if we build a DLL.
+      old_archive_from_new_cmds='true'
+      # FIXME: Should let the user specify the lib program.
+      old_archive_cmds='lib -OUT:$oldlib$oldobjs$old_deplibs'
+      fix_srcfile_path='`cygpath -w "$srcfile"`'
+      enable_shared_with_static_runtimes=yes
+      ;;
+
+    darwin* | rhapsody*)
+
+
+  archive_cmds_need_lc=no
+  hardcode_direct=no
+  hardcode_automatic=yes
+  hardcode_shlibpath_var=unsupported
+  if test "$lt_cv_ld_force_load" = "yes"; then
+    whole_archive_flag_spec='`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience ${wl}-force_load,$conv\"; done; func_echo_all \"$new_convenience\"`'
+  else
+    whole_archive_flag_spec=''
+  fi
+  link_all_deplibs=yes
+  allow_undefined_flag="$_lt_dar_allow_undefined"
+  case $cc_basename in
+     ifort*) _lt_dar_can_shared=yes ;;
+     *) _lt_dar_can_shared=$GCC ;;
+  esac
+  if test "$_lt_dar_can_shared" = "yes"; then
+    output_verbose_link_cmd=func_echo_all
+    archive_cmds="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
+    module_cmds="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
+    archive_expsym_cmds="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
+    module_expsym_cmds="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
+
+  else
+  ld_shlibs=no
+  fi
+
+      ;;
+
+    dgux*)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_shlibpath_var=no
+      ;;
+
+    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor
+    # support.  Future versions do this automatically, but an explicit c++rt0.o
+    # does not break anything, and helps significantly (at the cost of a little
+    # extra space).
+    freebsd2.2*)
+      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    # Unfortunately, older versions of FreeBSD 2 do not have this feature.
+    freebsd2.*)
+      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
+    freebsd* | dragonfly*)
+      archive_cmds='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    hpux9*)
+      if test "$GCC" = yes; then
+	archive_cmds='$RM $output_objdir/$soname~$CC -shared -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      else
+	archive_cmds='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      fi
+      hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+      hardcode_libdir_separator=:
+      hardcode_direct=yes
+
+      # hardcode_minus_L: Not really in the search PATH,
+      # but as the default location of the library.
+      hardcode_minus_L=yes
+      export_dynamic_flag_spec='${wl}-E'
+      ;;
+
+    hpux10*)
+      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
+	archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      if test "$with_gnu_ld" = no; then
+	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+	hardcode_libdir_flag_spec_ld='+b $libdir'
+	hardcode_libdir_separator=:
+	hardcode_direct=yes
+	hardcode_direct_absolute=yes
+	export_dynamic_flag_spec='${wl}-E'
+	# hardcode_minus_L: Not really in the search PATH,
+	# but as the default location of the library.
+	hardcode_minus_L=yes
+      fi
+      ;;
+
+    hpux11*)
+      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
+	case $host_cpu in
+	hppa*64*)
+	  archive_cmds='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	esac
+      else
+	case $host_cpu in
+	hppa*64*)
+	  archive_cmds='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+
+	  # Older versions of the 11.00 compiler do not understand -b yet
+	  # (HP92453-01 A.11.01.20 doesn't, HP92453-01 B.11.X.35175-35176.GP does)
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $CC understands -b" >&5
+$as_echo_n "checking if $CC understands -b... " >&6; }
+if test "${lt_cv_prog_compiler__b+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler__b=no
+   save_LDFLAGS="$LDFLAGS"
+   LDFLAGS="$LDFLAGS -b"
+   echo "$lt_simple_link_test_code" > conftest.$ac_ext
+   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
+     # The linker can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     if test -s conftest.err; then
+       # Append any errors to the config.log.
+       cat conftest.err 1>&5
+       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
+       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+       if diff conftest.exp conftest.er2 >/dev/null; then
+         lt_cv_prog_compiler__b=yes
+       fi
+     else
+       lt_cv_prog_compiler__b=yes
+     fi
+   fi
+   $RM -r conftest*
+   LDFLAGS="$save_LDFLAGS"
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler__b" >&5
+$as_echo "$lt_cv_prog_compiler__b" >&6; }
+
+if test x"$lt_cv_prog_compiler__b" = xyes; then
+    archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+else
+    archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
+fi
+
+	  ;;
+	esac
+      fi
+      if test "$with_gnu_ld" = no; then
+	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+	hardcode_libdir_separator=:
+
+	case $host_cpu in
+	hppa*64*|ia64*)
+	  hardcode_direct=no
+	  hardcode_shlibpath_var=no
+	  ;;
+	*)
+	  hardcode_direct=yes
+	  hardcode_direct_absolute=yes
+	  export_dynamic_flag_spec='${wl}-E'
+
+	  # hardcode_minus_L: Not really in the search PATH,
+	  # but as the default location of the library.
+	  hardcode_minus_L=yes
+	  ;;
+	esac
+      fi
+      ;;
+
+    irix5* | irix6* | nonstopux*)
+      if test "$GCC" = yes; then
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	# Try to use the -exported_symbol ld option, if it does not
+	# work, assume that -exports_file does not work either and
+	# implicitly export all symbols.
+        save_LDFLAGS="$LDFLAGS"
+        LDFLAGS="$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null"
+        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int foo(void) {}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'
+
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+        LDFLAGS="$save_LDFLAGS"
+      else
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'
+      fi
+      archive_cmds_need_lc='no'
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      inherit_rpath=yes
+      link_all_deplibs=yes
+      ;;
+
+    netbsd*)
+      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
+      else
+	archive_cmds='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF
+      fi
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    newsos6)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_direct=yes
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      hardcode_shlibpath_var=no
+      ;;
+
+    *nto* | *qnx*)
+      ;;
+
+    openbsd*)
+      if test -f /usr/libexec/ld.so; then
+	hardcode_direct=yes
+	hardcode_shlibpath_var=no
+	hardcode_direct_absolute=yes
+	if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+	  archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_expsym_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'
+	  hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+	  export_dynamic_flag_spec='${wl}-E'
+	else
+	  case $host_os in
+	   openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
+	     archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+	     hardcode_libdir_flag_spec='-R$libdir'
+	     ;;
+	   *)
+	     archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	     hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+	     ;;
+	  esac
+	fi
+      else
+	ld_shlibs=no
+      fi
+      ;;
+
+    os2*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      allow_undefined_flag=unsupported
+      archive_cmds='$ECHO "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~echo DATA >> $output_objdir/$libname.def~echo " SINGLE NONSHARED" >> $output_objdir/$libname.def~echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
+      old_archive_from_new_cmds='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
+      ;;
+
+    osf3*)
+      if test "$GCC" = yes; then
+	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      else
+	allow_undefined_flag=' -expect_unresolved \*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+      fi
+      archive_cmds_need_lc='no'
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+
+    osf4* | osf5*)	# as osf3* with the addition of -msym flag
+      if test "$GCC" = yes; then
+	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      else
+	allow_undefined_flag=' -expect_unresolved \*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	archive_expsym_cmds='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done; printf "%s\\n" "-hidden">> $lib.exp~
+	$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'
+
+	# Both c and cxx compiler support -rpath directly
+	hardcode_libdir_flag_spec='-rpath $libdir'
+      fi
+      archive_cmds_need_lc='no'
+      hardcode_libdir_separator=:
+      ;;
+
+    solaris*)
+      no_undefined_flag=' -z defs'
+      if test "$GCC" = yes; then
+	wlarc='${wl}'
+	archive_cmds='$CC -shared ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $CC -shared ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+      else
+	case `$CC -V 2>&1` in
+	*"Compilers 5.0"*)
+	  wlarc=''
+	  archive_cmds='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'
+	  ;;
+	*)
+	  wlarc='${wl}'
+	  archive_cmds='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+	  ;;
+	esac
+      fi
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_shlibpath_var=no
+      case $host_os in
+      solaris2.[0-5] | solaris2.[0-5].*) ;;
+      *)
+	# The compiler driver will combine and reorder linker options,
+	# but understands `-z linker_flag'.  GCC discards it without `$wl',
+	# but is careful enough not to reorder.
+	# Supported since Solaris 2.6 (maybe 2.5.1?)
+	if test "$GCC" = yes; then
+	  whole_archive_flag_spec='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
+	else
+	  whole_archive_flag_spec='-z allextract$convenience -z defaultextract'
+	fi
+	;;
+      esac
+      link_all_deplibs=yes
+      ;;
+
+    sunos4*)
+      if test "x$host_vendor" = xsequent; then
+	# Use $CC to link under sequent, because it throws in some extra .o
+	# files that make .init and .fini sections work.
+	archive_cmds='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    sysv4)
+      case $host_vendor in
+	sni)
+	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  hardcode_direct=yes # is this really true???
+	;;
+	siemens)
+	  ## LD is ld it makes a PLAMLIB
+	  ## CC just makes a GrossModule.
+	  archive_cmds='$LD -G -o $lib $libobjs $deplibs $linker_flags'
+	  reload_cmds='$CC -r -o $output$reload_objs'
+	  hardcode_direct=no
+        ;;
+	motorola)
+	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  hardcode_direct=no #Motorola manual says yes, but my tests say they lie
+	;;
+      esac
+      runpath_var='LD_RUN_PATH'
+      hardcode_shlibpath_var=no
+      ;;
+
+    sysv4.3*)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_shlibpath_var=no
+      export_dynamic_flag_spec='-Bexport'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	hardcode_shlibpath_var=no
+	runpath_var=LD_RUN_PATH
+	hardcode_runpath_var=yes
+	ld_shlibs=yes
+      fi
+      ;;
+
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)
+      no_undefined_flag='${wl}-z,text'
+      archive_cmds_need_lc=no
+      hardcode_shlibpath_var=no
+      runpath_var='LD_RUN_PATH'
+
+      if test "$GCC" = yes; then
+	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
+
+    sysv5* | sco3.2v5* | sco5v6*)
+      # Note: We can NOT use -z defs as we might desire, because we do not
+      # link with -lc, and that would cause any symbols used from libc to
+      # always be unresolved, which means just about no library would
+      # ever link correctly.  If we're not using GNU ld we use -z text
+      # though, which does catch some bad symbols but isn't as heavy-handed
+      # as -z defs.
+      no_undefined_flag='${wl}-z,text'
+      allow_undefined_flag='${wl}-z,nodefs'
+      archive_cmds_need_lc=no
+      hardcode_shlibpath_var=no
+      hardcode_libdir_flag_spec='${wl}-R,$libdir'
+      hardcode_libdir_separator=':'
+      link_all_deplibs=yes
+      export_dynamic_flag_spec='${wl}-Bexport'
+      runpath_var='LD_RUN_PATH'
+
+      if test "$GCC" = yes; then
+	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
+
+    uts4*)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_shlibpath_var=no
+      ;;
+
+    *)
+      ld_shlibs=no
+      ;;
+    esac
+
+    if test x$host_vendor = xsni; then
+      case $host in
+      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
+	export_dynamic_flag_spec='${wl}-Blargedynsym'
+	;;
+      esac
+    fi
+  fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs" >&5
+$as_echo "$ld_shlibs" >&6; }
+test "$ld_shlibs" = no && can_build_shared=no
+
+with_gnu_ld=$with_gnu_ld
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#
+# Do we need to explicitly link libc?
+#
+case "x$archive_cmds_need_lc" in
+x|xyes)
+  # Assume -lc should be added
+  archive_cmds_need_lc=yes
+
+  if test "$enable_shared" = yes && test "$GCC" = yes; then
+    case $archive_cmds in
+    *'~'*)
+      # FIXME: we may have to deal with multi-command sequences.
+      ;;
+    '$CC '*)
+      # Test whether the compiler implicitly links with -lc since on some
+      # systems, -lgcc has to come before -lc. If gcc already passes -lc
+      # to ld, don't add -lc before -lgcc.
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -lc should be explicitly linked in" >&5
+$as_echo_n "checking whether -lc should be explicitly linked in... " >&6; }
+if test "${lt_cv_archive_cmds_need_lc+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  $RM conftest*
+	echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+	if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } 2>conftest.err; then
+	  soname=conftest
+	  lib=conftest
+	  libobjs=conftest.$ac_objext
+	  deplibs=
+	  wl=$lt_prog_compiler_wl
+	  pic_flag=$lt_prog_compiler_pic
+	  compiler_flags=-v
+	  linker_flags=-v
+	  verstring=
+	  output_objdir=.
+	  libname=conftest
+	  lt_save_allow_undefined_flag=$allow_undefined_flag
+	  allow_undefined_flag=
+	  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1\""; } >&5
+  (eval $archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+	  then
+	    lt_cv_archive_cmds_need_lc=no
+	  else
+	    lt_cv_archive_cmds_need_lc=yes
+	  fi
+	  allow_undefined_flag=$lt_save_allow_undefined_flag
+	else
+	  cat conftest.err 1>&5
+	fi
+	$RM conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_archive_cmds_need_lc" >&5
+$as_echo "$lt_cv_archive_cmds_need_lc" >&6; }
+      archive_cmds_need_lc=$lt_cv_archive_cmds_need_lc
+      ;;
+    esac
+  fi
+  ;;
+esac
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking dynamic linker characteristics" >&5
+$as_echo_n "checking dynamic linker characteristics... " >&6; }
+
+if test "$GCC" = yes; then
+  case $host_os in
+    darwin*) lt_awk_arg="/^libraries:/,/LR/" ;;
+    *) lt_awk_arg="/^libraries:/" ;;
+  esac
+  case $host_os in
+    mingw* | cegcc*) lt_sed_strip_eq="s,=\([A-Za-z]:\),\1,g" ;;
+    *) lt_sed_strip_eq="s,=/,/,g" ;;
+  esac
+  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e "s/^libraries://" -e $lt_sed_strip_eq`
+  case $lt_search_path_spec in
+  *\;*)
+    # if the path contains ";" then we assume it to be the separator
+    # otherwise default to the standard path separator (i.e. ":") - it is
+    # assumed that no part of a normal pathname contains ";" but that should
+    # okay in the real world where ";" in dirpaths is itself problematic.
     lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED 's/;/ /g'`
     ;;
-  *)
-    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED "s/$PATH_SEPARATOR/ /g"`
+  *)
+    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED "s/$PATH_SEPARATOR/ /g"`
+    ;;
+  esac
+  # Ok, now we have the path, separated by spaces, we can step through it
+  # and add multilib dir if necessary.
+  lt_tmp_lt_search_path_spec=
+  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`
+  for lt_sys_path in $lt_search_path_spec; do
+    if test -d "$lt_sys_path/$lt_multi_os_dir"; then
+      lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir"
+    else
+      test -d "$lt_sys_path" && \
+	lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path"
+    fi
+  done
+  lt_search_path_spec=`$ECHO "$lt_tmp_lt_search_path_spec" | awk '
+BEGIN {RS=" "; FS="/|\n";} {
+  lt_foo="";
+  lt_count=0;
+  for (lt_i = NF; lt_i > 0; lt_i--) {
+    if ($lt_i != "" && $lt_i != ".") {
+      if ($lt_i == "..") {
+        lt_count++;
+      } else {
+        if (lt_count == 0) {
+          lt_foo="/" $lt_i lt_foo;
+        } else {
+          lt_count--;
+        }
+      }
+    }
+  }
+  if (lt_foo != "") { lt_freq[lt_foo]++; }
+  if (lt_freq[lt_foo] == 1) { print lt_foo; }
+}'`
+  # AWK program above erroneously prepends '/' to C:/dos/paths
+  # for these hosts.
+  case $host_os in
+    mingw* | cegcc*) lt_search_path_spec=`$ECHO "$lt_search_path_spec" |\
+      $SED 's,/\([A-Za-z]:\),\1,g'` ;;
+  esac
+  sys_lib_search_path_spec=`$ECHO "$lt_search_path_spec" | $lt_NL2SP`
+else
+  sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
+fi
+library_names_spec=
+libname_spec='lib$name'
+soname_spec=
+shrext_cmds=".so"
+postinstall_cmds=
+postuninstall_cmds=
+finish_cmds=
+finish_eval=
+shlibpath_var=
+shlibpath_overrides_runpath=unknown
+version_type=none
+dynamic_linker="$host_os ld.so"
+sys_lib_dlsearch_path_spec="/lib /usr/lib"
+need_lib_prefix=unknown
+hardcode_into_libs=no
+
+# when you set need_version to no, make sure it does not cause -set_version
+# flags to be left without arguments
+need_version=unknown
+
+case $host_os in
+aix3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
+  shlibpath_var=LIBPATH
+
+  # AIX 3 has no versioning support, so we append a major version to the name.
+  soname_spec='${libname}${release}${shared_ext}$major'
+  ;;
+
+aix[4-9]*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  hardcode_into_libs=yes
+  if test "$host_cpu" = ia64; then
+    # AIX 5 supports IA64
+    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+    shlibpath_var=LD_LIBRARY_PATH
+  else
+    # With GCC up to 2.95.x, collect2 would create an import file
+    # for dependence libraries.  The import file would start with
+    # the line `#! .'.  This would cause the generated library to
+    # depend on `.', always an invalid library.  This was fixed in
+    # development snapshots of GCC prior to 3.0.
+    case $host_os in
+      aix4 | aix4.[01] | aix4.[01].*)
+      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
+	   echo ' yes '
+	   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then
+	:
+      else
+	can_build_shared=no
+      fi
+      ;;
+    esac
+    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
+    # soname into executable. Probably we can add versioning support to
+    # collect2, so additional links can be useful in future.
+    if test "$aix_use_runtimelinking" = yes; then
+      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
+      # instead of lib<name>.a to let people know that these are not
+      # typical AIX shared libraries.
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    else
+      # We preserve .a as extension for shared libraries through AIX4.2
+      # and later when we are not doing run time linking.
+      library_names_spec='${libname}${release}.a $libname.a'
+      soname_spec='${libname}${release}${shared_ext}$major'
+    fi
+    shlibpath_var=LIBPATH
+  fi
+  ;;
+
+amigaos*)
+  case $host_cpu in
+  powerpc)
+    # Since July 2007 AmigaOS4 officially supports .so libraries.
+    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    ;;
+  m68k)
+    library_names_spec='$libname.ixlibrary $libname.a'
+    # Create ${libname}_ixlibrary.a entries in /sys/libs.
+    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all "$lib" | $SED '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
+    ;;
+  esac
+  ;;
+
+beos*)
+  library_names_spec='${libname}${shared_ext}'
+  dynamic_linker="$host_os ld.so"
+  shlibpath_var=LIBRARY_PATH
+  ;;
+
+bsdi[45]*)
+  version_type=linux
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
+  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
+  # the default ld.so.conf also contains /usr/contrib/lib and
+  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
+  # libtool to hard-code these into programs
+  ;;
+
+cygwin* | mingw* | pw32* | cegcc*)
+  version_type=windows
+  shrext_cmds=".dll"
+  need_version=no
+  need_lib_prefix=no
+
+  case $GCC,$host_os in
+  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+    library_names_spec='$libname.dll.a'
+    # DLL is installed to $(libdir)/../bin by postinstall_cmds
+    postinstall_cmds='base_file=`basename \${file}`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
+      dldir=$destdir/`dirname \$dlpath`~
+      test -d \$dldir || mkdir -p \$dldir~
+      $install_prog $dir/$dlname \$dldir/$dlname~
+      chmod a+x \$dldir/$dlname~
+      if test -n '\''$stripme'\'' && test -n '\''$striplib'\''; then
+        eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
+      fi'
+    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
+      dlpath=$dir/\$dldll~
+       $RM \$dlpath'
+    shlibpath_overrides_runpath=yes
+
+    case $host_os in
+    cygwin*)
+      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
+      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+
+      sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
+      ;;
+    mingw* | cegcc*)
+      # MinGW DLLs use traditional 'lib' prefix
+      soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    pw32*)
+      # pw32 DLLs use 'pw' prefix rather than 'lib'
+      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    esac
+    ;;
+
+  *)
+    library_names_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext} $libname.lib'
+    ;;
+  esac
+  dynamic_linker='Win32 ld.exe'
+  # FIXME: first we should search . and the directory the executable is in
+  shlibpath_var=PATH
+  ;;
+
+darwin* | rhapsody*)
+  dynamic_linker="$host_os dyld"
+  version_type=darwin
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
+  soname_spec='${libname}${release}${major}$shared_ext'
+  shlibpath_overrides_runpath=yes
+  shlibpath_var=DYLD_LIBRARY_PATH
+  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
+
+  sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/local/lib"
+  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'
+  ;;
+
+dgux*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+freebsd* | dragonfly*)
+  # DragonFly does not have aout.  When/if they implement a new
+  # versioning mechanism, adjust this.
+  if test -x /usr/bin/objformat; then
+    objformat=`/usr/bin/objformat`
+  else
+    case $host_os in
+    freebsd[23].*) objformat=aout ;;
+    *) objformat=elf ;;
+    esac
+  fi
+  version_type=freebsd-$objformat
+  case $version_type in
+    freebsd-elf*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+      need_version=no
+      need_lib_prefix=no
+      ;;
+    freebsd-*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
+      need_version=yes
+      ;;
+  esac
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_os in
+  freebsd2.*)
+    shlibpath_overrides_runpath=yes
+    ;;
+  freebsd3.[01]* | freebsdelf3.[01]*)
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  freebsd3.[2-9]* | freebsdelf3.[2-9]* | \
+  freebsd4.[0-5] | freebsdelf4.[0-5] | freebsd4.1.1 | freebsdelf4.1.1)
+    shlibpath_overrides_runpath=no
+    hardcode_into_libs=yes
+    ;;
+  *) # from 4.6 on, and DragonFly
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  esac
+  ;;
+
+gnu*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  hardcode_into_libs=yes
+  ;;
+
+haiku*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  dynamic_linker="$host_os runtime_loader"
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/beos/system/lib'
+  hardcode_into_libs=yes
+  ;;
+
+hpux9* | hpux10* | hpux11*)
+  # Give a soname corresponding to the major version so that dld.sl refuses to
+  # link against other versions.
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  case $host_cpu in
+  ia64*)
+    shrext_cmds='.so'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.so"
+    shlibpath_var=LD_LIBRARY_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    if test "X$HPUX_IA64_MODE" = X32; then
+      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
+    else
+      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
+    fi
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  hppa*64*)
+    shrext_cmds='.sl'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  *)
+    shrext_cmds='.sl'
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=SHLIB_PATH
+    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    ;;
+  esac
+  # HP-UX runs *really* slowly unless shared libraries are mode 555, ...
+  postinstall_cmds='chmod 555 $lib'
+  # or fails outright, so override atomically:
+  install_override_mode=555
+  ;;
+
+interix[3-9]*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $host_os in
+    nonstopux*) version_type=nonstopux ;;
+    *)
+	if test "$lt_cv_prog_gnu_ld" = yes; then
+		version_type=linux
+	else
+		version_type=irix
+	fi ;;
+  esac
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
+  case $host_os in
+  irix5* | nonstopux*)
+    libsuff= shlibsuff=
+    ;;
+  *)
+    case $LD in # libtool.m4 will add one of these switches to LD
+    *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ")
+      libsuff= shlibsuff= libmagic=32-bit;;
+    *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ")
+      libsuff=32 shlibsuff=N32 libmagic=N32;;
+    *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ")
+      libsuff=64 shlibsuff=64 libmagic=64-bit;;
+    *) libsuff= shlibsuff= libmagic=never-match;;
+    esac
+    ;;
+  esac
+  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
+  shlibpath_overrides_runpath=no
+  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
+  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
+  hardcode_into_libs=yes
+  ;;
+
+# No shared lib support for Linux oldld, aout, or coff.
+linux*oldld* | linux*aout* | linux*coff*)
+  dynamic_linker=no
+  ;;
+
+# This must be Linux ELF.
+linux* | k*bsd*-gnu | kopensolaris*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+
+  # Some binutils ld are patched to set DT_RUNPATH
+  if test "${lt_cv_shlibpath_overrides_runpath+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_shlibpath_overrides_runpath=no
+    save_LDFLAGS=$LDFLAGS
+    save_libdir=$libdir
+    eval "libdir=/foo; wl=\"$lt_prog_compiler_wl\"; \
+	 LDFLAGS=\"\$LDFLAGS $hardcode_libdir_flag_spec\""
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  if  ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null; then :
+  lt_cv_shlibpath_overrides_runpath=yes
+fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+    LDFLAGS=$save_LDFLAGS
+    libdir=$save_libdir
+
+fi
+
+  shlibpath_overrides_runpath=$lt_cv_shlibpath_overrides_runpath
+
+  # This implies no fast_install, which is unacceptable.
+  # Some rework will be needed to allow for fast_install
+  # before this can be enabled.
+  hardcode_into_libs=yes
+
+  # Append ld.so.conf contents to the search path
+  if test -f /etc/ld.so.conf; then
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/"//g;/^$/d' | tr '\n' ' '`
+    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
+  fi
+
+  # We used to test for /lib/ld.so.1 and disable shared libraries on
+  # powerpc, because MkLinux only supported shared libraries with the
+  # GNU dynamic linker.  Since this was broken with cross compilers,
+  # most powerpc-linux boxes support dynamic linking these days and
+  # people can always --disable-shared, the test was removed, and we
+  # assume the GNU/Linux dynamic linker is in use.
+  dynamic_linker='GNU/Linux ld.so'
+  ;;
+
+netbsd*)
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+    dynamic_linker='NetBSD (a.out) ld.so'
+  else
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    dynamic_linker='NetBSD ld.elf_so'
+  fi
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  ;;
+
+newsos6)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  ;;
+
+*nto* | *qnx*)
+  version_type=qnx
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='ldqnx.so'
+  ;;
+
+openbsd*)
+  version_type=sunos
+  sys_lib_dlsearch_path_spec="/usr/lib"
+  need_lib_prefix=no
+  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
+  case $host_os in
+    openbsd3.3 | openbsd3.3.*)	need_version=yes ;;
+    *)				need_version=no  ;;
+  esac
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    case $host_os in
+      openbsd2.[89] | openbsd2.[89].*)
+	shlibpath_overrides_runpath=no
+	;;
+      *)
+	shlibpath_overrides_runpath=yes
+	;;
+      esac
+  else
+    shlibpath_overrides_runpath=yes
+  fi
+  ;;
+
+os2*)
+  libname_spec='$name'
+  shrext_cmds=".dll"
+  need_lib_prefix=no
+  library_names_spec='$libname${shared_ext} $libname.a'
+  dynamic_linker='OS/2 ld.exe'
+  shlibpath_var=LIBPATH
+  ;;
+
+osf3* | osf4* | osf5*)
+  version_type=osf
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
+  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
+  ;;
+
+rdos*)
+  dynamic_linker=no
+  ;;
+
+solaris*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  # ldd complains unless libraries are executable
+  postinstall_cmds='chmod +x $lib'
+  ;;
+
+sunos4*)
+  version_type=sunos
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  if test "$with_gnu_ld" = yes; then
+    need_lib_prefix=no
+  fi
+  need_version=yes
+  ;;
+
+sysv4 | sysv4.3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_vendor in
+    sni)
+      shlibpath_overrides_runpath=no
+      need_lib_prefix=no
+      runpath_var=LD_RUN_PATH
+      ;;
+    siemens)
+      need_lib_prefix=no
+      ;;
+    motorola)
+      need_lib_prefix=no
+      need_version=no
+      shlibpath_overrides_runpath=no
+      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
+      ;;
+  esac
+  ;;
+
+sysv4*MP*)
+  if test -d /usr/nec ;then
+    version_type=linux
+    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
+    soname_spec='$libname${shared_ext}.$major'
+    shlibpath_var=LD_LIBRARY_PATH
+  fi
+  ;;
+
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  version_type=freebsd-elf
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  if test "$with_gnu_ld" = yes; then
+    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
+  else
+    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
+    case $host_os in
+      sco3.2v5*)
+        sys_lib_search_path_spec="$sys_lib_search_path_spec /lib"
+	;;
+    esac
+  fi
+  sys_lib_dlsearch_path_spec='/usr/lib'
+  ;;
+
+tpf*)
+  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+uts4*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+*)
+  dynamic_linker=no
+  ;;
+esac
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $dynamic_linker" >&5
+$as_echo "$dynamic_linker" >&6; }
+test "$dynamic_linker" = no && can_build_shared=no
+
+variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
+if test "$GCC" = yes; then
+  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
+fi
+
+if test "${lt_cv_sys_lib_search_path_spec+set}" = set; then
+  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
+fi
+if test "${lt_cv_sys_lib_dlsearch_path_spec+set}" = set; then
+  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking how to hardcode library paths into programs" >&5
+$as_echo_n "checking how to hardcode library paths into programs... " >&6; }
+hardcode_action=
+if test -n "$hardcode_libdir_flag_spec" ||
+   test -n "$runpath_var" ||
+   test "X$hardcode_automatic" = "Xyes" ; then
+
+  # We can hardcode non-existent directories.
+  if test "$hardcode_direct" != no &&
+     # If the only mechanism to avoid hardcoding is shlibpath_var, we
+     # have to relink, otherwise we might link with an installed library
+     # when we should be linking with a yet-to-be-installed one
+     ## test "$_LT_TAGVAR(hardcode_shlibpath_var, )" != no &&
+     test "$hardcode_minus_L" != no; then
+    # Linking always hardcodes the temporary library directory.
+    hardcode_action=relink
+  else
+    # We can link without hardcoding, and we can hardcode nonexisting dirs.
+    hardcode_action=immediate
+  fi
+else
+  # We cannot hardcode anything, or else we can only hardcode existing
+  # directories.
+  hardcode_action=unsupported
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $hardcode_action" >&5
+$as_echo "$hardcode_action" >&6; }
+
+if test "$hardcode_action" = relink ||
+   test "$inherit_rpath" = yes; then
+  # Fast installation is not supported
+  enable_fast_install=no
+elif test "$shlibpath_overrides_runpath" = yes ||
+     test "$enable_shared" = no; then
+  # Fast installation is not necessary
+  enable_fast_install=needless
+fi
+
+
+
+
+
+
+  if test "x$enable_dlopen" != xyes; then
+  enable_dlopen=unknown
+  enable_dlopen_self=unknown
+  enable_dlopen_self_static=unknown
+else
+  lt_cv_dlopen=no
+  lt_cv_dlopen_libs=
+
+  case $host_os in
+  beos*)
+    lt_cv_dlopen="load_add_on"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+    ;;
+
+  mingw* | pw32* | cegcc*)
+    lt_cv_dlopen="LoadLibrary"
+    lt_cv_dlopen_libs=
+    ;;
+
+  cygwin*)
+    lt_cv_dlopen="dlopen"
+    lt_cv_dlopen_libs=
+    ;;
+
+  darwin*)
+  # if libdl is installed we need to link against it
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
+$as_echo_n "checking for dlopen in -ldl... " >&6; }
+if test "${ac_cv_lib_dl_dlopen+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dl_dlopen=yes
+else
+  ac_cv_lib_dl_dlopen=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
+$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
+if test "x$ac_cv_lib_dl_dlopen" = x""yes; then :
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
+else
+
+    lt_cv_dlopen="dyld"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+
+fi
+
+    ;;
+
+  *)
+    ac_fn_c_check_func "$LINENO" "shl_load" "ac_cv_func_shl_load"
+if test "x$ac_cv_func_shl_load" = x""yes; then :
+  lt_cv_dlopen="shl_load"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for shl_load in -ldld" >&5
+$as_echo_n "checking for shl_load in -ldld... " >&6; }
+if test "${ac_cv_lib_dld_shl_load+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldld  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char shl_load ();
+int
+main ()
+{
+return shl_load ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dld_shl_load=yes
+else
+  ac_cv_lib_dld_shl_load=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_shl_load" >&5
+$as_echo "$ac_cv_lib_dld_shl_load" >&6; }
+if test "x$ac_cv_lib_dld_shl_load" = x""yes; then :
+  lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-ldld"
+else
+  ac_fn_c_check_func "$LINENO" "dlopen" "ac_cv_func_dlopen"
+if test "x$ac_cv_func_dlopen" = x""yes; then :
+  lt_cv_dlopen="dlopen"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
+$as_echo_n "checking for dlopen in -ldl... " >&6; }
+if test "${ac_cv_lib_dl_dlopen+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dl_dlopen=yes
+else
+  ac_cv_lib_dl_dlopen=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
+$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
+if test "x$ac_cv_lib_dl_dlopen" = x""yes; then :
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -lsvld" >&5
+$as_echo_n "checking for dlopen in -lsvld... " >&6; }
+if test "${ac_cv_lib_svld_dlopen+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsvld  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_svld_dlopen=yes
+else
+  ac_cv_lib_svld_dlopen=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_svld_dlopen" >&5
+$as_echo "$ac_cv_lib_svld_dlopen" >&6; }
+if test "x$ac_cv_lib_svld_dlopen" = x""yes; then :
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dld_link in -ldld" >&5
+$as_echo_n "checking for dld_link in -ldld... " >&6; }
+if test "${ac_cv_lib_dld_dld_link+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldld  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dld_link ();
+int
+main ()
+{
+return dld_link ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dld_dld_link=yes
+else
+  ac_cv_lib_dld_dld_link=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_dld_link" >&5
+$as_echo "$ac_cv_lib_dld_dld_link" >&6; }
+if test "x$ac_cv_lib_dld_dld_link" = x""yes; then :
+  lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-ldld"
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+    ;;
+  esac
+
+  if test "x$lt_cv_dlopen" != xno; then
+    enable_dlopen=yes
+  else
+    enable_dlopen=no
+  fi
+
+  case $lt_cv_dlopen in
+  dlopen)
+    save_CPPFLAGS="$CPPFLAGS"
+    test "x$ac_cv_header_dlfcn_h" = xyes && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
+
+    save_LDFLAGS="$LDFLAGS"
+    wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
+
+    save_LIBS="$LIBS"
+    LIBS="$lt_cv_dlopen_libs $LIBS"
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a program can dlopen itself" >&5
+$as_echo_n "checking whether a program can dlopen itself... " >&6; }
+if test "${lt_cv_dlopen_self+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  	  if test "$cross_compiling" = yes; then :
+  lt_cv_dlopen_self=cross
+else
+  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+  lt_status=$lt_dlunknown
+  cat > conftest.$ac_ext <<_LT_EOF
+#line 11157 "configure"
+#include "confdefs.h"
+
+#if HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
+
+#include <stdio.h>
+
+#ifdef RTLD_GLOBAL
+#  define LT_DLGLOBAL		RTLD_GLOBAL
+#else
+#  ifdef DL_GLOBAL
+#    define LT_DLGLOBAL		DL_GLOBAL
+#  else
+#    define LT_DLGLOBAL		0
+#  endif
+#endif
+
+/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#ifndef LT_DLLAZY_OR_NOW
+#  ifdef RTLD_LAZY
+#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
+#  else
+#    ifdef DL_LAZY
+#      define LT_DLLAZY_OR_NOW		DL_LAZY
+#    else
+#      ifdef RTLD_NOW
+#        define LT_DLLAZY_OR_NOW	RTLD_NOW
+#      else
+#        ifdef DL_NOW
+#          define LT_DLLAZY_OR_NOW	DL_NOW
+#        else
+#          define LT_DLLAZY_OR_NOW	0
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+
+/* When -fvisbility=hidden is used, assume the code has been annotated
+   correspondingly for the symbols needed.  */
+#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
+void fnord () __attribute__((visibility("default")));
+#endif
+
+void fnord () { int i=42; }
+int main ()
+{
+  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
+  int status = $lt_dlunknown;
+
+  if (self)
+    {
+      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
+      else
+        {
+	  if (dlsym( self,"_fnord"))  status = $lt_dlneed_uscore;
+          else puts (dlerror ());
+	}
+      /* dlclose (self); */
+    }
+  else
+    puts (dlerror ());
+
+  return status;
+}
+_LT_EOF
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
+    (./conftest; exit; ) >&5 2>/dev/null
+    lt_status=$?
+    case x$lt_status in
+      x$lt_dlno_uscore) lt_cv_dlopen_self=yes ;;
+      x$lt_dlneed_uscore) lt_cv_dlopen_self=yes ;;
+      x$lt_dlunknown|x*) lt_cv_dlopen_self=no ;;
+    esac
+  else :
+    # compilation failed
+    lt_cv_dlopen_self=no
+  fi
+fi
+rm -fr conftest*
+
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self" >&5
+$as_echo "$lt_cv_dlopen_self" >&6; }
+
+    if test "x$lt_cv_dlopen_self" = xyes; then
+      wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $lt_prog_compiler_static\"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a statically linked program can dlopen itself" >&5
+$as_echo_n "checking whether a statically linked program can dlopen itself... " >&6; }
+if test "${lt_cv_dlopen_self_static+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  	  if test "$cross_compiling" = yes; then :
+  lt_cv_dlopen_self_static=cross
+else
+  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+  lt_status=$lt_dlunknown
+  cat > conftest.$ac_ext <<_LT_EOF
+#line 11263 "configure"
+#include "confdefs.h"
+
+#if HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
+
+#include <stdio.h>
+
+#ifdef RTLD_GLOBAL
+#  define LT_DLGLOBAL		RTLD_GLOBAL
+#else
+#  ifdef DL_GLOBAL
+#    define LT_DLGLOBAL		DL_GLOBAL
+#  else
+#    define LT_DLGLOBAL		0
+#  endif
+#endif
+
+/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#ifndef LT_DLLAZY_OR_NOW
+#  ifdef RTLD_LAZY
+#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
+#  else
+#    ifdef DL_LAZY
+#      define LT_DLLAZY_OR_NOW		DL_LAZY
+#    else
+#      ifdef RTLD_NOW
+#        define LT_DLLAZY_OR_NOW	RTLD_NOW
+#      else
+#        ifdef DL_NOW
+#          define LT_DLLAZY_OR_NOW	DL_NOW
+#        else
+#          define LT_DLLAZY_OR_NOW	0
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+
+/* When -fvisbility=hidden is used, assume the code has been annotated
+   correspondingly for the symbols needed.  */
+#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
+void fnord () __attribute__((visibility("default")));
+#endif
+
+void fnord () { int i=42; }
+int main ()
+{
+  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
+  int status = $lt_dlunknown;
+
+  if (self)
+    {
+      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
+      else
+        {
+	  if (dlsym( self,"_fnord"))  status = $lt_dlneed_uscore;
+          else puts (dlerror ());
+	}
+      /* dlclose (self); */
+    }
+  else
+    puts (dlerror ());
+
+  return status;
+}
+_LT_EOF
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
+    (./conftest; exit; ) >&5 2>/dev/null
+    lt_status=$?
+    case x$lt_status in
+      x$lt_dlno_uscore) lt_cv_dlopen_self_static=yes ;;
+      x$lt_dlneed_uscore) lt_cv_dlopen_self_static=yes ;;
+      x$lt_dlunknown|x*) lt_cv_dlopen_self_static=no ;;
+    esac
+  else :
+    # compilation failed
+    lt_cv_dlopen_self_static=no
+  fi
+fi
+rm -fr conftest*
+
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self_static" >&5
+$as_echo "$lt_cv_dlopen_self_static" >&6; }
+    fi
+
+    CPPFLAGS="$save_CPPFLAGS"
+    LDFLAGS="$save_LDFLAGS"
+    LIBS="$save_LIBS"
+    ;;
+  esac
+
+  case $lt_cv_dlopen_self in
+  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;
+  *) enable_dlopen_self=unknown ;;
+  esac
+
+  case $lt_cv_dlopen_self_static in
+  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;
+  *) enable_dlopen_self_static=unknown ;;
+  esac
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+striplib=
+old_striplib=
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether stripping libraries is possible" >&5
+$as_echo_n "checking whether stripping libraries is possible... " >&6; }
+if test -n "$STRIP" && $STRIP -V 2>&1 | $GREP "GNU strip" >/dev/null; then
+  test -z "$old_striplib" && old_striplib="$STRIP --strip-debug"
+  test -z "$striplib" && striplib="$STRIP --strip-unneeded"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+# FIXME - insert some real tests, host_os isn't really good enough
+  case $host_os in
+  darwin*)
+    if test -n "$STRIP" ; then
+      striplib="$STRIP -x"
+      old_striplib="$STRIP -S"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+    fi
+    ;;
+  *)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+    ;;
+  esac
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+  # Report which library types will actually be built
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if libtool supports shared libraries" >&5
+$as_echo_n "checking if libtool supports shared libraries... " >&6; }
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $can_build_shared" >&5
+$as_echo "$can_build_shared" >&6; }
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build shared libraries" >&5
+$as_echo_n "checking whether to build shared libraries... " >&6; }
+  test "$can_build_shared" = "no" && enable_shared=no
+
+  # On AIX, shared libraries and static libraries use the same namespace, and
+  # are all built from PIC.
+  case $host_os in
+  aix3*)
+    test "$enable_shared" = yes && enable_static=no
+    if test -n "$RANLIB"; then
+      archive_cmds="$archive_cmds~\$RANLIB \$lib"
+      postinstall_cmds='$RANLIB $lib'
+    fi
+    ;;
+
+  aix[4-9]*)
+    if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+      test "$enable_shared" = yes && enable_static=no
+    fi
     ;;
   esac
-  # Ok, now we have the path, separated by spaces, we can step through it
-  # and add multilib dir if necessary.
-  lt_tmp_lt_search_path_spec=
-  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`
-  for lt_sys_path in $lt_search_path_spec; do
-    if test -d "$lt_sys_path/$lt_multi_os_dir"; then
-      lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_shared" >&5
+$as_echo "$enable_shared" >&6; }
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build static libraries" >&5
+$as_echo_n "checking whether to build static libraries... " >&6; }
+  # Make sure either enable_shared or enable_static is yes.
+  test "$enable_shared" = yes || enable_static=yes
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_static" >&5
+$as_echo "$enable_static" >&6; }
+
+
+
+
+fi
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+CC="$lt_save_CC"
+
+      if test -n "$CXX" && ( test "X$CXX" != "Xno" &&
+    ( (test "X$CXX" = "Xg++" && `g++ -v >/dev/null 2>&1` ) ||
+    (test "X$CXX" != "Xg++"))) ; then
+  ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C++ preprocessor" >&5
+$as_echo_n "checking how to run the C++ preprocessor... " >&6; }
+if test -z "$CXXCPP"; then
+  if test "${ac_cv_prog_CXXCPP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+      # Double quotes because CXXCPP needs to be expanded
+    for CXXCPP in "$CXX -E" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_cxx_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if ac_fn_cxx_try_cpp "$LINENO"; then :
+
+else
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_cxx_try_cpp "$LINENO"; then :
+  # Broken: success on invalid input.
+continue
+else
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then :
+  break
+fi
+
+    done
+    ac_cv_prog_CXXCPP=$CXXCPP
+
+fi
+  CXXCPP=$ac_cv_prog_CXXCPP
+else
+  ac_cv_prog_CXXCPP=$CXXCPP
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CXXCPP" >&5
+$as_echo "$CXXCPP" >&6; }
+ac_preproc_ok=false
+for ac_cxx_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if ac_fn_cxx_try_cpp "$LINENO"; then :
+
+else
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_cxx_try_cpp "$LINENO"; then :
+  # Broken: success on invalid input.
+continue
+else
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then :
+
+else
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error "C++ preprocessor \"$CXXCPP\" fails sanity check
+See \`config.log' for more details." "$LINENO" 5; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+else
+  _lt_caught_CXX_error=yes
+fi
+
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+archive_cmds_need_lc_CXX=no
+allow_undefined_flag_CXX=
+always_export_symbols_CXX=no
+archive_expsym_cmds_CXX=
+compiler_needs_object_CXX=no
+export_dynamic_flag_spec_CXX=
+hardcode_direct_CXX=no
+hardcode_direct_absolute_CXX=no
+hardcode_libdir_flag_spec_CXX=
+hardcode_libdir_flag_spec_ld_CXX=
+hardcode_libdir_separator_CXX=
+hardcode_minus_L_CXX=no
+hardcode_shlibpath_var_CXX=unsupported
+hardcode_automatic_CXX=no
+inherit_rpath_CXX=no
+module_cmds_CXX=
+module_expsym_cmds_CXX=
+link_all_deplibs_CXX=unknown
+old_archive_cmds_CXX=$old_archive_cmds
+reload_flag_CXX=$reload_flag
+reload_cmds_CXX=$reload_cmds
+no_undefined_flag_CXX=
+whole_archive_flag_spec_CXX=
+enable_shared_with_static_runtimes_CXX=no
+
+# Source file extension for C++ test sources.
+ac_ext=cpp
+
+# Object file extension for compiled C++ test sources.
+objext=o
+objext_CXX=$objext
+
+# No sense in running all these tests if we already determined that
+# the CXX compiler isn't working.  Some variables (like enable_shared)
+# are currently assumed to apply to all compilers on this platform,
+# and will be corrupted by setting them based on a non-working compiler.
+if test "$_lt_caught_CXX_error" != yes; then
+  # Code to be used in simple compile tests
+  lt_simple_compile_test_code="int some_variable = 0;"
+
+  # Code to be used in simple link tests
+  lt_simple_link_test_code='int main(int, char *[]) { return(0); }'
+
+  # ltmain only uses $CC for tagged configurations so make sure $CC is set.
+
+
+
+
+
+
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
+
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
+
+# Allow CC to be a program name with arguments.
+compiler=$CC
+
+
+  # save warnings/boilerplate of simple test code
+  ac_outfile=conftest.$ac_objext
+echo "$lt_simple_compile_test_code" >conftest.$ac_ext
+eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_compiler_boilerplate=`cat conftest.err`
+$RM conftest*
+
+  ac_outfile=conftest.$ac_objext
+echo "$lt_simple_link_test_code" >conftest.$ac_ext
+eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_linker_boilerplate=`cat conftest.err`
+$RM -r conftest*
+
+
+  # Allow CC to be a program name with arguments.
+  lt_save_CC=$CC
+  lt_save_LD=$LD
+  lt_save_GCC=$GCC
+  GCC=$GXX
+  lt_save_with_gnu_ld=$with_gnu_ld
+  lt_save_path_LD=$lt_cv_path_LD
+  if test -n "${lt_cv_prog_gnu_ldcxx+set}"; then
+    lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx
+  else
+    $as_unset lt_cv_prog_gnu_ld
+  fi
+  if test -n "${lt_cv_path_LDCXX+set}"; then
+    lt_cv_path_LD=$lt_cv_path_LDCXX
+  else
+    $as_unset lt_cv_path_LD
+  fi
+  test -z "${LDCXX+set}" || LD=$LDCXX
+  CC=${CXX-"c++"}
+  compiler=$CC
+  compiler_CXX=$CC
+  for cc_temp in $compiler""; do
+  case $cc_temp in
+    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
+    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
+done
+cc_basename=`$ECHO "$cc_temp" | $SED "s%.*/%%; s%^$host_alias-%%"`
+
+
+  if test -n "$compiler"; then
+    # We don't want -fno-exception when compiling C++ code, so set the
+    # no_builtin_flag separately
+    if test "$GXX" = yes; then
+      lt_prog_compiler_no_builtin_flag_CXX=' -fno-builtin'
     else
-      test -d "$lt_sys_path" && \
-	lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path"
+      lt_prog_compiler_no_builtin_flag_CXX=
+    fi
+
+    if test "$GXX" = yes; then
+      # Set up default GNU C++ configuration
+
+
+
+# Check whether --with-gnu-ld was given.
+if test "${with_gnu_ld+set}" = set; then :
+  withval=$with_gnu_ld; test "$withval" = no || with_gnu_ld=yes
+else
+  with_gnu_ld=no
+fi
+
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
+$as_echo_n "checking for ld used by $CC... " >&6; }
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [\\/]* | ?:[\\/]*)
+      re_direlt='/[^/][^/]*/\.\./'
+      # Canonicalize the pathname of ld
+      ac_prog=`$ECHO "$ac_prog"| $SED 's%\\\\%/%g'`
+      while $ECHO "$ac_prog" | $GREP "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`$ECHO $ac_prog| $SED "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNU ld" >&5
+$as_echo_n "checking for GNU ld... " >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for non-GNU ld" >&5
+$as_echo_n "checking for non-GNU ld... " >&6; }
+fi
+if test "${lt_cv_path_LD+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$LD"; then
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  for ac_dir in $PATH; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      lt_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some variants of GNU ld only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      case `"$lt_cv_path_LD" -v 2>&1 </dev/null` in
+      *GNU* | *'with BFD'*)
+	test "$with_gnu_ld" != no && break
+	;;
+      *)
+	test "$with_gnu_ld" != yes && break
+	;;
+      esac
     fi
   done
-  lt_search_path_spec=`$ECHO "$lt_tmp_lt_search_path_spec" | awk '
-BEGIN {RS=" "; FS="/|\n";} {
-  lt_foo="";
-  lt_count=0;
-  for (lt_i = NF; lt_i > 0; lt_i--) {
-    if ($lt_i != "" && $lt_i != ".") {
-      if ($lt_i == "..") {
-        lt_count++;
-      } else {
-        if (lt_count == 0) {
-          lt_foo="/" $lt_i lt_foo;
-        } else {
-          lt_count--;
-        }
-      }
-    }
-  }
-  if (lt_foo != "") { lt_freq[lt_foo]++; }
-  if (lt_freq[lt_foo] == 1) { print lt_foo; }
-}'`
-  # AWK program above erroneously prepends '/' to C:/dos/paths
-  # for these hosts.
-  case $host_os in
-    mingw* | cegcc*) lt_search_path_spec=`$ECHO "$lt_search_path_spec" |\
-      $SED 's,/\([A-Za-z]:\),\1,g'` ;;
-  esac
-  sys_lib_search_path_spec=`$ECHO "$lt_search_path_spec" | $lt_NL2SP`
+  IFS="$lt_save_ifs"
 else
-  sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
+  lt_cv_path_LD="$LD" # Let the user override the test with a path.
 fi
-library_names_spec=
-libname_spec='lib$name'
-soname_spec=
-shrext_cmds=".so"
-postinstall_cmds=
-postuninstall_cmds=
-finish_cmds=
-finish_eval=
-shlibpath_var=
-shlibpath_overrides_runpath=unknown
-version_type=none
-dynamic_linker="$host_os ld.so"
-sys_lib_dlsearch_path_spec="/lib /usr/lib"
-need_lib_prefix=unknown
-hardcode_into_libs=no
+fi
+
+LD="$lt_cv_path_LD"
+if test -n "$LD"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LD" >&5
+$as_echo "$LD" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+test -z "$LD" && as_fn_error "no acceptable ld found in \$PATH" "$LINENO" 5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if the linker ($LD) is GNU ld" >&5
+$as_echo_n "checking if the linker ($LD) is GNU ld... " >&6; }
+if test "${lt_cv_prog_gnu_ld+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  # I'd rather use --version here, but apparently some GNU lds only accept -v.
+case `$LD -v 2>&1 </dev/null` in
+*GNU* | *'with BFD'*)
+  lt_cv_prog_gnu_ld=yes
+  ;;
+*)
+  lt_cv_prog_gnu_ld=no
+  ;;
+esac
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_gnu_ld" >&5
+$as_echo "$lt_cv_prog_gnu_ld" >&6; }
+with_gnu_ld=$lt_cv_prog_gnu_ld
+
+
+
+
+
+
+
+      # Check if GNU C++ uses GNU ld as the underlying linker, since the
+      # archiving commands below assume that GNU ld is being used.
+      if test "$with_gnu_ld" = yes; then
+        archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+        archive_expsym_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+
+        hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
+        export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
+
+        # If archive_cmds runs LD, not CC, wlarc should be empty
+        # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to
+        #     investigate it a little bit more. (MM)
+        wlarc='${wl}'
+
+        # ancient GNU ld didn't support --whole-archive et. al.
+        if eval "`$CC -print-prog-name=ld` --help 2>&1" |
+	  $GREP 'no-whole-archive' > /dev/null; then
+          whole_archive_flag_spec_CXX="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+        else
+          whole_archive_flag_spec_CXX=
+        fi
+      else
+        with_gnu_ld=no
+        wlarc=
+
+        # A generic and very simple default shared library creation
+        # command for GNU C++ for the case where it uses the native
+        # linker, instead of GNU ld.  If possible, this setting should
+        # overridden to take advantage of the native linker features on
+        # the platform it is being used on.
+        archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'
+      fi
+
+      # Commands to make compiler produce verbose output that lists
+      # what "hidden" libraries, object files and flags are used when
+      # linking a shared library.
+      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
+
+    else
+      GXX=no
+      with_gnu_ld=no
+      wlarc=
+    fi
+
+    # PORTME: fill in a description of your system's C++ link characteristics
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $compiler linker ($LD) supports shared libraries" >&5
+$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
+    ld_shlibs_CXX=yes
+    case $host_os in
+      aix3*)
+        # FIXME: insert proper C++ library support
+        ld_shlibs_CXX=no
+        ;;
+      aix[4-9]*)
+        if test "$host_cpu" = ia64; then
+          # On IA64, the linker does run time linking by default, so we don't
+          # have to do anything special.
+          aix_use_runtimelinking=no
+          exp_sym_flag='-Bexport'
+          no_entry_flag=""
+        else
+          aix_use_runtimelinking=no
+
+          # Test if we are trying to use run time linking or normal
+          # AIX style linking. If -brtl is somewhere in LDFLAGS, we
+          # need to do runtime linking.
+          case $host_os in aix4.[23]|aix4.[23].*|aix[5-9]*)
+	    for ld_flag in $LDFLAGS; do
+	      case $ld_flag in
+	      *-brtl*)
+	        aix_use_runtimelinking=yes
+	        break
+	        ;;
+	      esac
+	    done
+	    ;;
+          esac
+
+          exp_sym_flag='-bexport'
+          no_entry_flag='-bnoentry'
+        fi
+
+        # When large executables or shared objects are built, AIX ld can
+        # have problems creating the table of contents.  If linking a library
+        # or program results in "error TOC overflow" add -mminimal-toc to
+        # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+        # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
+
+        archive_cmds_CXX=''
+        hardcode_direct_CXX=yes
+        hardcode_direct_absolute_CXX=yes
+        hardcode_libdir_separator_CXX=':'
+        link_all_deplibs_CXX=yes
+        file_list_spec_CXX='${wl}-f,'
+
+        if test "$GXX" = yes; then
+          case $host_os in aix4.[012]|aix4.[012].*)
+          # We only want to do this on AIX 4.2 and lower, the check
+          # below for broken collect2 doesn't work under 4.3+
+	  collect2name=`${CC} -print-prog-name=collect2`
+	  if test -f "$collect2name" &&
+	     strings "$collect2name" | $GREP resolve_lib_name >/dev/null
+	  then
+	    # We have reworked collect2
+	    :
+	  else
+	    # We have old collect2
+	    hardcode_direct_CXX=unsupported
+	    # It fails to find uninstalled libraries when the uninstalled
+	    # path is not listed in the libpath.  Setting hardcode_minus_L
+	    # to unsupported forces relinking
+	    hardcode_minus_L_CXX=yes
+	    hardcode_libdir_flag_spec_CXX='-L$libdir'
+	    hardcode_libdir_separator_CXX=
+	  fi
+          esac
+          shared_flag='-shared'
+	  if test "$aix_use_runtimelinking" = yes; then
+	    shared_flag="$shared_flag "'${wl}-G'
+	  fi
+        else
+          # not using gcc
+          if test "$host_cpu" = ia64; then
+	  # VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
+	  # chokes on -Wl,-G. The following line is correct:
+	  shared_flag='-G'
+          else
+	    if test "$aix_use_runtimelinking" = yes; then
+	      shared_flag='${wl}-G'
+	    else
+	      shared_flag='${wl}-bM:SRE'
+	    fi
+          fi
+        fi
+
+        export_dynamic_flag_spec_CXX='${wl}-bexpall'
+        # It seems that -bexpall does not export symbols beginning with
+        # underscore (_), so it is better to generate a list of symbols to
+	# export.
+        always_export_symbols_CXX=yes
+        if test "$aix_use_runtimelinking" = yes; then
+          # Warning - without using the other runtime loading flags (-brtl),
+          # -berok will link without error, but may produce a broken library.
+          allow_undefined_flag_CXX='-berok'
+          # Determine the default libpath from the value encoded in an empty
+          # executable.
+          cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+
+lt_aix_libpath_sed='
+    /Import File Strings/,/^$/ {
+	/^0/ {
+	    s/^0  *\(.*\)$/\1/
+	    p
+	}
+    }'
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then
+  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
+
+          hardcode_libdir_flag_spec_CXX='${wl}-blibpath:$libdir:'"$aix_libpath"
+
+          archive_expsym_cmds_CXX='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then func_echo_all "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+        else
+          if test "$host_cpu" = ia64; then
+	    hardcode_libdir_flag_spec_CXX='${wl}-R $libdir:/usr/lib:/lib'
+	    allow_undefined_flag_CXX="-z nodefs"
+	    archive_expsym_cmds_CXX="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+          else
+	    # Determine the default libpath from the value encoded in an
+	    # empty executable.
+	    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+
+lt_aix_libpath_sed='
+    /Import File Strings/,/^$/ {
+	/^0/ {
+	    s/^0  *\(.*\)$/\1/
+	    p
+	}
+    }'
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then
+  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
+
+	    hardcode_libdir_flag_spec_CXX='${wl}-blibpath:$libdir:'"$aix_libpath"
+	    # Warning - without using the other run time loading flags,
+	    # -berok will link without error, but may produce a broken library.
+	    no_undefined_flag_CXX=' ${wl}-bernotok'
+	    allow_undefined_flag_CXX=' ${wl}-berok'
+	    if test "$with_gnu_ld" = yes; then
+	      # We only use this code for GNU lds that support --whole-archive.
+	      whole_archive_flag_spec_CXX='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	    else
+	      # Exported symbols can be pulled into shared objects from archives
+	      whole_archive_flag_spec_CXX='$convenience'
+	    fi
+	    archive_cmds_need_lc_CXX=yes
+	    # This is similar to how AIX traditionally builds its shared
+	    # libraries.
+	    archive_expsym_cmds_CXX="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+          fi
+        fi
+        ;;
+
+      beos*)
+	if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	  allow_undefined_flag_CXX=unsupported
+	  # Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+	  # support --undefined.  This deserves some investigation.  FIXME
+	  archive_cmds_CXX='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	else
+	  ld_shlibs_CXX=no
+	fi
+	;;
+
+      chorus*)
+        case $cc_basename in
+          *)
+	  # FIXME: insert proper C++ library support
+	  ld_shlibs_CXX=no
+	  ;;
+        esac
+        ;;
+
+      cygwin* | mingw* | pw32* | cegcc*)
+        # _LT_TAGVAR(hardcode_libdir_flag_spec, CXX) is actually meaningless,
+        # as there is no search path for DLLs.
+        hardcode_libdir_flag_spec_CXX='-L$libdir'
+        export_dynamic_flag_spec_CXX='${wl}--export-all-symbols'
+        allow_undefined_flag_CXX=unsupported
+        always_export_symbols_CXX=no
+        enable_shared_with_static_runtimes_CXX=yes
+
+        if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
+          archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+          # If the export-symbols file already is a .def file (1st line
+          # is EXPORTS), use it as is; otherwise, prepend...
+          archive_expsym_cmds_CXX='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	    cp $export_symbols $output_objdir/$soname.def;
+          else
+	    echo EXPORTS > $output_objdir/$soname.def;
+	    cat $export_symbols >> $output_objdir/$soname.def;
+          fi~
+          $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+        else
+          ld_shlibs_CXX=no
+        fi
+        ;;
+      darwin* | rhapsody*)
+
+
+  archive_cmds_need_lc_CXX=no
+  hardcode_direct_CXX=no
+  hardcode_automatic_CXX=yes
+  hardcode_shlibpath_var_CXX=unsupported
+  if test "$lt_cv_ld_force_load" = "yes"; then
+    whole_archive_flag_spec_CXX='`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience ${wl}-force_load,$conv\"; done; func_echo_all \"$new_convenience\"`'
+  else
+    whole_archive_flag_spec_CXX=''
+  fi
+  link_all_deplibs_CXX=yes
+  allow_undefined_flag_CXX="$_lt_dar_allow_undefined"
+  case $cc_basename in
+     ifort*) _lt_dar_can_shared=yes ;;
+     *) _lt_dar_can_shared=$GCC ;;
+  esac
+  if test "$_lt_dar_can_shared" = "yes"; then
+    output_verbose_link_cmd=func_echo_all
+    archive_cmds_CXX="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
+    module_cmds_CXX="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
+    archive_expsym_cmds_CXX="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
+    module_expsym_cmds_CXX="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
+       if test "$lt_cv_apple_cc_single_mod" != "yes"; then
+      archive_cmds_CXX="\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dsymutil}"
+      archive_expsym_cmds_CXX="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dar_export_syms}${_lt_dsymutil}"
+    fi
+
+  else
+  ld_shlibs_CXX=no
+  fi
+
+	;;
+
+      dgux*)
+        case $cc_basename in
+          ec++*)
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+          ghcx*)
+	    # Green Hills C++ Compiler
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+          *)
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+        esac
+        ;;
+
+      freebsd2.*)
+        # C++ shared libraries reported to be fairly broken before
+	# switch to ELF
+        ld_shlibs_CXX=no
+        ;;
+
+      freebsd-elf*)
+        archive_cmds_need_lc_CXX=no
+        ;;
+
+      freebsd* | dragonfly*)
+        # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF
+        # conventions
+        ld_shlibs_CXX=yes
+        ;;
+
+      gnu*)
+        ;;
+
+      haiku*)
+        archive_cmds_CXX='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+        link_all_deplibs_CXX=yes
+        ;;
+
+      hpux9*)
+        hardcode_libdir_flag_spec_CXX='${wl}+b ${wl}$libdir'
+        hardcode_libdir_separator_CXX=:
+        export_dynamic_flag_spec_CXX='${wl}-E'
+        hardcode_direct_CXX=yes
+        hardcode_minus_L_CXX=yes # Not in the search PATH,
+				             # but as the default
+				             # location of the library.
+
+        case $cc_basename in
+          CC*)
+            # FIXME: insert proper C++ library support
+            ld_shlibs_CXX=no
+            ;;
+          aCC*)
+            archive_cmds_CXX='$RM $output_objdir/$soname~$CC -b ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+            # Commands to make compiler produce verbose output that lists
+            # what "hidden" libraries, object files and flags are used when
+            # linking a shared library.
+            #
+            # There doesn't appear to be a way to prevent this compiler from
+            # explicitly linking system object files so we need to strip them
+            # from the output so that they don't get included in the library
+            # dependencies.
+            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+            ;;
+          *)
+            if test "$GXX" = yes; then
+              archive_cmds_CXX='$RM $output_objdir/$soname~$CC -shared -nostdlib -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+            else
+              # FIXME: insert proper C++ library support
+              ld_shlibs_CXX=no
+            fi
+            ;;
+        esac
+        ;;
+
+      hpux10*|hpux11*)
+        if test $with_gnu_ld = no; then
+	  hardcode_libdir_flag_spec_CXX='${wl}+b ${wl}$libdir'
+	  hardcode_libdir_separator_CXX=:
+
+          case $host_cpu in
+            hppa*64*|ia64*)
+              ;;
+            *)
+	      export_dynamic_flag_spec_CXX='${wl}-E'
+              ;;
+          esac
+        fi
+        case $host_cpu in
+          hppa*64*|ia64*)
+            hardcode_direct_CXX=no
+            hardcode_shlibpath_var_CXX=no
+            ;;
+          *)
+            hardcode_direct_CXX=yes
+            hardcode_direct_absolute_CXX=yes
+            hardcode_minus_L_CXX=yes # Not in the search PATH,
+					         # but as the default
+					         # location of the library.
+            ;;
+        esac
+
+        case $cc_basename in
+          CC*)
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+          aCC*)
+	    case $host_cpu in
+	      hppa*64*)
+	        archive_cmds_CXX='$CC -b ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        ;;
+	      ia64*)
+	        archive_cmds_CXX='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        ;;
+	      *)
+	        archive_cmds_CXX='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        ;;
+	    esac
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+	    ;;
+          *)
+	    if test "$GXX" = yes; then
+	      if test $with_gnu_ld = no; then
+	        case $host_cpu in
+	          hppa*64*)
+	            archive_cmds_CXX='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            ;;
+	          ia64*)
+	            archive_cmds_CXX='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            ;;
+	          *)
+	            archive_cmds_CXX='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            ;;
+	        esac
+	      fi
+	    else
+	      # FIXME: insert proper C++ library support
+	      ld_shlibs_CXX=no
+	    fi
+	    ;;
+        esac
+        ;;
+
+      interix[3-9]*)
+	hardcode_direct_CXX=no
+	hardcode_shlibpath_var_CXX=no
+	hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
+	export_dynamic_flag_spec_CXX='${wl}-E'
+	# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
+	# Instead, shared libraries are loaded at an image base (0x10000000 by
+	# default) and relocated if they conflict, which is a slow very memory
+	# consuming and fragmenting process.  To avoid this, we pick a random,
+	# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
+	# time.  Moving up from 0x10000000 also allows more sbrk(2) space.
+	archive_cmds_CXX='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+	archive_expsym_cmds_CXX='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+	;;
+      irix5* | irix6*)
+        case $cc_basename in
+          CC*)
+	    # SGI C++
+	    archive_cmds_CXX='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+
+	    # Archives containing C++ object files must be created using
+	    # "CC -ar", where "CC" is the IRIX C++ compiler.  This is
+	    # necessary to make sure instantiated templates are included
+	    # in the archive.
+	    old_archive_cmds_CXX='$CC -ar -WR,-u -o $oldlib $oldobjs'
+	    ;;
+          *)
+	    if test "$GXX" = yes; then
+	      if test "$with_gnu_ld" = no; then
+	        archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	      else
+	        archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` -o $lib'
+	      fi
+	    fi
+	    link_all_deplibs_CXX=yes
+	    ;;
+        esac
+        hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
+        hardcode_libdir_separator_CXX=:
+        inherit_rpath_CXX=yes
+        ;;
+
+      linux* | k*bsd*-gnu | kopensolaris*-gnu)
+        case $cc_basename in
+          KCC*)
+	    # Kuck and Associates, Inc. (KAI) C++ Compiler
+
+	    # KCC will only create a shared library if the output file
+	    # ends with ".so" (or ".sl" for HP-UX), so rename the library
+	    # to its proper name (with version) after linking.
+	    archive_cmds_CXX='tempext=`echo $shared_ext | $SED -e '\''s/\([^()0-9A-Za-z{}]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
+	    archive_expsym_cmds_CXX='tempext=`echo $shared_ext | $SED -e '\''s/\([^()0-9A-Za-z{}]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib ${wl}-retain-symbols-file,$export_symbols; mv \$templib $lib'
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP "ld"`; rm -f libconftest$shared_ext; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+
+	    hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
+	    export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
+
+	    # Archives containing C++ object files must be created using
+	    # "CC -Bstatic", where "CC" is the KAI C++ compiler.
+	    old_archive_cmds_CXX='$CC -Bstatic -o $oldlib $oldobjs'
+	    ;;
+	  icpc* | ecpc* )
+	    # Intel C++
+	    with_gnu_ld=yes
+	    # version 8.0 and above of icpc choke on multiply defined symbols
+	    # if we add $predep_objects and $postdep_objects, however 7.1 and
+	    # earlier do not add the objects themselves.
+	    case `$CC -V 2>&1` in
+	      *"Version 7."*)
+	        archive_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+		archive_expsym_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+		;;
+	      *)  # Version 8.0 or newer
+	        tmp_idyn=
+	        case $host_cpu in
+		  ia64*) tmp_idyn=' -i_dynamic';;
+		esac
+	        archive_cmds_CXX='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+		archive_expsym_cmds_CXX='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+		;;
+	    esac
+	    archive_cmds_need_lc_CXX=no
+	    hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
+	    export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
+	    whole_archive_flag_spec_CXX='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	    ;;
+          pgCC* | pgcpp*)
+            # Portland Group C++ compiler
+	    case `$CC -V` in
+	    *pgCC\ [1-5].* | *pgcpp\ [1-5].*)
+	      prelink_cmds_CXX='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~
+		compile_command="$compile_command `find $tpldir -name \*.o | $NL2SP`"'
+	      old_archive_cmds_CXX='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~
+		$AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \*.o | $NL2SP`~
+		$RANLIB $oldlib'
+	      archive_cmds_CXX='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
+		$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
+	      archive_expsym_cmds_CXX='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
+		$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
+	      ;;
+	    *) # Version 6 and above use weak symbols
+	      archive_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
+	      archive_expsym_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
+	      ;;
+	    esac
 
-# when you set need_version to no, make sure it does not cause -set_version
-# flags to be left without arguments
-need_version=unknown
+	    hardcode_libdir_flag_spec_CXX='${wl}--rpath ${wl}$libdir'
+	    export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
+	    whole_archive_flag_spec_CXX='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+            ;;
+	  cxx*)
+	    # Compaq C++
+	    archive_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    archive_expsym_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname  -o $lib ${wl}-retain-symbols-file $wl$export_symbols'
+
+	    runpath_var=LD_RUN_PATH
+	    hardcode_libdir_flag_spec_CXX='-rpath $libdir'
+	    hardcode_libdir_separator_CXX=:
+
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld"`; templist=`func_echo_all "$templist" | $SED "s/\(^.*ld.*\)\( .*ld .*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "X$list" | $Xsed'
+	    ;;
+	  xl* | mpixl* | bgxl*)
+	    # IBM XL 8.0 on PPC, with GNU ld
+	    hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
+	    export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
+	    archive_cmds_CXX='$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    if test "x$supports_anon_versioning" = xyes; then
+	      archive_expsym_cmds_CXX='echo "{ global:" > $output_objdir/$libname.ver~
+		cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+		echo "local: *; };" >> $output_objdir/$libname.ver~
+		$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+	    fi
+	    ;;
+	  *)
+	    case `$CC -V 2>&1 | sed 5q` in
+	    *Sun\ C*)
+	      # Sun C++ 5.9
+	      no_undefined_flag_CXX=' -zdefs'
+	      archive_cmds_CXX='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	      archive_expsym_cmds_CXX='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file ${wl}$export_symbols'
+	      hardcode_libdir_flag_spec_CXX='-R$libdir'
+	      whole_archive_flag_spec_CXX='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	      compiler_needs_object_CXX=yes
+
+	      # Not sure whether something based on
+	      # $CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1
+	      # would be better.
+	      output_verbose_link_cmd='func_echo_all'
+
+	      # Archives containing C++ object files must be created using
+	      # "CC -xar", where "CC" is the Sun C++ compiler.  This is
+	      # necessary to make sure instantiated templates are included
+	      # in the archive.
+	      old_archive_cmds_CXX='$CC -xar -o $oldlib $oldobjs'
+	      ;;
+	    esac
+	    ;;
+	esac
+	;;
 
-case $host_os in
-aix3*)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
-  shlibpath_var=LIBPATH
+      lynxos*)
+        # FIXME: insert proper C++ library support
+	ld_shlibs_CXX=no
+	;;
 
-  # AIX 3 has no versioning support, so we append a major version to the name.
-  soname_spec='${libname}${release}${shared_ext}$major'
-  ;;
+      m88k*)
+        # FIXME: insert proper C++ library support
+        ld_shlibs_CXX=no
+	;;
 
-aix[4-9]*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  hardcode_into_libs=yes
-  if test "$host_cpu" = ia64; then
-    # AIX 5 supports IA64
-    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
-    shlibpath_var=LD_LIBRARY_PATH
-  else
-    # With GCC up to 2.95.x, collect2 would create an import file
-    # for dependence libraries.  The import file would start with
-    # the line `#! .'.  This would cause the generated library to
-    # depend on `.', always an invalid library.  This was fixed in
-    # development snapshots of GCC prior to 3.0.
-    case $host_os in
-      aix4 | aix4.[01] | aix4.[01].*)
-      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
-	   echo ' yes '
-	   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then
-	:
-      else
-	can_build_shared=no
-      fi
-      ;;
-    esac
-    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
-    # soname into executable. Probably we can add versioning support to
-    # collect2, so additional links can be useful in future.
-    if test "$aix_use_runtimelinking" = yes; then
-      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
-      # instead of lib<name>.a to let people know that these are not
-      # typical AIX shared libraries.
-      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    else
-      # We preserve .a as extension for shared libraries through AIX4.2
-      # and later when we are not doing run time linking.
-      library_names_spec='${libname}${release}.a $libname.a'
-      soname_spec='${libname}${release}${shared_ext}$major'
-    fi
-    shlibpath_var=LIBPATH
-  fi
-  ;;
+      mvs*)
+        case $cc_basename in
+          cxx*)
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+	  *)
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+	esac
+	;;
 
-amigaos*)
-  case $host_cpu in
-  powerpc)
-    # Since July 2007 AmigaOS4 officially supports .so libraries.
-    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    ;;
-  m68k)
-    library_names_spec='$libname.ixlibrary $libname.a'
-    # Create ${libname}_ixlibrary.a entries in /sys/libs.
-    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all "$lib" | $SED '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
-    ;;
-  esac
-  ;;
+      netbsd*)
+        if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	  archive_cmds_CXX='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'
+	  wlarc=
+	  hardcode_libdir_flag_spec_CXX='-R$libdir'
+	  hardcode_direct_CXX=yes
+	  hardcode_shlibpath_var_CXX=no
+	fi
+	# Workaround some broken pre-1.5 toolchains
+	output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP conftest.$objext | $SED -e "s:-lgcc -lc -lgcc::"'
+	;;
 
-beos*)
-  library_names_spec='${libname}${shared_ext}'
-  dynamic_linker="$host_os ld.so"
-  shlibpath_var=LIBRARY_PATH
-  ;;
+      *nto* | *qnx*)
+        ld_shlibs_CXX=yes
+	;;
 
-bsdi[45]*)
-  version_type=linux
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
-  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
-  # the default ld.so.conf also contains /usr/contrib/lib and
-  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
-  # libtool to hard-code these into programs
-  ;;
+      openbsd2*)
+        # C++ shared libraries are fairly broken
+	ld_shlibs_CXX=no
+	;;
 
-cygwin* | mingw* | pw32* | cegcc*)
-  version_type=windows
-  shrext_cmds=".dll"
-  need_version=no
-  need_lib_prefix=no
+      openbsd*)
+	if test -f /usr/libexec/ld.so; then
+	  hardcode_direct_CXX=yes
+	  hardcode_shlibpath_var_CXX=no
+	  hardcode_direct_absolute_CXX=yes
+	  archive_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'
+	  hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
+	  if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+	    archive_expsym_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file,$export_symbols -o $lib'
+	    export_dynamic_flag_spec_CXX='${wl}-E'
+	    whole_archive_flag_spec_CXX="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+	  fi
+	  output_verbose_link_cmd=func_echo_all
+	else
+	  ld_shlibs_CXX=no
+	fi
+	;;
 
-  case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
-    library_names_spec='$libname.dll.a'
-    # DLL is installed to $(libdir)/../bin by postinstall_cmds
-    postinstall_cmds='base_file=`basename \${file}`~
-      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
-      dldir=$destdir/`dirname \$dlpath`~
-      test -d \$dldir || mkdir -p \$dldir~
-      $install_prog $dir/$dlname \$dldir/$dlname~
-      chmod a+x \$dldir/$dlname~
-      if test -n '\''$stripme'\'' && test -n '\''$striplib'\''; then
-        eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
-      fi'
-    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
-      dlpath=$dir/\$dldll~
-       $RM \$dlpath'
-    shlibpath_overrides_runpath=yes
+      osf3* | osf4* | osf5*)
+        case $cc_basename in
+          KCC*)
+	    # Kuck and Associates, Inc. (KAI) C++ Compiler
 
-    case $host_os in
-    cygwin*)
-      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
-      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+	    # KCC will only create a shared library if the output file
+	    # ends with ".so" (or ".sl" for HP-UX), so rename the library
+	    # to its proper name (with version) after linking.
+	    archive_cmds_CXX='tempext=`echo $shared_ext | $SED -e '\''s/\([^()0-9A-Za-z{}]\)/\\\\\1/g'\''`; templib=`echo "$lib" | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
 
-      sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
-      ;;
-    mingw* | cegcc*)
-      # MinGW DLLs use traditional 'lib' prefix
-      soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+	    hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
+	    hardcode_libdir_separator_CXX=:
+
+	    # Archives containing C++ object files must be created using
+	    # the KAI C++ compiler.
+	    case $host in
+	      osf3*) old_archive_cmds_CXX='$CC -Bstatic -o $oldlib $oldobjs' ;;
+	      *) old_archive_cmds_CXX='$CC -o $oldlib $oldobjs' ;;
+	    esac
+	    ;;
+          RCC*)
+	    # Rational C++ 2.4.1
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+          cxx*)
+	    case $host in
+	      osf3*)
+	        allow_undefined_flag_CXX=' ${wl}-expect_unresolved ${wl}\*'
+	        archive_cmds_CXX='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $soname `test -n "$verstring" && func_echo_all "${wl}-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	        hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
+		;;
+	      *)
+	        allow_undefined_flag_CXX=' -expect_unresolved \*'
+	        archive_cmds_CXX='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	        archive_expsym_cmds_CXX='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done~
+	          echo "-hidden">> $lib.exp~
+	          $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname ${wl}-input ${wl}$lib.exp  `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib~
+	          $RM $lib.exp'
+	        hardcode_libdir_flag_spec_CXX='-rpath $libdir'
+		;;
+	    esac
+
+	    hardcode_libdir_separator_CXX=:
+
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld" | $GREP -v "ld:"`; templist=`func_echo_all "$templist" | $SED "s/\(^.*ld.*\)\( .*ld.*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+	    ;;
+	  *)
+	    if test "$GXX" = yes && test "$with_gnu_ld" = no; then
+	      allow_undefined_flag_CXX=' ${wl}-expect_unresolved ${wl}\*'
+	      case $host in
+	        osf3*)
+	          archive_cmds_CXX='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+		  ;;
+	        *)
+	          archive_cmds_CXX='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+		  ;;
+	      esac
+
+	      hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
+	      hardcode_libdir_separator_CXX=:
+
+	      # Commands to make compiler produce verbose output that lists
+	      # what "hidden" libraries, object files and flags are used when
+	      # linking a shared library.
+	      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
+
+	    else
+	      # FIXME: insert proper C++ library support
+	      ld_shlibs_CXX=no
+	    fi
+	    ;;
+        esac
+        ;;
+
+      psos*)
+        # FIXME: insert proper C++ library support
+        ld_shlibs_CXX=no
+        ;;
+
+      sunos4*)
+        case $cc_basename in
+          CC*)
+	    # Sun C++ 4.x
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+          lcc*)
+	    # Lucid
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+          *)
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+        esac
+        ;;
+
+      solaris*)
+        case $cc_basename in
+          CC*)
+	    # Sun C++ 4.2, 5.x and Centerline C++
+            archive_cmds_need_lc_CXX=yes
+	    no_undefined_flag_CXX=' -zdefs'
+	    archive_cmds_CXX='$CC -G${allow_undefined_flag}  -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	    archive_expsym_cmds_CXX='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	      $CC -G${allow_undefined_flag} ${wl}-M ${wl}$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+
+	    hardcode_libdir_flag_spec_CXX='-R$libdir'
+	    hardcode_shlibpath_var_CXX=no
+	    case $host_os in
+	      solaris2.[0-5] | solaris2.[0-5].*) ;;
+	      *)
+		# The compiler driver will combine and reorder linker options,
+		# but understands `-z linker_flag'.
+	        # Supported since Solaris 2.6 (maybe 2.5.1?)
+		whole_archive_flag_spec_CXX='-z allextract$convenience -z defaultextract'
+	        ;;
+	    esac
+	    link_all_deplibs_CXX=yes
+
+	    output_verbose_link_cmd='func_echo_all'
+
+	    # Archives containing C++ object files must be created using
+	    # "CC -xar", where "CC" is the Sun C++ compiler.  This is
+	    # necessary to make sure instantiated templates are included
+	    # in the archive.
+	    old_archive_cmds_CXX='$CC -xar -o $oldlib $oldobjs'
+	    ;;
+          gcx*)
+	    # Green Hills C++ Compiler
+	    archive_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+
+	    # The C++ compiler must be used to create the archive.
+	    old_archive_cmds_CXX='$CC $LDFLAGS -archive -o $oldlib $oldobjs'
+	    ;;
+          *)
+	    # GNU C++ compiler with Solaris linker
+	    if test "$GXX" = yes && test "$with_gnu_ld" = no; then
+	      no_undefined_flag_CXX=' ${wl}-z ${wl}defs'
+	      if $CC --version | $GREP -v '^2\.7' > /dev/null; then
+	        archive_cmds_CXX='$CC -shared -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+	        archive_expsym_cmds_CXX='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+		  $CC -shared -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+
+	        # Commands to make compiler produce verbose output that lists
+	        # what "hidden" libraries, object files and flags are used when
+	        # linking a shared library.
+	        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
+	      else
+	        # g++ 2.7 appears to require `-G' NOT `-shared' on this
+	        # platform.
+	        archive_cmds_CXX='$CC -G -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+	        archive_expsym_cmds_CXX='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+		  $CC -G -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+
+	        # Commands to make compiler produce verbose output that lists
+	        # what "hidden" libraries, object files and flags are used when
+	        # linking a shared library.
+	        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
+	      fi
+
+	      hardcode_libdir_flag_spec_CXX='${wl}-R $wl$libdir'
+	      case $host_os in
+		solaris2.[0-5] | solaris2.[0-5].*) ;;
+		*)
+		  whole_archive_flag_spec_CXX='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
+		  ;;
+	      esac
+	    fi
+	    ;;
+        esac
+        ;;
+
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)
+      no_undefined_flag_CXX='${wl}-z,text'
+      archive_cmds_need_lc_CXX=no
+      hardcode_shlibpath_var_CXX=no
+      runpath_var='LD_RUN_PATH'
+
+      case $cc_basename in
+        CC*)
+	  archive_cmds_CXX='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_expsym_cmds_CXX='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  archive_cmds_CXX='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_expsym_cmds_CXX='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+      esac
       ;;
-    pw32*)
-      # pw32 DLLs use 'pw' prefix rather than 'lib'
-      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+
+      sysv5* | sco3.2v5* | sco5v6*)
+	# Note: We can NOT use -z defs as we might desire, because we do not
+	# link with -lc, and that would cause any symbols used from libc to
+	# always be unresolved, which means just about no library would
+	# ever link correctly.  If we're not using GNU ld we use -z text
+	# though, which does catch some bad symbols but isn't as heavy-handed
+	# as -z defs.
+	no_undefined_flag_CXX='${wl}-z,text'
+	allow_undefined_flag_CXX='${wl}-z,nodefs'
+	archive_cmds_need_lc_CXX=no
+	hardcode_shlibpath_var_CXX=no
+	hardcode_libdir_flag_spec_CXX='${wl}-R,$libdir'
+	hardcode_libdir_separator_CXX=':'
+	link_all_deplibs_CXX=yes
+	export_dynamic_flag_spec_CXX='${wl}-Bexport'
+	runpath_var='LD_RUN_PATH'
+
+	case $cc_basename in
+          CC*)
+	    archive_cmds_CXX='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    archive_expsym_cmds_CXX='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    old_archive_cmds_CXX='$CC -Tprelink_objects $oldobjs~
+	      '"$old_archive_cmds_CXX"
+	    reload_cmds_CXX='$CC -Tprelink_objects $reload_objs~
+	      '"$reload_cmds_CXX"
+	    ;;
+	  *)
+	    archive_cmds_CXX='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    archive_expsym_cmds_CXX='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    ;;
+	esac
       ;;
+
+      tandem*)
+        case $cc_basename in
+          NCC*)
+	    # NonStop-UX NCC 3.20
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+          *)
+	    # FIXME: insert proper C++ library support
+	    ld_shlibs_CXX=no
+	    ;;
+        esac
+        ;;
+
+      vxworks*)
+        # FIXME: insert proper C++ library support
+        ld_shlibs_CXX=no
+        ;;
+
+      *)
+        # FIXME: insert proper C++ library support
+        ld_shlibs_CXX=no
+        ;;
     esac
-    ;;
 
-  *)
-    library_names_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext} $libname.lib'
-    ;;
-  esac
-  dynamic_linker='Win32 ld.exe'
-  # FIXME: first we should search . and the directory the executable is in
-  shlibpath_var=PATH
-  ;;
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs_CXX" >&5
+$as_echo "$ld_shlibs_CXX" >&6; }
+    test "$ld_shlibs_CXX" = no && can_build_shared=no
+
+    GCC_CXX="$GXX"
+    LD_CXX="$LD"
+
+    ## CAVEAT EMPTOR:
+    ## There is no encapsulation within the following macros, do not change
+    ## the running order or otherwise move them around unless you know exactly
+    ## what you are doing...
+    # Dependencies to place before and after the object being linked:
+predep_objects_CXX=
+postdep_objects_CXX=
+predeps_CXX=
+postdeps_CXX=
+compiler_lib_search_path_CXX=
+
+cat > conftest.$ac_ext <<_LT_EOF
+class Foo
+{
+public:
+  Foo (void) { a = 0; }
+private:
+  int a;
+};
+_LT_EOF
 
-darwin* | rhapsody*)
-  dynamic_linker="$host_os dyld"
-  version_type=darwin
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
-  soname_spec='${libname}${release}${major}$shared_ext'
-  shlibpath_overrides_runpath=yes
-  shlibpath_var=DYLD_LIBRARY_PATH
-  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
+if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+  # Parse the compiler output and extract the necessary
+  # objects, libraries and library flags.
+
+  # Sentinel used to keep track of whether or not we are before
+  # the conftest object file.
+  pre_test_object_deps_done=no
+
+  for p in `eval "$output_verbose_link_cmd"`; do
+    case $p in
+
+    -L* | -R* | -l*)
+       # Some compilers place space between "-{L,R}" and the path.
+       # Remove the space.
+       if test $p = "-L" ||
+          test $p = "-R"; then
+	 prev=$p
+	 continue
+       else
+	 prev=
+       fi
 
-  sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/local/lib"
-  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'
-  ;;
+       if test "$pre_test_object_deps_done" = no; then
+	 case $p in
+	 -L* | -R*)
+	   # Internal compiler library paths should come after those
+	   # provided the user.  The postdeps already come after the
+	   # user supplied libs so there is no need to process them.
+	   if test -z "$compiler_lib_search_path_CXX"; then
+	     compiler_lib_search_path_CXX="${prev}${p}"
+	   else
+	     compiler_lib_search_path_CXX="${compiler_lib_search_path_CXX} ${prev}${p}"
+	   fi
+	   ;;
+	 # The "-l" case would never come before the object being
+	 # linked, so don't bother handling this case.
+	 esac
+       else
+	 if test -z "$postdeps_CXX"; then
+	   postdeps_CXX="${prev}${p}"
+	 else
+	   postdeps_CXX="${postdeps_CXX} ${prev}${p}"
+	 fi
+       fi
+       ;;
+
+    *.$objext)
+       # This assumes that the test object file only shows up
+       # once in the compiler output.
+       if test "$p" = "conftest.$objext"; then
+	 pre_test_object_deps_done=yes
+	 continue
+       fi
 
-dgux*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
+       if test "$pre_test_object_deps_done" = no; then
+	 if test -z "$predep_objects_CXX"; then
+	   predep_objects_CXX="$p"
+	 else
+	   predep_objects_CXX="$predep_objects_CXX $p"
+	 fi
+       else
+	 if test -z "$postdep_objects_CXX"; then
+	   postdep_objects_CXX="$p"
+	 else
+	   postdep_objects_CXX="$postdep_objects_CXX $p"
+	 fi
+       fi
+       ;;
+
+    *) ;; # Ignore the rest.
+
+    esac
+  done
+
+  # Clean up.
+  rm -f a.out a.exe
+else
+  echo "libtool.m4: error: problem compiling CXX test program"
+fi
+
+$RM -f confest.$objext
+
+# PORTME: override above test on systems where it is broken
+case $host_os in
+interix[3-9]*)
+  # Interix 3.5 installs completely hosed .la files for C++, so rather than
+  # hack all around it, let's just trust "g++" to DTRT.
+  predep_objects_CXX=
+  postdep_objects_CXX=
+  postdeps_CXX=
   ;;
 
-freebsd* | dragonfly*)
-  # DragonFly does not have aout.  When/if they implement a new
-  # versioning mechanism, adjust this.
-  if test -x /usr/bin/objformat; then
-    objformat=`/usr/bin/objformat`
-  else
-    case $host_os in
-    freebsd[23].*) objformat=aout ;;
-    *) objformat=elf ;;
-    esac
-  fi
-  version_type=freebsd-$objformat
-  case $version_type in
-    freebsd-elf*)
-      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
-      need_version=no
-      need_lib_prefix=no
-      ;;
-    freebsd-*)
-      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
-      need_version=yes
+linux*)
+  case `$CC -V 2>&1 | sed 5q` in
+  *Sun\ C*)
+    # Sun C++ 5.9
+
+    # The more standards-conforming stlport4 library is
+    # incompatible with the Cstd library. Avoid specifying
+    # it if it's in CXXFLAGS. Ignore libCrun as
+    # -library=stlport4 depends on it.
+    case " $CXX $CXXFLAGS " in
+    *" -library=stlport4 "*)
+      solaris_use_stlport4=yes
       ;;
-  esac
-  shlibpath_var=LD_LIBRARY_PATH
-  case $host_os in
-  freebsd2.*)
-    shlibpath_overrides_runpath=yes
-    ;;
-  freebsd3.[01]* | freebsdelf3.[01]*)
-    shlibpath_overrides_runpath=yes
-    hardcode_into_libs=yes
-    ;;
-  freebsd3.[2-9]* | freebsdelf3.[2-9]* | \
-  freebsd4.[0-5] | freebsdelf4.[0-5] | freebsd4.1.1 | freebsdelf4.1.1)
-    shlibpath_overrides_runpath=no
-    hardcode_into_libs=yes
-    ;;
-  *) # from 4.6 on, and DragonFly
-    shlibpath_overrides_runpath=yes
-    hardcode_into_libs=yes
+    esac
+
+    if test "$solaris_use_stlport4" != yes; then
+      postdeps_CXX='-library=Cstd -library=Crun'
+    fi
     ;;
   esac
   ;;
 
-gnu*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  hardcode_into_libs=yes
-  ;;
-
-haiku*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  dynamic_linker="$host_os runtime_loader"
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/beos/system/lib'
-  hardcode_into_libs=yes
-  ;;
+solaris*)
+  case $cc_basename in
+  CC*)
+    # The more standards-conforming stlport4 library is
+    # incompatible with the Cstd library. Avoid specifying
+    # it if it's in CXXFLAGS. Ignore libCrun as
+    # -library=stlport4 depends on it.
+    case " $CXX $CXXFLAGS " in
+    *" -library=stlport4 "*)
+      solaris_use_stlport4=yes
+      ;;
+    esac
 
-hpux9* | hpux10* | hpux11*)
-  # Give a soname corresponding to the major version so that dld.sl refuses to
-  # link against other versions.
-  version_type=sunos
-  need_lib_prefix=no
-  need_version=no
-  case $host_cpu in
-  ia64*)
-    shrext_cmds='.so'
-    hardcode_into_libs=yes
-    dynamic_linker="$host_os dld.so"
-    shlibpath_var=LD_LIBRARY_PATH
-    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    if test "X$HPUX_IA64_MODE" = X32; then
-      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
-    else
-      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
+    # Adding this requires a known-good setup of shared libraries for
+    # Sun compiler versions before 5.6, else PIC objects from an old
+    # archive will be linked into the output, leading to subtle bugs.
+    if test "$solaris_use_stlport4" != yes; then
+      postdeps_CXX='-library=Cstd -library=Crun'
     fi
-    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
-    ;;
-  hppa*64*)
-    shrext_cmds='.sl'
-    hardcode_into_libs=yes
-    dynamic_linker="$host_os dld.sl"
-    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
-    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
-    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
-    ;;
-  *)
-    shrext_cmds='.sl'
-    dynamic_linker="$host_os dld.sl"
-    shlibpath_var=SHLIB_PATH
-    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
     ;;
   esac
-  # HP-UX runs *really* slowly unless shared libraries are mode 555, ...
-  postinstall_cmds='chmod 555 $lib'
-  # or fails outright, so override atomically:
-  install_override_mode=555
   ;;
+esac
 
-interix[3-9]*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  ;;
 
-irix5* | irix6* | nonstopux*)
-  case $host_os in
-    nonstopux*) version_type=nonstopux ;;
-    *)
-	if test "$lt_cv_prog_gnu_ld" = yes; then
-		version_type=linux
-	else
-		version_type=irix
-	fi ;;
-  esac
-  need_lib_prefix=no
-  need_version=no
-  soname_spec='${libname}${release}${shared_ext}$major'
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
-  case $host_os in
-  irix5* | nonstopux*)
-    libsuff= shlibsuff=
+case " $postdeps_CXX " in
+*" -lc "*) archive_cmds_need_lc_CXX=no ;;
+esac
+ compiler_lib_search_dirs_CXX=
+if test -n "${compiler_lib_search_path_CXX}"; then
+ compiler_lib_search_dirs_CXX=`echo " ${compiler_lib_search_path_CXX}" | ${SED} -e 's! -L! !g' -e 's!^ !!'`
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    lt_prog_compiler_wl_CXX=
+lt_prog_compiler_pic_CXX=
+lt_prog_compiler_static_CXX=
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $compiler option to produce PIC" >&5
+$as_echo_n "checking for $compiler option to produce PIC... " >&6; }
+
+  # C++ specific cases for pic, static, wl, etc.
+  if test "$GXX" = yes; then
+    lt_prog_compiler_wl_CXX='-Wl,'
+    lt_prog_compiler_static_CXX='-static'
+
+    case $host_os in
+    aix*)
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	lt_prog_compiler_static_CXX='-Bstatic'
+      fi
+      lt_prog_compiler_pic_CXX='-fPIC'
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            lt_prog_compiler_pic_CXX='-fPIC'
+        ;;
+      m68k)
+            # FIXME: we need at least 68020 code to build shared libraries, but
+            # adding the `-m68020' flag to GCC prevents building anything better,
+            # like `-m68040'.
+            lt_prog_compiler_pic_CXX='-m68020 -resident32 -malways-restore-a4'
+        ;;
+      esac
+      ;;
+
+    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
+    mingw* | cygwin* | os2* | pw32* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      # Although the cygwin gcc ignores -fPIC, still need this for old-style
+      # (--disable-auto-import) libraries
+      lt_prog_compiler_pic_CXX='-DDLL_EXPORT'
+      ;;
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      lt_prog_compiler_pic_CXX='-fno-common'
+      ;;
+    *djgpp*)
+      # DJGPP does not support shared libraries at all
+      lt_prog_compiler_pic_CXX=
+      ;;
+    haiku*)
+      # PIC is the default for Haiku.
+      # The "-static" flag exists, but is broken.
+      lt_prog_compiler_static_CXX=
+      ;;
+    interix[3-9]*)
+      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
+      # Instead, we relocate shared libraries at runtime.
+      ;;
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	lt_prog_compiler_pic_CXX=-Kconform_pic
+      fi
+      ;;
+    hpux*)
+      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
+      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
+      # sets the default TLS model and affects inlining.
+      case $host_cpu in
+      hppa*64*)
+	;;
+      *)
+	lt_prog_compiler_pic_CXX='-fPIC'
+	;;
+      esac
+      ;;
+    *qnx* | *nto*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      lt_prog_compiler_pic_CXX='-fPIC -shared'
+      ;;
+    *)
+      lt_prog_compiler_pic_CXX='-fPIC'
+      ;;
+    esac
+  else
+    case $host_os in
+      aix[4-9]*)
+	# All AIX code is PIC.
+	if test "$host_cpu" = ia64; then
+	  # AIX 5 now supports IA64 processor
+	  lt_prog_compiler_static_CXX='-Bstatic'
+	else
+	  lt_prog_compiler_static_CXX='-bnso -bI:/lib/syscalls.exp'
+	fi
+	;;
+      chorus*)
+	case $cc_basename in
+	cxch68*)
+	  # Green Hills C++ Compiler
+	  # _LT_TAGVAR(lt_prog_compiler_static, CXX)="--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a"
+	  ;;
+	esac
+	;;
+      dgux*)
+	case $cc_basename in
+	  ec++*)
+	    lt_prog_compiler_pic_CXX='-KPIC'
+	    ;;
+	  ghcx*)
+	    # Green Hills C++ Compiler
+	    lt_prog_compiler_pic_CXX='-pic'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      freebsd* | dragonfly*)
+	# FreeBSD uses GNU C++
+	;;
+      hpux9* | hpux10* | hpux11*)
+	case $cc_basename in
+	  CC*)
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    lt_prog_compiler_static_CXX='${wl}-a ${wl}archive'
+	    if test "$host_cpu" != ia64; then
+	      lt_prog_compiler_pic_CXX='+Z'
+	    fi
+	    ;;
+	  aCC*)
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    lt_prog_compiler_static_CXX='${wl}-a ${wl}archive'
+	    case $host_cpu in
+	    hppa*64*|ia64*)
+	      # +Z the default
+	      ;;
+	    *)
+	      lt_prog_compiler_pic_CXX='+Z'
+	      ;;
+	    esac
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      interix*)
+	# This is c89, which is MS Visual C++ (no shared libs)
+	# Anyone wants to do a port?
+	;;
+      irix5* | irix6* | nonstopux*)
+	case $cc_basename in
+	  CC*)
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    lt_prog_compiler_static_CXX='-non_shared'
+	    # CC pic flag -KPIC is the default.
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      linux* | k*bsd*-gnu | kopensolaris*-gnu)
+	case $cc_basename in
+	  KCC*)
+	    # KAI C++ Compiler
+	    lt_prog_compiler_wl_CXX='--backend -Wl,'
+	    lt_prog_compiler_pic_CXX='-fPIC'
+	    ;;
+	  ecpc* )
+	    # old Intel C++ for x86_64 which still supported -KPIC.
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    lt_prog_compiler_pic_CXX='-KPIC'
+	    lt_prog_compiler_static_CXX='-static'
+	    ;;
+	  icpc* )
+	    # Intel C++, used to be incompatible with GCC.
+	    # ICC 10 doesn't accept -KPIC any more.
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    lt_prog_compiler_pic_CXX='-fPIC'
+	    lt_prog_compiler_static_CXX='-static'
+	    ;;
+	  pgCC* | pgcpp*)
+	    # Portland Group C++ compiler
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    lt_prog_compiler_pic_CXX='-fpic'
+	    lt_prog_compiler_static_CXX='-Bstatic'
+	    ;;
+	  cxx*)
+	    # Compaq C++
+	    # Make sure the PIC flag is empty.  It appears that all Alpha
+	    # Linux and Compaq Tru64 Unix objects are PIC.
+	    lt_prog_compiler_pic_CXX=
+	    lt_prog_compiler_static_CXX='-non_shared'
+	    ;;
+	  xlc* | xlC* | bgxl[cC]* | mpixl[cC]*)
+	    # IBM XL 8.0, 9.0 on PPC and BlueGene
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    lt_prog_compiler_pic_CXX='-qpic'
+	    lt_prog_compiler_static_CXX='-qstaticlink'
+	    ;;
+	  *)
+	    case `$CC -V 2>&1 | sed 5q` in
+	    *Sun\ C*)
+	      # Sun C++ 5.9
+	      lt_prog_compiler_pic_CXX='-KPIC'
+	      lt_prog_compiler_static_CXX='-Bstatic'
+	      lt_prog_compiler_wl_CXX='-Qoption ld '
+	      ;;
+	    esac
+	    ;;
+	esac
+	;;
+      lynxos*)
+	;;
+      m88k*)
+	;;
+      mvs*)
+	case $cc_basename in
+	  cxx*)
+	    lt_prog_compiler_pic_CXX='-W c,exportall'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      netbsd*)
+	;;
+      *qnx* | *nto*)
+        # QNX uses GNU C++, but need to define -shared option too, otherwise
+        # it will coredump.
+        lt_prog_compiler_pic_CXX='-fPIC -shared'
+        ;;
+      osf3* | osf4* | osf5*)
+	case $cc_basename in
+	  KCC*)
+	    lt_prog_compiler_wl_CXX='--backend -Wl,'
+	    ;;
+	  RCC*)
+	    # Rational C++ 2.4.1
+	    lt_prog_compiler_pic_CXX='-pic'
+	    ;;
+	  cxx*)
+	    # Digital/Compaq C++
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    # Make sure the PIC flag is empty.  It appears that all Alpha
+	    # Linux and Compaq Tru64 Unix objects are PIC.
+	    lt_prog_compiler_pic_CXX=
+	    lt_prog_compiler_static_CXX='-non_shared'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      psos*)
+	;;
+      solaris*)
+	case $cc_basename in
+	  CC*)
+	    # Sun C++ 4.2, 5.x and Centerline C++
+	    lt_prog_compiler_pic_CXX='-KPIC'
+	    lt_prog_compiler_static_CXX='-Bstatic'
+	    lt_prog_compiler_wl_CXX='-Qoption ld '
+	    ;;
+	  gcx*)
+	    # Green Hills C++ Compiler
+	    lt_prog_compiler_pic_CXX='-PIC'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      sunos4*)
+	case $cc_basename in
+	  CC*)
+	    # Sun C++ 4.x
+	    lt_prog_compiler_pic_CXX='-pic'
+	    lt_prog_compiler_static_CXX='-Bstatic'
+	    ;;
+	  lcc*)
+	    # Lucid
+	    lt_prog_compiler_pic_CXX='-pic'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+	case $cc_basename in
+	  CC*)
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    lt_prog_compiler_pic_CXX='-KPIC'
+	    lt_prog_compiler_static_CXX='-Bstatic'
+	    ;;
+	esac
+	;;
+      tandem*)
+	case $cc_basename in
+	  NCC*)
+	    # NonStop-UX NCC 3.20
+	    lt_prog_compiler_pic_CXX='-KPIC'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      vxworks*)
+	;;
+      *)
+	lt_prog_compiler_can_build_shared_CXX=no
+	;;
+    esac
+  fi
+
+case $host_os in
+  # For platforms which do not support PIC, -DPIC is meaningless:
+  *djgpp*)
+    lt_prog_compiler_pic_CXX=
     ;;
   *)
-    case $LD in # libtool.m4 will add one of these switches to LD
-    *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ")
-      libsuff= shlibsuff= libmagic=32-bit;;
-    *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ")
-      libsuff=32 shlibsuff=N32 libmagic=N32;;
-    *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ")
-      libsuff=64 shlibsuff=64 libmagic=64-bit;;
-    *) libsuff= shlibsuff= libmagic=never-match;;
-    esac
+    lt_prog_compiler_pic_CXX="$lt_prog_compiler_pic_CXX -DPIC"
     ;;
-  esac
-  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
-  shlibpath_overrides_runpath=no
-  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
-  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
-  hardcode_into_libs=yes
-  ;;
+esac
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_prog_compiler_pic_CXX" >&5
+$as_echo "$lt_prog_compiler_pic_CXX" >&6; }
 
-# No shared lib support for Linux oldld, aout, or coff.
-linux*oldld* | linux*aout* | linux*coff*)
-  dynamic_linker=no
-  ;;
 
-# This must be Linux ELF.
-linux* | k*bsd*-gnu | kopensolaris*-gnu)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
 
-  # Some binutils ld are patched to set DT_RUNPATH
-  if test "${lt_cv_shlibpath_overrides_runpath+set}" = set; then :
+#
+# Check to make sure the PIC flag actually works.
+#
+if test -n "$lt_prog_compiler_pic_CXX"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler PIC flag $lt_prog_compiler_pic_CXX works" >&5
+$as_echo_n "checking if $compiler PIC flag $lt_prog_compiler_pic_CXX works... " >&6; }
+if test "${lt_cv_prog_compiler_pic_works_CXX+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  lt_cv_shlibpath_overrides_runpath=no
-    save_LDFLAGS=$LDFLAGS
-    save_libdir=$libdir
-    eval "libdir=/foo; wl=\"$lt_prog_compiler_wl\"; \
-	 LDFLAGS=\"\$LDFLAGS $hardcode_libdir_flag_spec\""
-    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
+  lt_cv_prog_compiler_pic_works_CXX=no
+   ac_outfile=conftest.$ac_objext
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="$lt_prog_compiler_pic_CXX -DPIC"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&5
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_pic_works_CXX=yes
+     fi
+   fi
+   $RM conftest*
 
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  if  ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null; then :
-  lt_cv_shlibpath_overrides_runpath=yes
 fi
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-    LDFLAGS=$save_LDFLAGS
-    libdir=$save_libdir
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_pic_works_CXX" >&5
+$as_echo "$lt_cv_prog_compiler_pic_works_CXX" >&6; }
 
+if test x"$lt_cv_prog_compiler_pic_works_CXX" = xyes; then
+    case $lt_prog_compiler_pic_CXX in
+     "" | " "*) ;;
+     *) lt_prog_compiler_pic_CXX=" $lt_prog_compiler_pic_CXX" ;;
+     esac
+else
+    lt_prog_compiler_pic_CXX=
+     lt_prog_compiler_can_build_shared_CXX=no
 fi
 
-  shlibpath_overrides_runpath=$lt_cv_shlibpath_overrides_runpath
-
-  # This implies no fast_install, which is unacceptable.
-  # Some rework will be needed to allow for fast_install
-  # before this can be enabled.
-  hardcode_into_libs=yes
-
-  # Append ld.so.conf contents to the search path
-  if test -f /etc/ld.so.conf; then
-    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/"//g;/^$/d' | tr '\n' ' '`
-    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
-  fi
-
-  # We used to test for /lib/ld.so.1 and disable shared libraries on
-  # powerpc, because MkLinux only supported shared libraries with the
-  # GNU dynamic linker.  Since this was broken with cross compilers,
-  # most powerpc-linux boxes support dynamic linking these days and
-  # people can always --disable-shared, the test was removed, and we
-  # assume the GNU/Linux dynamic linker is in use.
-  dynamic_linker='GNU/Linux ld.so'
-  ;;
+fi
 
-netbsd*)
-  version_type=sunos
-  need_lib_prefix=no
-  need_version=no
-  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
-    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
-    dynamic_linker='NetBSD (a.out) ld.so'
-  else
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    dynamic_linker='NetBSD ld.elf_so'
-  fi
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  hardcode_into_libs=yes
-  ;;
 
-newsos6)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  ;;
 
-*nto* | *qnx*)
-  version_type=qnx
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  dynamic_linker='ldqnx.so'
-  ;;
+#
+# Check to make sure the static flag actually works.
+#
+wl=$lt_prog_compiler_wl_CXX eval lt_tmp_static_flag=\"$lt_prog_compiler_static_CXX\"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler static flag $lt_tmp_static_flag works" >&5
+$as_echo_n "checking if $compiler static flag $lt_tmp_static_flag works... " >&6; }
+if test "${lt_cv_prog_compiler_static_works_CXX+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_static_works_CXX=no
+   save_LDFLAGS="$LDFLAGS"
+   LDFLAGS="$LDFLAGS $lt_tmp_static_flag"
+   echo "$lt_simple_link_test_code" > conftest.$ac_ext
+   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
+     # The linker can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     if test -s conftest.err; then
+       # Append any errors to the config.log.
+       cat conftest.err 1>&5
+       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
+       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+       if diff conftest.exp conftest.er2 >/dev/null; then
+         lt_cv_prog_compiler_static_works_CXX=yes
+       fi
+     else
+       lt_cv_prog_compiler_static_works_CXX=yes
+     fi
+   fi
+   $RM -r conftest*
+   LDFLAGS="$save_LDFLAGS"
 
-openbsd*)
-  version_type=sunos
-  sys_lib_dlsearch_path_spec="/usr/lib"
-  need_lib_prefix=no
-  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
-  case $host_os in
-    openbsd3.3 | openbsd3.3.*)	need_version=yes ;;
-    *)				need_version=no  ;;
-  esac
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
-  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
-    case $host_os in
-      openbsd2.[89] | openbsd2.[89].*)
-	shlibpath_overrides_runpath=no
-	;;
-      *)
-	shlibpath_overrides_runpath=yes
-	;;
-      esac
-  else
-    shlibpath_overrides_runpath=yes
-  fi
-  ;;
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_static_works_CXX" >&5
+$as_echo "$lt_cv_prog_compiler_static_works_CXX" >&6; }
 
-os2*)
-  libname_spec='$name'
-  shrext_cmds=".dll"
-  need_lib_prefix=no
-  library_names_spec='$libname${shared_ext} $libname.a'
-  dynamic_linker='OS/2 ld.exe'
-  shlibpath_var=LIBPATH
-  ;;
+if test x"$lt_cv_prog_compiler_static_works_CXX" = xyes; then
+    :
+else
+    lt_prog_compiler_static_CXX=
+fi
 
-osf3* | osf4* | osf5*)
-  version_type=osf
-  need_lib_prefix=no
-  need_version=no
-  soname_spec='${libname}${release}${shared_ext}$major'
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  shlibpath_var=LD_LIBRARY_PATH
-  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
-  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
-  ;;
 
-rdos*)
-  dynamic_linker=no
-  ;;
 
-solaris*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  hardcode_into_libs=yes
-  # ldd complains unless libraries are executable
-  postinstall_cmds='chmod +x $lib'
-  ;;
 
-sunos4*)
-  version_type=sunos
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
-  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  if test "$with_gnu_ld" = yes; then
-    need_lib_prefix=no
-  fi
-  need_version=yes
-  ;;
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
+$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
+if test "${lt_cv_prog_compiler_c_o_CXX+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_c_o_CXX=no
+   $RM -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
 
-sysv4 | sysv4.3*)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  case $host_vendor in
-    sni)
-      shlibpath_overrides_runpath=no
-      need_lib_prefix=no
-      runpath_var=LD_RUN_PATH
-      ;;
-    siemens)
-      need_lib_prefix=no
-      ;;
-    motorola)
-      need_lib_prefix=no
-      need_version=no
-      shlibpath_overrides_runpath=no
-      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
-      ;;
-  esac
-  ;;
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&5
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_c_o_CXX=yes
+     fi
+   fi
+   chmod u+w . 2>&5
+   $RM conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
+   $RM out/* && rmdir out
+   cd ..
+   $RM -r conftest
+   $RM conftest*
 
-sysv4*MP*)
-  if test -d /usr/nec ;then
-    version_type=linux
-    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
-    soname_spec='$libname${shared_ext}.$major'
-    shlibpath_var=LD_LIBRARY_PATH
-  fi
-  ;;
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o_CXX" >&5
+$as_echo "$lt_cv_prog_compiler_c_o_CXX" >&6; }
 
-sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
-  version_type=freebsd-elf
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  hardcode_into_libs=yes
-  if test "$with_gnu_ld" = yes; then
-    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
-  else
-    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
-    case $host_os in
-      sco3.2v5*)
-        sys_lib_search_path_spec="$sys_lib_search_path_spec /lib"
-	;;
-    esac
-  fi
-  sys_lib_dlsearch_path_spec='/usr/lib'
-  ;;
 
-tpf*)
-  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  ;;
 
-uts4*)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  ;;
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
+$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
+if test "${lt_cv_prog_compiler_c_o_CXX+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_c_o_CXX=no
+   $RM -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
 
-*)
-  dynamic_linker=no
-  ;;
-esac
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $dynamic_linker" >&5
-$as_echo "$dynamic_linker" >&6; }
-test "$dynamic_linker" = no && can_build_shared=no
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&5
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_c_o_CXX=yes
+     fi
+   fi
+   chmod u+w . 2>&5
+   $RM conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
+   $RM out/* && rmdir out
+   cd ..
+   $RM -r conftest
+   $RM conftest*
 
-variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
-if test "$GCC" = yes; then
-  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o_CXX" >&5
+$as_echo "$lt_cv_prog_compiler_c_o_CXX" >&6; }
 
-if test "${lt_cv_sys_lib_search_path_spec+set}" = set; then
-  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
-fi
-if test "${lt_cv_sys_lib_dlsearch_path_spec+set}" = set; then
-  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
+
+
+
+hard_links="nottested"
+if test "$lt_cv_prog_compiler_c_o_CXX" = no && test "$need_locks" != no; then
+  # do not overwrite the value of need_locks provided by the user
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if we can lock with hard links" >&5
+$as_echo_n "checking if we can lock with hard links... " >&6; }
+  hard_links=yes
+  $RM conftest*
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  touch conftest.a
+  ln conftest.a conftest.b 2>&5 || hard_links=no
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $hard_links" >&5
+$as_echo "$hard_links" >&6; }
+  if test "$hard_links" = no; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
+$as_echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
+    need_locks=warn
+  fi
+else
+  need_locks=no
 fi
 
 
 
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $compiler linker ($LD) supports shared libraries" >&5
+$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
 
+  export_symbols_cmds_CXX='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  case $host_os in
+  aix[4-9]*)
+    # If we're using GNU nm, then we don't want the "-C" option.
+    # -C means demangle to AIX nm, but means don't demangle with GNU nm
+    # Also, AIX nm treats weak defined symbols like other global defined
+    # symbols, whereas GNU nm marks them as "W".
+    if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
+      export_symbols_cmds_CXX='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+    else
+      export_symbols_cmds_CXX='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+    fi
+    ;;
+  pw32*)
+    export_symbols_cmds_CXX="$ltdll_cmds"
+  ;;
+  cygwin* | mingw* | cegcc*)
+    export_symbols_cmds_CXX='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[BCDGRS][ ]/s/.*[ ]\([^ ]*\)/\1 DATA/;/^.*[ ]__nm__/s/^.*[ ]__nm__\([^ ]*\)[ ][^ ]*/\1 DATA/;/^I[ ]/d;/^[AITW][ ]/s/.* //'\'' | sort | uniq > $export_symbols'
+  ;;
+  *)
+    export_symbols_cmds_CXX='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  ;;
+  esac
+  exclude_expsyms_CXX='_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*'
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs_CXX" >&5
+$as_echo "$ld_shlibs_CXX" >&6; }
+test "$ld_shlibs_CXX" = no && can_build_shared=no
 
+with_gnu_ld_CXX=$with_gnu_ld
 
 
 
 
 
 
+#
+# Do we need to explicitly link libc?
+#
+case "x$archive_cmds_need_lc_CXX" in
+x|xyes)
+  # Assume -lc should be added
+  archive_cmds_need_lc_CXX=yes
 
+  if test "$enable_shared" = yes && test "$GCC" = yes; then
+    case $archive_cmds_CXX in
+    *'~'*)
+      # FIXME: we may have to deal with multi-command sequences.
+      ;;
+    '$CC '*)
+      # Test whether the compiler implicitly links with -lc since on some
+      # systems, -lgcc has to come before -lc. If gcc already passes -lc
+      # to ld, don't add -lc before -lgcc.
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -lc should be explicitly linked in" >&5
+$as_echo_n "checking whether -lc should be explicitly linked in... " >&6; }
+if test "${lt_cv_archive_cmds_need_lc_CXX+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  $RM conftest*
+	echo "$lt_simple_compile_test_code" > conftest.$ac_ext
 
+	if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } 2>conftest.err; then
+	  soname=conftest
+	  lib=conftest
+	  libobjs=conftest.$ac_objext
+	  deplibs=
+	  wl=$lt_prog_compiler_wl_CXX
+	  pic_flag=$lt_prog_compiler_pic_CXX
+	  compiler_flags=-v
+	  linker_flags=-v
+	  verstring=
+	  output_objdir=.
+	  libname=conftest
+	  lt_save_allow_undefined_flag=$allow_undefined_flag_CXX
+	  allow_undefined_flag_CXX=
+	  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$archive_cmds_CXX 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1\""; } >&5
+  (eval $archive_cmds_CXX 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+	  then
+	    lt_cv_archive_cmds_need_lc_CXX=no
+	  else
+	    lt_cv_archive_cmds_need_lc_CXX=yes
+	  fi
+	  allow_undefined_flag_CXX=$lt_save_allow_undefined_flag
+	else
+	  cat conftest.err 1>&5
+	fi
+	$RM conftest*
 
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_archive_cmds_need_lc_CXX" >&5
+$as_echo "$lt_cv_archive_cmds_need_lc_CXX" >&6; }
+      archive_cmds_need_lc_CXX=$lt_cv_archive_cmds_need_lc_CXX
+      ;;
+    esac
+  fi
+  ;;
+esac
 
 
 
@@ -10272,565 +13770,637 @@ fi
 
 
 
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking dynamic linker characteristics" >&5
+$as_echo_n "checking dynamic linker characteristics... " >&6; }
 
+library_names_spec=
+libname_spec='lib$name'
+soname_spec=
+shrext_cmds=".so"
+postinstall_cmds=
+postuninstall_cmds=
+finish_cmds=
+finish_eval=
+shlibpath_var=
+shlibpath_overrides_runpath=unknown
+version_type=none
+dynamic_linker="$host_os ld.so"
+sys_lib_dlsearch_path_spec="/lib /usr/lib"
+need_lib_prefix=unknown
+hardcode_into_libs=no
 
+# when you set need_version to no, make sure it does not cause -set_version
+# flags to be left without arguments
+need_version=unknown
 
+case $host_os in
+aix3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
+  shlibpath_var=LIBPATH
 
+  # AIX 3 has no versioning support, so we append a major version to the name.
+  soname_spec='${libname}${release}${shared_ext}$major'
+  ;;
 
+aix[4-9]*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  hardcode_into_libs=yes
+  if test "$host_cpu" = ia64; then
+    # AIX 5 supports IA64
+    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+    shlibpath_var=LD_LIBRARY_PATH
+  else
+    # With GCC up to 2.95.x, collect2 would create an import file
+    # for dependence libraries.  The import file would start with
+    # the line `#! .'.  This would cause the generated library to
+    # depend on `.', always an invalid library.  This was fixed in
+    # development snapshots of GCC prior to 3.0.
+    case $host_os in
+      aix4 | aix4.[01] | aix4.[01].*)
+      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
+	   echo ' yes '
+	   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then
+	:
+      else
+	can_build_shared=no
+      fi
+      ;;
+    esac
+    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
+    # soname into executable. Probably we can add versioning support to
+    # collect2, so additional links can be useful in future.
+    if test "$aix_use_runtimelinking" = yes; then
+      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
+      # instead of lib<name>.a to let people know that these are not
+      # typical AIX shared libraries.
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    else
+      # We preserve .a as extension for shared libraries through AIX4.2
+      # and later when we are not doing run time linking.
+      library_names_spec='${libname}${release}.a $libname.a'
+      soname_spec='${libname}${release}${shared_ext}$major'
+    fi
+    shlibpath_var=LIBPATH
+  fi
+  ;;
 
+amigaos*)
+  case $host_cpu in
+  powerpc)
+    # Since July 2007 AmigaOS4 officially supports .so libraries.
+    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    ;;
+  m68k)
+    library_names_spec='$libname.ixlibrary $libname.a'
+    # Create ${libname}_ixlibrary.a entries in /sys/libs.
+    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all "$lib" | $SED '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
+    ;;
+  esac
+  ;;
 
+beos*)
+  library_names_spec='${libname}${shared_ext}'
+  dynamic_linker="$host_os ld.so"
+  shlibpath_var=LIBRARY_PATH
+  ;;
 
+bsdi[45]*)
+  version_type=linux
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
+  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
+  # the default ld.so.conf also contains /usr/contrib/lib and
+  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
+  # libtool to hard-code these into programs
+  ;;
 
+cygwin* | mingw* | pw32* | cegcc*)
+  version_type=windows
+  shrext_cmds=".dll"
+  need_version=no
+  need_lib_prefix=no
 
+  case $GCC,$host_os in
+  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+    library_names_spec='$libname.dll.a'
+    # DLL is installed to $(libdir)/../bin by postinstall_cmds
+    postinstall_cmds='base_file=`basename \${file}`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
+      dldir=$destdir/`dirname \$dlpath`~
+      test -d \$dldir || mkdir -p \$dldir~
+      $install_prog $dir/$dlname \$dldir/$dlname~
+      chmod a+x \$dldir/$dlname~
+      if test -n '\''$stripme'\'' && test -n '\''$striplib'\''; then
+        eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
+      fi'
+    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
+      dlpath=$dir/\$dldll~
+       $RM \$dlpath'
+    shlibpath_overrides_runpath=yes
 
+    case $host_os in
+    cygwin*)
+      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
+      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
 
+      ;;
+    mingw* | cegcc*)
+      # MinGW DLLs use traditional 'lib' prefix
+      soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    pw32*)
+      # pw32 DLLs use 'pw' prefix rather than 'lib'
+      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    esac
+    ;;
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking how to hardcode library paths into programs" >&5
-$as_echo_n "checking how to hardcode library paths into programs... " >&6; }
-hardcode_action=
-if test -n "$hardcode_libdir_flag_spec" ||
-   test -n "$runpath_var" ||
-   test "X$hardcode_automatic" = "Xyes" ; then
-
-  # We can hardcode non-existent directories.
-  if test "$hardcode_direct" != no &&
-     # If the only mechanism to avoid hardcoding is shlibpath_var, we
-     # have to relink, otherwise we might link with an installed library
-     # when we should be linking with a yet-to-be-installed one
-     ## test "$_LT_TAGVAR(hardcode_shlibpath_var, )" != no &&
-     test "$hardcode_minus_L" != no; then
-    # Linking always hardcodes the temporary library directory.
-    hardcode_action=relink
-  else
-    # We can link without hardcoding, and we can hardcode nonexisting dirs.
-    hardcode_action=immediate
-  fi
-else
-  # We cannot hardcode anything, or else we can only hardcode existing
-  # directories.
-  hardcode_action=unsupported
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $hardcode_action" >&5
-$as_echo "$hardcode_action" >&6; }
-
-if test "$hardcode_action" = relink ||
-   test "$inherit_rpath" = yes; then
-  # Fast installation is not supported
-  enable_fast_install=no
-elif test "$shlibpath_overrides_runpath" = yes ||
-     test "$enable_shared" = no; then
-  # Fast installation is not necessary
-  enable_fast_install=needless
-fi
-
-
-
+  *)
+    library_names_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext} $libname.lib'
+    ;;
+  esac
+  dynamic_linker='Win32 ld.exe'
+  # FIXME: first we should search . and the directory the executable is in
+  shlibpath_var=PATH
+  ;;
 
+darwin* | rhapsody*)
+  dynamic_linker="$host_os dyld"
+  version_type=darwin
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
+  soname_spec='${libname}${release}${major}$shared_ext'
+  shlibpath_overrides_runpath=yes
+  shlibpath_var=DYLD_LIBRARY_PATH
+  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
 
+  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'
+  ;;
 
-  if test "x$enable_dlopen" != xyes; then
-  enable_dlopen=unknown
-  enable_dlopen_self=unknown
-  enable_dlopen_self_static=unknown
-else
-  lt_cv_dlopen=no
-  lt_cv_dlopen_libs=
+dgux*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
 
+freebsd* | dragonfly*)
+  # DragonFly does not have aout.  When/if they implement a new
+  # versioning mechanism, adjust this.
+  if test -x /usr/bin/objformat; then
+    objformat=`/usr/bin/objformat`
+  else
+    case $host_os in
+    freebsd[23].*) objformat=aout ;;
+    *) objformat=elf ;;
+    esac
+  fi
+  version_type=freebsd-$objformat
+  case $version_type in
+    freebsd-elf*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+      need_version=no
+      need_lib_prefix=no
+      ;;
+    freebsd-*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
+      need_version=yes
+      ;;
+  esac
+  shlibpath_var=LD_LIBRARY_PATH
   case $host_os in
-  beos*)
-    lt_cv_dlopen="load_add_on"
-    lt_cv_dlopen_libs=
-    lt_cv_dlopen_self=yes
+  freebsd2.*)
+    shlibpath_overrides_runpath=yes
     ;;
-
-  mingw* | pw32* | cegcc*)
-    lt_cv_dlopen="LoadLibrary"
-    lt_cv_dlopen_libs=
+  freebsd3.[01]* | freebsdelf3.[01]*)
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
     ;;
-
-  cygwin*)
-    lt_cv_dlopen="dlopen"
-    lt_cv_dlopen_libs=
+  freebsd3.[2-9]* | freebsdelf3.[2-9]* | \
+  freebsd4.[0-5] | freebsdelf4.[0-5] | freebsd4.1.1 | freebsdelf4.1.1)
+    shlibpath_overrides_runpath=no
+    hardcode_into_libs=yes
+    ;;
+  *) # from 4.6 on, and DragonFly
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
     ;;
+  esac
+  ;;
 
-  darwin*)
-  # if libdl is installed we need to link against it
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
-$as_echo_n "checking for dlopen in -ldl... " >&6; }
-if test "${ac_cv_lib_dl_dlopen+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldl  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+gnu*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  hardcode_into_libs=yes
+  ;;
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dlopen ();
-int
-main ()
-{
-return dlopen ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dl_dlopen=yes
-else
-  ac_cv_lib_dl_dlopen=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
-$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
-if test "x$ac_cv_lib_dl_dlopen" = x""yes; then :
-  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
-else
+haiku*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  dynamic_linker="$host_os runtime_loader"
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/beos/system/lib'
+  hardcode_into_libs=yes
+  ;;
 
-    lt_cv_dlopen="dyld"
-    lt_cv_dlopen_libs=
-    lt_cv_dlopen_self=yes
+hpux9* | hpux10* | hpux11*)
+  # Give a soname corresponding to the major version so that dld.sl refuses to
+  # link against other versions.
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  case $host_cpu in
+  ia64*)
+    shrext_cmds='.so'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.so"
+    shlibpath_var=LD_LIBRARY_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    if test "X$HPUX_IA64_MODE" = X32; then
+      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
+    else
+      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
+    fi
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  hppa*64*)
+    shrext_cmds='.sl'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  *)
+    shrext_cmds='.sl'
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=SHLIB_PATH
+    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    ;;
+  esac
+  # HP-UX runs *really* slowly unless shared libraries are mode 555, ...
+  postinstall_cmds='chmod 555 $lib'
+  # or fails outright, so override atomically:
+  install_override_mode=555
+  ;;
 
-fi
+interix[3-9]*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
 
+irix5* | irix6* | nonstopux*)
+  case $host_os in
+    nonstopux*) version_type=nonstopux ;;
+    *)
+	if test "$lt_cv_prog_gnu_ld" = yes; then
+		version_type=linux
+	else
+		version_type=irix
+	fi ;;
+  esac
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
+  case $host_os in
+  irix5* | nonstopux*)
+    libsuff= shlibsuff=
     ;;
-
   *)
-    ac_fn_c_check_func "$LINENO" "shl_load" "ac_cv_func_shl_load"
-if test "x$ac_cv_func_shl_load" = x""yes; then :
-  lt_cv_dlopen="shl_load"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for shl_load in -ldld" >&5
-$as_echo_n "checking for shl_load in -ldld... " >&6; }
-if test "${ac_cv_lib_dld_shl_load+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldld  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+    case $LD in # libtool.m4 will add one of these switches to LD
+    *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ")
+      libsuff= shlibsuff= libmagic=32-bit;;
+    *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ")
+      libsuff=32 shlibsuff=N32 libmagic=N32;;
+    *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ")
+      libsuff=64 shlibsuff=64 libmagic=64-bit;;
+    *) libsuff= shlibsuff= libmagic=never-match;;
+    esac
+    ;;
+  esac
+  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
+  shlibpath_overrides_runpath=no
+  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
+  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
+  hardcode_into_libs=yes
+  ;;
+
+# No shared lib support for Linux oldld, aout, or coff.
+linux*oldld* | linux*aout* | linux*coff*)
+  dynamic_linker=no
+  ;;
+
+# This must be Linux ELF.
+linux* | k*bsd*-gnu | kopensolaris*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char shl_load ();
-int
-main ()
-{
-return shl_load ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dld_shl_load=yes
-else
-  ac_cv_lib_dld_shl_load=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_shl_load" >&5
-$as_echo "$ac_cv_lib_dld_shl_load" >&6; }
-if test "x$ac_cv_lib_dld_shl_load" = x""yes; then :
-  lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-ldld"
-else
-  ac_fn_c_check_func "$LINENO" "dlopen" "ac_cv_func_dlopen"
-if test "x$ac_cv_func_dlopen" = x""yes; then :
-  lt_cv_dlopen="dlopen"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
-$as_echo_n "checking for dlopen in -ldl... " >&6; }
-if test "${ac_cv_lib_dl_dlopen+set}" = set; then :
+  # Some binutils ld are patched to set DT_RUNPATH
+  if test "${lt_cv_shlibpath_overrides_runpath+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldl  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+  lt_cv_shlibpath_overrides_runpath=no
+    save_LDFLAGS=$LDFLAGS
+    save_libdir=$libdir
+    eval "libdir=/foo; wl=\"$lt_prog_compiler_wl_CXX\"; \
+	 LDFLAGS=\"\$LDFLAGS $hardcode_libdir_flag_spec_CXX\""
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dlopen ();
 int
 main ()
 {
-return dlopen ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dl_dlopen=yes
-else
-  ac_cv_lib_dl_dlopen=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
-$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
-if test "x$ac_cv_lib_dl_dlopen" = x""yes; then :
-  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -lsvld" >&5
-$as_echo_n "checking for dlopen in -lsvld... " >&6; }
-if test "${ac_cv_lib_svld_dlopen+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lsvld  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dlopen ();
-int
-main ()
-{
-return dlopen ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_svld_dlopen=yes
-else
-  ac_cv_lib_svld_dlopen=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
+if ac_fn_cxx_try_link "$LINENO"; then :
+  if  ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null; then :
+  lt_cv_shlibpath_overrides_runpath=yes
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_svld_dlopen" >&5
-$as_echo "$ac_cv_lib_svld_dlopen" >&6; }
-if test "x$ac_cv_lib_svld_dlopen" = x""yes; then :
-  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dld_link in -ldld" >&5
-$as_echo_n "checking for dld_link in -ldld... " >&6; }
-if test "${ac_cv_lib_dld_dld_link+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldld  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dld_link ();
-int
-main ()
-{
-return dld_link ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dld_dld_link=yes
-else
-  ac_cv_lib_dld_dld_link=no
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_dld_link" >&5
-$as_echo "$ac_cv_lib_dld_dld_link" >&6; }
-if test "x$ac_cv_lib_dld_dld_link" = x""yes; then :
-  lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-ldld"
-fi
-
-
-fi
-
-
-fi
-
+    LDFLAGS=$save_LDFLAGS
+    libdir=$save_libdir
 
 fi
 
+  shlibpath_overrides_runpath=$lt_cv_shlibpath_overrides_runpath
 
-fi
-
+  # This implies no fast_install, which is unacceptable.
+  # Some rework will be needed to allow for fast_install
+  # before this can be enabled.
+  hardcode_into_libs=yes
 
-fi
+  # Append ld.so.conf contents to the search path
+  if test -f /etc/ld.so.conf; then
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/"//g;/^$/d' | tr '\n' ' '`
+    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
+  fi
 
-    ;;
-  esac
+  # We used to test for /lib/ld.so.1 and disable shared libraries on
+  # powerpc, because MkLinux only supported shared libraries with the
+  # GNU dynamic linker.  Since this was broken with cross compilers,
+  # most powerpc-linux boxes support dynamic linking these days and
+  # people can always --disable-shared, the test was removed, and we
+  # assume the GNU/Linux dynamic linker is in use.
+  dynamic_linker='GNU/Linux ld.so'
+  ;;
 
-  if test "x$lt_cv_dlopen" != xno; then
-    enable_dlopen=yes
+netbsd*)
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+    dynamic_linker='NetBSD (a.out) ld.so'
   else
-    enable_dlopen=no
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    dynamic_linker='NetBSD ld.elf_so'
   fi
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  ;;
 
-  case $lt_cv_dlopen in
-  dlopen)
-    save_CPPFLAGS="$CPPFLAGS"
-    test "x$ac_cv_header_dlfcn_h" = xyes && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
-
-    save_LDFLAGS="$LDFLAGS"
-    wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
+newsos6)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  ;;
 
-    save_LIBS="$LIBS"
-    LIBS="$lt_cv_dlopen_libs $LIBS"
+*nto* | *qnx*)
+  version_type=qnx
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='ldqnx.so'
+  ;;
 
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a program can dlopen itself" >&5
-$as_echo_n "checking whether a program can dlopen itself... " >&6; }
-if test "${lt_cv_dlopen_self+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  	  if test "$cross_compiling" = yes; then :
-  lt_cv_dlopen_self=cross
-else
-  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
-  lt_status=$lt_dlunknown
-  cat > conftest.$ac_ext <<_LT_EOF
-#line 10618 "configure"
-#include "confdefs.h"
+openbsd*)
+  version_type=sunos
+  sys_lib_dlsearch_path_spec="/usr/lib"
+  need_lib_prefix=no
+  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
+  case $host_os in
+    openbsd3.3 | openbsd3.3.*)	need_version=yes ;;
+    *)				need_version=no  ;;
+  esac
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    case $host_os in
+      openbsd2.[89] | openbsd2.[89].*)
+	shlibpath_overrides_runpath=no
+	;;
+      *)
+	shlibpath_overrides_runpath=yes
+	;;
+      esac
+  else
+    shlibpath_overrides_runpath=yes
+  fi
+  ;;
 
-#if HAVE_DLFCN_H
-#include <dlfcn.h>
-#endif
+os2*)
+  libname_spec='$name'
+  shrext_cmds=".dll"
+  need_lib_prefix=no
+  library_names_spec='$libname${shared_ext} $libname.a'
+  dynamic_linker='OS/2 ld.exe'
+  shlibpath_var=LIBPATH
+  ;;
 
-#include <stdio.h>
+osf3* | osf4* | osf5*)
+  version_type=osf
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
+  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
+  ;;
 
-#ifdef RTLD_GLOBAL
-#  define LT_DLGLOBAL		RTLD_GLOBAL
-#else
-#  ifdef DL_GLOBAL
-#    define LT_DLGLOBAL		DL_GLOBAL
-#  else
-#    define LT_DLGLOBAL		0
-#  endif
-#endif
+rdos*)
+  dynamic_linker=no
+  ;;
 
-/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
-   find out it does not work in some platform. */
-#ifndef LT_DLLAZY_OR_NOW
-#  ifdef RTLD_LAZY
-#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
-#  else
-#    ifdef DL_LAZY
-#      define LT_DLLAZY_OR_NOW		DL_LAZY
-#    else
-#      ifdef RTLD_NOW
-#        define LT_DLLAZY_OR_NOW	RTLD_NOW
-#      else
-#        ifdef DL_NOW
-#          define LT_DLLAZY_OR_NOW	DL_NOW
-#        else
-#          define LT_DLLAZY_OR_NOW	0
-#        endif
-#      endif
-#    endif
-#  endif
-#endif
+solaris*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  # ldd complains unless libraries are executable
+  postinstall_cmds='chmod +x $lib'
+  ;;
 
-/* When -fvisbility=hidden is used, assume the code has been annotated
-   correspondingly for the symbols needed.  */
-#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
-void fnord () __attribute__((visibility("default")));
-#endif
+sunos4*)
+  version_type=sunos
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  if test "$with_gnu_ld" = yes; then
+    need_lib_prefix=no
+  fi
+  need_version=yes
+  ;;
 
-void fnord () { int i=42; }
-int main ()
-{
-  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
-  int status = $lt_dlunknown;
+sysv4 | sysv4.3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_vendor in
+    sni)
+      shlibpath_overrides_runpath=no
+      need_lib_prefix=no
+      runpath_var=LD_RUN_PATH
+      ;;
+    siemens)
+      need_lib_prefix=no
+      ;;
+    motorola)
+      need_lib_prefix=no
+      need_version=no
+      shlibpath_overrides_runpath=no
+      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
+      ;;
+  esac
+  ;;
 
-  if (self)
-    {
-      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
-      else
-        {
-	  if (dlsym( self,"_fnord"))  status = $lt_dlneed_uscore;
-          else puts (dlerror ());
-	}
-      /* dlclose (self); */
-    }
-  else
-    puts (dlerror ());
+sysv4*MP*)
+  if test -d /usr/nec ;then
+    version_type=linux
+    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
+    soname_spec='$libname${shared_ext}.$major'
+    shlibpath_var=LD_LIBRARY_PATH
+  fi
+  ;;
 
-  return status;
-}
-_LT_EOF
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
-    (./conftest; exit; ) >&5 2>/dev/null
-    lt_status=$?
-    case x$lt_status in
-      x$lt_dlno_uscore) lt_cv_dlopen_self=yes ;;
-      x$lt_dlneed_uscore) lt_cv_dlopen_self=yes ;;
-      x$lt_dlunknown|x*) lt_cv_dlopen_self=no ;;
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  version_type=freebsd-elf
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  if test "$with_gnu_ld" = yes; then
+    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
+  else
+    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
+    case $host_os in
+      sco3.2v5*)
+        sys_lib_search_path_spec="$sys_lib_search_path_spec /lib"
+	;;
     esac
-  else :
-    # compilation failed
-    lt_cv_dlopen_self=no
   fi
-fi
-rm -fr conftest*
-
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self" >&5
-$as_echo "$lt_cv_dlopen_self" >&6; }
+  sys_lib_dlsearch_path_spec='/usr/lib'
+  ;;
 
-    if test "x$lt_cv_dlopen_self" = xyes; then
-      wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $lt_prog_compiler_static\"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a statically linked program can dlopen itself" >&5
-$as_echo_n "checking whether a statically linked program can dlopen itself... " >&6; }
-if test "${lt_cv_dlopen_self_static+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  	  if test "$cross_compiling" = yes; then :
-  lt_cv_dlopen_self_static=cross
-else
-  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
-  lt_status=$lt_dlunknown
-  cat > conftest.$ac_ext <<_LT_EOF
-#line 10724 "configure"
-#include "confdefs.h"
+tpf*)
+  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
 
-#if HAVE_DLFCN_H
-#include <dlfcn.h>
-#endif
+uts4*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
 
-#include <stdio.h>
+*)
+  dynamic_linker=no
+  ;;
+esac
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $dynamic_linker" >&5
+$as_echo "$dynamic_linker" >&6; }
+test "$dynamic_linker" = no && can_build_shared=no
 
-#ifdef RTLD_GLOBAL
-#  define LT_DLGLOBAL		RTLD_GLOBAL
-#else
-#  ifdef DL_GLOBAL
-#    define LT_DLGLOBAL		DL_GLOBAL
-#  else
-#    define LT_DLGLOBAL		0
-#  endif
-#endif
+variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
+if test "$GCC" = yes; then
+  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
+fi
 
-/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
-   find out it does not work in some platform. */
-#ifndef LT_DLLAZY_OR_NOW
-#  ifdef RTLD_LAZY
-#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
-#  else
-#    ifdef DL_LAZY
-#      define LT_DLLAZY_OR_NOW		DL_LAZY
-#    else
-#      ifdef RTLD_NOW
-#        define LT_DLLAZY_OR_NOW	RTLD_NOW
-#      else
-#        ifdef DL_NOW
-#          define LT_DLLAZY_OR_NOW	DL_NOW
-#        else
-#          define LT_DLLAZY_OR_NOW	0
-#        endif
-#      endif
-#    endif
-#  endif
-#endif
+if test "${lt_cv_sys_lib_search_path_spec+set}" = set; then
+  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
+fi
+if test "${lt_cv_sys_lib_dlsearch_path_spec+set}" = set; then
+  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
+fi
 
-/* When -fvisbility=hidden is used, assume the code has been annotated
-   correspondingly for the symbols needed.  */
-#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
-void fnord () __attribute__((visibility("default")));
-#endif
 
-void fnord () { int i=42; }
-int main ()
-{
-  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
-  int status = $lt_dlunknown;
 
-  if (self)
-    {
-      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
-      else
-        {
-	  if (dlsym( self,"_fnord"))  status = $lt_dlneed_uscore;
-          else puts (dlerror ());
-	}
-      /* dlclose (self); */
-    }
-  else
-    puts (dlerror ());
 
-  return status;
-}
-_LT_EOF
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
-    (./conftest; exit; ) >&5 2>/dev/null
-    lt_status=$?
-    case x$lt_status in
-      x$lt_dlno_uscore) lt_cv_dlopen_self_static=yes ;;
-      x$lt_dlneed_uscore) lt_cv_dlopen_self_static=yes ;;
-      x$lt_dlunknown|x*) lt_cv_dlopen_self_static=no ;;
-    esac
-  else :
-    # compilation failed
-    lt_cv_dlopen_self_static=no
-  fi
-fi
-rm -fr conftest*
 
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self_static" >&5
-$as_echo "$lt_cv_dlopen_self_static" >&6; }
-    fi
 
-    CPPFLAGS="$save_CPPFLAGS"
-    LDFLAGS="$save_LDFLAGS"
-    LIBS="$save_LIBS"
-    ;;
-  esac
 
-  case $lt_cv_dlopen_self in
-  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;
-  *) enable_dlopen_self=unknown ;;
-  esac
 
-  case $lt_cv_dlopen_self_static in
-  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;
-  *) enable_dlopen_self_static=unknown ;;
-  esac
-fi
 
 
 
@@ -10848,35 +14418,6 @@ fi
 
 
 
-striplib=
-old_striplib=
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether stripping libraries is possible" >&5
-$as_echo_n "checking whether stripping libraries is possible... " >&6; }
-if test -n "$STRIP" && $STRIP -V 2>&1 | $GREP "GNU strip" >/dev/null; then
-  test -z "$old_striplib" && old_striplib="$STRIP --strip-debug"
-  test -z "$striplib" && striplib="$STRIP --strip-unneeded"
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-else
-# FIXME - insert some real tests, host_os isn't really good enough
-  case $host_os in
-  darwin*)
-    if test -n "$STRIP" ; then
-      striplib="$STRIP -x"
-      old_striplib="$STRIP -S"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-    else
-      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-    fi
-    ;;
-  *)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-    ;;
-  esac
-fi
 
 
 
@@ -10889,55 +14430,69 @@ fi
 
 
 
-  # Report which library types will actually be built
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if libtool supports shared libraries" >&5
-$as_echo_n "checking if libtool supports shared libraries... " >&6; }
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $can_build_shared" >&5
-$as_echo "$can_build_shared" >&6; }
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking how to hardcode library paths into programs" >&5
+$as_echo_n "checking how to hardcode library paths into programs... " >&6; }
+hardcode_action_CXX=
+if test -n "$hardcode_libdir_flag_spec_CXX" ||
+   test -n "$runpath_var_CXX" ||
+   test "X$hardcode_automatic_CXX" = "Xyes" ; then
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build shared libraries" >&5
-$as_echo_n "checking whether to build shared libraries... " >&6; }
-  test "$can_build_shared" = "no" && enable_shared=no
+  # We can hardcode non-existent directories.
+  if test "$hardcode_direct_CXX" != no &&
+     # If the only mechanism to avoid hardcoding is shlibpath_var, we
+     # have to relink, otherwise we might link with an installed library
+     # when we should be linking with a yet-to-be-installed one
+     ## test "$_LT_TAGVAR(hardcode_shlibpath_var, CXX)" != no &&
+     test "$hardcode_minus_L_CXX" != no; then
+    # Linking always hardcodes the temporary library directory.
+    hardcode_action_CXX=relink
+  else
+    # We can link without hardcoding, and we can hardcode nonexisting dirs.
+    hardcode_action_CXX=immediate
+  fi
+else
+  # We cannot hardcode anything, or else we can only hardcode existing
+  # directories.
+  hardcode_action_CXX=unsupported
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $hardcode_action_CXX" >&5
+$as_echo "$hardcode_action_CXX" >&6; }
 
-  # On AIX, shared libraries and static libraries use the same namespace, and
-  # are all built from PIC.
-  case $host_os in
-  aix3*)
-    test "$enable_shared" = yes && enable_static=no
-    if test -n "$RANLIB"; then
-      archive_cmds="$archive_cmds~\$RANLIB \$lib"
-      postinstall_cmds='$RANLIB $lib'
-    fi
-    ;;
+if test "$hardcode_action_CXX" = relink ||
+   test "$inherit_rpath_CXX" = yes; then
+  # Fast installation is not supported
+  enable_fast_install=no
+elif test "$shlibpath_overrides_runpath" = yes ||
+     test "$enable_shared" = no; then
+  # Fast installation is not necessary
+  enable_fast_install=needless
+fi
 
-  aix[4-9]*)
-    if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
-      test "$enable_shared" = yes && enable_static=no
-    fi
-    ;;
-  esac
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_shared" >&5
-$as_echo "$enable_shared" >&6; }
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build static libraries" >&5
-$as_echo_n "checking whether to build static libraries... " >&6; }
-  # Make sure either enable_shared or enable_static is yes.
-  test "$enable_shared" = yes || enable_static=yes
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_static" >&5
-$as_echo "$enable_static" >&6; }
 
 
 
 
-fi
+
+  fi # test -n "$compiler"
+
+  CC=$lt_save_CC
+  LDCXX=$LD
+  LD=$lt_save_LD
+  GCC=$lt_save_GCC
+  with_gnu_ld=$lt_save_with_gnu_ld
+  lt_cv_path_LDCXX=$lt_cv_path_LD
+  lt_cv_path_LD=$lt_save_path_LD
+  lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld
+  lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld
+fi # test "$_lt_caught_CXX_error" != yes
+
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
-CC="$lt_save_CC"
-
 
 
 
@@ -11800,6 +15355,10 @@ if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
   as_fn_error "conditional \"am__fastdepCC\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${am__fastdepCXX_TRUE}" && test -z "${am__fastdepCXX_FALSE}"; then
+  as_fn_error "conditional \"am__fastdepCXX\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${LIBMUDFLAPTH_TRUE}" && test -z "${LIBMUDFLAPTH_FALSE}"; then
   as_fn_error "conditional \"LIBMUDFLAPTH\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
@@ -12531,6 +16090,61 @@ enable_dlopen_self='`$ECHO "$enable_dlopen_self" | $SED "$delay_single_quote_sub
 enable_dlopen_self_static='`$ECHO "$enable_dlopen_self_static" | $SED "$delay_single_quote_subst"`'
 old_striplib='`$ECHO "$old_striplib" | $SED "$delay_single_quote_subst"`'
 striplib='`$ECHO "$striplib" | $SED "$delay_single_quote_subst"`'
+compiler_lib_search_dirs='`$ECHO "$compiler_lib_search_dirs" | $SED "$delay_single_quote_subst"`'
+predep_objects='`$ECHO "$predep_objects" | $SED "$delay_single_quote_subst"`'
+postdep_objects='`$ECHO "$postdep_objects" | $SED "$delay_single_quote_subst"`'
+predeps='`$ECHO "$predeps" | $SED "$delay_single_quote_subst"`'
+postdeps='`$ECHO "$postdeps" | $SED "$delay_single_quote_subst"`'
+compiler_lib_search_path='`$ECHO "$compiler_lib_search_path" | $SED "$delay_single_quote_subst"`'
+LD_CXX='`$ECHO "$LD_CXX" | $SED "$delay_single_quote_subst"`'
+reload_flag_CXX='`$ECHO "$reload_flag_CXX" | $SED "$delay_single_quote_subst"`'
+reload_cmds_CXX='`$ECHO "$reload_cmds_CXX" | $SED "$delay_single_quote_subst"`'
+old_archive_cmds_CXX='`$ECHO "$old_archive_cmds_CXX" | $SED "$delay_single_quote_subst"`'
+compiler_CXX='`$ECHO "$compiler_CXX" | $SED "$delay_single_quote_subst"`'
+GCC_CXX='`$ECHO "$GCC_CXX" | $SED "$delay_single_quote_subst"`'
+lt_prog_compiler_no_builtin_flag_CXX='`$ECHO "$lt_prog_compiler_no_builtin_flag_CXX" | $SED "$delay_single_quote_subst"`'
+lt_prog_compiler_wl_CXX='`$ECHO "$lt_prog_compiler_wl_CXX" | $SED "$delay_single_quote_subst"`'
+lt_prog_compiler_pic_CXX='`$ECHO "$lt_prog_compiler_pic_CXX" | $SED "$delay_single_quote_subst"`'
+lt_prog_compiler_static_CXX='`$ECHO "$lt_prog_compiler_static_CXX" | $SED "$delay_single_quote_subst"`'
+lt_cv_prog_compiler_c_o_CXX='`$ECHO "$lt_cv_prog_compiler_c_o_CXX" | $SED "$delay_single_quote_subst"`'
+archive_cmds_need_lc_CXX='`$ECHO "$archive_cmds_need_lc_CXX" | $SED "$delay_single_quote_subst"`'
+enable_shared_with_static_runtimes_CXX='`$ECHO "$enable_shared_with_static_runtimes_CXX" | $SED "$delay_single_quote_subst"`'
+export_dynamic_flag_spec_CXX='`$ECHO "$export_dynamic_flag_spec_CXX" | $SED "$delay_single_quote_subst"`'
+whole_archive_flag_spec_CXX='`$ECHO "$whole_archive_flag_spec_CXX" | $SED "$delay_single_quote_subst"`'
+compiler_needs_object_CXX='`$ECHO "$compiler_needs_object_CXX" | $SED "$delay_single_quote_subst"`'
+old_archive_from_new_cmds_CXX='`$ECHO "$old_archive_from_new_cmds_CXX" | $SED "$delay_single_quote_subst"`'
+old_archive_from_expsyms_cmds_CXX='`$ECHO "$old_archive_from_expsyms_cmds_CXX" | $SED "$delay_single_quote_subst"`'
+archive_cmds_CXX='`$ECHO "$archive_cmds_CXX" | $SED "$delay_single_quote_subst"`'
+archive_expsym_cmds_CXX='`$ECHO "$archive_expsym_cmds_CXX" | $SED "$delay_single_quote_subst"`'
+module_cmds_CXX='`$ECHO "$module_cmds_CXX" | $SED "$delay_single_quote_subst"`'
+module_expsym_cmds_CXX='`$ECHO "$module_expsym_cmds_CXX" | $SED "$delay_single_quote_subst"`'
+with_gnu_ld_CXX='`$ECHO "$with_gnu_ld_CXX" | $SED "$delay_single_quote_subst"`'
+allow_undefined_flag_CXX='`$ECHO "$allow_undefined_flag_CXX" | $SED "$delay_single_quote_subst"`'
+no_undefined_flag_CXX='`$ECHO "$no_undefined_flag_CXX" | $SED "$delay_single_quote_subst"`'
+hardcode_libdir_flag_spec_CXX='`$ECHO "$hardcode_libdir_flag_spec_CXX" | $SED "$delay_single_quote_subst"`'
+hardcode_libdir_flag_spec_ld_CXX='`$ECHO "$hardcode_libdir_flag_spec_ld_CXX" | $SED "$delay_single_quote_subst"`'
+hardcode_libdir_separator_CXX='`$ECHO "$hardcode_libdir_separator_CXX" | $SED "$delay_single_quote_subst"`'
+hardcode_direct_CXX='`$ECHO "$hardcode_direct_CXX" | $SED "$delay_single_quote_subst"`'
+hardcode_direct_absolute_CXX='`$ECHO "$hardcode_direct_absolute_CXX" | $SED "$delay_single_quote_subst"`'
+hardcode_minus_L_CXX='`$ECHO "$hardcode_minus_L_CXX" | $SED "$delay_single_quote_subst"`'
+hardcode_shlibpath_var_CXX='`$ECHO "$hardcode_shlibpath_var_CXX" | $SED "$delay_single_quote_subst"`'
+hardcode_automatic_CXX='`$ECHO "$hardcode_automatic_CXX" | $SED "$delay_single_quote_subst"`'
+inherit_rpath_CXX='`$ECHO "$inherit_rpath_CXX" | $SED "$delay_single_quote_subst"`'
+link_all_deplibs_CXX='`$ECHO "$link_all_deplibs_CXX" | $SED "$delay_single_quote_subst"`'
+fix_srcfile_path_CXX='`$ECHO "$fix_srcfile_path_CXX" | $SED "$delay_single_quote_subst"`'
+always_export_symbols_CXX='`$ECHO "$always_export_symbols_CXX" | $SED "$delay_single_quote_subst"`'
+export_symbols_cmds_CXX='`$ECHO "$export_symbols_cmds_CXX" | $SED "$delay_single_quote_subst"`'
+exclude_expsyms_CXX='`$ECHO "$exclude_expsyms_CXX" | $SED "$delay_single_quote_subst"`'
+include_expsyms_CXX='`$ECHO "$include_expsyms_CXX" | $SED "$delay_single_quote_subst"`'
+prelink_cmds_CXX='`$ECHO "$prelink_cmds_CXX" | $SED "$delay_single_quote_subst"`'
+file_list_spec_CXX='`$ECHO "$file_list_spec_CXX" | $SED "$delay_single_quote_subst"`'
+hardcode_action_CXX='`$ECHO "$hardcode_action_CXX" | $SED "$delay_single_quote_subst"`'
+compiler_lib_search_dirs_CXX='`$ECHO "$compiler_lib_search_dirs_CXX" | $SED "$delay_single_quote_subst"`'
+predep_objects_CXX='`$ECHO "$predep_objects_CXX" | $SED "$delay_single_quote_subst"`'
+postdep_objects_CXX='`$ECHO "$postdep_objects_CXX" | $SED "$delay_single_quote_subst"`'
+predeps_CXX='`$ECHO "$predeps_CXX" | $SED "$delay_single_quote_subst"`'
+postdeps_CXX='`$ECHO "$postdeps_CXX" | $SED "$delay_single_quote_subst"`'
+compiler_lib_search_path_CXX='`$ECHO "$compiler_lib_search_path_CXX" | $SED "$delay_single_quote_subst"`'
 
 LTCC='$LTCC'
 LTCFLAGS='$LTCFLAGS'
@@ -12603,7 +16217,40 @@ soname_spec \
 install_override_mode \
 finish_eval \
 old_striplib \
-striplib; do
+striplib \
+compiler_lib_search_dirs \
+predep_objects \
+postdep_objects \
+predeps \
+postdeps \
+compiler_lib_search_path \
+LD_CXX \
+reload_flag_CXX \
+compiler_CXX \
+lt_prog_compiler_no_builtin_flag_CXX \
+lt_prog_compiler_wl_CXX \
+lt_prog_compiler_pic_CXX \
+lt_prog_compiler_static_CXX \
+lt_cv_prog_compiler_c_o_CXX \
+export_dynamic_flag_spec_CXX \
+whole_archive_flag_spec_CXX \
+compiler_needs_object_CXX \
+with_gnu_ld_CXX \
+allow_undefined_flag_CXX \
+no_undefined_flag_CXX \
+hardcode_libdir_flag_spec_CXX \
+hardcode_libdir_flag_spec_ld_CXX \
+hardcode_libdir_separator_CXX \
+fix_srcfile_path_CXX \
+exclude_expsyms_CXX \
+include_expsyms_CXX \
+file_list_spec_CXX \
+compiler_lib_search_dirs_CXX \
+predep_objects_CXX \
+postdep_objects_CXX \
+predeps_CXX \
+postdeps_CXX \
+compiler_lib_search_path_CXX; do
     case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
     *[\\\\\\\`\\"\\\$]*)
       eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED \\"\\\$sed_quote_subst\\"\\\`\\\\\\""
@@ -12632,7 +16279,17 @@ postinstall_cmds \
 postuninstall_cmds \
 finish_cmds \
 sys_lib_search_path_spec \
-sys_lib_dlsearch_path_spec; do
+sys_lib_dlsearch_path_spec \
+reload_cmds_CXX \
+old_archive_cmds_CXX \
+old_archive_from_new_cmds_CXX \
+old_archive_from_expsyms_cmds_CXX \
+archive_cmds_CXX \
+archive_expsym_cmds_CXX \
+module_cmds_CXX \
+module_expsym_cmds_CXX \
+export_symbols_cmds_CXX \
+prelink_cmds_CXX; do
     case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
     *[\\\\\\\`\\"\\\$]*)
       eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED -e \\"\\\$double_quote_subst\\" -e \\"\\\$sed_quote_subst\\" -e \\"\\\$delay_variable_subst\\"\\\`\\\\\\""
@@ -12663,6 +16320,8 @@ fi
 
 
 
+
+
 _ACEOF
 
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
@@ -13414,7 +17073,7 @@ $as_echo X"$file" |
 
 
 # The names of the tagged configurations supported by this script.
-available_tags=""
+available_tags="CXX "
 
 # ### BEGIN LIBTOOL CONFIG
 
@@ -13770,6 +17429,20 @@ file_list_spec=$lt_file_list_spec
 # How to hardcode a shared library path into an executable.
 hardcode_action=$hardcode_action
 
+# The directories searched by this compiler when creating a shared library.
+compiler_lib_search_dirs=$lt_compiler_lib_search_dirs
+
+# Dependencies to place before and after the objects being linked to
+# create a shared library.
+predep_objects=$lt_predep_objects
+postdep_objects=$lt_postdep_objects
+predeps=$lt_predeps
+postdeps=$lt_postdeps
+
+# The library search path used internally by the compiler when linking
+# a shared library.
+compiler_lib_search_path=$lt_compiler_lib_search_path
+
 # ### END LIBTOOL CONFIG
 
 _LT_EOF
@@ -14003,6 +17676,163 @@ _LT_EOF
     (rm -f "$ofile" && cp "$cfgfile" "$ofile" && rm -f "$cfgfile")
   chmod +x "$ofile"
 
+
+    cat <<_LT_EOF >> "$ofile"
+
+# ### BEGIN LIBTOOL TAG CONFIG: CXX
+
+# The linker used to build libraries.
+LD=$lt_LD_CXX
+
+# How to create reloadable object files.
+reload_flag=$lt_reload_flag_CXX
+reload_cmds=$lt_reload_cmds_CXX
+
+# Commands used to build an old-style archive.
+old_archive_cmds=$lt_old_archive_cmds_CXX
+
+# A language specific compiler.
+CC=$lt_compiler_CXX
+
+# Is the compiler the GNU compiler?
+with_gcc=$GCC_CXX
+
+# Compiler flag to turn off builtin functions.
+no_builtin_flag=$lt_lt_prog_compiler_no_builtin_flag_CXX
+
+# How to pass a linker flag through the compiler.
+wl=$lt_lt_prog_compiler_wl_CXX
+
+# Additional compiler flags for building library objects.
+pic_flag=$lt_lt_prog_compiler_pic_CXX
+
+# Compiler flag to prevent dynamic linking.
+link_static_flag=$lt_lt_prog_compiler_static_CXX
+
+# Does compiler simultaneously support -c and -o options?
+compiler_c_o=$lt_lt_cv_prog_compiler_c_o_CXX
+
+# Whether or not to add -lc for building shared libraries.
+build_libtool_need_lc=$archive_cmds_need_lc_CXX
+
+# Whether or not to disallow shared libs when runtime libs are static.
+allow_libtool_libs_with_static_runtimes=$enable_shared_with_static_runtimes_CXX
+
+# Compiler flag to allow reflexive dlopens.
+export_dynamic_flag_spec=$lt_export_dynamic_flag_spec_CXX
+
+# Compiler flag to generate shared objects directly from archives.
+whole_archive_flag_spec=$lt_whole_archive_flag_spec_CXX
+
+# Whether the compiler copes with passing no objects directly.
+compiler_needs_object=$lt_compiler_needs_object_CXX
+
+# Create an old-style archive from a shared archive.
+old_archive_from_new_cmds=$lt_old_archive_from_new_cmds_CXX
+
+# Create a temporary old-style archive to link instead of a shared archive.
+old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds_CXX
+
+# Commands used to build a shared archive.
+archive_cmds=$lt_archive_cmds_CXX
+archive_expsym_cmds=$lt_archive_expsym_cmds_CXX
+
+# Commands used to build a loadable module if different from building
+# a shared archive.
+module_cmds=$lt_module_cmds_CXX
+module_expsym_cmds=$lt_module_expsym_cmds_CXX
+
+# Whether we are building with GNU ld or not.
+with_gnu_ld=$lt_with_gnu_ld_CXX
+
+# Flag that allows shared libraries with undefined symbols to be built.
+allow_undefined_flag=$lt_allow_undefined_flag_CXX
+
+# Flag that enforces no undefined symbols.
+no_undefined_flag=$lt_no_undefined_flag_CXX
+
+# Flag to hardcode \$libdir into a binary during linking.
+# This must work even if \$libdir does not exist
+hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec_CXX
+
+# If ld is used when linking, flag to hardcode \$libdir into a binary
+# during linking.  This must work even if \$libdir does not exist.
+hardcode_libdir_flag_spec_ld=$lt_hardcode_libdir_flag_spec_ld_CXX
+
+# Whether we need a single "-rpath" flag with a separated argument.
+hardcode_libdir_separator=$lt_hardcode_libdir_separator_CXX
+
+# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
+# DIR into the resulting binary.
+hardcode_direct=$hardcode_direct_CXX
+
+# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
+# DIR into the resulting binary and the resulting library dependency is
+# "absolute",i.e impossible to change by setting \${shlibpath_var} if the
+# library is relocated.
+hardcode_direct_absolute=$hardcode_direct_absolute_CXX
+
+# Set to "yes" if using the -LDIR flag during linking hardcodes DIR
+# into the resulting binary.
+hardcode_minus_L=$hardcode_minus_L_CXX
+
+# Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
+# into the resulting binary.
+hardcode_shlibpath_var=$hardcode_shlibpath_var_CXX
+
+# Set to "yes" if building a shared library automatically hardcodes DIR
+# into the library and all subsequent libraries and executables linked
+# against it.
+hardcode_automatic=$hardcode_automatic_CXX
+
+# Set to yes if linker adds runtime paths of dependent libraries
+# to runtime path list.
+inherit_rpath=$inherit_rpath_CXX
+
+# Whether libtool must link a program against all its dependency libraries.
+link_all_deplibs=$link_all_deplibs_CXX
+
+# Fix the shell variable \$srcfile for the compiler.
+fix_srcfile_path=$lt_fix_srcfile_path_CXX
+
+# Set to "yes" if exported symbols are required.
+always_export_symbols=$always_export_symbols_CXX
+
+# The commands to list exported symbols.
+export_symbols_cmds=$lt_export_symbols_cmds_CXX
+
+# Symbols that should not be listed in the preloaded symbols.
+exclude_expsyms=$lt_exclude_expsyms_CXX
+
+# Symbols that must always be exported.
+include_expsyms=$lt_include_expsyms_CXX
+
+# Commands necessary for linking programs (against libraries) with templates.
+prelink_cmds=$lt_prelink_cmds_CXX
+
+# Specify filename containing input files.
+file_list_spec=$lt_file_list_spec_CXX
+
+# How to hardcode a shared library path into an executable.
+hardcode_action=$hardcode_action_CXX
+
+# The directories searched by this compiler when creating a shared library.
+compiler_lib_search_dirs=$lt_compiler_lib_search_dirs_CXX
+
+# Dependencies to place before and after the objects being linked to
+# create a shared library.
+predep_objects=$lt_predep_objects_CXX
+postdep_objects=$lt_postdep_objects_CXX
+predeps=$lt_predeps_CXX
+postdeps=$lt_postdeps_CXX
+
+# The library search path used internally by the compiler when linking
+# a shared library.
+compiler_lib_search_path=$lt_compiler_lib_search_path_CXX
+
+# ### END LIBTOOL TAG CONFIG: CXX
+_LT_EOF
+
  ;;
 
   esac
diff --git a/libmudflap/configure.ac b/libmudflap/configure.ac
index 83aba5a..9fb5a82 100644
--- a/libmudflap/configure.ac
+++ b/libmudflap/configure.ac
@@ -48,6 +48,9 @@ if test "x$GCC" != "xyes"; then
 fi
 AC_PROG_CPP
 
+# We use the C++ compiler during testing.
+AC_PROG_CXX
+
 # Some hosts don't have dlsym(RTLD_NEXT, "symbol") for use in
 # symbol interposition.  We disable shared libraries for these.
 AC_MSG_CHECKING([whether dlsym(RTLD_NEXT,...) is available])
diff --git a/libmudflap/testsuite/lib/libmudflap.exp b/libmudflap/testsuite/lib/libmudflap.exp
index 48166e1..f15dd65 100644
--- a/libmudflap/testsuite/lib/libmudflap.exp
+++ b/libmudflap/testsuite/lib/libmudflap.exp
@@ -41,10 +41,23 @@ proc libmudflap-init { language } {
     global libs
     global gluefile wrap_flags
     global ld_library_path
+    global CC_UNDER_TEST
+    global CXX_UNDER_TEST
 
     switch $language {
-        "c" { set cxx [find_gcc] }
-        "c++" { set cxx [find_g++] }
+        "c" {
+	    if [info exists CC_UNDER_TEST] then {
+	        set cxx $CC_UNDER_TEST
+	    } else {
+	        set cxx [find_gcc] }
+	    }
+        "c++" {
+	    if [info exists CXX_UNDER_TEST] then {
+	        set cxx $CXX_UNDER_TEST
+	    } else {
+	        set cxx [find_g++]
+	    }
+	}
         default { error "bad language code $language"; return }
     }
 
diff --git a/libmudflap/testsuite/mfconfig.exp.in b/libmudflap/testsuite/mfconfig.exp.in
index bed1654..670390b 100644
--- a/libmudflap/testsuite/mfconfig.exp.in
+++ b/libmudflap/testsuite/mfconfig.exp.in
@@ -2,3 +2,7 @@ global mfconfig_libs
 set mfconfig_libs "@LIBS@"
 global libmudflapth
 set libmudflapth "@build_libmudflapth@"
+global CC_UNDER_TEST
+set CC_UNDER_TEST "@CC@"
+global CXX_UNDER_TEST
+set CXX_UNDER_TEST "@CXX@"
diff --git a/libobjc/configure b/libobjc/configure
index a220b15..15291c9 100755
--- a/libobjc/configure
+++ b/libobjc/configure
@@ -7169,7 +7169,22 @@ fi
 
 # Check whether --with-pic was given.
 if test "${with_pic+set}" = set; then :
-  withval=$with_pic; pic_mode="$withval"
+  withval=$with_pic; p=${PACKAGE-default}
+    case "$withval" in
+    yes|no) pic_mode="$withval" ;;
+    *)
+      pic_mode=default
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $withval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  pic_mode=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
 else
   pic_mode=default
 fi
@@ -10595,7 +10610,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10598 "configure"
+#line 10613 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -10701,7 +10716,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10704 "configure"
+#line 10719 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11472,7 +11487,7 @@ if test "${enable_sjlj_exceptions+set}" = set; then :
   enableval=$enable_sjlj_exceptions; :
 else
   cat > conftest.$ac_ext << EOF
-#line 11475 "configure"
+#line 11490 "configure"
 @interface Frob
 @end
 @implementation Frob
diff --git a/libquadmath/configure b/libquadmath/configure
index 0ea6e07..709b13e 100755
--- a/libquadmath/configure
+++ b/libquadmath/configure
@@ -7095,7 +7095,22 @@ fi
 
 # Check whether --with-pic was given.
 if test "${with_pic+set}" = set; then :
-  withval=$with_pic; pic_mode="$withval"
+  withval=$with_pic; p=${PACKAGE-default}
+    case "$withval" in
+    yes|no) pic_mode="$withval" ;;
+    *)
+      pic_mode=default
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $withval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  pic_mode=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
 else
   pic_mode=default
 fi
@@ -10521,7 +10536,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10524 "configure"
+#line 10539 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -10627,7 +10642,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10630 "configure"
+#line 10645 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
diff --git a/libssp/configure b/libssp/configure
index 5e16208..ea3d2a2 100755
--- a/libssp/configure
+++ b/libssp/configure
@@ -7232,7 +7232,22 @@ fi
 
 # Check whether --with-pic was given.
 if test "${with_pic+set}" = set; then :
-  withval=$with_pic; pic_mode="$withval"
+  withval=$with_pic; p=${PACKAGE-default}
+    case "$withval" in
+    yes|no) pic_mode="$withval" ;;
+    *)
+      pic_mode=default
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $withval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  pic_mode=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
 else
   pic_mode=default
 fi
@@ -10658,7 +10673,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10661 "configure"
+#line 10676 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -10764,7 +10779,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10767 "configure"
+#line 10782 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
diff --git a/libstdc++-v3/acinclude.m4 b/libstdc++-v3/acinclude.m4
index af0b23b..0dc41b5 100644
--- a/libstdc++-v3/acinclude.m4
+++ b/libstdc++-v3/acinclude.m4
@@ -2562,10 +2562,16 @@ int main()
 }
 EOF
 
+    AH_VERBATIM([_GLIBCXX_USE_FLOAT128,],
+                [/* Define if __float128 is supported on this host.
+   Hide all uses of __float128 from Clang.  Google ref b/6422845  */
+#ifndef __clang__
+#undef _GLIBCXX_USE_FLOAT128
+#endif])
+
     AC_MSG_CHECKING([for __float128])
     if AC_TRY_EVAL(ac_compile); then
-      AC_DEFINE(_GLIBCXX_USE_FLOAT128, 1,
-      [Define if __float128 is supported on this host.])
+      AC_DEFINE(_GLIBCXX_USE_FLOAT128, 1)
       enable_float128=yes
     else
       enable_float128=no
@@ -3503,9 +3509,15 @@ AC_DEFUN([GLIBCXX_CHECK_X86_RDRAND], [
 		[ac_cv_x86_rdrand=yes], [ac_cv_x86_rdrand=no])
   esac
   ])
+  AH_VERBATIM([_GLIBCXX_X86_RDRAND,],
+              [/* Defined if as can handle rdrand.
+   Disable when building with Clang.  Google ref b/8680429 */
+#ifndef __clang__
+#undef _GLIBCXX_X86_RDRAND
+#endif])
+
   if test $ac_cv_x86_rdrand = yes; then
-    AC_DEFINE(_GLIBCXX_X86_RDRAND, 1,
-		[ Defined if as can handle rdrand. ])
+    AC_DEFINE(_GLIBCXX_X86_RDRAND, 1)
   fi
   AC_MSG_RESULT($ac_cv_x86_rdrand)
 ])
diff --git a/libstdc++-v3/config.h.in b/libstdc++-v3/config.h.in
index 61ac3ab..fd3f239 100644
--- a/libstdc++-v3/config.h.in
+++ b/libstdc++-v3/config.h.in
@@ -823,8 +823,11 @@
    this host. */
 #undef _GLIBCXX_USE_DECIMAL_FLOAT
 
-/* Define if __float128 is supported on this host. */
+/* Define if __float128 is supported on this host.
+   Hide all uses of __float128 from Clang.  Google ref b/6422845  */
+#ifndef __clang__
 #undef _GLIBCXX_USE_FLOAT128
+#endif
 
 /* Defined if gettimeofday is available. */
 #undef _GLIBCXX_USE_GETTIMEOFDAY
@@ -872,8 +875,11 @@
 /* Define to 1 if a verbose library is built, or 0 otherwise. */
 #undef _GLIBCXX_VERBOSE
 
-/* Defined if as can handle rdrand. */
+/* Defined if as can handle rdrand.
+   Disable when building with Clang.  Google ref b/8680429 */
+#ifndef __clang__
 #undef _GLIBCXX_X86_RDRAND
+#endif
 
 /* Define to 1 if mutex_timedlock is available. */
 #undef _GTHREAD_USE_MUTEX_TIMEDLOCK
diff --git a/libstdc++-v3/config/abi/post/x86_64-linux-gnu/32/baseline_symbols.txt b/libstdc++-v3/config/abi/post/x86_64-linux-gnu/32/baseline_symbols.txt
index 6876176..e21a01a 100644
--- a/libstdc++-v3/config/abi/post/x86_64-linux-gnu/32/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/x86_64-linux-gnu/32/baseline_symbols.txt
@@ -2452,6 +2452,7 @@ FUNC:_ZdaPv@@GLIBCXX_3.4
 FUNC:_ZdaPvRKSt9nothrow_t@@GLIBCXX_3.4
 FUNC:_ZdlPv@@GLIBCXX_3.4
 FUNC:_ZdlPvRKSt9nothrow_t@@GLIBCXX_3.4
+FUNC:_ZdlPvj@@GLIBCXX_3.4.18
 FUNC:_Znaj@@GLIBCXX_3.4
 FUNC:_ZnajRKSt9nothrow_t@@GLIBCXX_3.4
 FUNC:_Znwj@@GLIBCXX_3.4
@@ -3648,3 +3649,5 @@ OBJECT:8:_ZTTSi@@GLIBCXX_3.4
 OBJECT:8:_ZTTSo@@GLIBCXX_3.4
 OBJECT:8:_ZTTSt13basic_istreamIwSt11char_traitsIwEE@@GLIBCXX_3.4
 OBJECT:8:_ZTTSt13basic_ostreamIwSt11char_traitsIwEE@@GLIBCXX_3.4
+TLS:4:_ZSt11__once_call@@GLIBCXX_3.4.11
+TLS:4:_ZSt15__once_callable@@GLIBCXX_3.4.11
diff --git a/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt b/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt
index 0217375..8d6ab95 100644
--- a/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt
+++ b/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt
@@ -2452,6 +2452,7 @@ FUNC:_ZdaPv@@GLIBCXX_3.4
 FUNC:_ZdaPvRKSt9nothrow_t@@GLIBCXX_3.4
 FUNC:_ZdlPv@@GLIBCXX_3.4
 FUNC:_ZdlPvRKSt9nothrow_t@@GLIBCXX_3.4
+FUNC:_ZdlPvm@@GLIBCXX_3.4.18
 FUNC:_Znam@@GLIBCXX_3.4
 FUNC:_ZnamRKSt9nothrow_t@@GLIBCXX_3.4
 FUNC:_Znwm@@GLIBCXX_3.4
diff --git a/libstdc++-v3/config/abi/pre/gnu.ver b/libstdc++-v3/config/abi/pre/gnu.ver
index 781dd8e..3df1963 100644
--- a/libstdc++-v3/config/abi/pre/gnu.ver
+++ b/libstdc++-v3/config/abi/pre/gnu.ver
@@ -1339,6 +1339,9 @@ GLIBCXX_3.4.18 {
     # std::this_thread::__sleep_for
     _ZNSt11this_thread11__sleep_for*;
 
+    # operator delete(void*, , unsigned long)
+    _ZdlPv[jmy];
+
     # std::bad_function_call::what()
     _ZNKSt17bad_function_call4whatEv;
 
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index a43fa2b..a3f276d 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -8087,7 +8087,22 @@ fi
 
 # Check whether --with-pic was given.
 if test "${with_pic+set}" = set; then :
-  withval=$with_pic; pic_mode="$withval"
+  withval=$with_pic; p=${PACKAGE-default}
+    case "$withval" in
+    yes|no) pic_mode="$withval" ;;
+    *)
+      pic_mode=default
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $withval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  pic_mode=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
 else
   pic_mode=default
 fi
@@ -11513,7 +11528,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11516 "configure"
+#line 11531 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11619,7 +11634,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11622 "configure"
+#line 11637 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -15033,7 +15048,7 @@ fi
     #
     # Fake what AC_TRY_COMPILE does.  XXX Look at redoing this new-style.
     cat > conftest.$ac_ext << EOF
-#line 15036 "configure"
+#line 15051 "configure"
 struct S { ~S(); };
 void bar();
 void foo()
@@ -15383,7 +15398,7 @@ $as_echo "$glibcxx_cv_atomic_long_long" >&6; }
   # Fake what AC_TRY_COMPILE does.
 
     cat > conftest.$ac_ext << EOF
-#line 15386 "configure"
+#line 15401 "configure"
 int main()
 {
   typedef bool atomic_type;
@@ -15418,7 +15433,7 @@ $as_echo "$glibcxx_cv_atomic_bool" >&6; }
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15421 "configure"
+#line 15436 "configure"
 int main()
 {
   typedef short atomic_type;
@@ -15453,7 +15468,7 @@ $as_echo "$glibcxx_cv_atomic_short" >&6; }
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15456 "configure"
+#line 15471 "configure"
 int main()
 {
   // NB: _Atomic_word not necessarily int.
@@ -15489,7 +15504,7 @@ $as_echo "$glibcxx_cv_atomic_int" >&6; }
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15492 "configure"
+#line 15507 "configure"
 int main()
 {
   typedef long long atomic_type;
@@ -15568,7 +15583,7 @@ $as_echo "$as_me: WARNING: Performance of certain classes will degrade as a resu
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15571 "configure"
+#line 15586 "configure"
 int main()
 {
   _Decimal32 d1;
@@ -15610,7 +15625,7 @@ ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15613 "configure"
+#line 15628 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -15644,7 +15659,7 @@ $as_echo "$enable_int128" >&6; }
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15647 "configure"
+#line 15662 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -15659,6 +15674,8 @@ int main()
 }
 EOF
 
+
+
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __float128" >&5
 $as_echo_n "checking for __float128... " >&6; }
     if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
@@ -15666,8 +15683,7 @@ $as_echo_n "checking for __float128... " >&6; }
   ac_status=$?
   $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; }; then
-
-$as_echo "#define _GLIBCXX_USE_FLOAT128 1" >>confdefs.h
+      $as_echo "#define _GLIBCXX_USE_FLOAT128 1" >>confdefs.h
 
       enable_float128=yes
     else
@@ -71915,9 +71931,10 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
 fi
 
-  if test $ac_cv_x86_rdrand = yes; then
 
-$as_echo "#define _GLIBCXX_X86_RDRAND 1" >>confdefs.h
+
+  if test $ac_cv_x86_rdrand = yes; then
+    $as_echo "#define _GLIBCXX_X86_RDRAND 1" >>confdefs.h
 
   fi
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_x86_rdrand" >&5
diff --git a/libstdc++-v3/include/Makefile.am b/libstdc++-v3/include/Makefile.am
index 16f8342..a478d5d 100644
--- a/libstdc++-v3/include/Makefile.am
+++ b/libstdc++-v3/include/Makefile.am
@@ -929,6 +929,7 @@ stamp-bits: ${bits_headers}
 
 stamp-bits-sup: stamp-bits ${bits_sup_headers}
 	@-cd ${bits_builddir} && $(LN_S) $? . 2>/dev/null
+	@-cd ${bits_builddir} && rm -f stamp-bits && $(STAMP) stamp-bits
 	@$(STAMP) stamp-bits-sup
 
 stamp-c_base: ${c_base_headers}
diff --git a/libstdc++-v3/include/Makefile.in b/libstdc++-v3/include/Makefile.in
index 5b8a206..9957f3c 100644
--- a/libstdc++-v3/include/Makefile.in
+++ b/libstdc++-v3/include/Makefile.in
@@ -1342,6 +1342,7 @@ stamp-bits: ${bits_headers}
 
 stamp-bits-sup: stamp-bits ${bits_sup_headers}
 	@-cd ${bits_builddir} && $(LN_S) $? . 2>/dev/null
+	@-cd ${bits_builddir} && rm -f stamp-bits && $(STAMP) stamp-bits
 	@$(STAMP) stamp-bits-sup
 
 stamp-c_base: ${c_base_headers}
diff --git a/libstdc++-v3/include/backward/hashtable.h b/libstdc++-v3/include/backward/hashtable.h
index fbdf673..454b012 100644
--- a/libstdc++-v3/include/backward/hashtable.h
+++ b/libstdc++-v3/include/backward/hashtable.h
@@ -125,7 +125,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       _Hashtable_iterator(_Node* __n, _Hashtable* __tab)
       : _M_cur(__n), _M_ht(__tab) { }
 
-      _Hashtable_iterator() { }
+      _Hashtable_iterator()
+      : _M_cur(0), _M_ht(0) { }
 
       reference
       operator*() const
diff --git a/libstdc++-v3/include/bits/stl_algo.h b/libstdc++-v3/include/bits/stl_algo.h
index 873005b..a8805f1 100644
--- a/libstdc++-v3/include/bits/stl_algo.h
+++ b/libstdc++-v3/include/bits/stl_algo.h
@@ -337,6 +337,39 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   // count_if
   // search
 
+// Local modification: if __google_stl_debug_compare is defined to
+// non-zero value, check sort predicate for strict weak ordering.
+// Google ref b/1731200.
+#if __google_stl_debug_compare
+  template<typename _Compare>
+  struct _CheckedCompare {
+    _Compare _M_compare;
+
+    _CheckedCompare(const _Compare & __comp): _M_compare(__comp) { }
+
+    template <typename _Tp>
+    bool operator()(const _Tp& __x, const _Tp& __y) {
+      if (_M_compare(__x, __x))
+        __throw_runtime_error("strict weak ordering: (__x LT __x) != false");
+      if (_M_compare(__y, __y))
+        __throw_runtime_error("strict weak ordering: (__y LT __y) != false");
+      bool lt = _M_compare(__x, __y);
+      if (lt && _M_compare(__y, __x))
+        __throw_runtime_error("strict weak ordering: ((__x LT __y) && (__y LT __x)) != false");
+      return lt;
+    }
+
+    // Different types; can't perform any checks.
+    template <typename _Tp1, typename _Tp2>
+    bool operator()(const _Tp1& __x, const _Tp2& __y) {
+      return _M_compare(__x, __y);
+    }
+  };
+# define __CheckedCompare(__comp) _CheckedCompare<__typeof__(__comp)>(__comp)
+#else
+# define __CheckedCompare(__comp) __comp
+#endif
+
   /**
    *  This is an uglified
    *  search_n(_ForwardIterator, _ForwardIterator, _Integer, const _Tp&)
@@ -2095,18 +2128,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  ++__result_real_last;
 	  ++__first;
 	}
-      std::make_heap(__result_first, __result_real_last, __comp);
+      std::make_heap(__result_first, __result_real_last,
+                     __CheckedCompare(__comp));
       while (__first != __last)
 	{
-	  if (__comp(*__first, *__result_first))
+	  if (__CheckedCompare(__comp)(*__first, *__result_first))
 	    std::__adjust_heap(__result_first, _DistanceType(0),
 			       _DistanceType(__result_real_last
 					     - __result_first),
 			       _InputValueType(*__first),
-			       __comp);
+			       __CheckedCompare(__comp));
 	  ++__first;
 	}
-      std::sort_heap(__result_first, __result_real_last, __comp);
+      std::sort_heap(__result_first, __result_real_last,
+                     __CheckedCompare(__comp));
       return __result_real_last;
     }
 
@@ -2467,7 +2502,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  _DistanceType __half = __len >> 1;
 	  _ForwardIterator __middle = __first;
 	  std::advance(__middle, __half);
-	  if (__comp(*__middle, __val))
+	  if (__CheckedCompare(__comp)(*__middle, __val))
 	    {
 	      __first = __middle;
 	      ++__first;
@@ -2563,7 +2598,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  _DistanceType __half = __len >> 1;
 	  _ForwardIterator __middle = __first;
 	  std::advance(__middle, __half);
-	  if (__comp(__val, *__middle))
+	  if (__CheckedCompare(__comp)(__val, *__middle))
 	    __len = __half;
 	  else
 	    {
@@ -2682,13 +2717,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  _DistanceType __half = __len >> 1;
 	  _ForwardIterator __middle = __first;
 	  std::advance(__middle, __half);
-	  if (__comp(*__middle, __val))
+	  if (__CheckedCompare(__comp)(*__middle, __val))
 	    {
 	      __first = __middle;
 	      ++__first;
 	      __len = __len - __half - 1;
 	    }
-	  else if (__comp(__val, *__middle))
+	  else if (__CheckedCompare(__comp)(__val, *__middle))
 	    __len = __half;
 	  else
 	    {
@@ -2766,7 +2801,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 						__val, __comp);
 
       _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
-      return __i != __last && !bool(__comp(__val, *__i));
+      return __i != __last && !bool(__CheckedCompare(__comp)(__val, *__i));
     }
 
   // merge
@@ -3257,11 +3292,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 								  __last);
       if (__buf.begin() == 0)
 	std::__merge_without_buffer(__first, __middle, __last, __len1,
-				    __len2, __comp);
+				    __len2, __CheckedCompare(__comp));
       else
 	std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
 			      __buf.begin(), _DistanceType(__buf.size()),
-			      __comp);
+			      __CheckedCompare(__comp));
     }
 
 
@@ -3640,9 +3675,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
 
       while (__first1 != __last1 && __first2 != __last2)
-	if (__comp(*__first2, *__first1))
+	if (__CheckedCompare(__comp)(*__first2, *__first1))
 	  return false;
-	else if(__comp(*__first1, *__first2))
+	else if(__CheckedCompare(__comp)(*__first1, *__first2))
 	  ++__first1;
 	else
 	  ++__first1, ++__first2;
@@ -3755,10 +3790,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	{
 	  _BidirectionalIterator __ii = __i;
 	  --__i;
-	  if (__comp(*__i, *__ii))
+	  if (__CheckedCompare(__comp)(*__i, *__ii))
 	    {
 	      _BidirectionalIterator __j = __last;
-	      while (!bool(__comp(*__i, *--__j)))
+	      while (!bool(__CheckedCompare(__comp)(*__i, *--__j)))
 		{}
 	      std::iter_swap(__i, __j);
 	      std::reverse(__ii, __last);
@@ -3868,10 +3903,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	{
 	  _BidirectionalIterator __ii = __i;
 	  --__i;
-	  if (__comp(*__ii, *__i))
+	  if (__CheckedCompare(__comp)(*__ii, *__i))
 	    {
 	      _BidirectionalIterator __j = __last;
-	      while (!bool(__comp(*--__j, *__i)))
+	      while (!bool(__CheckedCompare(__comp)(*--__j, *__i)))
 		{}
 	      std::iter_swap(__i, __j);
 	      std::reverse(__ii, __last);
@@ -4044,7 +4079,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
       _ForwardIterator __next = __first;
       for (++__next; __next != __last; __first = __next, ++__next)
-	if (__comp(*__next, *__first))
+	if (__CheckedCompare(__comp)(*__next, *__first))
 	  return __next;
       return __next;
     }
@@ -4081,8 +4116,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     inline pair<const _Tp&, const _Tp&>
     minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
     {
-      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
-	                      : pair<const _Tp&, const _Tp&>(__a, __b);
+      return __CheckedCompare(__comp)(__b, __a)
+          ? pair<const _Tp&, const _Tp&>(__b, __a)
+          : pair<const _Tp&, const _Tp&>(__a, __b);
     }
 
   /**
@@ -4190,7 +4226,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	return std::make_pair(__first, __first);
 
       _ForwardIterator __min, __max;
-      if (__comp(*__next, *__first))
+      if (__CheckedCompare(__comp)(*__next, *__first))
 	{
 	  __min = __next;
 	  __max = __first;
@@ -4209,25 +4245,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  __next = __first;
 	  if (++__next == __last)
 	    {
-	      if (__comp(*__first, *__min))
+	      if (__CheckedCompare(__comp)(*__first, *__min))
 		__min = __first;
-	      else if (!__comp(*__first, *__max))
+	      else if (!__CheckedCompare(__comp)(*__first, *__max))
 		__max = __first;
 	      break;
 	    }
 
-	  if (__comp(*__next, *__first))
+	  if (__CheckedCompare(__comp)(*__next, *__first))
 	    {
-	      if (__comp(*__next, *__min))
+	      if (__CheckedCompare(__comp)(*__next, *__min))
 		__min = __next;
-	      if (!__comp(*__first, *__max))
+	      if (!__CheckedCompare(__comp)(*__first, *__max))
 		__max = __first;
 	    }
 	  else
 	    {
-	      if (__comp(*__first, *__min))
+	      if (__CheckedCompare(__comp)(*__first, *__min))
 		__min = __first;
-	      if (!__comp(*__next, *__max))
+	      if (!__CheckedCompare(__comp)(*__next, *__max))
 		__max = __next;
 	    }
 
@@ -5360,8 +5396,8 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
       __glibcxx_requires_valid_range(__first, __middle);
       __glibcxx_requires_valid_range(__middle, __last);
 
-      std::__heap_select(__first, __middle, __last, __comp);
-      std::sort_heap(__first, __middle, __comp);
+      std::__heap_select(__first, __middle, __last, __CheckedCompare(__comp));
+      std::sort_heap(__first, __middle, __CheckedCompare(__comp));
     }
 
   /**
@@ -5438,7 +5474,8 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
 	return;
 
       std::__introselect(__first, __nth, __last,
-			 std::__lg(__last - __first) * 2, __comp);
+			 std::__lg(__last - __first) * 2,
+                         __CheckedCompare(__comp));
     }
 
 
@@ -5510,8 +5547,10 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
       if (__first != __last)
 	{
 	  std::__introsort_loop(__first, __last,
-				std::__lg(__last - __first) * 2, __comp);
-	  std::__final_insertion_sort(__first, __last, __comp);
+				std::__lg(__last - __first) * 2,
+                                __CheckedCompare(__comp));
+	  std::__final_insertion_sort(__first, __last,
+                                      __CheckedCompare(__comp));
 	}
     }
 
@@ -5624,7 +5663,7 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
 
       while (__first1 != __last1 && __first2 != __last2)
 	{
-	  if (__comp(*__first2, *__first1))
+	  if (__CheckedCompare(__comp)(*__first2, *__first1))
 	    {
 	      *__result = *__first2;
 	      ++__first2;
@@ -5721,10 +5760,11 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
       _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
 								 __last);
       if (__buf.begin() == 0)
-	std::__inplace_stable_sort(__first, __last, __comp);
+	std::__inplace_stable_sort(__first, __last, __CheckedCompare(__comp));
       else
 	std::__stable_sort_adaptive(__first, __last, __buf.begin(),
-				    _DistanceType(__buf.size()), __comp);
+				    _DistanceType(__buf.size()),
+                                    __CheckedCompare(__comp));
     }
 
 
@@ -5841,12 +5881,12 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
 
       while (__first1 != __last1 && __first2 != __last2)
 	{
-	  if (__comp(*__first1, *__first2))
+	  if (__CheckedCompare(__comp)(*__first1, *__first2))
 	    {
 	      *__result = *__first1;
 	      ++__first1;
 	    }
-	  else if (__comp(*__first2, *__first1))
+	  else if (__CheckedCompare(__comp)(*__first2, *__first1))
 	    {
 	      *__result = *__first2;
 	      ++__first2;
@@ -5962,9 +6002,9 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
       __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
 
       while (__first1 != __last1 && __first2 != __last2)
-	if (__comp(*__first1, *__first2))
+	if (__CheckedCompare(__comp)(*__first1, *__first2))
 	  ++__first1;
-	else if (__comp(*__first2, *__first1))
+	else if (__CheckedCompare(__comp)(*__first2, *__first1))
 	  ++__first2;
 	else
 	  {
@@ -6081,13 +6121,13 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
       __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
 
       while (__first1 != __last1 && __first2 != __last2)
-	if (__comp(*__first1, *__first2))
+	if (__CheckedCompare(__comp)(*__first1, *__first2))
 	  {
 	    *__result = *__first1;
 	    ++__first1;
 	    ++__result;
 	  }
-	else if (__comp(*__first2, *__first1))
+	else if (__CheckedCompare(__comp)(*__first2, *__first1))
 	  ++__first2;
 	else
 	  {
@@ -6208,13 +6248,13 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
       __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
 
       while (__first1 != __last1 && __first2 != __last2)
-	if (__comp(*__first1, *__first2))
+	if (__CheckedCompare(__comp)(*__first1, *__first2))
 	  {
 	    *__result = *__first1;
 	    ++__first1;
 	    ++__result;
 	  }
-	else if (__comp(*__first2, *__first1))
+	else if (__CheckedCompare(__comp)(*__first2, *__first1))
 	  {
 	    *__result = *__first2;
 	    ++__first2;
@@ -6281,7 +6321,7 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
 	return __first;
       _ForwardIterator __result = __first;
       while (++__first != __last)
-	if (__comp(*__first, *__result))
+	if (__CheckedCompare(__comp)(*__first, *__result))
 	  __result = __first;
       return __result;
     }
@@ -6336,11 +6376,13 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
       if (__first == __last) return __first;
       _ForwardIterator __result = __first;
       while (++__first != __last)
-	if (__comp(*__result, *__first))
+	if (__CheckedCompare(__comp)(*__result, *__first))
 	  __result = __first;
       return __result;
     }
 
+#undef __CheckedCompare
+
 _GLIBCXX_END_NAMESPACE_ALGO
 } // namespace std
 
diff --git a/libstdc++-v3/include/bits/stl_bvector.h b/libstdc++-v3/include/bits/stl_bvector.h
index 670b195..cf204e4 100644
--- a/libstdc++-v3/include/bits/stl_bvector.h
+++ b/libstdc++-v3/include/bits/stl_bvector.h
@@ -463,11 +463,31 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 #endif
 
       ~_Bvector_base()
-      { this->_M_deallocate(); }
+      {
+        this->_M_deallocate();
+#if __google_stl_debug_bvector
+        __builtin_memset(this, 0xcd, sizeof(*this));
+#endif
+      }
 
     protected:
       _Bvector_impl _M_impl;
 
+#if __google_stl_debug_bvector
+      bool _M_is_valid() const
+      {
+	return (this->_M_impl._M_start._M_p == 0
+		&& this->_M_impl._M_finish._M_p == 0
+		&& this->_M_impl._M_end_of_storage == 0)
+	  || (this->_M_impl._M_start._M_p <= this->_M_impl._M_finish._M_p
+	      && this->_M_impl._M_finish._M_p <= this->_M_impl._M_end_of_storage
+	      && (this->_M_impl._M_start._M_p < this->_M_impl._M_end_of_storage
+                  || (this->_M_impl._M_start._M_p == this->_M_impl._M_end_of_storage
+                      && this->_M_impl._M_start._M_offset == 0
+                      && this->_M_impl._M_finish._M_offset == 0)));
+      }
+#endif
+
       _Bit_type*
       _M_allocate(size_t __n)
       { return _M_impl.allocate(_S_nword(__n)); }
@@ -623,6 +643,10 @@ template<typename _Alloc>
     vector&
     operator=(const vector& __x)
     {
+#if __google_stl_debug_bvector
+      if (!this->_M_is_valid())
+	__throw_logic_error("op=() on corrupt (dangling?) vector");
+#endif
       if (&__x == this)
 	return *this;
       if (__x.size() > capacity())
@@ -639,6 +663,10 @@ template<typename _Alloc>
     vector&
     operator=(vector&& __x)
     {
+#if __google_stl_debug_bvector
+      if (!this->_M_is_valid())
+	__throw_logic_error("op=() on corrupt (dangling?) vector");
+#endif
       // NB: DR 1204.
       // NB: DR 675.
       this->clear();
@@ -660,19 +688,35 @@ template<typename _Alloc>
     // or not the type is an integer.
     void
     assign(size_type __n, const bool& __x)
-    { _M_fill_assign(__n, __x); }
+    {
+#if __google_stl_debug_bvector
+      if (!this->_M_is_valid())
+	__throw_logic_error("assign() on corrupt (dangling?) vector");
+#endif
+      _M_fill_assign(__n, __x);
+    }
 
 #if __cplusplus >= 201103L
     template<typename _InputIterator,
 	     typename = std::_RequireInputIter<_InputIterator>>
       void
       assign(_InputIterator __first, _InputIterator __last)
-      { _M_assign_dispatch(__first, __last, __false_type()); }
+      {
+#if __google_stl_debug_bvector
+	if (!this->_M_is_valid())
+	  __throw_logic_error("assign() on corrupt (dangling?) vector");
+#endif
+	_M_assign_dispatch(__first, __last, __false_type());
+      }
 #else
     template<typename _InputIterator>
       void
       assign(_InputIterator __first, _InputIterator __last)
       {
+#if __google_stl_debug_bvector
+	if (!this->_M_is_valid())
+	  __throw_logic_error("assign() on corrupt (dangling?) vector");
+#endif
 	typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 	_M_assign_dispatch(__first, __last, _Integral());
       }
@@ -686,19 +730,43 @@ template<typename _Alloc>
 
     iterator
     begin() _GLIBCXX_NOEXCEPT
-    { return this->_M_impl._M_start; }
+    {
+#if __google_stl_debug_bvector
+      if (!this->_M_is_valid())
+	__throw_logic_error("begin() on corrupt (dangling?) vector");
+#endif
+      return this->_M_impl._M_start;
+    }
 
     const_iterator
     begin() const _GLIBCXX_NOEXCEPT
-    { return this->_M_impl._M_start; }
+    {
+#if __google_stl_debug_bvector
+      if (!this->_M_is_valid())
+	__throw_logic_error("begin() on corrupt (dangling?) vector");
+#endif
+      return this->_M_impl._M_start;
+    }
 
     iterator
     end() _GLIBCXX_NOEXCEPT
-    { return this->_M_impl._M_finish; }
+    {
+#if __google_stl_debug_bvector
+      if (!this->_M_is_valid())
+	__throw_logic_error("end() on corrupt (dangling?) vector");
+#endif
+      return this->_M_impl._M_finish;
+    }
 
     const_iterator
     end() const _GLIBCXX_NOEXCEPT
-    { return this->_M_impl._M_finish; }
+    {
+#if __google_stl_debug_bvector
+      if (!this->_M_is_valid())
+	__throw_logic_error("end() on corrupt (dangling?) vector");
+#endif
+      return this->_M_impl._M_finish;
+    }
 
     reverse_iterator
     rbegin() _GLIBCXX_NOEXCEPT
@@ -719,11 +787,23 @@ template<typename _Alloc>
 #if __cplusplus >= 201103L
     const_iterator
     cbegin() const noexcept
-    { return this->_M_impl._M_start; }
+    {
+#if __google_stl_debug_bvector
+      if (!this->_M_is_valid())
+	__throw_logic_error("cbegin() on corrupt (dangling?) vector");
+#endif
+      return this->_M_impl._M_start;
+    }
 
     const_iterator
     cend() const noexcept
-    { return this->_M_impl._M_finish; }
+    {
+#if __google_stl_debug_bvector
+      if (!this->_M_is_valid())
+	__throw_logic_error("cend() on corrupt (dangling?) vector");
+#endif
+      return this->_M_impl._M_finish;
+    }
 
     const_reverse_iterator
     crbegin() const noexcept
@@ -741,6 +821,10 @@ template<typename _Alloc>
     size_type
     max_size() const _GLIBCXX_NOEXCEPT
     {
+#if __google_stl_debug_bvector
+      if (!this->_M_is_valid())
+	__throw_logic_error("max_size() on corrupt (dangling?) vector");
+#endif
       const size_type __isize =
 	__gnu_cxx::__numeric_traits<difference_type>::__max
 	- int(_S_word_bit) + 1;
@@ -761,6 +845,9 @@ template<typename _Alloc>
     reference
     operator[](size_type __n)
     {
+#if __google_stl_debug_bvector
+      _M_range_check(__n);
+#endif
       return *iterator(this->_M_impl._M_start._M_p
 		       + __n / int(_S_word_bit), __n % int(_S_word_bit));
     }
@@ -768,6 +855,9 @@ template<typename _Alloc>
     const_reference
     operator[](size_type __n) const
     {
+#if __google_stl_debug_bvector
+      _M_range_check(__n);
+#endif
       return *const_iterator(this->_M_impl._M_start._M_p
 			     + __n / int(_S_word_bit), __n % int(_S_word_bit));
     }
@@ -800,19 +890,39 @@ template<typename _Alloc>
 
     reference
     front()
-    { return *begin(); }
+    {
+#if __google_stl_debug_bvector
+      _M_range_check(0);
+#endif
+      return *begin();
+    }
 
     const_reference
     front() const
-    { return *begin(); }
+    {
+#if __google_stl_debug_bvector
+      _M_range_check(0);
+#endif
+      return *begin();
+    }
 
     reference
     back()
-    { return *(end() - 1); }
+    {
+#if __google_stl_debug_bvector
+      _M_range_check(0);
+#endif
+      return *(end() - 1);
+    }
 
     const_reference
     back() const
-    { return *(end() - 1); }
+    {
+#if __google_stl_debug_bvector
+      _M_range_check(0);
+#endif
+      return *(end() - 1);
+    }
 
     // _GLIBCXX_RESOLVE_LIB_DEFECTS
     // DR 464. Suggestion for new member functions in standard containers.
@@ -825,6 +935,10 @@ template<typename _Alloc>
     void
     push_back(bool __x)
     {
+#if __google_stl_debug_bvector
+      if (!this->_M_is_valid())
+	__throw_logic_error("push_back() on corrupt (dangling?) vector");
+#endif
       if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
         *this->_M_impl._M_finish++ = __x;
       else
@@ -834,6 +948,10 @@ template<typename _Alloc>
     void
     swap(vector& __x)
     {
+#if __google_stl_debug_bvector
+      if (!this->_M_is_valid() || !__x._M_is_valid())
+	__throw_logic_error("swap() on corrupt (dangling?) vector");
+#endif
       std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
       std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
       std::swap(this->_M_impl._M_end_of_storage, 
@@ -872,13 +990,23 @@ template<typename _Alloc>
       void
       insert(iterator __position,
 	     _InputIterator __first, _InputIterator __last)
-      { _M_insert_dispatch(__position, __first, __last, __false_type()); }
+      {
+#if __google_stl_debug_bvector
+	if (!this->_M_is_valid())
+	  __throw_logic_error("insert() on corrupt (dangling?) vector");
+#endif
+	_M_insert_dispatch(__position, __first, __last, __false_type());
+      }
 #else
     template<typename _InputIterator>
       void
       insert(iterator __position,
 	     _InputIterator __first, _InputIterator __last)
       {
+#if __google_stl_debug_bvector
+	if (!this->_M_is_valid())
+	  __throw_logic_error("insert() on corrupt (dangling?) vector");
+#endif
 	typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 	_M_insert_dispatch(__position, __first, __last, _Integral());
       }
@@ -886,7 +1014,13 @@ template<typename _Alloc>
 
     void
     insert(iterator __position, size_type __n, const bool& __x)
-    { _M_fill_insert(__position, __n, __x); }
+    {
+#if __google_stl_debug_bvector
+      if (!this->_M_is_valid())
+	__throw_logic_error("insert() on corrupt (dangling?) vector");
+#endif
+      _M_fill_insert(__position, __n, __x);
+    }
 
 #if __cplusplus >= 201103L
     void insert(iterator __p, initializer_list<bool> __l)
@@ -895,11 +1029,19 @@ template<typename _Alloc>
 
     void
     pop_back()
-    { --this->_M_impl._M_finish; }
+    {
+#if __google_stl_debug_bvector
+      _M_range_check(0);
+#endif
+      --this->_M_impl._M_finish;
+    }
 
     iterator
     erase(iterator __position)
     {
+#if __google_stl_debug_bvector
+      _M_range_check(__position - begin());
+#endif
       if (__position + 1 != end())
         std::copy(__position + 1, end(), __position);
       --this->_M_impl._M_finish;
@@ -909,6 +1051,10 @@ template<typename _Alloc>
     iterator
     erase(iterator __first, iterator __last)
     {
+#if __google_stl_debug_bvector
+      if (!this->_M_is_valid())
+	__throw_logic_error("erase() on corrupt (dangling?) vector");
+#endif
       if (__first != __last)
 	_M_erase_at_end(std::copy(__last, end(), __first));
       return __first;
@@ -926,12 +1072,22 @@ template<typename _Alloc>
 #if __cplusplus >= 201103L
     void
     shrink_to_fit()
-    { _M_shrink_to_fit(); }
+    {
+#if __google_stl_debug_bvector
+      if (!this->_M_is_valid())
+	__throw_logic_error("shrink_to_fit() on corrupt (dangling?) vector");
+#endif
+      _M_shrink_to_fit();
+    }
 #endif
 
     void
     flip() _GLIBCXX_NOEXCEPT
     {
+#if __google_stl_debug_bvector
+      if (!this->_M_is_valid())
+	__throw_logic_error("flip() on corrupt (dangling?) vector");
+#endif
       for (_Bit_type * __p = this->_M_impl._M_start._M_p;
 	   __p != this->_M_impl._M_end_of_storage; ++__p)
         *__p = ~*__p;
diff --git a/libstdc++-v3/include/bits/stl_tree.h b/libstdc++-v3/include/bits/stl_tree.h
index 91bf4df..510d375 100644
--- a/libstdc++-v3/include/bits/stl_tree.h
+++ b/libstdc++-v3/include/bits/stl_tree.h
@@ -470,7 +470,47 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	  }	    
 	};
 
+      // Local modification: if __google_stl_debug_rbtree is defined to
+      // non-zero value, check sort predicate for strict weak ordering.
+      // Google ref b/1731200.
+#if __google_stl_debug_rbtree
+      template<typename _KeyCompare>
+      struct _CheckedCompare {
+        _KeyCompare _M_key_compare;
+
+        _CheckedCompare(): _M_key_compare() { }
+        _CheckedCompare(const _KeyCompare & __comp): _M_key_compare(__comp) { }
+
+	// Template arg required to avoid duplicating code in the two op()
+	// operators below.  User-provided _M_key_compare may not be const,
+	// but needs to be callable from our const op().
+	// Google ref. b/1731200.
+	template <typename _KeyCompareT>
+        static bool _M_compare_with(_KeyCompareT& __comp, const _Key& __x, const _Key& __y) {
+          if (__comp(__x, __x))
+            __throw_runtime_error("strict weak ordering: (__x LT __x) != false");
+          if (__comp(__y, __y))
+            __throw_runtime_error("strict weak ordering: (__y LT __y) != false");
+          bool lt = __comp(__x, __y);
+          if (lt && __comp(__y, __x))
+            __throw_runtime_error("strict weak ordering: ((__x LT __y) && (__y LT __x)) != false");
+          return lt;
+        }
+        bool operator()(const _Key& __x, const _Key& __y) const {
+	  return _M_compare_with(_M_key_compare, __x, __y);
+        }
+
+        bool operator()(const _Key& __x, const _Key& __y) {
+	  return _M_compare_with(_M_key_compare, __x, __y);
+        }
+
+        operator _KeyCompare() const { return _M_key_compare; }
+      };
+
+      _Rb_tree_impl<_CheckedCompare<_Compare> > _M_impl;
+#else
       _Rb_tree_impl<_Compare> _M_impl;
+#endif
 
     protected:
       _Base_ptr&
diff --git a/libstdc++-v3/include/bits/stl_vector.h b/libstdc++-v3/include/bits/stl_vector.h
index 69c6e27..164a111 100644
--- a/libstdc++-v3/include/bits/stl_vector.h
+++ b/libstdc++-v3/include/bits/stl_vector.h
@@ -158,7 +158,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 
       ~_Vector_base()
       { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
-		      - this->_M_impl._M_start); }
+		      - this->_M_impl._M_start);
+#if __google_stl_debug_dangling_vector
+        this->_M_impl._M_start = 0;
+        this->_M_impl._M_finish = reinterpret_cast<_Tp*>(~0UL);
+#endif
+      }
 
     public:
       _Vector_impl _M_impl;
@@ -239,6 +244,31 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       using _Base::_M_impl;
       using _Base::_M_get_Tp_allocator;
 
+      bool _M_is_valid() const
+      {
+        if (this->_M_impl._M_end_of_storage == 0
+	    && this->_M_impl._M_start == 0
+	    && this->_M_impl._M_finish == 0)
+	  return true;
+
+	if (this->_M_impl._M_start <= this->_M_impl._M_finish
+	    && this->_M_impl._M_finish <= this->_M_impl._M_end_of_storage)
+	  {
+	    if (this->_M_impl._M_start < this->_M_impl._M_end_of_storage)
+	      return true;
+	    else if (this->_M_impl._M_start == this->_M_impl._M_end_of_storage
+		     && this->_M_impl._M_start == this->_M_impl._M_finish)
+	      {
+		pointer _0xcdcd;
+
+		__builtin_memset(&_0xcdcd, 0xcd, sizeof(_0xcdcd));
+		return this->_M_impl._M_finish != _0xcdcd;
+	      }
+	  }
+
+	return false;
+      }
+
     public:
       // [23.2.4.1] construct/copy/destroy
       // (assign() and get_allocator() are also listed in this section)
@@ -536,7 +566,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        */
       iterator
       begin() _GLIBCXX_NOEXCEPT
-      { return iterator(this->_M_impl._M_start); }
+      {
+#if __google_stl_debug_dangling_vector
+        if (!this->_M_is_valid())
+          __throw_logic_error("begin() on corrupt (dangling?) vector");
+#endif
+	return iterator(this->_M_impl._M_start);
+      }
 
       /**
        *  Returns a read-only (constant) iterator that points to the
@@ -545,7 +581,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        */
       const_iterator
       begin() const _GLIBCXX_NOEXCEPT
-      { return const_iterator(this->_M_impl._M_start); }
+      {
+#if __google_stl_debug_dangling_vector
+        if (!this->_M_is_valid())
+          __throw_logic_error("begin() on corrupt (dangling?) vector");
+#endif
+	return const_iterator(this->_M_impl._M_start);
+      }
 
       /**
        *  Returns a read/write iterator that points one past the last
@@ -554,7 +596,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        */
       iterator
       end() _GLIBCXX_NOEXCEPT
-      { return iterator(this->_M_impl._M_finish); }
+      {
+#if __google_stl_debug_dangling_vector
+        if (!this->_M_is_valid())
+          __throw_logic_error("end() on corrupt (dangling?) vector");
+#endif
+	return iterator(this->_M_impl._M_finish);
+      }
 
       /**
        *  Returns a read-only (constant) iterator that points one past
@@ -563,7 +611,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        */
       const_iterator
       end() const _GLIBCXX_NOEXCEPT
-      { return const_iterator(this->_M_impl._M_finish); }
+      {
+#if __google_stl_debug_dangling_vector
+        if (!this->_M_is_valid())
+          __throw_logic_error("end() on corrupt (dangling?) vector");
+#endif
+	return const_iterator(this->_M_impl._M_finish);
+      }
 
       /**
        *  Returns a read/write reverse iterator that points to the
@@ -643,7 +697,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       /**  Returns the number of elements in the %vector.  */
       size_type
       size() const _GLIBCXX_NOEXCEPT
-      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
+      {
+#if __google_stl_debug_dangling_vector
+        if (!this->_M_is_valid())
+          __throw_logic_error("size() on corrupt (dangling?) vector");
+#endif
+	return size_type(this->_M_impl._M_finish - this->_M_impl._M_start);
+      }
 
       /**  Returns the size() of the largest possible %vector.  */
       size_type
@@ -723,7 +783,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        */
       size_type
       capacity() const _GLIBCXX_NOEXCEPT
-      { return size_type(this->_M_impl._M_end_of_storage
+      {
+#if __google_stl_debug_dangling_vector
+        if (!this->_M_is_valid())
+          __throw_logic_error("capacity() on corrupt (dangling?) vector");
+#endif
+	return size_type(this->_M_impl._M_end_of_storage
 			 - this->_M_impl._M_start); }
 
       /**
@@ -765,10 +830,18 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        *  Note that data access with this operator is unchecked and
        *  out_of_range lookups are not defined. (For checked lookups
        *  see at().)
+       *
+       *  Local modification: range checks are performed if
+       *  __google_stl_debug_vector is defined to non-zero.
        */
       reference
       operator[](size_type __n)
-      { return *(this->_M_impl._M_start + __n); }
+      {
+#if __google_stl_debug_vector
+	_M_range_check(__n);
+#endif
+	return *(this->_M_impl._M_start + __n);
+      }
 
       /**
        *  @brief  Subscript access to the data contained in the %vector.
@@ -780,10 +853,18 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        *  Note that data access with this operator is unchecked and
        *  out_of_range lookups are not defined. (For checked lookups
        *  see at().)
+       *
+       *  Local modification: range checks are performed if
+       *  __google_stl_debug_vector is defined to non-zero.
        */
       const_reference
       operator[](size_type __n) const
-      { return *(this->_M_impl._M_start + __n); }
+      {
+#if __google_stl_debug_vector
+	_M_range_check(__n);
+#endif
+	return *(this->_M_impl._M_start + __n);
+      }
 
     protected:
       /// Safety check used only from at().
@@ -837,7 +918,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        */
       reference
       front()
-      { return *begin(); }
+      {
+#if __google_stl_debug_vector
+        if (empty()) __throw_logic_error("front() on empty vector");
+#endif
+        return *begin();
+      }
 
       /**
        *  Returns a read-only (constant) reference to the data at the first
@@ -845,7 +931,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        */
       const_reference
       front() const
-      { return *begin(); }
+      {
+#if __google_stl_debug_vector
+        if (empty()) __throw_logic_error("front() on empty vector");
+#endif
+        return *begin();
+      }
 
       /**
        *  Returns a read/write reference to the data at the last
@@ -853,7 +944,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        */
       reference
       back()
-      { return *(end() - 1); }
+      {
+#if __google_stl_debug_vector
+        if (empty()) __throw_logic_error("back() on empty vector");
+#endif
+        return *(end() - 1);
+      }
       
       /**
        *  Returns a read-only (constant) reference to the data at the
@@ -861,7 +957,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        */
       const_reference
       back() const
-      { return *(end() - 1); }
+      {
+#if __google_stl_debug_vector
+        if (empty()) __throw_logic_error("back() on empty vector");
+#endif
+        return *(end() - 1);
+      }
 
       // _GLIBCXX_RESOLVE_LIB_DEFECTS
       // DR 464. Suggestion for new member functions in standard containers.
@@ -876,7 +977,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       pointer
 #endif
       data() _GLIBCXX_NOEXCEPT
-      { return std::__addressof(front()); }
+      {
+#if __google_stl_debug_vector
+        if (empty()) return 0;
+#endif
+        return std::__addressof(front());
+      }
 
 #if __cplusplus >= 201103L
       const _Tp*
@@ -884,7 +990,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
       const_pointer
 #endif
       data() const _GLIBCXX_NOEXCEPT
-      { return std::__addressof(front()); }
+      {
+#if __google_stl_debug_vector
+        if (empty()) return 0;
+#endif
+        return std::__addressof(front());
+      }
 
       // [23.2.4.3] modifiers
       /**
@@ -1110,6 +1221,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
 			noexcept(_Alloc_traits::_S_nothrow_swap())
 #endif
       {
+#if __google_stl_debug_dangling_vector
+        if (!this->_M_is_valid() || !__x._M_is_valid())
+          __throw_logic_error("swap() on corrupt (dangling?) vector");
+#endif
 	this->_M_impl._M_swap_data(__x._M_impl);
 	_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
 	                          __x._M_get_Tp_allocator());
@@ -1123,7 +1238,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
        */
       void
       clear() _GLIBCXX_NOEXCEPT
-      { _M_erase_at_end(this->_M_impl._M_start); }
+      {
+#if __google_stl_debug_dangling_vector
+        if (!this->_M_is_valid())
+          __throw_logic_error("clear() on corrupt (dangling?) vector");
+#endif
+	_M_erase_at_end(this->_M_impl._M_start);
+      }
 
     protected:
       /**
diff --git a/libstdc++-v3/include/bits/vector.tcc b/libstdc++-v3/include/bits/vector.tcc
index 0882fe6..d4cd16e 100644
--- a/libstdc++-v3/include/bits/vector.tcc
+++ b/libstdc++-v3/include/bits/vector.tcc
@@ -160,6 +160,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
     vector<_Tp, _Alloc>::
     operator=(const vector<_Tp, _Alloc>& __x)
     {
+#if __google_stl_debug_dangling_vector
+      if (!this->_M_is_valid() || !__x._M_is_valid())
+	__throw_logic_error("operator=() on corrupt (dangling?) vector");
+#endif
       if (&__x != this)
 	{
 #if __cplusplus >= 201103L
diff --git a/libstdc++-v3/include/ext/new_allocator.h b/libstdc++-v3/include/ext/new_allocator.h
index 9866fed..8a77523 100644
--- a/libstdc++-v3/include/ext/new_allocator.h
+++ b/libstdc++-v3/include/ext/new_allocator.h
@@ -104,10 +104,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
       }
 
+#ifdef __GXX_DELETE_WITH_SIZE__
+      // __p is not permitted to be a null pointer.
+      void
+      deallocate(pointer __p, size_type __t)
+      { ::operator delete(__p, __t * sizeof(_Tp)); }
+#else
       // __p is not permitted to be a null pointer.
       void
       deallocate(pointer __p, size_type)
       { ::operator delete(__p); }
+#endif
 
       size_type
       max_size() const _GLIBCXX_USE_NOEXCEPT
diff --git a/libstdc++-v3/include/ext/sso_string_base.h b/libstdc++-v3/include/ext/sso_string_base.h
index 9e5b50e..c02cb8b 100644
--- a/libstdc++-v3/include/ext/sso_string_base.h
+++ b/libstdc++-v3/include/ext/sso_string_base.h
@@ -85,6 +85,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       {
 	if (!_M_is_local())
 	  _M_destroy(_M_allocated_capacity);
+#if __google_stl_debug_dangling_string
+	else {
+          // Wipe local storage for destructed string with 0xCD.
+          // This mimics what DebugAllocation does to free()d memory.
+          __builtin_memset(_M_local_data, 0xcd, sizeof(_M_local_data));
+        }
+#endif
       }
 
       void
@@ -168,15 +175,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       _M_leak() { }
 
       void
-      _M_set_length(size_type __n)
+      _M_set_length_no_wipe(size_type __n)
       {
 	_M_length(__n);
 	traits_type::assign(_M_data()[__n], _CharT());
       }
 
+      void
+      _M_set_length(size_type __n)
+      {
+#if __google_stl_debug_dangling_string
+	if (__n + 1 < _M_length())
+	  {
+	    // Wipe the storage with 0xCD.
+	    // Also wipes the old NUL terminator.
+	    __builtin_memset(_M_data() + __n + 1, 0xcd, _M_length() - __n);
+	  }
+#endif
+	  _M_set_length_no_wipe(__n);
+      }
+
       __sso_string_base()
       : _M_dataplus(_M_local_data)
-      { _M_set_length(0); }
+      { _M_set_length_no_wipe(0); }
 
       __sso_string_base(const _Alloc& __a);
 
@@ -193,7 +214,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 			  const _Alloc& __a);
 
       ~__sso_string_base()
-      { _M_dispose(); }
+      {
+          _M_dispose();
+#ifdef __google_stl_debug_dangling_string
+          __builtin_memset(this, 0xcd, sizeof(*this));
+#endif
+      }
 
       _CharT_alloc_type&
       _M_get_allocator()
@@ -335,7 +361,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
     __sso_string_base<_CharT, _Traits, _Alloc>::
     __sso_string_base(const _Alloc& __a)
     : _M_dataplus(__a, _M_local_data)
-    { _M_set_length(0); }
+    { _M_set_length_no_wipe(0); }
 
   template<typename _CharT, typename _Traits, typename _Alloc>
     __sso_string_base<_CharT, _Traits, _Alloc>::
@@ -425,7 +451,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	    __throw_exception_again;
 	  }
 
-	_M_set_length(__len);
+	_M_set_length_no_wipe(__len);
       }
 
   template<typename _CharT, typename _Traits, typename _Alloc>
@@ -457,7 +483,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 	    __throw_exception_again;
 	  }
 
-	_M_set_length(__dnew);
+	_M_set_length_no_wipe(__dnew);
       }
 
   template<typename _CharT, typename _Traits, typename _Alloc>
@@ -474,7 +500,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       if (__n)
 	this->_S_assign(_M_data(), __n, __c);
 
-      _M_set_length(__n);
+      _M_set_length_no_wipe(__n);
     }
 
   template<typename _CharT, typename _Traits, typename _Alloc>
diff --git a/libstdc++-v3/include/ext/vstring.h b/libstdc++-v3/include/ext/vstring.h
index d46a996..10587f5 100644
--- a/libstdc++-v3/include/ext/vstring.h
+++ b/libstdc++-v3/include/ext/vstring.h
@@ -39,6 +39,21 @@
 #include <ext/rc_string_base.h>
 #include <ext/sso_string_base.h>
 
+#if __google_stl_debug_string && !defined(_GLIBCXX_DEBUG)
+# undef _GLIBCXX_DEBUG_ASSERT
+# undef _GLIBCXX_DEBUG_PEDASSERT
+// Perform additional checks (but only in this file).
+# define _GLIBCXX_DEBUG_ASSERT(_Condition)                             \
+  if (! (_Condition)) {                                                \
+    char buf[512];                                                     \
+    __builtin_snprintf(buf, sizeof(buf),                               \
+                      "%s:%d: %s: Assertion '%s' failed.\n",           \
+                      __FILE__, __LINE__, __func__, # _Condition);     \
+    std::__throw_runtime_error(buf);                                   \
+  }
+# define _GLIBCXX_DEBUG_PEDASSERT(_Condition) _GLIBCXX_DEBUG_ASSERT(_Condition)
+#endif
+
 namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
@@ -2851,4 +2866,12 @@ _GLIBCXX_END_NAMESPACE_VERSION
 
 #include "vstring.tcc" 
 
+#if __google_stl_debug_string && !defined(_GLIBCXX_DEBUG)
+// Undo our defines, so they don't affect anything else.
+# undef _GLIBCXX_DEBUG_ASSERT
+# undef _GLIBCXX_DEBUG_PEDASSERT
+# define _GLIBCXX_DEBUG_ASSERT(_Condition)
+# define _GLIBCXX_DEBUG_PEDASSERT(_Condition)
+#endif
+
 #endif /* _VSTRING_H */
diff --git a/libstdc++-v3/libsupc++/Makefile.am b/libstdc++-v3/libsupc++/Makefile.am
index f276eda..827bda5 100644
--- a/libstdc++-v3/libsupc++/Makefile.am
+++ b/libstdc++-v3/libsupc++/Makefile.am
@@ -52,6 +52,7 @@ sources = \
 	bad_typeid.cc \
 	class_type_info.cc \
 	del_op.cc \
+	del_opsz.cc \
 	del_opnt.cc \
 	del_opv.cc \
 	del_opvnt.cc \
@@ -140,7 +141,8 @@ nested_exception.o: nested_exception.cc
 AM_CXXFLAGS = \
 	$(glibcxx_lt_pic_flag) $(glibcxx_compiler_shared_flag) \
 	$(XTEMPLATE_FLAGS) \
-	$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS)  $(CONFIG_CXXFLAGS)
+	$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS)  $(CONFIG_CXXFLAGS) \
+	$($(@)_no_omit_frame_pointer)
 
 AM_MAKEFLAGS = \
 	"gxx_include_dir=$(gxx_include_dir)"
@@ -245,3 +247,8 @@ uninstall-bitsHEADERS:
 	  q=`echo $$p | sed -e 's,.*/,,'`; \
 	  rm -f $(DESTDIR)$(bitsdir)/$$q; \
 	done
+
+# Google-specific pessimization
+eh_terminate.lo_no_omit_frame_pointer = -fno-omit-frame-pointer
+eh_throw.lo_no_omit_frame_pointer = -fno-omit-frame-pointer
+vterminate.lo_no_omit_frame_pointer = -fno-omit-frame-pointer
diff --git a/libstdc++-v3/libsupc++/Makefile.in b/libstdc++-v3/libsupc++/Makefile.in
index 8bf86f3..fbb4e0b 100644
--- a/libstdc++-v3/libsupc++/Makefile.in
+++ b/libstdc++-v3/libsupc++/Makefile.in
@@ -93,7 +93,7 @@ LTLIBRARIES = $(noinst_LTLIBRARIES) $(toolexeclib_LTLIBRARIES)
 libsupc___la_LIBADD =
 am__objects_1 = array_type_info.lo atexit_arm.lo atexit_thread.lo \
 	bad_alloc.lo bad_cast.lo bad_typeid.lo class_type_info.lo \
-	del_op.lo del_opnt.lo del_opv.lo del_opvnt.lo dyncast.lo \
+	del_op.lo del_opsz.lo del_opnt.lo del_opv.lo del_opvnt.lo dyncast.lo \
 	eh_alloc.lo eh_arm.lo eh_aux_runtime.lo eh_call.lo eh_catch.lo \
 	eh_exception.lo eh_globals.lo eh_personality.lo eh_ptr.lo \
 	eh_term_handler.lo eh_terminate.lo eh_tm.lo eh_throw.lo \
@@ -370,6 +370,7 @@ sources = \
 	bad_typeid.cc \
 	class_type_info.cc \
 	del_op.cc \
+	del_opsz.cc \
 	del_opnt.cc \
 	del_opv.cc \
 	del_opvnt.cc \
@@ -423,7 +424,8 @@ libsupc__convenience_la_SOURCES = $(sources) $(c_sources)
 AM_CXXFLAGS = \
 	$(glibcxx_lt_pic_flag) $(glibcxx_compiler_shared_flag) \
 	$(XTEMPLATE_FLAGS) \
-	$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS)  $(CONFIG_CXXFLAGS)
+	$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS)  $(CONFIG_CXXFLAGS) \
+	$($(@)_no_omit_frame_pointer)
 
 AM_MAKEFLAGS = \
 	"gxx_include_dir=$(gxx_include_dir)"
@@ -497,6 +499,11 @@ CXXLINK = \
 # prepending each of $(*_HEADERS) with VPATH below.
 stddir = $(gxx_include_dir)
 bitsdir = $(gxx_include_dir)/bits
+
+# Google-specific pessimization
+eh_terminate.lo_no_omit_frame_pointer = -fno-omit-frame-pointer
+eh_throw.lo_no_omit_frame_pointer = -fno-omit-frame-pointer
+vterminate.lo_no_omit_frame_pointer = -fno-omit-frame-pointer
 all: all-am
 
 .SUFFIXES:
diff --git a/libstdc++-v3/libsupc++/del_opsz.cc b/libstdc++-v3/libsupc++/del_opsz.cc
new file mode 100644
index 0000000..2f6325b
--- /dev/null
+++ b/libstdc++-v3/libsupc++/del_opsz.cc
@@ -0,0 +1,50 @@
+// Boilerplate support routines for -*- C++ -*- dynamic memory management.
+
+// Copyright (C) 2012
+// Free Software Foundation
+//
+// This file is part of GCC.
+//
+// GCC is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// GCC is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+#include <bits/c++config.h>
+
+#if !_GLIBCXX_HOSTED
+// A freestanding C runtime may not provide "free" -- but there is no
+// other reasonable way to implement "operator delete".
+namespace std
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+  extern "C" void free(void*);
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
+#else
+# include <cstdlib>
+#endif
+
+#include "new"
+
+_GLIBCXX_WEAK_DEFINITION void
+operator delete(void* ptr,
+                std::size_t bytes __attribute__((__unused__))) throw ()
+{
+  if (ptr)
+    std::free(ptr);
+}
diff --git a/libstdc++-v3/libsupc++/new b/libstdc++-v3/libsupc++/new
index 2a92603..fd30c33 100644
--- a/libstdc++-v3/libsupc++/new
+++ b/libstdc++-v3/libsupc++/new
@@ -94,6 +94,8 @@ void* operator new[](std::size_t) _GLIBCXX_THROW (std::bad_alloc)
   __attribute__((__externally_visible__));
 void operator delete(void*) _GLIBCXX_USE_NOEXCEPT
   __attribute__((__externally_visible__));
+void operator delete(void*, std::size_t) _GLIBCXX_USE_NOEXCEPT
+  __attribute__((__externally_visible__));
 void operator delete[](void*) _GLIBCXX_USE_NOEXCEPT
   __attribute__((__externally_visible__));
 void* operator new(std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
diff --git a/libstdc++-v3/src/Makefile.am b/libstdc++-v3/src/Makefile.am
index 07c4160..693becd 100644
--- a/libstdc++-v3/src/Makefile.am
+++ b/libstdc++-v3/src/Makefile.am
@@ -165,7 +165,8 @@ LTCXXCOMPILE = \
 	$(LIBTOOL) --tag CXX \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 	--mode=compile $(CXX) $(INCLUDES) \
-	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) $(EXTRA_CXX_FLAGS)
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) \
+	$(EXTRA_CXX_FLAGS) -Xcompiler-static -UPIC
 
 LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))
 
diff --git a/libstdc++-v3/src/Makefile.in b/libstdc++-v3/src/Makefile.in
index 9721ebb..7b760ea 100644
--- a/libstdc++-v3/src/Makefile.in
+++ b/libstdc++-v3/src/Makefile.in
@@ -435,7 +435,8 @@ LTCXXCOMPILE = \
 	$(LIBTOOL) --tag CXX \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 	--mode=compile $(CXX) $(INCLUDES) \
-	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) $(EXTRA_CXX_FLAGS)
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) \
+	$(EXTRA_CXX_FLAGS) -Xcompiler-static -UPIC
 
 LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))
 
diff --git a/libstdc++-v3/src/c++11/Makefile.am b/libstdc++-v3/src/c++11/Makefile.am
index e7b48ac..7c7936d 100644
--- a/libstdc++-v3/src/c++11/Makefile.am
+++ b/libstdc++-v3/src/c++11/Makefile.am
@@ -76,7 +76,10 @@ AM_CXXFLAGS = \
 	-std=gnu++11 \
 	$(glibcxx_lt_pic_flag) $(glibcxx_compiler_shared_flag) \
 	$(XTEMPLATE_FLAGS) \
-	$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS) $(CONFIG_CXXFLAGS)
+	$(WARN_CXXFLAGS) \
+	$(OPTIMIZE_CXXFLAGS) \
+	$(CONFIG_CXXFLAGS) -std=gnu++11 \
+	$($(@)_no_omit_frame_pointer)
 
 AM_MAKEFLAGS = \
 	"gxx_include_dir=$(gxx_include_dir)"
@@ -121,8 +124,10 @@ LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))
 # course is problematic at this point.  So, we get the top-level
 # directory to configure libstdc++-v3 to use gcc as the C++
 # compilation driver.
-CXXLINK = \
-	$(LIBTOOL) --tag CXX --tag disable-shared \
-	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
-	--mode=link $(CXX) \
-	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@
+CXXLINK = $(LIBTOOL) --tag CXX --tag disable-shared $(LIBTOOLFLAGS) \
+	  --mode=link $(CXX) \
+	  $(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@
+
+# Google-specific pessimization
+functexcept.lo_no_omit_frame_pointer = -fno-omit-frame-pointer
+debug.lo_no_omit_frame_pointer = -fno-omit-frame-pointer
diff --git a/libstdc++-v3/src/c++11/Makefile.in b/libstdc++-v3/src/c++11/Makefile.in
index a410748..1a35c83 100644
--- a/libstdc++-v3/src/c++11/Makefile.in
+++ b/libstdc++-v3/src/c++11/Makefile.in
@@ -341,7 +341,10 @@ AM_CXXFLAGS = \
 	-std=gnu++11 \
 	$(glibcxx_lt_pic_flag) $(glibcxx_compiler_shared_flag) \
 	$(XTEMPLATE_FLAGS) \
-	$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS) $(CONFIG_CXXFLAGS)
+	$(WARN_CXXFLAGS) \
+	$(OPTIMIZE_CXXFLAGS) \
+	$(CONFIG_CXXFLAGS) -std=gnu++11 \
+	$($(@)_no_omit_frame_pointer)
 
 AM_MAKEFLAGS = \
 	"gxx_include_dir=$(gxx_include_dir)"
@@ -387,12 +390,14 @@ LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))
 # course is problematic at this point.  So, we get the top-level
 # directory to configure libstdc++-v3 to use gcc as the C++
 # compilation driver.
-CXXLINK = \
-	$(LIBTOOL) --tag CXX --tag disable-shared \
-	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
-	--mode=link $(CXX) \
-	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@
+CXXLINK = $(LIBTOOL) --tag CXX --tag disable-shared $(LIBTOOLFLAGS) \
+	  --mode=link $(CXX) \
+	  $(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@
+
 
+# Google-specific pessimization
+functexcept.lo_no_omit_frame_pointer = -fno-omit-frame-pointer
+debug.lo_no_omit_frame_pointer = -fno-omit-frame-pointer
 all: all-am
 
 .SUFFIXES:
diff --git a/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/constructor_1_neg.cc b/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/constructor_1_neg.cc
index b4e881d..cfe19a8 100644
--- a/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/constructor_1_neg.cc
+++ b/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/constructor_1_neg.cc
@@ -18,7 +18,7 @@
 // <http://www.gnu.org/licenses/>.
 
 // { dg-do compile }
-// { dg-error "no matching" "" { target *-*-* } 1166 }
+// { dg-error "no matching" "" { target *-*-* } 1287 }
 
 #include <vector>
 
diff --git a/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/constructor_2_neg.cc b/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/constructor_2_neg.cc
index 74bea14..2afdd89 100644
--- a/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/constructor_2_neg.cc
+++ b/libstdc++-v3/testsuite/23_containers/vector/requirements/dr438/constructor_2_neg.cc
@@ -18,7 +18,7 @@
 // <http://www.gnu.org/licenses/>.
 
 // { dg-do compile }
-// { dg-error "no matching" "" { target *-*-* } 1166 }
+// { dg-error "no matching" "" { target *-*-* } 1287 }
 
 #include <vector>
 #include <utility>
diff --git a/ltmain.sh b/ltmain.sh
index a03433f..3aac68f 100644
--- a/ltmain.sh
+++ b/ltmain.sh
@@ -1280,6 +1280,8 @@ func_mode_compile ()
     $opt_debug
     # Get the compilation command and the source file.
     base_compile=
+    shared_compile=
+    static_compile=
     srcfile="$nonopt"  #  always keep a non-empty value in "srcfile"
     suppress_opt=yes
     suppress_output=
@@ -1303,6 +1305,20 @@ func_mode_compile ()
 	continue
 	;;
 
+      xcompiler-shared )
+        arg_mode=normal
+	func_quote_for_eval "$arg"
+	shared_compile="$shared_compile $func_quote_for_eval_result"
+	continue
+	;;
+
+      xcompiler-static )
+        arg_mode=normal
+	func_quote_for_eval "$arg"
+	static_compile="$static_compile $func_quote_for_eval_result"
+	continue
+	;;
+
       normal )
 	# Accept any command-line options.
 	case $arg in
@@ -1333,6 +1349,18 @@ func_mode_compile ()
 	  continue      #  The current "srcfile" will either be retained or
 	  ;;            #  replaced later.  I would guess that would be a bug.
 
+	-Xcompiler-shared)
+	  arg_mode=xcompiler-shared  #  the next one goes into the
+	                             #  "shared_compile" arg list
+	  continue
+	  ;;
+
+	-Xcompiler-static)
+	  arg_mode=xcompiler-static  #  the next one goes into the
+	                             #  "static_compile" arg list
+	  continue
+	  ;;
+
 	-Wc,*)
 	  func_stripname '-Wc,' '' "$arg"
 	  args=$func_stripname_result
@@ -1516,10 +1544,10 @@ compiler."
       fbsd_hideous_sh_bug=$base_compile
 
       if test "$pic_mode" != no; then
-	command="$base_compile $qsrcfile $pic_flag"
+	command="$base_compile $qsrcfile $pic_flag $shared_compile"
       else
 	# Don't build PIC code
-	command="$base_compile $qsrcfile"
+	command="$base_compile $qsrcfile $shared_compile"
       fi
 
       func_mkdir_p "$xdir$objdir"
@@ -1568,9 +1596,9 @@ compiler."
     if test "$build_old_libs" = yes; then
       if test "$pic_mode" != yes; then
 	# Don't build PIC code
-	command="$base_compile $qsrcfile$pie_flag"
+	command="$base_compile $qsrcfile$pie_flag $static_compile"
       else
-	command="$base_compile $qsrcfile $pic_flag"
+	command="$base_compile $qsrcfile $pic_flag $static_compile"
       fi
       if test "$compiler_c_o" = yes; then
 	command="$command -o $obj"
@@ -1664,6 +1692,12 @@ This mode accepts the following additional options:
   -shared           do not build a \`.o' file suitable for static linking
   -static           only build a \`.o' file suitable for static linking
   -Wc,FLAG          pass FLAG directly to the compiler
+  -Xcompiler-shared FLAG
+                    pass FLAG directly to the compiler when compiling shared
+		    libraries
+  -Xcompiler-static FLAG
+                    pass FLAG directly to the compiler when compiling static
+		    libraries
 
 COMPILE-COMMAND is a command to be used in creating a \`standard' object file
 from the given SOURCEFILE.
@@ -2932,7 +2966,7 @@ func_extract_archives ()
         func_extract_an_archive "$my_xdir" "$my_xabs"
 	;;
       esac
-      my_oldobjs="$my_oldobjs "`find $my_xdir -name \*.$objext -print -o -name \*.lo -print | $NL2SP`
+      my_oldobjs="$my_oldobjs "`find $my_xdir -name \*.$objext -print -o -name \*.lo -print | sort | $NL2SP`
     done
 
     func_extract_archives_result="$my_oldobjs"
diff --git a/lto-plugin/configure b/lto-plugin/configure
index 4900d80..f018c7d 100755
--- a/lto-plugin/configure
+++ b/lto-plugin/configure
@@ -7153,7 +7153,22 @@ fi
 
 # Check whether --with-pic was given.
 if test "${with_pic+set}" = set; then :
-  withval=$with_pic; pic_mode="$withval"
+  withval=$with_pic; p=${PACKAGE-default}
+    case "$withval" in
+    yes|no) pic_mode="$withval" ;;
+    *)
+      pic_mode=default
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $withval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  pic_mode=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
 else
   pic_mode=default
 fi
@@ -10552,7 +10567,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10555 "configure"
+#line 10570 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -10658,7 +10673,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10661 "configure"
+#line 10676 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
diff --git a/ltoptions.m4 b/ltoptions.m4
index 5ef12ce..93a44ad 100644
--- a/ltoptions.m4
+++ b/ltoptions.m4
@@ -328,7 +328,22 @@ m4_define([_LT_WITH_PIC],
 [AC_ARG_WITH([pic],
     [AS_HELP_STRING([--with-pic],
 	[try to use only PIC/non-PIC objects @<:@default=use both@:>@])],
-    [pic_mode="$withval"],
+    [p=${PACKAGE-default}
+    case "$withval" in
+    yes|no) pic_mode="$withval" ;;
+    *)
+      pic_mode=default
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $withval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  pic_mode=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac],
     [pic_mode=default])
 
 test -z "$pic_mode" && pic_mode=m4_default([$1], [default])
diff --git a/zlib/configure b/zlib/configure
index 8e4a93f..83bea8e 100755
--- a/zlib/configure
+++ b/zlib/configure
@@ -6968,7 +6968,22 @@ fi
 
 # Check whether --with-pic was given.
 if test "${with_pic+set}" = set; then :
-  withval=$with_pic; pic_mode="$withval"
+  withval=$with_pic; p=${PACKAGE-default}
+    case "$withval" in
+    yes|no) pic_mode="$withval" ;;
+    *)
+      pic_mode=default
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $withval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  pic_mode=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
 else
   pic_mode=default
 fi
@@ -10394,7 +10409,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10397 "configure"
+#line 10412 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -10500,7 +10515,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10503 "configure"
+#line 10518 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
